namespace Aardvark.Base

open Microsoft.FSharp.NativeInterop
open System.Runtime.InteropServices

#nowarn "9"

[<Sealed>]
type NativeVector<'a when 'a : unmanaged>(ptr : nativeptr<'a>, info : VectorInfo) = 
    member x.Pointer = ptr
    member x.Info = info
    member x.Size = info.Size
    member x.Delta = info.Delta
    member x.Origin = info.Origin
    member x.SX = info.SX
    member x.DX = info.DX
    member inline private x.SetX(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let eX = ptr + sX
        while ptr <> eX do
            NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
            ptr <- ptr + jX
    member x.Set(value : 'a) = 
        x.SetX(value)
    member inline private x.SetByCoordX(getValue : int64 -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = 0L
        let step = 1L
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
            coord <- coord + step
            ptr <- ptr + jX
    member x.SetByCoord(value : int64 -> 'a) = 
        x.SetByCoordX(value)
    member inline private x.SetByCoordX(getValue : int -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = 0
        let step = 1
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
            coord <- coord + step
            ptr <- ptr + jX
    member x.SetByCoord(value : int -> 'a) = 
        x.SetByCoordX(value)
    member inline private x.SetByCoordX(getValue : float -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = 0.5 / float(x.Size)
        let step = 1.0 / float(x.Size)
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
            coord <- coord + step
            ptr <- ptr + jX
    member x.SetByCoord(value : float -> 'a) = 
        x.SetByCoordX(value)
    member inline private x.BlitToInternalX(y : NativeVector<'a>, srcOffset : float, srcSize : float, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (float(x.Size) * srcSize) / float(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * float(x.Size) - 0.5
        let initialiCoord = int64(floor(initialCoord))
        let initialFrac = initialCoord - float(initialiCoord)
        let step = 1.0 * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord
        let yeX = py + ysX
        while py <> yeX do
            let v0 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
            let v1 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
            // lerp X
            let vx = lerp.Invoke(frac, v0, v1)
            NativePtr.write (NativePtr.ofNativeInt<'a> py) vx
            py <- py + yjX
            coord <- coord + step
            let ni = int64 (floor coord)
            px <- px + xdX * nativeint (ni - icoord)
            icoord <- ni
            frac <- coord - float(icoord)
    member inline private x.BlitToInternalXE(y : NativeVector<'a>, srcOffset : float, srcSize : float, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (float(x.Size) * srcSize) / float(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * float(x.Size) - 0.5
        let initialiCoord = int64(floor(initialCoord))
        let initialFrac = initialCoord - float(initialiCoord)
        let step = 1.0 * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord
        let yeX = py + ysX
        while py <> yeX do
            let v0 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
            NativePtr.write (NativePtr.ofNativeInt<'a> py) v0
            py <- py + yjX
            px <- px + xjX
            coord <- coord + step
            icoord <- icoord + 1L
    member inline private x.BlitToX(y : NativeVector<'a>, srcOffset : float, srcSize : float, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size > x.Size then failwith "[NativeTensor] upsampling not implemented"
        if x.SX = y.SX && srcOffset = 0.0 && srcSize = 1.0 then x.BlitToInternalXE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalX(y, srcOffset, srcSize, lerp)
    member x.BlitTo(y : NativeVector<'a>, srcOffset : float, srcSize : float, lerp : float -> 'a -> 'a -> 'a) = 
        x.BlitToX(y, srcOffset, srcSize, lerp)
    member x.BlitTo(y : NativeVector<'a>, lerp : float -> 'a -> 'a -> 'a) = x.BlitTo(y, 0.0, 1.0, lerp)
    member x.Item
        with get(c0 : int64) : 'a = 
            let i = x.Delta * c0
            NativePtr.read (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i)))
        and set (c0 : int64) (value : 'a) =
            let i = x.Delta * c0
            NativePtr.write (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i))) value
    member x.Item
        with get(c0 : int) : 'a = 
            let i = x.Delta * int64(c0)
            NativePtr.read (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i)))
        and set (c0 : int) (value : 'a) =
            let i = x.Delta * int64(c0)
            NativePtr.write (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i))) value
    member inline private x.CopyToX(y : NativeVector<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sa
        let eX = xptr + sX
        while xptr <> eX do
            NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member x.CopyTo(y : NativeVector<'a>) = 
        if info.Size <> y.Size then
            failwithf "NativeVector size mismatch: { src = %A; dst = %A }" info.Size y.Size
        x.CopyToX(y)
    member inline private x.CopyToX<'b when 'b : unmanaged>(y : NativeVector<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sb
        let eX = xptr + sX
        while xptr <> eX do
            NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member x.CopyTo(y : NativeVector<'b>, f : 'a -> 'b) = 
        if info.Size <> y.Size then
            failwithf "NativeVector size mismatch: { src = %A; dst = %A }" info.Size y.Size
        x.CopyToX(y, f)
    static member Using<'b> (m : Vector<'a>, f : NativeVector<'a> -> 'b) = 
        let gc = GCHandle.Alloc(m.Data, GCHandleType.Pinned)
        try f (NativeVector<'a>(NativePtr.ofNativeInt (gc.AddrOfPinnedObject()), m.Info))
        finally gc.Free()
    member x.SubVector(beginX : int64, sizeX : int64, deltaX : int64) = NativeVector<'a>(ptr, info.SubVector(beginX, sizeX, deltaX))
    member x.SubVector(beginX : int64, sizeX : int64) = NativeVector<'a>(ptr, info.SubVector(beginX, sizeX))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let info = VectorInfo(info.Index(beginX), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let info = VectorInfo(info.Index(beginX), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let info = VectorInfo(info.Index(beginX), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let info = VectorInfo(info.Index(beginX), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, src : NativeVector<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let info = VectorInfo(info.Index(beginX), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, src : NativeVector<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let info = VectorInfo(info.Index(beginX), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, src : Vector<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let info = VectorInfo(info.Index(beginX), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, src : Vector<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let info = VectorInfo(info.Index(beginX), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))

/// The NativeVector module providers convenient F#-style functions for accessing NativeVectors
module NativeVector =
    let inline private lerpy< ^a, ^b when (^a or ^b) : (static member Lerp : float * ^b * ^b -> ^b)> (_ : ^a) (t : float) (a : ^b) (b : ^b) =
        ((^a or ^b) : (static member Lerp : float * ^b * ^b -> ^b) (t, a,b))
    let inline private lerper t a b = lerpy (Unchecked.defaultof<Fun>) t a b
    /// sets the entire Vector to the given value
    let inline set (value : 'a) (dst : NativeVector<'a>) = dst.Set(value)
    
    /// sets each entry to the value computed by getValue
    let inline setByCoord (getValue : int64 -> 'a) (m : NativeVector<'a>) = m.SetByCoord(getValue)
    
    let inline blit (src : NativeVector<'a>) (dst : NativeVector<'a>) = src.BlitTo(dst, lerper)
    
    /// copies the content of 'src' to 'dst'
    let inline copy (src : NativeVector<'a>) (dst : NativeVector<'a>) = src.CopyTo(dst)
    
    /// copies the content of 'src' to 'dst' by applying the given function
    let inline copyWith (f : 'a -> 'b) (src : NativeVector<'a>) (dst : NativeVector<'b>) = src.CopyTo(dst, f)
    
    /// temporarily pins a Vector making it available as NativeVector
    let using (m : Vector<'a>) (f : NativeVector<'a> -> 'b) = NativeVector<'a>.Using(m, f)


[<Sealed>]
type NativeMatrix<'a when 'a : unmanaged>(ptr : nativeptr<'a>, info : MatrixInfo) = 
    member x.Pointer = ptr
    member x.Info = info
    member x.Size = info.Size
    member x.Delta = info.Delta
    member x.Origin = info.Origin
    member x.SX = info.SX
    member x.SY = info.SY
    member x.DX = info.DX
    member x.DY = info.DY
    member inline private x.SetXY(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            while ptr <> eY do
                NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                ptr <- ptr + jY
            ptr <- ptr + jX
    member inline private x.SetYX(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            while ptr <> eX do
                NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                ptr <- ptr + jX
            ptr <- ptr + jY
    member x.Set(value : 'a) = 
        let cXY = compare (abs info.DX) (abs info.DY)
        if cXY >= 0  then x.SetXY(value)
        else x.SetYX(value)
    member inline private x.SetByCoordXY(getValue : V2l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V2l.Zero
        let step = V2l.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordYX(getValue : V2l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V2l.Zero
        let step = V2l.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member x.SetByCoord(value : V2l -> 'a) = 
        let cXY = compare (abs info.DX) (abs info.DY)
        if cXY >= 0  then x.SetByCoordXY(value)
        else x.SetByCoordYX(value)
    member inline private x.SetByCoordXY(getValue : V2i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V2i.Zero
        let step = V2i.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordYX(getValue : V2i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V2i.Zero
        let step = V2i.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member x.SetByCoord(value : V2i -> 'a) = 
        let cXY = compare (abs info.DX) (abs info.DY)
        if cXY >= 0  then x.SetByCoordXY(value)
        else x.SetByCoordYX(value)
    member inline private x.SetByCoordXY(getValue : V2d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V2d(0.5, 0.5) / V2d(x.Size)
        let step = V2d.One / V2d(x.Size)
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordYX(getValue : V2d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V2d(0.5, 0.5) / V2d(x.Size)
        let step = V2d.One / V2d(x.Size)
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member x.SetByCoord(value : V2d -> 'a) = 
        let cXY = compare (abs info.DX) (abs info.DY)
        if cXY >= 0  then x.SetByCoordXY(value)
        else x.SetByCoordYX(value)
    member inline private x.BlitToInternalXY(y : NativeMatrix<'a>, srcOffset : V2d, srcSize : V2d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V2d(x.Size) * srcSize) / V2d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V2d(x.Size) - V2d.Half
        let initialiCoord = V2l(initialCoord.Floor)
        let initialFrac = initialCoord - V2d(initialiCoord)
        let step = V2d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let v00 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                let v01 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                let v10 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                let v11 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                // lerp X
                let vx0 = lerp.Invoke(frac.X, v00, v10)
                let vx1 = lerp.Invoke(frac.X, v01, v11)
                // lerp Y
                let vxx = lerp.Invoke(frac.Y, vx0, vx1)
                NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYE(y : NativeMatrix<'a>, srcOffset : V2d, srcSize : V2d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V2d(x.Size) * srcSize) / V2d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V2d(x.Size) - V2d.Half
        let initialiCoord = V2l(initialCoord.Floor)
        let initialFrac = initialCoord - V2d(initialiCoord)
        let step = V2d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let v00 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                let v10 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                // lerp X
                let vx0 = lerp.Invoke(frac.X, v00, v10)
                NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXEY(y : NativeMatrix<'a>, srcOffset : V2d, srcSize : V2d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V2d(x.Size) * srcSize) / V2d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V2d(x.Size) - V2d.Half
        let initialiCoord = V2l(initialCoord.Floor)
        let initialFrac = initialCoord - V2d(initialiCoord)
        let step = V2d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let v00 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                let v01 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                // lerp Y
                let v0x = lerp.Invoke(frac.Y, v00, v01)
                NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYE(y : NativeMatrix<'a>, srcOffset : V2d, srcSize : V2d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V2d(x.Size) * srcSize) / V2d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V2d(x.Size) - V2d.Half
        let initialiCoord = V2l(initialCoord.Floor)
        let initialFrac = initialCoord - V2d(initialiCoord)
        let step = V2d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let v00 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                NativePtr.write (NativePtr.ofNativeInt<'a> py) v00
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToXY(y : NativeMatrix<'a>, srcOffset : V2d, srcSize : V2d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalXEY(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXYE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalXY(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalYX(y : NativeMatrix<'a>, srcOffset : V2d, srcSize : V2d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V2d(x.Size) * srcSize) / V2d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V2d(x.Size) - V2d.Half
        let initialiCoord = V2l(initialCoord.Floor)
        let initialFrac = initialCoord - V2d(initialiCoord)
        let step = V2d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let v00 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                let v01 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                let v10 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                let v11 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                // lerp X
                let vx0 = lerp.Invoke(frac.X, v00, v10)
                let vx1 = lerp.Invoke(frac.X, v01, v11)
                // lerp Y
                let vxx = lerp.Invoke(frac.Y, vx0, vx1)
                NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXE(y : NativeMatrix<'a>, srcOffset : V2d, srcSize : V2d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V2d(x.Size) * srcSize) / V2d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V2d(x.Size) - V2d.Half
        let initialiCoord = V2l(initialCoord.Floor)
        let initialFrac = initialCoord - V2d(initialiCoord)
        let step = V2d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let v00 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                let v10 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                // lerp X
                let vx0 = lerp.Invoke(frac.X, v00, v10)
                NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYEX(y : NativeMatrix<'a>, srcOffset : V2d, srcSize : V2d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V2d(x.Size) * srcSize) / V2d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V2d(x.Size) - V2d.Half
        let initialiCoord = V2l(initialCoord.Floor)
        let initialFrac = initialCoord - V2d(initialiCoord)
        let step = V2d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let v00 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                let v01 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                // lerp Y
                let v0x = lerp.Invoke(frac.Y, v00, v01)
                NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXE(y : NativeMatrix<'a>, srcOffset : V2d, srcSize : V2d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V2d(x.Size) * srcSize) / V2d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V2d(x.Size) - V2d.Half
        let initialiCoord = V2l(initialCoord.Floor)
        let initialFrac = initialCoord - V2d(initialiCoord)
        let step = V2d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let v00 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                NativePtr.write (NativePtr.ofNativeInt<'a> py) v00
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToYX(y : NativeMatrix<'a>, srcOffset : V2d, srcSize : V2d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalYEX(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYXE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalYX(y, srcOffset, srcSize, lerp)
    member x.BlitTo(y : NativeMatrix<'a>, srcOffset : V2d, srcSize : V2d, lerp : float -> 'a -> 'a -> 'a) = 
        let cXY = compare (abs info.DX) (abs info.DY)
        if cXY >= 0  then x.BlitToXY(y, srcOffset, srcSize, lerp)
        else x.BlitToYX(y, srcOffset, srcSize, lerp)
    member x.BlitTo(y : NativeMatrix<'a>, lerp : float -> 'a -> 'a -> 'a) = x.BlitTo(y, V2d.Zero, V2d.One, lerp)
    member x.Item
        with get(c0 : V2l) : 'a = 
            let i = V2l.Dot(x.Delta, c0)
            NativePtr.read (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i)))
        and set (c0 : V2l) (value : 'a) =
            let i = V2l.Dot(x.Delta, c0)
            NativePtr.write (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i))) value
    member x.Item
        with get(c0 : V2i) : 'a = 
            let i = V2l.Dot(x.Delta, V2l(c0))
            NativePtr.read (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i)))
        and set (c0 : V2i) (value : 'a) =
            let i = V2l.Dot(x.Delta, V2l(c0))
            NativePtr.write (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i))) value
    member x.Item
        with get(c0 : int, c1 : int) : 'a = 
            let i = V2l.Dot(x.Delta, V2l(c0, c1))
            NativePtr.read (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i)))
        and set (c0 : int, c1 : int) (value : 'a) =
            let i = V2l.Dot(x.Delta, V2l(c0, c1))
            NativePtr.write (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i))) value
    member x.Item
        with get(c0 : int64, c1 : int64) : 'a = 
            let i = V2l.Dot(x.Delta, V2l(c0, c1))
            NativePtr.read (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i)))
        and set (c0 : int64, c1 : int64) (value : 'a) =
            let i = V2l.Dot(x.Delta, V2l(c0, c1))
            NativePtr.write (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i))) value
    member inline private x.CopyToXY(y : NativeMatrix<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sa
        let eX = xptr + sX
        while xptr <> eX do
            let eY = xptr + sY
            while xptr <> eY do
                NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToYX(y : NativeMatrix<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sa
        let eY = xptr + sY
        while xptr <> eY do
            let eX = xptr + sX
            while xptr <> eX do
                NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member x.CopyTo(y : NativeMatrix<'a>) = 
        if info.Size <> y.Size then
            failwithf "NativeMatrix size mismatch: { src = %A; dst = %A }" info.Size y.Size
        let cXY = compare (abs info.DX) (abs info.DY)
        if cXY >= 0  then x.CopyToXY(y)
        else x.CopyToYX(y)
    member inline private x.CopyToXY<'b when 'b : unmanaged>(y : NativeMatrix<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sb
        let eX = xptr + sX
        while xptr <> eX do
            let eY = xptr + sY
            while xptr <> eY do
                NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToYX<'b when 'b : unmanaged>(y : NativeMatrix<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sb
        let eY = xptr + sY
        while xptr <> eY do
            let eX = xptr + sX
            while xptr <> eX do
                NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member x.CopyTo(y : NativeMatrix<'b>, f : 'a -> 'b) = 
        if info.Size <> y.Size then
            failwithf "NativeMatrix size mismatch: { src = %A; dst = %A }" info.Size y.Size
        let cXY = compare (abs info.DX) (abs info.DY)
        if cXY >= 0  then x.CopyToXY(y, f)
        else x.CopyToYX(y, f)
    member x.SampleNearest(coord : float) : 'a[] = 
        let p0f = coord * float x.Size.X
        let mutable nearest = int64 (Fun.Round p0f)
        if nearest < 0L then nearest <- 0L
        else if nearest >= x.Size.X then nearest <- x.Size.X - 1L
        let sa = nativeint sizeof<'a>
        let ptr = NativePtr.toNativeInt x.Pointer + nativeint (nearest * x.Delta.X) * sa
        let dY = nativeint x.DY * sa
        Array.init (int x.Size.Y) (fun i -> NativePtr.read (NativePtr.ofNativeInt (ptr + nativeint i * dY)))
    member x.SampleLinear(coord : V2d, lerp : float -> 'a -> 'a -> 'a) : 'a = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let coord = V2d.Min(V2d.Max(coord, V2d.Zero), V2d.One)
        let p0f = coord * V2d x.Size.XY - V2d(0.5, 0.5)
        let mutable p0 = V2l(int64 (floor p0f.X), int64 (floor p0f.Y))
        let frac = p0f - V2d p0
        let sa = nativeint sizeof<'a>
        let dX = nativeint x.DX * sa
        let dY = nativeint x.DY * sa
        if p0.X >= 0L && p0.X < x.Size.X - 1L && p0.Y >= 0L && p0.Y < x.Size.Y - 1L then
            let ptr0 = NativePtr.toNativeInt x.Pointer + nativeint (V2l.Dot(p0, x.Delta.XY)) * sa
            let v00 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0))
            let v01 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dY))
            let v10 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dX))
            let v11 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dX + dY))
            let vx0 = lerp.Invoke(frac.X, v00, v10)
            let vx1 = lerp.Invoke(frac.X, v01, v11)
            let vxx = lerp.Invoke(frac.Y, vx0, vx1)
            vxx
        else
            let max = x.Size - V2l.One
            let v00 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V2l.Dot(x.Delta, V2l.Min(V2l.Max(V2l.Zero, p0), max))) * sa))
            let v01 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V2l.Dot(x.Delta, V2l.Min(V2l.Max(V2l.Zero, p0 + V2l(0L, 1L)), max))) * sa))
            let v10 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V2l.Dot(x.Delta, V2l.Min(V2l.Max(V2l.Zero, p0 + V2l(1L, 0L)), max))) * sa))
            let v11 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V2l.Dot(x.Delta, V2l.Min(V2l.Max(V2l.Zero, p0 + V2l(1L, 1L)), max))) * sa))
            let vx0 = lerp.Invoke(frac.X, v00, v10)
            let vx1 = lerp.Invoke(frac.X, v01, v11)
            let vxx = lerp.Invoke(frac.Y, vx0, vx1)
            vxx
    static member Using<'b> (m : Matrix<'a>, f : NativeMatrix<'a> -> 'b) = 
        let gc = GCHandle.Alloc(m.Data, GCHandleType.Pinned)
        try f (NativeMatrix<'a>(NativePtr.ofNativeInt (gc.AddrOfPinnedObject()), m.Info))
        finally gc.Free()
    member x.SubMatrix(beginX : int64, beginY : int64, sizeX : int64, sizeY : int64, deltaX : int64, deltaY : int64) = NativeMatrix<'a>(ptr, info.SubMatrix(beginX, beginY, sizeX, sizeY, deltaX, deltaY))
    member x.SubMatrix(beginX : int64, beginY : int64, sizeX : int64, sizeY : int64) = NativeMatrix<'a>(ptr, info.SubMatrix(beginX, beginY, sizeX, sizeY))
    member x.SubMatrix(offset : V2l, size : V2l) = NativeMatrix<'a>(ptr, info.SubMatrix(offset, size))
    member x.SubMatrix(offset : V2l, size : V2l, delta : V2l) = NativeMatrix<'a>(ptr, info.SubMatrix(offset, size, delta))
    member x.SubMatrix(offset : V2i, size : V2i) = NativeMatrix<'a>(ptr, info.SubMatrix(offset, size))
    member x.SubMatrix(offset : V2i, size : V2i, delta : V2i) = NativeMatrix<'a>(ptr, info.SubMatrix(offset, size, delta))
    member x.GetSlice(minX : int, minY : Option<int>, maxY : Option<int>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let info = VectorInfo(info.Index(beginX, beginY), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.GetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let info = VectorInfo(info.Index(beginX, beginY), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, value : 'a) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let info = VectorInfo(info.Index(beginX, beginY), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, value : 'a) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let info = VectorInfo(info.Index(beginX, beginY), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, src : NativeVector<'a>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let info = VectorInfo(info.Index(beginX, beginY), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, src : NativeVector<'a>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let info = VectorInfo(info.Index(beginX, beginY), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, src : Vector<'a>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let info = VectorInfo(info.Index(beginX, beginY), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, src : Vector<'a>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let info = VectorInfo(info.Index(beginX, beginY), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>, minY : int) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let info = VectorInfo(info.Index(beginX, beginY), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let info = VectorInfo(info.Index(beginX, beginY), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let info = VectorInfo(info.Index(beginX, beginY), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let info = VectorInfo(info.Index(beginX, beginY), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, src : NativeVector<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let info = VectorInfo(info.Index(beginX, beginY), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, src : NativeVector<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let info = VectorInfo(info.Index(beginX, beginY), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, src : Vector<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let info = VectorInfo(info.Index(beginX, beginY), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, src : Vector<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let info = VectorInfo(info.Index(beginX, beginY), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let info = MatrixInfo(info.Index(beginX, beginY), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let info = MatrixInfo(info.Index(beginX, beginY), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let info = MatrixInfo(info.Index(beginX, beginY), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let info = MatrixInfo(info.Index(beginX, beginY), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, src : NativeMatrix<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let info = MatrixInfo(info.Index(beginX, beginY), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, src : NativeMatrix<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let info = MatrixInfo(info.Index(beginX, beginY), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, src : Matrix<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let info = MatrixInfo(info.Index(beginX, beginY), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, src : Matrix<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let info = MatrixInfo(info.Index(beginX, beginY), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))

/// The NativeMatrix module providers convenient F#-style functions for accessing NativeMatrixs
module NativeMatrix =
    let inline private lerpy< ^a, ^b when (^a or ^b) : (static member Lerp : float * ^b * ^b -> ^b)> (_ : ^a) (t : float) (a : ^b) (b : ^b) =
        ((^a or ^b) : (static member Lerp : float * ^b * ^b -> ^b) (t, a,b))
    let inline private lerper t a b = lerpy (Unchecked.defaultof<Fun>) t a b
    /// sets the entire Matrix to the given value
    let inline set (value : 'a) (dst : NativeMatrix<'a>) = dst.Set(value)
    
    /// sets each entry to the value computed by getValue
    let inline setByCoord (getValue : V2l -> 'a) (m : NativeMatrix<'a>) = m.SetByCoord(getValue)
    
    let inline sample (location : V2d) (m : NativeMatrix<'a>) = m.SampleLinear(location, lerper)
    
    let inline blit (src : NativeMatrix<'a>) (dst : NativeMatrix<'a>) = src.BlitTo(dst, lerper)
    
    /// copies the content of 'src' to 'dst'
    let inline copy (src : NativeMatrix<'a>) (dst : NativeMatrix<'a>) = src.CopyTo(dst)
    
    /// copies the content of 'src' to 'dst' by applying the given function
    let inline copyWith (f : 'a -> 'b) (src : NativeMatrix<'a>) (dst : NativeMatrix<'b>) = src.CopyTo(dst, f)
    
    /// temporarily pins a Matrix making it available as NativeMatrix
    let using (m : Matrix<'a>) (f : NativeMatrix<'a> -> 'b) = NativeMatrix<'a>.Using(m, f)


[<Sealed>]
type NativeVolume<'a when 'a : unmanaged>(ptr : nativeptr<'a>, info : VolumeInfo) = 
    member x.Pointer = ptr
    member x.Info = info
    member x.Size = info.Size
    member x.Delta = info.Delta
    member x.Origin = info.Origin
    member x.SX = info.SX
    member x.SY = info.SY
    member x.SZ = info.SZ
    member x.DX = info.DX
    member x.DY = info.DY
    member x.DZ = info.DZ
    member inline private x.SetXYZ(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            while ptr <> eY do
                let eZ = ptr + sZ
                while ptr <> eZ do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                    ptr <- ptr + jZ
                ptr <- ptr + jY
            ptr <- ptr + jX
    member inline private x.SetYXZ(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            while ptr <> eX do
                let eZ = ptr + sZ
                while ptr <> eZ do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                    ptr <- ptr + jZ
                ptr <- ptr + jX
            ptr <- ptr + jY
    member inline private x.SetYZX(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let eY = ptr + sY
        while ptr <> eY do
            let eZ = ptr + sZ
            while ptr <> eZ do
                let eX = ptr + sX
                while ptr <> eX do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                    ptr <- ptr + jX
                ptr <- ptr + jZ
            ptr <- ptr + jY
    member inline private x.SetXZY(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let eX = ptr + sX
        while ptr <> eX do
            let eZ = ptr + sZ
            while ptr <> eZ do
                let eY = ptr + sY
                while ptr <> eY do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                    ptr <- ptr + jY
                ptr <- ptr + jZ
            ptr <- ptr + jX
    member inline private x.SetZXY(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eX = ptr + sX
            while ptr <> eX do
                let eY = ptr + sY
                while ptr <> eY do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                    ptr <- ptr + jY
                ptr <- ptr + jX
            ptr <- ptr + jZ
    member inline private x.SetZYX(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eY = ptr + sY
            while ptr <> eY do
                let eX = ptr + sX
                while ptr <> eX do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                    ptr <- ptr + jX
                ptr <- ptr + jY
            ptr <- ptr + jZ
    member x.Set(value : 'a) = 
        let cXY = compare (abs info.DX) (abs info.DY)
        let cXZ = compare (abs info.DX) (abs info.DZ)
        let cYZ = compare (abs info.DY) (abs info.DZ)
        if cXY >= 0  && cXZ >= 0  && cYZ >= 0  then x.SetXYZ(value)
        elif cXY <= 0 && cXZ >= 0  && cYZ >= 0  then x.SetYXZ(value)
        elif cXY <= 0 && cXZ <= 0 && cYZ >= 0  then x.SetYZX(value)
        elif cXY >= 0  && cXZ >= 0  && cYZ <= 0 then x.SetXZY(value)
        elif cXY >= 0  && cXZ <= 0 && cYZ <= 0 then x.SetZXY(value)
        else x.SetZYX(value)
    member inline private x.SetByCoordXYZ(getValue : V3l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V3l.Zero
        let step = V3l.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordYXZ(getValue : V3l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V3l.Zero
        let step = V3l.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYZX(getValue : V3l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V3l.Zero
        let step = V3l.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordXZY(getValue : V3l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V3l.Zero
        let step = V3l.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordZXY(getValue : V3l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V3l.Zero
        let step = V3l.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZYX(getValue : V3l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V3l.Zero
        let step = V3l.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member x.SetByCoord(value : V3l -> 'a) = 
        let cXY = compare (abs info.DX) (abs info.DY)
        let cXZ = compare (abs info.DX) (abs info.DZ)
        let cYZ = compare (abs info.DY) (abs info.DZ)
        if cXY >= 0  && cXZ >= 0  && cYZ >= 0  then x.SetByCoordXYZ(value)
        elif cXY <= 0 && cXZ >= 0  && cYZ >= 0  then x.SetByCoordYXZ(value)
        elif cXY <= 0 && cXZ <= 0 && cYZ >= 0  then x.SetByCoordYZX(value)
        elif cXY >= 0  && cXZ >= 0  && cYZ <= 0 then x.SetByCoordXZY(value)
        elif cXY >= 0  && cXZ <= 0 && cYZ <= 0 then x.SetByCoordZXY(value)
        else x.SetByCoordZYX(value)
    member inline private x.SetByCoordXYZ(getValue : V3i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V3i.Zero
        let step = V3i.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordYXZ(getValue : V3i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V3i.Zero
        let step = V3i.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYZX(getValue : V3i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V3i.Zero
        let step = V3i.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordXZY(getValue : V3i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V3i.Zero
        let step = V3i.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordZXY(getValue : V3i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V3i.Zero
        let step = V3i.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZYX(getValue : V3i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V3i.Zero
        let step = V3i.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member x.SetByCoord(value : V3i -> 'a) = 
        let cXY = compare (abs info.DX) (abs info.DY)
        let cXZ = compare (abs info.DX) (abs info.DZ)
        let cYZ = compare (abs info.DY) (abs info.DZ)
        if cXY >= 0  && cXZ >= 0  && cYZ >= 0  then x.SetByCoordXYZ(value)
        elif cXY <= 0 && cXZ >= 0  && cYZ >= 0  then x.SetByCoordYXZ(value)
        elif cXY <= 0 && cXZ <= 0 && cYZ >= 0  then x.SetByCoordYZX(value)
        elif cXY >= 0  && cXZ >= 0  && cYZ <= 0 then x.SetByCoordXZY(value)
        elif cXY >= 0  && cXZ <= 0 && cYZ <= 0 then x.SetByCoordZXY(value)
        else x.SetByCoordZYX(value)
    member inline private x.SetByCoordXYZ(getValue : V3d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V3d(0.5, 0.5, 0.5) / V3d(x.Size)
        let step = V3d.One / V3d(x.Size)
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordYXZ(getValue : V3d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V3d(0.5, 0.5, 0.5) / V3d(x.Size)
        let step = V3d.One / V3d(x.Size)
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYZX(getValue : V3d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V3d(0.5, 0.5, 0.5) / V3d(x.Size)
        let step = V3d.One / V3d(x.Size)
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordXZY(getValue : V3d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V3d(0.5, 0.5, 0.5) / V3d(x.Size)
        let step = V3d.One / V3d(x.Size)
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordZXY(getValue : V3d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V3d(0.5, 0.5, 0.5) / V3d(x.Size)
        let step = V3d.One / V3d(x.Size)
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZYX(getValue : V3d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V3d(0.5, 0.5, 0.5) / V3d(x.Size)
        let step = V3d.One / V3d(x.Size)
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member x.SetByCoord(value : V3d -> 'a) = 
        let cXY = compare (abs info.DX) (abs info.DY)
        let cXZ = compare (abs info.DX) (abs info.DZ)
        let cYZ = compare (abs info.DY) (abs info.DZ)
        if cXY >= 0  && cXZ >= 0  && cYZ >= 0  then x.SetByCoordXYZ(value)
        elif cXY <= 0 && cXZ >= 0  && cYZ >= 0  then x.SetByCoordYXZ(value)
        elif cXY <= 0 && cXZ <= 0 && cYZ >= 0  then x.SetByCoordYZX(value)
        elif cXY >= 0  && cXZ >= 0  && cYZ <= 0 then x.SetByCoordXZY(value)
        elif cXY >= 0  && cXZ <= 0 && cYZ <= 0 then x.SetByCoordZXY(value)
        else x.SetByCoordZYX(value)
    member inline private x.BlitToInternalXYZ(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                    let v110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                    let v111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx01 = lerp.Invoke(frac.X, v001, v101)
                    let vx10 = lerp.Invoke(frac.X, v010, v110)
                    let vx11 = lerp.Invoke(frac.X, v011, v111)
                    // lerp Y
                    let vxx0 = lerp.Invoke(frac.Y, vx00, vx10)
                    let vxx1 = lerp.Invoke(frac.Y, vx01, vx11)
                    // lerp Z
                    let vxxx = lerp.Invoke(frac.Z, vxx0, vxx1)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYZE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx10 = lerp.Invoke(frac.X, v010, v110)
                    // lerp Y
                    let vxx0 = lerp.Invoke(frac.Y, vx00, vx10)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYEZ(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx01 = lerp.Invoke(frac.X, v001, v101)
                    // lerp Z
                    let vx0x = lerp.Invoke(frac.Z, vx00, vx01)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYEZE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXEYZ(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                    // lerp Y
                    let v0x0 = lerp.Invoke(frac.Y, v000, v010)
                    let v0x1 = lerp.Invoke(frac.Y, v001, v011)
                    // lerp Z
                    let v0xx = lerp.Invoke(frac.Z, v0x0, v0x1)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYZE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    // lerp Y
                    let v0x0 = lerp.Invoke(frac.Y, v000, v010)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYEZ(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    // lerp Z
                    let v00x = lerp.Invoke(frac.Z, v000, v001)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYEZE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v000
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToXYZ(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEYEZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEYEZ(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEYZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXYEZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalXEYZ(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXYEZ(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXYZE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalXYZ(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalYXZ(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                    let v110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                    let v111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx01 = lerp.Invoke(frac.X, v001, v101)
                    let vx10 = lerp.Invoke(frac.X, v010, v110)
                    let vx11 = lerp.Invoke(frac.X, v011, v111)
                    // lerp Y
                    let vxx0 = lerp.Invoke(frac.Y, vx00, vx10)
                    let vxx1 = lerp.Invoke(frac.Y, vx01, vx11)
                    // lerp Z
                    let vxxx = lerp.Invoke(frac.Z, vxx0, vxx1)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXZE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx10 = lerp.Invoke(frac.X, v010, v110)
                    // lerp Y
                    let vxx0 = lerp.Invoke(frac.Y, vx00, vx10)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXEZ(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx01 = lerp.Invoke(frac.X, v001, v101)
                    // lerp Z
                    let vx0x = lerp.Invoke(frac.Z, vx00, vx01)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXEZE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYEXZ(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                    // lerp Y
                    let v0x0 = lerp.Invoke(frac.Y, v000, v010)
                    let v0x1 = lerp.Invoke(frac.Y, v001, v011)
                    // lerp Z
                    let v0xx = lerp.Invoke(frac.Z, v0x0, v0x1)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXZE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    // lerp Y
                    let v0x0 = lerp.Invoke(frac.Y, v000, v010)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXEZ(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    // lerp Z
                    let v00x = lerp.Invoke(frac.Z, v000, v001)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXEZE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v000
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToYXZ(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEXEZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEXEZ(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEXZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYXEZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalYEXZ(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYXEZ(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYXZE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalYXZ(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalYZX(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                    let v110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                    let v111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx01 = lerp.Invoke(frac.X, v001, v101)
                    let vx10 = lerp.Invoke(frac.X, v010, v110)
                    let vx11 = lerp.Invoke(frac.X, v011, v111)
                    // lerp Y
                    let vxx0 = lerp.Invoke(frac.Y, vx00, vx10)
                    let vxx1 = lerp.Invoke(frac.Y, vx01, vx11)
                    // lerp Z
                    let vxxx = lerp.Invoke(frac.Z, vxx0, vxx1)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZXE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx10 = lerp.Invoke(frac.X, v010, v110)
                    // lerp Y
                    let vxx0 = lerp.Invoke(frac.Y, vx00, vx10)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZEX(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx01 = lerp.Invoke(frac.X, v001, v101)
                    // lerp Z
                    let vx0x = lerp.Invoke(frac.Z, vx00, vx01)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZEXE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYEZX(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                    // lerp Y
                    let v0x0 = lerp.Invoke(frac.Y, v000, v010)
                    let v0x1 = lerp.Invoke(frac.Y, v001, v011)
                    // lerp Z
                    let v0xx = lerp.Invoke(frac.Z, v0x0, v0x1)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZXE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    // lerp Y
                    let v0x0 = lerp.Invoke(frac.Y, v000, v010)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZEX(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    // lerp Z
                    let v00x = lerp.Invoke(frac.Z, v000, v001)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZEXE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v000
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToYZX(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEZEXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEZEX(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEZXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYZEXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalYEZX(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYZEX(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYZXE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalYZX(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalXZY(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                    let v110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                    let v111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx01 = lerp.Invoke(frac.X, v001, v101)
                    let vx10 = lerp.Invoke(frac.X, v010, v110)
                    let vx11 = lerp.Invoke(frac.X, v011, v111)
                    // lerp Y
                    let vxx0 = lerp.Invoke(frac.Y, vx00, vx10)
                    let vxx1 = lerp.Invoke(frac.Y, vx01, vx11)
                    // lerp Z
                    let vxxx = lerp.Invoke(frac.Z, vxx0, vxx1)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZYE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx10 = lerp.Invoke(frac.X, v010, v110)
                    // lerp Y
                    let vxx0 = lerp.Invoke(frac.Y, vx00, vx10)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZEY(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx01 = lerp.Invoke(frac.X, v001, v101)
                    // lerp Z
                    let vx0x = lerp.Invoke(frac.Z, vx00, vx01)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZEYE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXEZY(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                    // lerp Y
                    let v0x0 = lerp.Invoke(frac.Y, v000, v010)
                    let v0x1 = lerp.Invoke(frac.Y, v001, v011)
                    // lerp Z
                    let v0xx = lerp.Invoke(frac.Z, v0x0, v0x1)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZYE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    // lerp Y
                    let v0x0 = lerp.Invoke(frac.Y, v000, v010)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZEY(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    // lerp Z
                    let v00x = lerp.Invoke(frac.Z, v000, v001)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZEYE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v000
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToXZY(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEZEYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEZEY(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEZYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXZEYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalXEZY(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXZEY(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXZYE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalXZY(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalZXY(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                    let v110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                    let v111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx01 = lerp.Invoke(frac.X, v001, v101)
                    let vx10 = lerp.Invoke(frac.X, v010, v110)
                    let vx11 = lerp.Invoke(frac.X, v011, v111)
                    // lerp Y
                    let vxx0 = lerp.Invoke(frac.Y, vx00, vx10)
                    let vxx1 = lerp.Invoke(frac.Y, vx01, vx11)
                    // lerp Z
                    let vxxx = lerp.Invoke(frac.Z, vxx0, vxx1)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXYE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx10 = lerp.Invoke(frac.X, v010, v110)
                    // lerp Y
                    let vxx0 = lerp.Invoke(frac.Y, vx00, vx10)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXEY(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx01 = lerp.Invoke(frac.X, v001, v101)
                    // lerp Z
                    let vx0x = lerp.Invoke(frac.Z, vx00, vx01)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXEYE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZEXY(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                    // lerp Y
                    let v0x0 = lerp.Invoke(frac.Y, v000, v010)
                    let v0x1 = lerp.Invoke(frac.Y, v001, v011)
                    // lerp Z
                    let v0xx = lerp.Invoke(frac.Z, v0x0, v0x1)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXYE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    // lerp Y
                    let v0x0 = lerp.Invoke(frac.Y, v000, v010)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXEY(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    // lerp Z
                    let v00x = lerp.Invoke(frac.Z, v000, v001)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXEYE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v000
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToZXY(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEXEYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEXEY(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEXYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZXEYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalZEXY(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZXEY(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZXYE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalZXY(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalZYX(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                    let v110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                    let v111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx01 = lerp.Invoke(frac.X, v001, v101)
                    let vx10 = lerp.Invoke(frac.X, v010, v110)
                    let vx11 = lerp.Invoke(frac.X, v011, v111)
                    // lerp Y
                    let vxx0 = lerp.Invoke(frac.Y, vx00, vx10)
                    let vxx1 = lerp.Invoke(frac.Y, vx01, vx11)
                    // lerp Z
                    let vxxx = lerp.Invoke(frac.Z, vxx0, vxx1)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYXE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx10 = lerp.Invoke(frac.X, v010, v110)
                    // lerp Y
                    let vxx0 = lerp.Invoke(frac.Y, vx00, vx10)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYEX(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    let v101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    let vx01 = lerp.Invoke(frac.X, v001, v101)
                    // lerp Z
                    let vx0x = lerp.Invoke(frac.Z, vx00, vx01)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYEXE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                    // lerp X
                    let vx00 = lerp.Invoke(frac.X, v000, v100)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZEYX(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    let v011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                    // lerp Y
                    let v0x0 = lerp.Invoke(frac.Y, v000, v010)
                    let v0x1 = lerp.Invoke(frac.Y, v001, v011)
                    // lerp Z
                    let v0xx = lerp.Invoke(frac.Z, v0x0, v0x1)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYXE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                    // lerp Y
                    let v0x0 = lerp.Invoke(frac.Y, v000, v010)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYEX(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                    // lerp Z
                    let v00x = lerp.Invoke(frac.Z, v000, v001)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYEXE(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V3d(x.Size) * srcSize) / V3d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V3d(x.Size) - V3d.Half
        let initialiCoord = V3l(initialCoord.Floor)
        let initialFrac = initialCoord - V3d(initialiCoord)
        let step = V3d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                    NativePtr.write (NativePtr.ofNativeInt<'a> py) v000
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToZYX(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEYEXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEYEX(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEYXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZYEXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalZEYX(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZYEX(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZYXE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalZYX(y, srcOffset, srcSize, lerp)
    member x.BlitTo(y : NativeVolume<'a>, srcOffset : V3d, srcSize : V3d, lerp : float -> 'a -> 'a -> 'a) = 
        let cXY = compare (abs info.DX) (abs info.DY)
        let cXZ = compare (abs info.DX) (abs info.DZ)
        let cYZ = compare (abs info.DY) (abs info.DZ)
        if cXY >= 0  && cXZ >= 0  && cYZ >= 0  then x.BlitToXYZ(y, srcOffset, srcSize, lerp)
        elif cXY <= 0 && cXZ >= 0  && cYZ >= 0  then x.BlitToYXZ(y, srcOffset, srcSize, lerp)
        elif cXY <= 0 && cXZ <= 0 && cYZ >= 0  then x.BlitToYZX(y, srcOffset, srcSize, lerp)
        elif cXY >= 0  && cXZ >= 0  && cYZ <= 0 then x.BlitToXZY(y, srcOffset, srcSize, lerp)
        elif cXY >= 0  && cXZ <= 0 && cYZ <= 0 then x.BlitToZXY(y, srcOffset, srcSize, lerp)
        else x.BlitToZYX(y, srcOffset, srcSize, lerp)
    member x.BlitTo(y : NativeVolume<'a>, lerp : float -> 'a -> 'a -> 'a) = x.BlitTo(y, V3d.Zero, V3d.One, lerp)
    member x.Item
        with get(c0 : V3l) : 'a = 
            let i = V3l.Dot(x.Delta, c0)
            NativePtr.read (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i)))
        and set (c0 : V3l) (value : 'a) =
            let i = V3l.Dot(x.Delta, c0)
            NativePtr.write (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i))) value
    member x.Item
        with get(c0 : V3i) : 'a = 
            let i = V3l.Dot(x.Delta, V3l(c0))
            NativePtr.read (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i)))
        and set (c0 : V3i) (value : 'a) =
            let i = V3l.Dot(x.Delta, V3l(c0))
            NativePtr.write (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i))) value
    member x.Item
        with get(c0 : int, c1 : int, c2 : int) : 'a = 
            let i = V3l.Dot(x.Delta, V3l(c0, c1, c2))
            NativePtr.read (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i)))
        and set (c0 : int, c1 : int, c2 : int) (value : 'a) =
            let i = V3l.Dot(x.Delta, V3l(c0, c1, c2))
            NativePtr.write (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i))) value
    member x.Item
        with get(c0 : int64, c1 : int64, c2 : int64) : 'a = 
            let i = V3l.Dot(x.Delta, V3l(c0, c1, c2))
            NativePtr.read (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i)))
        and set (c0 : int64, c1 : int64, c2 : int64) (value : 'a) =
            let i = V3l.Dot(x.Delta, V3l(c0, c1, c2))
            NativePtr.write (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i))) value
    member inline private x.CopyToXYZ(y : NativeVolume<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sa
        let eX = xptr + sX
        while xptr <> eX do
            let eY = xptr + sY
            while xptr <> eY do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToYXZ(y : NativeVolume<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sa
        let eY = xptr + sY
        while xptr <> eY do
            let eX = xptr + sX
            while xptr <> eX do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToYZX(y : NativeVolume<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sa
        let eY = xptr + sY
        while xptr <> eY do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eX = xptr + sX
                while xptr <> eX do
                    NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToXZY(y : NativeVolume<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sa
        let eX = xptr + sX
        while xptr <> eX do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eY = xptr + sY
                while xptr <> eY do
                    NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToZXY(y : NativeVolume<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sa
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eX = xptr + sX
            while xptr <> eX do
                let eY = xptr + sY
                while xptr <> eY do
                    NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member inline private x.CopyToZYX(y : NativeVolume<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sa
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eY = xptr + sY
            while xptr <> eY do
                let eX = xptr + sX
                while xptr <> eX do
                    NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member x.CopyTo(y : NativeVolume<'a>) = 
        if info.Size <> y.Size then
            failwithf "NativeVolume size mismatch: { src = %A; dst = %A }" info.Size y.Size
        let cXY = compare (abs info.DX) (abs info.DY)
        let cXZ = compare (abs info.DX) (abs info.DZ)
        let cYZ = compare (abs info.DY) (abs info.DZ)
        if cXY >= 0  && cXZ >= 0  && cYZ >= 0  then x.CopyToXYZ(y)
        elif cXY <= 0 && cXZ >= 0  && cYZ >= 0  then x.CopyToYXZ(y)
        elif cXY <= 0 && cXZ <= 0 && cYZ >= 0  then x.CopyToYZX(y)
        elif cXY >= 0  && cXZ >= 0  && cYZ <= 0 then x.CopyToXZY(y)
        elif cXY >= 0  && cXZ <= 0 && cYZ <= 0 then x.CopyToZXY(y)
        else x.CopyToZYX(y)
    member inline private x.CopyToXYZ<'b when 'b : unmanaged>(y : NativeVolume<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sb
        let eX = xptr + sX
        while xptr <> eX do
            let eY = xptr + sY
            while xptr <> eY do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToYXZ<'b when 'b : unmanaged>(y : NativeVolume<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sb
        let eY = xptr + sY
        while xptr <> eY do
            let eX = xptr + sX
            while xptr <> eX do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToYZX<'b when 'b : unmanaged>(y : NativeVolume<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sb
        let eY = xptr + sY
        while xptr <> eY do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eX = xptr + sX
                while xptr <> eX do
                    NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToXZY<'b when 'b : unmanaged>(y : NativeVolume<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sb
        let eX = xptr + sX
        while xptr <> eX do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eY = xptr + sY
                while xptr <> eY do
                    NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToZXY<'b when 'b : unmanaged>(y : NativeVolume<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sb
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eX = xptr + sX
            while xptr <> eX do
                let eY = xptr + sY
                while xptr <> eY do
                    NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member inline private x.CopyToZYX<'b when 'b : unmanaged>(y : NativeVolume<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sb
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eY = xptr + sY
            while xptr <> eY do
                let eX = xptr + sX
                while xptr <> eX do
                    NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member x.CopyTo(y : NativeVolume<'b>, f : 'a -> 'b) = 
        if info.Size <> y.Size then
            failwithf "NativeVolume size mismatch: { src = %A; dst = %A }" info.Size y.Size
        let cXY = compare (abs info.DX) (abs info.DY)
        let cXZ = compare (abs info.DX) (abs info.DZ)
        let cYZ = compare (abs info.DY) (abs info.DZ)
        if cXY >= 0  && cXZ >= 0  && cYZ >= 0  then x.CopyToXYZ(y, f)
        elif cXY <= 0 && cXZ >= 0  && cYZ >= 0  then x.CopyToYXZ(y, f)
        elif cXY <= 0 && cXZ <= 0 && cYZ >= 0  then x.CopyToYZX(y, f)
        elif cXY >= 0  && cXZ >= 0  && cYZ <= 0 then x.CopyToXZY(y, f)
        elif cXY >= 0  && cXZ <= 0 && cYZ <= 0 then x.CopyToZXY(y, f)
        else x.CopyToZYX(y, f)
    member x.SampleNearest(coord : V2d) : 'a[] = 
        let p0f = coord * V2d x.Size.XY
        let mutable nearest = V2l(int64 (Fun.Round p0f.X), int64 (Fun.Round p0f.Y))
        if nearest.X < 0L then nearest.X <- 0L
        else if nearest.X >= x.SX then nearest.X <- x.SX - 1L
        if nearest.Y < 0L then nearest.Y <- 0L
        else if nearest.Y >= x.SY then nearest.Y <- x.SY - 1L
        let sa = nativeint sizeof<'a>
        let ptr = NativePtr.toNativeInt x.Pointer + nativeint (V2l.Dot(nearest, x.Delta.XY)) * sa
        let dZ = nativeint x.DZ * sa
        Array.init (int x.Size.Z) (fun i -> NativePtr.read (NativePtr.ofNativeInt (ptr + nativeint i * dZ)))
    member x.SampleLinear(coord : V3d, lerp : float -> 'a -> 'a -> 'a) : 'a = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let coord = V3d.Min(V3d.Max(coord, V3d.Zero), V3d.One)
        let p0f = coord * V3d x.Size.XYZ - V3d(0.5, 0.5, 0.5)
        let mutable p0 = V3l(int64 (floor p0f.X), int64 (floor p0f.Y), int64 (floor p0f.Z))
        let frac = p0f - V3d p0
        let sa = nativeint sizeof<'a>
        let dX = nativeint x.DX * sa
        let dY = nativeint x.DY * sa
        let dZ = nativeint x.DZ * sa
        if p0.X >= 0L && p0.X < x.Size.X - 1L && p0.Y >= 0L && p0.Y < x.Size.Y - 1L && p0.Z >= 0L && p0.Z < x.Size.Z - 1L then
            let ptr0 = NativePtr.toNativeInt x.Pointer + nativeint (V3l.Dot(p0, x.Delta.XYZ)) * sa
            let v000 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0))
            let v001 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dZ))
            let v010 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dY))
            let v011 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dY + dZ))
            let v100 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dX))
            let v101 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dX + dZ))
            let v110 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dX + dY))
            let v111 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dX + dY + dZ))
            let vx00 = lerp.Invoke(frac.X, v000, v100)
            let vx01 = lerp.Invoke(frac.X, v001, v101)
            let vx10 = lerp.Invoke(frac.X, v010, v110)
            let vx11 = lerp.Invoke(frac.X, v011, v111)
            let vxx0 = lerp.Invoke(frac.Y, vx00, vx10)
            let vxx1 = lerp.Invoke(frac.Y, vx01, vx11)
            let vxxx = lerp.Invoke(frac.Z, vxx0, vxx1)
            vxxx
        else
            let max = x.Size - V3l.One
            let v000 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V3l.Dot(x.Delta, V3l.Min(V3l.Max(V3l.Zero, p0), max))) * sa))
            let v001 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V3l.Dot(x.Delta, V3l.Min(V3l.Max(V3l.Zero, p0 + V3l(0L, 0L, 1L)), max))) * sa))
            let v010 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V3l.Dot(x.Delta, V3l.Min(V3l.Max(V3l.Zero, p0 + V3l(0L, 1L, 0L)), max))) * sa))
            let v011 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V3l.Dot(x.Delta, V3l.Min(V3l.Max(V3l.Zero, p0 + V3l(0L, 1L, 1L)), max))) * sa))
            let v100 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V3l.Dot(x.Delta, V3l.Min(V3l.Max(V3l.Zero, p0 + V3l(1L, 0L, 0L)), max))) * sa))
            let v101 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V3l.Dot(x.Delta, V3l.Min(V3l.Max(V3l.Zero, p0 + V3l(1L, 0L, 1L)), max))) * sa))
            let v110 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V3l.Dot(x.Delta, V3l.Min(V3l.Max(V3l.Zero, p0 + V3l(1L, 1L, 0L)), max))) * sa))
            let v111 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V3l.Dot(x.Delta, V3l.Min(V3l.Max(V3l.Zero, p0 + V3l(1L, 1L, 1L)), max))) * sa))
            let vx00 = lerp.Invoke(frac.X, v000, v100)
            let vx01 = lerp.Invoke(frac.X, v001, v101)
            let vx10 = lerp.Invoke(frac.X, v010, v110)
            let vx11 = lerp.Invoke(frac.X, v011, v111)
            let vxx0 = lerp.Invoke(frac.Y, vx00, vx10)
            let vxx1 = lerp.Invoke(frac.Y, vx01, vx11)
            let vxxx = lerp.Invoke(frac.Z, vxx0, vxx1)
            vxxx
    static member Using<'b> (m : Volume<'a>, f : NativeVolume<'a> -> 'b) = 
        let gc = GCHandle.Alloc(m.Data, GCHandleType.Pinned)
        try f (NativeVolume<'a>(NativePtr.ofNativeInt (gc.AddrOfPinnedObject()), m.Info))
        finally gc.Free()
    member x.SubVolume(beginX : int64, beginY : int64, beginZ : int64, sizeX : int64, sizeY : int64, sizeZ : int64, deltaX : int64, deltaY : int64, deltaZ : int64) = NativeVolume<'a>(ptr, info.SubVolume(beginX, beginY, beginZ, sizeX, sizeY, sizeZ, deltaX, deltaY, deltaZ))
    member x.SubVolume(beginX : int64, beginY : int64, beginZ : int64, sizeX : int64, sizeY : int64, sizeZ : int64) = NativeVolume<'a>(ptr, info.SubVolume(beginX, beginY, beginZ, sizeX, sizeY, sizeZ))
    member x.SubVolume(offset : V3l, size : V3l) = NativeVolume<'a>(ptr, info.SubVolume(offset, size))
    member x.SubVolume(offset : V3l, size : V3l, delta : V3l) = NativeVolume<'a>(ptr, info.SubVolume(offset, size, delta))
    member x.SubVolume(offset : V3i, size : V3i) = NativeVolume<'a>(ptr, info.SubVolume(offset, size))
    member x.SubVolume(offset : V3i, size : V3i, delta : V3i) = NativeVolume<'a>(ptr, info.SubVolume(offset, size, delta))
    member x.GetSlice(minX : int, minY : int, minZ : Option<int>, maxZ : Option<int>) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.GetSlice(minX : int64, minY : int64, minZ : Option<int64>, maxZ : Option<int64>) = 
        let beginX = minX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.SetSlice(minX : int, minY : int, minZ : Option<int>, maxZ : Option<int>, value : 'a) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int64, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, value : 'a) = 
        let beginX = minX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int, minY : int, minZ : Option<int>, maxZ : Option<int>, src : NativeVector<'a>) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int64, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, src : NativeVector<'a>) = 
        let beginX = minX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int, minY : int, minZ : Option<int>, maxZ : Option<int>, src : Vector<'a>) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : int64, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, src : Vector<'a>) = 
        let beginX = minX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : int) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.GetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : int64) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : int, value : 'a) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : int64, value : 'a) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : int, src : NativeVector<'a>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : int64, src : NativeVector<'a>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : int, src : Vector<'a>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : int64, src : Vector<'a>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.GetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, value : 'a) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, value : 'a) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, src : NativeMatrix<'a>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, src : NativeMatrix<'a>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, src : Matrix<'a>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, src : Matrix<'a>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : int) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : int64) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = minZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : int, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : int64, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = minZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : int, src : NativeVector<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : int64, src : NativeVector<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = minZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : int, src : Vector<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : int64, src : Vector<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = minZ
        let info = VectorInfo(info.Index(beginX, beginY, beginZ), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : Option<int>, maxZ : Option<int>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : Option<int64>, maxZ : Option<int64>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : Option<int>, maxZ : Option<int>, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : Option<int>, maxZ : Option<int>, src : NativeMatrix<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, src : NativeMatrix<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : Option<int>, maxZ : Option<int>, src : Matrix<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, src : Matrix<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : int) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : int64) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : int, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : int64, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : int, src : NativeMatrix<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : int64, src : NativeMatrix<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : int, src : Matrix<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : int64, src : Matrix<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, src : NativeVolume<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, src : NativeVolume<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, src : Volume<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        NativeVolume<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, src : Volume<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        NativeVolume<'a>.Using(src, fun src -> src.CopyTo(res))

/// The NativeVolume module providers convenient F#-style functions for accessing NativeVolumes
module NativeVolume =
    let inline private lerpy< ^a, ^b when (^a or ^b) : (static member Lerp : float * ^b * ^b -> ^b)> (_ : ^a) (t : float) (a : ^b) (b : ^b) =
        ((^a or ^b) : (static member Lerp : float * ^b * ^b -> ^b) (t, a,b))
    let inline private lerper t a b = lerpy (Unchecked.defaultof<Fun>) t a b
    /// sets the entire Volume to the given value
    let inline set (value : 'a) (dst : NativeVolume<'a>) = dst.Set(value)
    
    /// sets each entry to the value computed by getValue
    let inline setByCoord (getValue : V3l -> 'a) (m : NativeVolume<'a>) = m.SetByCoord(getValue)
    
    let inline sample (location : V3d) (m : NativeVolume<'a>) = m.SampleLinear(location, lerper)
    
    let inline blit (src : NativeVolume<'a>) (dst : NativeVolume<'a>) = src.BlitTo(dst, lerper)
    
    /// copies the content of 'src' to 'dst'
    let inline copy (src : NativeVolume<'a>) (dst : NativeVolume<'a>) = src.CopyTo(dst)
    
    /// copies the content of 'src' to 'dst' by applying the given function
    let inline copyWith (f : 'a -> 'b) (src : NativeVolume<'a>) (dst : NativeVolume<'b>) = src.CopyTo(dst, f)
    
    /// temporarily pins a Volume making it available as NativeVolume
    let using (m : Volume<'a>) (f : NativeVolume<'a> -> 'b) = NativeVolume<'a>.Using(m, f)


[<Sealed>]
type NativeTensor4<'a when 'a : unmanaged>(ptr : nativeptr<'a>, info : Tensor4Info) = 
    member x.Pointer = ptr
    member x.Info = info
    member x.Size = info.Size
    member x.Delta = info.Delta
    member x.Origin = info.Origin
    member x.SX = info.SX
    member x.SY = info.SY
    member x.SZ = info.SZ
    member x.SW = info.SW
    member x.DX = info.DX
    member x.DY = info.DY
    member x.DZ = info.DZ
    member x.DW = info.DW
    member inline private x.SetXYZW(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            while ptr <> eY do
                let eZ = ptr + sZ
                while ptr <> eZ do
                    let eW = ptr + sW
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jW
                    ptr <- ptr + jZ
                ptr <- ptr + jY
            ptr <- ptr + jX
    member inline private x.SetYXZW(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            while ptr <> eX do
                let eZ = ptr + sZ
                while ptr <> eZ do
                    let eW = ptr + sW
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jW
                    ptr <- ptr + jZ
                ptr <- ptr + jX
            ptr <- ptr + jY
    member inline private x.SetYZXW(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let eY = ptr + sY
        while ptr <> eY do
            let eZ = ptr + sZ
            while ptr <> eZ do
                let eX = ptr + sX
                while ptr <> eX do
                    let eW = ptr + sW
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jW
                    ptr <- ptr + jX
                ptr <- ptr + jZ
            ptr <- ptr + jY
    member inline private x.SetYZWX(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let eY = ptr + sY
        while ptr <> eY do
            let eZ = ptr + sZ
            while ptr <> eZ do
                let eW = ptr + sW
                while ptr <> eW do
                    let eX = ptr + sX
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jX
                    ptr <- ptr + jW
                ptr <- ptr + jZ
            ptr <- ptr + jY
    member inline private x.SetXZYW(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let eX = ptr + sX
        while ptr <> eX do
            let eZ = ptr + sZ
            while ptr <> eZ do
                let eY = ptr + sY
                while ptr <> eY do
                    let eW = ptr + sW
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jW
                    ptr <- ptr + jY
                ptr <- ptr + jZ
            ptr <- ptr + jX
    member inline private x.SetZXYW(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eX = ptr + sX
            while ptr <> eX do
                let eY = ptr + sY
                while ptr <> eY do
                    let eW = ptr + sW
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jW
                    ptr <- ptr + jY
                ptr <- ptr + jX
            ptr <- ptr + jZ
    member inline private x.SetZYXW(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eY = ptr + sY
            while ptr <> eY do
                let eX = ptr + sX
                while ptr <> eX do
                    let eW = ptr + sW
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jW
                    ptr <- ptr + jX
                ptr <- ptr + jY
            ptr <- ptr + jZ
    member inline private x.SetZYWX(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eY = ptr + sY
            while ptr <> eY do
                let eW = ptr + sW
                while ptr <> eW do
                    let eX = ptr + sX
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jX
                    ptr <- ptr + jW
                ptr <- ptr + jY
            ptr <- ptr + jZ
    member inline private x.SetXZWY(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let eX = ptr + sX
        while ptr <> eX do
            let eZ = ptr + sZ
            while ptr <> eZ do
                let eW = ptr + sW
                while ptr <> eW do
                    let eY = ptr + sY
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jY
                    ptr <- ptr + jW
                ptr <- ptr + jZ
            ptr <- ptr + jX
    member inline private x.SetZXWY(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eX = ptr + sX
            while ptr <> eX do
                let eW = ptr + sW
                while ptr <> eW do
                    let eY = ptr + sY
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jY
                    ptr <- ptr + jW
                ptr <- ptr + jX
            ptr <- ptr + jZ
    member inline private x.SetZWXY(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eW = ptr + sW
            while ptr <> eW do
                let eX = ptr + sX
                while ptr <> eX do
                    let eY = ptr + sY
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jY
                    ptr <- ptr + jX
                ptr <- ptr + jW
            ptr <- ptr + jZ
    member inline private x.SetZWYX(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eW = ptr + sW
            while ptr <> eW do
                let eY = ptr + sY
                while ptr <> eY do
                    let eX = ptr + sX
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jX
                    ptr <- ptr + jY
                ptr <- ptr + jW
            ptr <- ptr + jZ
    member inline private x.SetXYWZ(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            while ptr <> eY do
                let eW = ptr + sW
                while ptr <> eW do
                    let eZ = ptr + sZ
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jZ
                    ptr <- ptr + jW
                ptr <- ptr + jY
            ptr <- ptr + jX
    member inline private x.SetYXWZ(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            while ptr <> eX do
                let eW = ptr + sW
                while ptr <> eW do
                    let eZ = ptr + sZ
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jZ
                    ptr <- ptr + jW
                ptr <- ptr + jX
            ptr <- ptr + jY
    member inline private x.SetYWXZ(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let eY = ptr + sY
        while ptr <> eY do
            let eW = ptr + sW
            while ptr <> eW do
                let eX = ptr + sX
                while ptr <> eX do
                    let eZ = ptr + sZ
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jZ
                    ptr <- ptr + jX
                ptr <- ptr + jW
            ptr <- ptr + jY
    member inline private x.SetYWZX(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let eY = ptr + sY
        while ptr <> eY do
            let eW = ptr + sW
            while ptr <> eW do
                let eZ = ptr + sZ
                while ptr <> eZ do
                    let eX = ptr + sX
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jX
                    ptr <- ptr + jZ
                ptr <- ptr + jW
            ptr <- ptr + jY
    member inline private x.SetXWYZ(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let eX = ptr + sX
        while ptr <> eX do
            let eW = ptr + sW
            while ptr <> eW do
                let eY = ptr + sY
                while ptr <> eY do
                    let eZ = ptr + sZ
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jZ
                    ptr <- ptr + jY
                ptr <- ptr + jW
            ptr <- ptr + jX
    member inline private x.SetWXYZ(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let eW = ptr + sW
        while ptr <> eW do
            let eX = ptr + sX
            while ptr <> eX do
                let eY = ptr + sY
                while ptr <> eY do
                    let eZ = ptr + sZ
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jZ
                    ptr <- ptr + jY
                ptr <- ptr + jX
            ptr <- ptr + jW
    member inline private x.SetWYXZ(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let eW = ptr + sW
        while ptr <> eW do
            let eY = ptr + sY
            while ptr <> eY do
                let eX = ptr + sX
                while ptr <> eX do
                    let eZ = ptr + sZ
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jZ
                    ptr <- ptr + jX
                ptr <- ptr + jY
            ptr <- ptr + jW
    member inline private x.SetWYZX(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let eW = ptr + sW
        while ptr <> eW do
            let eY = ptr + sY
            while ptr <> eY do
                let eZ = ptr + sZ
                while ptr <> eZ do
                    let eX = ptr + sX
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jX
                    ptr <- ptr + jZ
                ptr <- ptr + jY
            ptr <- ptr + jW
    member inline private x.SetXWZY(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let eX = ptr + sX
        while ptr <> eX do
            let eW = ptr + sW
            while ptr <> eW do
                let eZ = ptr + sZ
                while ptr <> eZ do
                    let eY = ptr + sY
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jY
                    ptr <- ptr + jZ
                ptr <- ptr + jW
            ptr <- ptr + jX
    member inline private x.SetWXZY(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let eW = ptr + sW
        while ptr <> eW do
            let eX = ptr + sX
            while ptr <> eX do
                let eZ = ptr + sZ
                while ptr <> eZ do
                    let eY = ptr + sY
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jY
                    ptr <- ptr + jZ
                ptr <- ptr + jX
            ptr <- ptr + jW
    member inline private x.SetWZXY(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let eW = ptr + sW
        while ptr <> eW do
            let eZ = ptr + sZ
            while ptr <> eZ do
                let eX = ptr + sX
                while ptr <> eX do
                    let eY = ptr + sY
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jY
                    ptr <- ptr + jX
                ptr <- ptr + jZ
            ptr <- ptr + jW
    member inline private x.SetWZYX(value : 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let eW = ptr + sW
        while ptr <> eW do
            let eZ = ptr + sZ
            while ptr <> eZ do
                let eY = ptr + sY
                while ptr <> eY do
                    let eX = ptr + sX
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) value
                        ptr <- ptr + jX
                    ptr <- ptr + jY
                ptr <- ptr + jZ
            ptr <- ptr + jW
    member x.Set(value : 'a) = 
        let cXW = compare (abs info.DX) (abs info.DW)
        let cXY = compare (abs info.DX) (abs info.DY)
        let cXZ = compare (abs info.DX) (abs info.DZ)
        let cYW = compare (abs info.DY) (abs info.DW)
        let cYZ = compare (abs info.DY) (abs info.DZ)
        let cZW = compare (abs info.DZ) (abs info.DW)
        if cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetXYZW(value)
        elif cXW >= 0  && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetYXZW(value)
        elif cXW >= 0  && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetYZXW(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetYZWX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetXZYW(value)
        elif cXW >= 0  && cXY >= 0  && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetZXYW(value)
        elif cXW >= 0  && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetZYXW(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetZYWX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetXZWY(value)
        elif cXW >= 0  && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetZXWY(value)
        elif cXW <= 0 && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetZWXY(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetZWYX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetXYWZ(value)
        elif cXW >= 0  && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetYXWZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetYWXZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetYWZX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetXWYZ(value)
        elif cXW <= 0 && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetWXYZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetWYXZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetWYZX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.SetXWZY(value)
        elif cXW <= 0 && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.SetWXZY(value)
        elif cXW <= 0 && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.SetWZXY(value)
        else x.SetWZYX(value)
    member inline private x.SetByCoordXYZW(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordYXZW(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYZXW(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYZWX(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordXZYW(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordZXYW(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZYXW(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZYWX(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordXZWY(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordZXWY(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZWXY(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZWYX(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordXYWZ(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordYXWZ(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYWXZ(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYWZX(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordXWYZ(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordWXYZ(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordWYXZ(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordWYZX(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordXWZY(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordWXZY(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordWZXY(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordWZYX(getValue : V4l -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4l.Zero
        let step = V4l.One
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member x.SetByCoord(value : V4l -> 'a) = 
        let cXW = compare (abs info.DX) (abs info.DW)
        let cXY = compare (abs info.DX) (abs info.DY)
        let cXZ = compare (abs info.DX) (abs info.DZ)
        let cYW = compare (abs info.DY) (abs info.DW)
        let cYZ = compare (abs info.DY) (abs info.DZ)
        let cZW = compare (abs info.DZ) (abs info.DW)
        if cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetByCoordXYZW(value)
        elif cXW >= 0  && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetByCoordYXZW(value)
        elif cXW >= 0  && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetByCoordYZXW(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetByCoordYZWX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetByCoordXZYW(value)
        elif cXW >= 0  && cXY >= 0  && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetByCoordZXYW(value)
        elif cXW >= 0  && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetByCoordZYXW(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetByCoordZYWX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetByCoordXZWY(value)
        elif cXW >= 0  && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetByCoordZXWY(value)
        elif cXW <= 0 && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetByCoordZWXY(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetByCoordZWYX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetByCoordXYWZ(value)
        elif cXW >= 0  && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetByCoordYXWZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetByCoordYWXZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetByCoordYWZX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetByCoordXWYZ(value)
        elif cXW <= 0 && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetByCoordWXYZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetByCoordWYXZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetByCoordWYZX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.SetByCoordXWZY(value)
        elif cXW <= 0 && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.SetByCoordWXZY(value)
        elif cXW <= 0 && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.SetByCoordWZXY(value)
        else x.SetByCoordWZYX(value)
    member inline private x.SetByCoordXYZW(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordYXZW(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYZXW(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYZWX(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordXZYW(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordZXYW(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZYXW(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZYWX(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordXZWY(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordZXWY(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZWXY(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZWYX(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordXYWZ(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordYXWZ(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYWXZ(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYWZX(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordXWYZ(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordWXYZ(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordWYXZ(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordWYZX(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordXWZY(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordWXZY(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordWZXY(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordWZYX(getValue : V4i -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4i.Zero
        let step = V4i.One
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member x.SetByCoord(value : V4i -> 'a) = 
        let cXW = compare (abs info.DX) (abs info.DW)
        let cXY = compare (abs info.DX) (abs info.DY)
        let cXZ = compare (abs info.DX) (abs info.DZ)
        let cYW = compare (abs info.DY) (abs info.DW)
        let cYZ = compare (abs info.DY) (abs info.DZ)
        let cZW = compare (abs info.DZ) (abs info.DW)
        if cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetByCoordXYZW(value)
        elif cXW >= 0  && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetByCoordYXZW(value)
        elif cXW >= 0  && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetByCoordYZXW(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetByCoordYZWX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetByCoordXZYW(value)
        elif cXW >= 0  && cXY >= 0  && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetByCoordZXYW(value)
        elif cXW >= 0  && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetByCoordZYXW(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetByCoordZYWX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetByCoordXZWY(value)
        elif cXW >= 0  && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetByCoordZXWY(value)
        elif cXW <= 0 && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetByCoordZWXY(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetByCoordZWYX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetByCoordXYWZ(value)
        elif cXW >= 0  && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetByCoordYXWZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetByCoordYWXZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetByCoordYWZX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetByCoordXWYZ(value)
        elif cXW <= 0 && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetByCoordWXYZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetByCoordWYXZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetByCoordWYZX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.SetByCoordXWZY(value)
        elif cXW <= 0 && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.SetByCoordWXZY(value)
        elif cXW <= 0 && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.SetByCoordWZXY(value)
        else x.SetByCoordWZYX(value)
    member inline private x.SetByCoordXYZW(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordYXZW(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYZXW(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYZWX(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordXZYW(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordZXYW(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZYXW(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eW = ptr + sW
                    coord.W <- initialCoord.W
                    while ptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.W <- coord.W + step.W
                        ptr <- ptr + jW
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZYWX(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordXZWY(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordZXWY(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZWXY(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordZWYX(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eZ = ptr + sZ
        while ptr <> eZ do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.Z <- coord.Z + step.Z
            ptr <- ptr + jZ
    member inline private x.SetByCoordXYWZ(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordYXWZ(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eW = ptr + sW
                coord.W <- initialCoord.W
                while ptr <> eW do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.W <- coord.W + step.W
                    ptr <- ptr + jW
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYWXZ(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordYWZX(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eY = ptr + sY
        while ptr <> eY do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.Y <- coord.Y + step.Y
            ptr <- ptr + jY
    member inline private x.SetByCoordXWYZ(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordWXYZ(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordWYXZ(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eZ = ptr + sZ
                    coord.Z <- initialCoord.Z
                    while ptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Z <- coord.Z + step.Z
                        ptr <- ptr + jZ
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordWYZX(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eY = ptr + sY
            coord.Y <- initialCoord.Y
            while ptr <> eY do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.Y <- coord.Y + step.Y
                ptr <- ptr + jY
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordXWZY(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SW * info.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eX = ptr + sX
        while ptr <> eX do
            let eW = ptr + sW
            coord.W <- initialCoord.W
            while ptr <> eW do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.W <- coord.W + step.W
                ptr <- ptr + jW
            coord.X <- coord.X + step.X
            ptr <- ptr + jX
    member inline private x.SetByCoordWXZY(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eX = ptr + sX
            coord.X <- initialCoord.X
            while ptr <> eX do
                let eZ = ptr + sZ
                coord.Z <- initialCoord.Z
                while ptr <> eZ do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.Z <- coord.Z + step.Z
                    ptr <- ptr + jZ
                coord.X <- coord.X + step.X
                ptr <- ptr + jX
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordWZXY(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eX = ptr + sX
                coord.X <- initialCoord.X
                while ptr <> eX do
                    let eY = ptr + sY
                    coord.Y <- initialCoord.Y
                    while ptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.Y <- coord.Y + step.Y
                        ptr <- ptr + jY
                    coord.X <- coord.X + step.X
                    ptr <- ptr + jX
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member inline private x.SetByCoordWZYX(getValue : V4d -> 'a) = 
        let sa = nativeint (sizeof<'a>)
        let mutable ptr = ptr |> NativePtr.toNativeInt
        ptr <- ptr + nativeint info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let jW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let jZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let jY = nativeint (info.DY - info.SX * info.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let jX = nativeint (info.DX) * sa
        let initialCoord = V4d(0.5, 0.5, 0.5, 0.5) / V4d(x.Size)
        let step = V4d.One / V4d(x.Size)
        let mutable coord = initialCoord
        let eW = ptr + sW
        while ptr <> eW do
            let eZ = ptr + sZ
            coord.Z <- initialCoord.Z
            while ptr <> eZ do
                let eY = ptr + sY
                coord.Y <- initialCoord.Y
                while ptr <> eY do
                    let eX = ptr + sX
                    coord.X <- initialCoord.X
                    while ptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> ptr) (getValue coord)
                        coord.X <- coord.X + step.X
                        ptr <- ptr + jX
                    coord.Y <- coord.Y + step.Y
                    ptr <- ptr + jY
                coord.Z <- coord.Z + step.Z
                ptr <- ptr + jZ
            coord.W <- coord.W + step.W
            ptr <- ptr + jW
    member x.SetByCoord(value : V4d -> 'a) = 
        let cXW = compare (abs info.DX) (abs info.DW)
        let cXY = compare (abs info.DX) (abs info.DY)
        let cXZ = compare (abs info.DX) (abs info.DZ)
        let cYW = compare (abs info.DY) (abs info.DW)
        let cYZ = compare (abs info.DY) (abs info.DZ)
        let cZW = compare (abs info.DZ) (abs info.DW)
        if cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetByCoordXYZW(value)
        elif cXW >= 0  && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetByCoordYXZW(value)
        elif cXW >= 0  && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetByCoordYZXW(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.SetByCoordYZWX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetByCoordXZYW(value)
        elif cXW >= 0  && cXY >= 0  && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetByCoordZXYW(value)
        elif cXW >= 0  && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetByCoordZYXW(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.SetByCoordZYWX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetByCoordXZWY(value)
        elif cXW >= 0  && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetByCoordZXWY(value)
        elif cXW <= 0 && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetByCoordZWXY(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.SetByCoordZWYX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetByCoordXYWZ(value)
        elif cXW >= 0  && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetByCoordYXWZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetByCoordYWXZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.SetByCoordYWZX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetByCoordXWYZ(value)
        elif cXW <= 0 && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetByCoordWXYZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetByCoordWYXZ(value)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.SetByCoordWYZX(value)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.SetByCoordXWZY(value)
        elif cXW <= 0 && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.SetByCoordWXZY(value)
        elif cXW <= 0 && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.SetByCoordWZXY(value)
        else x.SetByCoordWZYX(value)
    member inline private x.BlitToInternalXYZW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYZWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYZEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYZEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYEZW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYEZWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYEZEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYEZEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXEYZW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYZWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYZEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYZEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYEZW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYEZWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYEZEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYEZEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToXYZW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXEYEZEWE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEYEZEW(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXEYEZWE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXEYZEWE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXYEZEWE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEYEZW(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEYZEW(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXEYZWE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXYEZEW(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXYEZWE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXYZEWE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalXEYZW(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXYEZW(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXYZEW(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXYZWE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalXYZW(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalYXZW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXZWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXZEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXZEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXEZW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXEZWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXEZEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXEZEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYEXZW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXZWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXZEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXZEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXEZW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXEZWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXEZEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXEZEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToYXZW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYEXEZEWE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEXEZEW(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYEXEZWE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYEXZEWE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYXEZEWE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEXEZW(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEXZEW(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYEXZWE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYXEZEW(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYXEZWE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYXZEWE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalYEXZW(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYXEZW(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYXZEW(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYXZWE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalYXZW(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalYZXW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZXWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZXEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZXEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZEXW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZEXWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZEXEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZEXEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYEZXW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZXWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZXEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZXEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZEXW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZEXWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZEXEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZEXEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToYZXW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYEZEXEWE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEZEXEW(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYEZEXWE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYEZXEWE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYZEXEWE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEZEXW(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEZXEW(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYEZXWE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYZEXEW(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYZEXWE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYZXEWE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalYEZXW(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYZEXW(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYZXEW(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYZXWE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalYZXW(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalYZWX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZWXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZWEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZWEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZEWX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZEWXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZEWEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYZEWEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYEZWX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZWXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZWEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZWEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZEWX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZEWXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZEWEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEZEWEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToYZWX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEZEWEXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYEZEWEX(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEZEWXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEZWEXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYZEWEXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEZEWX(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYEZWEX(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEZWXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYZEWEX(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYZEWXE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYZWEXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalYEZWX(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYZEWX(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYZWEX(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYZWXE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalYZWX(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalXZYW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZYWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZYEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZYEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZEYW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZEYWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZEYEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZEYEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXEZYW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZYWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZYEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZYEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZEYW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZEYWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZEYEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZEYEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToXZYW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXEZEYEWE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEZEYEW(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXEZEYWE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXEZYEWE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXZEYEWE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEZEYW(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEZYEW(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXEZYWE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXZEYEW(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXZEYWE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXZYEWE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalXEZYW(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXZEYW(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXZYEW(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXZYWE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalXZYW(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalZXYW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXYWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXYEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXYEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXEYW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXEYWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXEYEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXEYEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZEXYW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXYWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXYEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXYEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXEYW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXEYWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXEYEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXEYEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToZXYW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZEXEYEWE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEXEYEW(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZEXEYWE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZEXYEWE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZXEYEWE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEXEYW(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEXYEW(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZEXYWE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZXEYEW(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZXEYWE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZXYEWE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalZEXYW(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZXEYW(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZXYEW(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZXYWE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalZXYW(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalZYXW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYXWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYXEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYXEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYEXW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYEXWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYEXEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYEXEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZEYXW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYXWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYXEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYXEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYEXW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYEXWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYEXEW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    frac.W <- initialFrac.W
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjW
                        coord.W <- coord.W + step.W
                        let ni = int64 (floor coord.W)
                        px <- px + xdW * nativeint (ni - icoord.W)
                        icoord.W <- ni
                        frac.W <- coord.W - float(icoord.W)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYEXEWE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint y.DW * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeW = py + ysW
                    coord.W <- initialCoord.W
                    px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                    icoord.W <- initialiCoord.W
                    while py <> yeW do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjW
                        px <- px + xjW
                        coord.W <- coord.W + step.W
                        icoord.W <- icoord.W + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToZYXW(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZEYEXEWE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEYEXEW(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZEYEXWE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZEYXEWE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZYEXEWE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEYEXW(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEYXEW(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZEYXWE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZYEXEW(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZYEXWE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZYXEWE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalZEYXW(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZYEXW(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZYXEW(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZYXWE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalZYXW(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalZYWX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYWXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYWEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYWEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYEWX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYEWXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYEWEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZYEWEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZEYWX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYWXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYWEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYWEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYEWX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYEWXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYEWEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEYEWEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToZYWX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEYEWEXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZEYEWEX(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEYEWXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEYWEXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZYEWEXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEYEWX(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZEYWEX(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEYWXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZYEWEX(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZYEWXE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZYWEXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalZEYWX(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZYEWX(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZYWEX(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZYWXE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalZYWX(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalXZWY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZWYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZWEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZWEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZEWY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZEWYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZEWEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXZEWEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXEZWY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZWYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZWEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZWEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZEWY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZEWYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZEWEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEZEWEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToXZWY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEZEWEYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXEZEWEY(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEZEWYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEZWEYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXZEWEYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEZEWY(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXEZWEY(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEZWYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXZEWEY(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXZEWYE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXZWEYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalXEZWY(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXZEWY(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXZWEY(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXZWYE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalXZWY(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalZXWY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXWYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXWEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXWEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXEWY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXEWYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXEWEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZXEWEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZEXWY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXWYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXWEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXWEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXEWY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXEWYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXEWEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEXEWEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToZXWY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEXEWEYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZEXEWEY(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEXEWYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEXWEYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZXEWEYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEXEWY(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZEXWEY(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEXWYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZXEWEY(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZXEWYE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZXWEYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalZEXWY(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZXEWY(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZXWEY(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZXWYE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalZXWY(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalZWXY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZWXYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZWXEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZWXEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZWEXY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZWEXYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZWEXEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZWEXEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZEWXY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEWXYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEWXEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEWXEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEWEXY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEWEXYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEWEXEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEWEXEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToZWXY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEWEXEYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEWEXEY(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEWEXYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEWXEYE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZWEXEYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZEWEXY(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEWXEY(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEWXYE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZWEXEY(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZWEXYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZWXEYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalZEWXY(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZWEXY(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZWXEY(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZWXYE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalZWXY(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalZWYX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZWYXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZWYEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZWYEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZWEYX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZWEYXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZWEYEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZWEYEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            coord.Z <- coord.Z + step.Z
            let ni = int64 (floor coord.Z)
            px <- px + xdZ * nativeint (ni - icoord.Z)
            icoord.Z <- ni
            frac.Z <- coord.Z - float(icoord.Z)
    member inline private x.BlitToInternalZEWYX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEWYXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEWYEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEWYEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEWEYX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEWEYXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEWEYEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToInternalZEWEYEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SW * x.DW) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdZ * nativeint icoord.Z + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeZ = py + ysZ
        while py <> yeZ do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjZ
            px <- px + xjZ
            coord.Z <- coord.Z + step.Z
            icoord.Z <- icoord.Z + 1L
    member inline private x.BlitToZWYX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEWEYEXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEWEYEX(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEWEYXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEWYEXE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZWEYEXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZEWEYX(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZEWYEX(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZEWYXE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZWEYEX(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZWEYXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZWYEXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalZEWYX(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalZWEYX(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalZWYEX(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalZWYXE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalZWYX(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalXYWZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYWZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYWEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYWEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYEWZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYEWZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYEWEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXYEWEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXEYWZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYWZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYWEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYWEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYEWZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYEWZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYEWEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEYEWEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToXYWZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEYEWEZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXEYEWEZ(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEYEWZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEYWEZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXYEWEZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEYEWZ(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXEYWEZ(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEYWZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXYEWEZ(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXYEWZE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXYWEZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalXEYWZ(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXYEWZ(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXYWEZ(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXYWZE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalXYWZ(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalYXWZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXWZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXWEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXWEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXEWZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXEWZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXEWEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYXEWEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYEXWZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXWZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXWEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXWEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXEWZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXEWZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                frac.W <- initialFrac.W
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    coord.W <- coord.W + step.W
                    let ni = int64 (floor coord.W)
                    px <- px + xdW * nativeint (ni - icoord.W)
                    icoord.W <- ni
                    frac.W <- coord.W - float(icoord.W)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXEWEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEXEWEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeW = py + ysW
                coord.W <- initialCoord.W
                px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
                icoord.W <- initialiCoord.W
                while py <> yeW do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjW
                    px <- px + xjW
                    coord.W <- coord.W + step.W
                    icoord.W <- icoord.W + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToYXWZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEXEWEZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYEXEWEZ(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEXEWZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEXWEZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYXEWEZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEXEWZ(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYEXWEZ(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEXWZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYXEWEZ(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYXEWZE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYXWEZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalYEXWZ(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYXEWZ(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYXWEZ(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYXWZE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalYXWZ(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalYWXZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYWXZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYWXEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYWXEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYWEXZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYWEXZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYWEXEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYWEXEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYEWXZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEWXZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEWXEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEWXEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEWEXZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEWEXZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEWEXEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEWEXEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToYWXZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEWEXEZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEWEXEZ(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEWEXZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEWXEZE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYWEXEZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYEWEXZ(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEWXEZ(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEWXZE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYWEXEZ(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYWEXZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYWXEZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalYEWXZ(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYWEXZ(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYWXEZ(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYWXZE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalYWXZ(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalYWZX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYWZXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYWZEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYWZEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYWEZX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYWEZXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYWEZEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYWEZEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            coord.Y <- coord.Y + step.Y
            let ni = int64 (floor coord.Y)
            px <- px + xdY * nativeint (ni - icoord.Y)
            icoord.Y <- ni
            frac.Y <- coord.Y - float(icoord.Y)
    member inline private x.BlitToInternalYEWZX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEWZXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEWZEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEWZEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEWEZX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEWEZXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEWEZEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToInternalYEWEZEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SW * x.DW) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdY * nativeint icoord.Y + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeY = py + ysY
        while py <> yeY do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjY
            px <- px + xjY
            coord.Y <- coord.Y + step.Y
            icoord.Y <- icoord.Y + 1L
    member inline private x.BlitToYWZX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEWEZEXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEWEZEX(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEWEZXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEWZEXE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYWEZEXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYEWEZX(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYEWZEX(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYEWZXE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYWEZEX(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYWEZXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYWZEXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalYEWZX(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalYWEZX(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalYWZEX(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalYWZXE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalYWZX(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalXWYZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXWYZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXWYEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXWYEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXWEYZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXWEYZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXWEYEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXWEYEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXEWYZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEWYZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEWYEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEWYEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEWEYZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEWEYZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEWEYEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEWEYEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToXWYZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEWEYEZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEWEYEZ(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEWEYZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEWYEZE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXWEYEZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXEWEYZ(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEWYEZ(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEWYZE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXWEYEZ(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXWEYZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXWYEZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalXEWYZ(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXWEYZ(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXWYEZ(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXWYZE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalXWYZ(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalWXYZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWXYZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWXYEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWXYEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWXEYZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWXEYZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWXEYEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWXEYEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWEXYZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEXYZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEXYEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEXYEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEXEYZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEXEYZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEXEYEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEXEYEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToWXYZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWEXEYEZE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWEXEYEZ(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWEXEYZE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWEXYEZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWXEYEZE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWEXEYZ(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWEXYEZ(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWEXYZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWXEYEZ(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWXEYZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWXYEZE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalWEXYZ(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWXEYZ(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWXYEZ(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWXYZE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalWXYZ(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalWYXZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWYXZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWYXEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWYXEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWYEXZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWYEXZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWYEXEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWYEXEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWEYXZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEYXZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEYXEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEYXEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEYEXZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEYEXZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEYEXEZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    frac.Z <- initialFrac.Z
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjZ
                        coord.Z <- coord.Z + step.Z
                        let ni = int64 (floor coord.Z)
                        px <- px + xdZ * nativeint (ni - icoord.Z)
                        icoord.Z <- ni
                        frac.Z <- coord.Z - float(icoord.Z)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEYEXEZE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint y.DZ * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeZ = py + ysZ
                    coord.Z <- initialCoord.Z
                    px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                    icoord.Z <- initialiCoord.Z
                    while py <> yeZ do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjZ
                        px <- px + xjZ
                        coord.Z <- coord.Z + step.Z
                        icoord.Z <- icoord.Z + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToWYXZ(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWEYEXEZE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWEYEXEZ(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWEYEXZE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWEYXEZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWYEXEZE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWEYEXZ(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWEYXEZ(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWEYXZE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWYEXEZ(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWYEXZE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWYXEZE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalWEYXZ(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWYEXZ(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWYXEZ(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWYXZE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalWYXZ(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalWYZX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWYZXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWYZEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWYZEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWYEZX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWYEZXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWYEZEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWYEZEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWEYZX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEYZXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEYZEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEYZEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            frac.Y <- initialFrac.Y
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                coord.Y <- coord.Y + step.Y
                let ni = int64 (floor coord.Y)
                px <- px + xdY * nativeint (ni - icoord.Y)
                icoord.Y <- ni
                frac.Y <- coord.Y - float(icoord.Y)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEYEZX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEYEZXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEYEZEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEYEZEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SY * x.DY) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SZ * x.DZ) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdY * nativeint icoord.Y + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeY = py + ysY
            coord.Y <- initialCoord.Y
            px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
            icoord.Y <- initialiCoord.Y
            while py <> yeY do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjY
                px <- px + xjY
                coord.Y <- coord.Y + step.Y
                icoord.Y <- icoord.Y + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToWYZX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWEYEZEXE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWEYEZEX(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWEYEZXE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWEYZEXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWYEZEXE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWEYEZX(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWEYZEX(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWEYZXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWYEZEX(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWYEZXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWYZEXE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalWEYZX(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWYEZX(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWYZEX(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWYZXE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalWYZX(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalXWZY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXWZYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXWZEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXWZEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXWEZY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXWEZYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXWEZEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXWEZEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            coord.X <- coord.X + step.X
            let ni = int64 (floor coord.X)
            px <- px + xdX * nativeint (ni - icoord.X)
            icoord.X <- ni
            frac.X <- coord.X - float(icoord.X)
    member inline private x.BlitToInternalXEWZY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEWZYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEWZEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEWZEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            frac.W <- initialFrac.W
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                coord.W <- coord.W + step.W
                let ni = int64 (floor coord.W)
                px <- px + xdW * nativeint (ni - icoord.W)
                icoord.W <- ni
                frac.W <- coord.W - float(icoord.W)
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEWEZY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEWEZYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEWEZEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToInternalXEWEZEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SW * x.DW) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdX * nativeint icoord.X + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeX = py + ysX
        while py <> yeX do
            let yeW = py + ysW
            coord.W <- initialCoord.W
            px <- px + xdW * nativeint (initialiCoord.W - icoord.W)
            icoord.W <- initialiCoord.W
            while py <> yeW do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjW
                px <- px + xjW
                coord.W <- coord.W + step.W
                icoord.W <- icoord.W + 1L
            py <- py + yjX
            px <- px + xjX
            coord.X <- coord.X + step.X
            icoord.X <- icoord.X + 1L
    member inline private x.BlitToXWZY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEWEZEYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEWEZEY(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEWEZYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEWZEYE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXWEZEYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXEWEZY(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXEWZEY(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXEWZYE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXWEZEY(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXWEZYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXWZEYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalXEWZY(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalXWEZY(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalXWZEY(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalXWZYE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalXWZY(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalWXZY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWXZYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWXZEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWXZEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWXEZY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWXEZYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWXEZEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWXEZEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWEXZY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEXZYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEXZEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEXZEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            frac.X <- initialFrac.X
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                coord.X <- coord.X + step.X
                let ni = int64 (floor coord.X)
                px <- px + xdX * nativeint (ni - icoord.X)
                icoord.X <- ni
                frac.X <- coord.X - float(icoord.X)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEXEZY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEXEZYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                frac.Z <- initialFrac.Z
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    coord.Z <- coord.Z + step.Z
                    let ni = int64 (floor coord.Z)
                    px <- px + xdZ * nativeint (ni - icoord.Z)
                    icoord.Z <- ni
                    frac.Z <- coord.Z - float(icoord.Z)
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEXEZEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEXEZEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SX * x.DX) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SZ * x.DZ) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdX * nativeint icoord.X + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeX = py + ysX
            coord.X <- initialCoord.X
            px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
            icoord.X <- initialiCoord.X
            while py <> yeX do
                let yeZ = py + ysZ
                coord.Z <- initialCoord.Z
                px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
                icoord.Z <- initialiCoord.Z
                while py <> yeZ do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjZ
                    px <- px + xjZ
                    coord.Z <- coord.Z + step.Z
                    icoord.Z <- icoord.Z + 1L
                py <- py + yjX
                px <- px + xjX
                coord.X <- coord.X + step.X
                icoord.X <- icoord.X + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToWXZY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWEXEZEYE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWEXEZEY(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWEXEZYE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWEXZEYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWXEZEYE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWEXEZY(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWEXZEY(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWEXZYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWXEZEY(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWXEZYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWXZEYE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalWEXZY(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWXEZY(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWXZEY(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWXZYE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalWXZY(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalWZXY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWZXYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWZXEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWZXEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWZEXY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWZEXYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWZEXEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWZEXEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWEZXY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEZXYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEZXEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEZXEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEZEXY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEZEXYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                frac.X <- initialFrac.X
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    coord.X <- coord.X + step.X
                    let ni = int64 (floor coord.X)
                    px <- px + xdX * nativeint (ni - icoord.X)
                    icoord.X <- ni
                    frac.X <- coord.X - float(icoord.X)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEZEXEY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    frac.Y <- initialFrac.Y
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjY
                        coord.Y <- coord.Y + step.Y
                        let ni = int64 (floor coord.Y)
                        px <- px + xdY * nativeint (ni - icoord.Y)
                        icoord.Y <- ni
                        frac.Y <- coord.Y - float(icoord.Y)
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEZEXEYE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SX * x.DX) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint (x.DX - x.SY * x.DY) * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint y.DY * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdX * nativeint icoord.X + xdY * nativeint icoord.Y
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeX = py + ysX
                coord.X <- initialCoord.X
                px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                icoord.X <- initialiCoord.X
                while py <> yeX do
                    let yeY = py + ysY
                    coord.Y <- initialCoord.Y
                    px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                    icoord.Y <- initialiCoord.Y
                    while py <> yeY do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjY
                        px <- px + xjY
                        coord.Y <- coord.Y + step.Y
                        icoord.Y <- icoord.Y + 1L
                    py <- py + yjX
                    px <- px + xjX
                    coord.X <- coord.X + step.X
                    icoord.X <- icoord.X + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToWZXY(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWEZEXEYE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWEZEXEY(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWEZEXYE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWEZXEYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWZEXEYE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWEZEXY(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWEZXEY(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWEZXYE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWZEXEY(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWZEXYE(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWZXEYE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalWEZXY(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWZEXY(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWZXEY(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWZXYE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalWZXY(y, srcOffset, srcSize, lerp)
    member inline private x.BlitToInternalWZYX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        let vx111 = lerp.Invoke(frac.X, v0111, v1111)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
                        // lerp W
                        let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxxx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWZYXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx110 = lerp.Invoke(frac.X, v0110, v1110)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
                        // lerp Z
                        let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxxx0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWZYEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        let vx101 = lerp.Invoke(frac.X, v0101, v1101)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
                        // lerp W
                        let vxx0x = lerp.Invoke(frac.W, vxx00, vxx01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx0x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWZYEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdY))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx100 = lerp.Invoke(frac.X, v0100, v1100)
                        // lerp Y
                        let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vxx00
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWZEYX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        let vx011 = lerp.Invoke(frac.X, v0011, v1011)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        let vx0x1 = lerp.Invoke(frac.Z, vx001, vx011)
                        // lerp W
                        let vx0xx = lerp.Invoke(frac.W, vx0x0, vx0x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0xx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWZEYXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdZ))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx010 = lerp.Invoke(frac.X, v0010, v1010)
                        // lerp Z
                        let vx0x0 = lerp.Invoke(frac.Z, vx000, vx010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx0x0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWZEYEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX + xdW))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        let vx001 = lerp.Invoke(frac.X, v0001, v1001)
                        // lerp W
                        let vx00x = lerp.Invoke(frac.W, vx000, vx001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx00x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWZEYEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdX))
                        // lerp X
                        let vx000 = lerp.Invoke(frac.X, v0000, v1000)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) vx000
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            coord.W <- coord.W + step.W
            let ni = int64 (floor coord.W)
            px <- px + xdW * nativeint (ni - icoord.W)
            icoord.W <- ni
            frac.W <- coord.W - float(icoord.W)
    member inline private x.BlitToInternalWEZYX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        let v0x11 = lerp.Invoke(frac.Y, v0011, v0111)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        let v0xx1 = lerp.Invoke(frac.Z, v0x01, v0x11)
                        // lerp W
                        let v0xxx = lerp.Invoke(frac.W, v0xx0, v0xx1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xxx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEZYXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdZ))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x10 = lerp.Invoke(frac.Y, v0010, v0110)
                        // lerp Z
                        let v0xx0 = lerp.Invoke(frac.Z, v0x00, v0x10)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0xx0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEZYEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY + xdW))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        let v0x01 = lerp.Invoke(frac.Y, v0001, v0101)
                        // lerp W
                        let v0x0x = lerp.Invoke(frac.W, v0x00, v0x01)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x0x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEZYEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            frac.Z <- initialFrac.Z
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdY))
                        // lerp Y
                        let v0x00 = lerp.Invoke(frac.Y, v0000, v0100)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0x00
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                coord.Z <- coord.Z + step.Z
                let ni = int64 (floor coord.Z)
                px <- px + xdZ * nativeint (ni - icoord.Z)
                icoord.Z <- ni
                frac.Z <- coord.Z - float(icoord.Z)
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEZEYX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ + xdW))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        let v00x1 = lerp.Invoke(frac.Z, v0001, v0011)
                        // lerp W
                        let v00xx = lerp.Invoke(frac.W, v00x0, v00x1)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00xx
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEZEYXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                frac.Y <- initialFrac.Y
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdZ))
                        // lerp Z
                        let v00x0 = lerp.Invoke(frac.Z, v0000, v0010)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v00x0
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    coord.Y <- coord.Y + step.Y
                    let ni = int64 (floor coord.Y)
                    px <- px + xdY * nativeint (ni - icoord.Y)
                    icoord.Y <- ni
                    frac.Y <- coord.Y - float(icoord.Y)
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEZEYEX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    frac.X <- initialFrac.X
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (px + xdW))
                        // lerp W
                        let v000x = lerp.Invoke(frac.W, v0000, v0001)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v000x
                        py <- py + yjX
                        coord.X <- coord.X + step.X
                        let ni = int64 (floor coord.X)
                        px <- px + xdX * nativeint (ni - icoord.X)
                        icoord.X <- ni
                        frac.X <- coord.X - float(icoord.X)
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToInternalWEZEYEXE(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let sa = nativeint (sizeof<'a>)
        let mutable py = y.Pointer |> NativePtr.toNativeInt
        py <- py + nativeint y.Info.Origin * sa
        let mutable px = x.Pointer |> NativePtr.toNativeInt
        px <- px + nativeint x.Info.Origin * sa
        let xdW = nativeint x.DW * sa
        let xjW = nativeint (x.DW - x.SZ * x.DZ) * sa
        let ysW = nativeint (y.SW * y.DW) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let xdZ = nativeint x.DZ * sa
        let xjZ = nativeint (x.DZ - x.SY * x.DY) * sa
        let ysZ = nativeint (y.SZ * y.DZ) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let xdY = nativeint x.DY * sa
        let xjY = nativeint (x.DY - x.SX * x.DX) * sa
        let ysY = nativeint (y.SY * y.DY) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let xdX = nativeint x.DX * sa
        let xjX = nativeint x.DX * sa
        let ysX = nativeint (y.SX * y.DX) * sa
        let yjX = nativeint y.DX * sa
        let ratio = (V4d(x.Size) * srcSize) / V4d(y.Size)
        let initialCoord = (0.5 * ratio) + srcOffset * V4d(x.Size) - V4d.Half
        let initialiCoord = V4l(initialCoord.Floor)
        let initialFrac = initialCoord - V4d(initialiCoord)
        let step = V4d.One * ratio
        let mutable coord = initialCoord
        let mutable icoord = initialiCoord
        let mutable frac = initialFrac
        px <- px + xdW * nativeint icoord.W + xdZ * nativeint icoord.Z + xdY * nativeint icoord.Y + xdX * nativeint icoord.X
        let yeW = py + ysW
        while py <> yeW do
            let yeZ = py + ysZ
            coord.Z <- initialCoord.Z
            px <- px + xdZ * nativeint (initialiCoord.Z - icoord.Z)
            icoord.Z <- initialiCoord.Z
            while py <> yeZ do
                let yeY = py + ysY
                coord.Y <- initialCoord.Y
                px <- px + xdY * nativeint (initialiCoord.Y - icoord.Y)
                icoord.Y <- initialiCoord.Y
                while py <> yeY do
                    let yeX = py + ysX
                    coord.X <- initialCoord.X
                    px <- px + xdX * nativeint (initialiCoord.X - icoord.X)
                    icoord.X <- initialiCoord.X
                    while py <> yeX do
                        let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt px)
                        NativePtr.write (NativePtr.ofNativeInt<'a> py) v0000
                        py <- py + yjX
                        px <- px + xjX
                        coord.X <- coord.X + step.X
                        icoord.X <- icoord.X + 1L
                    py <- py + yjY
                    px <- px + xjY
                    coord.Y <- coord.Y + step.Y
                    icoord.Y <- icoord.Y + 1L
                py <- py + yjZ
                px <- px + xjZ
                coord.Z <- coord.Z + step.Z
                icoord.Z <- icoord.Z + 1L
            py <- py + yjW
            px <- px + xjW
            coord.W <- coord.W + step.W
            icoord.W <- icoord.W + 1L
    member inline private x.BlitToWZYX(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        if y.Size.AnyGreater(x.Size) then failwith "[NativeTensor] upsampling not implemented"
        if x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWEZEYEXE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWEZEYEX(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWEZEYXE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWEZYEXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWZEYEXE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWEZEYX(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWEZYEX(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWEZYXE(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWZEYEX(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWZEYXE(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 && x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWZYEXE(y, srcOffset, srcSize, lerp)
        elif x.SW = y.SW && srcOffset.W = 0.0 && srcSize.W = 1.0 then x.BlitToInternalWEZYX(y, srcOffset, srcSize, lerp)
        elif x.SZ = y.SZ && srcOffset.Z = 0.0 && srcSize.Z = 1.0 then x.BlitToInternalWZEYX(y, srcOffset, srcSize, lerp)
        elif x.SY = y.SY && srcOffset.Y = 0.0 && srcSize.Y = 1.0 then x.BlitToInternalWZYEX(y, srcOffset, srcSize, lerp)
        elif x.SX = y.SX && srcOffset.X = 0.0 && srcSize.X = 1.0 then x.BlitToInternalWZYXE(y, srcOffset, srcSize, lerp)
        else x.BlitToInternalWZYX(y, srcOffset, srcSize, lerp)
    member x.BlitTo(y : NativeTensor4<'a>, srcOffset : V4d, srcSize : V4d, lerp : float -> 'a -> 'a -> 'a) = 
        let cXW = compare (abs info.DX) (abs info.DW)
        let cXY = compare (abs info.DX) (abs info.DY)
        let cXZ = compare (abs info.DX) (abs info.DZ)
        let cYW = compare (abs info.DY) (abs info.DW)
        let cYZ = compare (abs info.DY) (abs info.DZ)
        let cZW = compare (abs info.DZ) (abs info.DW)
        if cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.BlitToXYZW(y, srcOffset, srcSize, lerp)
        elif cXW >= 0  && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.BlitToYXZW(y, srcOffset, srcSize, lerp)
        elif cXW >= 0  && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.BlitToYZXW(y, srcOffset, srcSize, lerp)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.BlitToYZWX(y, srcOffset, srcSize, lerp)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.BlitToXZYW(y, srcOffset, srcSize, lerp)
        elif cXW >= 0  && cXY >= 0  && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.BlitToZXYW(y, srcOffset, srcSize, lerp)
        elif cXW >= 0  && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.BlitToZYXW(y, srcOffset, srcSize, lerp)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.BlitToZYWX(y, srcOffset, srcSize, lerp)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.BlitToXZWY(y, srcOffset, srcSize, lerp)
        elif cXW >= 0  && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.BlitToZXWY(y, srcOffset, srcSize, lerp)
        elif cXW <= 0 && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.BlitToZWXY(y, srcOffset, srcSize, lerp)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.BlitToZWYX(y, srcOffset, srcSize, lerp)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.BlitToXYWZ(y, srcOffset, srcSize, lerp)
        elif cXW >= 0  && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.BlitToYXWZ(y, srcOffset, srcSize, lerp)
        elif cXW <= 0 && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.BlitToYWXZ(y, srcOffset, srcSize, lerp)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.BlitToYWZX(y, srcOffset, srcSize, lerp)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.BlitToXWYZ(y, srcOffset, srcSize, lerp)
        elif cXW <= 0 && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.BlitToWXYZ(y, srcOffset, srcSize, lerp)
        elif cXW <= 0 && cXY <= 0 && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.BlitToWYXZ(y, srcOffset, srcSize, lerp)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.BlitToWYZX(y, srcOffset, srcSize, lerp)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.BlitToXWZY(y, srcOffset, srcSize, lerp)
        elif cXW <= 0 && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.BlitToWXZY(y, srcOffset, srcSize, lerp)
        elif cXW <= 0 && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.BlitToWZXY(y, srcOffset, srcSize, lerp)
        else x.BlitToWZYX(y, srcOffset, srcSize, lerp)
    member x.BlitTo(y : NativeTensor4<'a>, lerp : float -> 'a -> 'a -> 'a) = x.BlitTo(y, V4d.Zero, V4d.One, lerp)
    member x.Item
        with get(c0 : V4l) : 'a = 
            let i = V4l.Dot(x.Delta, c0)
            NativePtr.read (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i)))
        and set (c0 : V4l) (value : 'a) =
            let i = V4l.Dot(x.Delta, c0)
            NativePtr.write (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i))) value
    member x.Item
        with get(c0 : V4i) : 'a = 
            let i = V4l.Dot(x.Delta, V4l(c0))
            NativePtr.read (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i)))
        and set (c0 : V4i) (value : 'a) =
            let i = V4l.Dot(x.Delta, V4l(c0))
            NativePtr.write (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i))) value
    member x.Item
        with get(c0 : int, c1 : int, c2 : int, c3 : int) : 'a = 
            let i = V4l.Dot(x.Delta, V4l(c0, c1, c2, c3))
            NativePtr.read (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i)))
        and set (c0 : int, c1 : int, c2 : int, c3 : int) (value : 'a) =
            let i = V4l.Dot(x.Delta, V4l(c0, c1, c2, c3))
            NativePtr.write (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i))) value
    member x.Item
        with get(c0 : int64, c1 : int64, c2 : int64, c3 : int64) : 'a = 
            let i = V4l.Dot(x.Delta, V4l(c0, c1, c2, c3))
            NativePtr.read (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i)))
        and set (c0 : int64, c1 : int64, c2 : int64, c3 : int64) (value : 'a) =
            let i = V4l.Dot(x.Delta, V4l(c0, c1, c2, c3))
            NativePtr.write (NativePtr.ofNativeInt<'a> (NativePtr.toNativeInt x.Pointer + nativeint sizeof<'a> * (nativeint x.Origin + nativeint i))) value
    member inline private x.CopyToXYZW(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW) * sa
        let yjW = nativeint (y.DW) * sa
        let eX = xptr + sX
        while xptr <> eX do
            let eY = xptr + sY
            while xptr <> eY do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    let eW = xptr + sW
                    while xptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjW
                        yptr <- yptr + yjW
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToYXZW(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW) * sa
        let yjW = nativeint (y.DW) * sa
        let eY = xptr + sY
        while xptr <> eY do
            let eX = xptr + sX
            while xptr <> eX do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    let eW = xptr + sW
                    while xptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjW
                        yptr <- yptr + yjW
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToYZXW(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SW * info.DW) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW) * sa
        let yjW = nativeint (y.DW) * sa
        let eY = xptr + sY
        while xptr <> eY do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eX = xptr + sX
                while xptr <> eX do
                    let eW = xptr + sW
                    while xptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjW
                        yptr <- yptr + yjW
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToYZWX(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SX * info.DX) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sa
        let eY = xptr + sY
        while xptr <> eY do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eW = xptr + sW
                while xptr <> eW do
                    let eX = xptr + sX
                    while xptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjX
                        yptr <- yptr + yjX
                    xptr <- xptr + xjW
                    yptr <- yptr + yjW
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToXZYW(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SW * info.DW) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW) * sa
        let yjW = nativeint (y.DW) * sa
        let eX = xptr + sX
        while xptr <> eX do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eY = xptr + sY
                while xptr <> eY do
                    let eW = xptr + sW
                    while xptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjW
                        yptr <- yptr + yjW
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToZXYW(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SW * info.DW) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW) * sa
        let yjW = nativeint (y.DW) * sa
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eX = xptr + sX
            while xptr <> eX do
                let eY = xptr + sY
                while xptr <> eY do
                    let eW = xptr + sW
                    while xptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjW
                        yptr <- yptr + yjW
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member inline private x.CopyToZYXW(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SW * info.DW) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW) * sa
        let yjW = nativeint (y.DW) * sa
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eY = xptr + sY
            while xptr <> eY do
                let eX = xptr + sX
                while xptr <> eX do
                    let eW = xptr + sW
                    while xptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjW
                        yptr <- yptr + yjW
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member inline private x.CopyToZYWX(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SW * info.DW) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SX * info.DX) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sa
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eY = xptr + sY
            while xptr <> eY do
                let eW = xptr + sW
                while xptr <> eW do
                    let eX = xptr + sX
                    while xptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjX
                        yptr <- yptr + yjX
                    xptr <- xptr + xjW
                    yptr <- yptr + yjW
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member inline private x.CopyToXZWY(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SY * info.DY) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sa
        let eX = xptr + sX
        while xptr <> eX do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eW = xptr + sW
                while xptr <> eW do
                    let eY = xptr + sY
                    while xptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjY
                        yptr <- yptr + yjY
                    xptr <- xptr + xjW
                    yptr <- yptr + yjW
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToZXWY(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SW * info.DW) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SY * info.DY) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sa
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eX = xptr + sX
            while xptr <> eX do
                let eW = xptr + sW
                while xptr <> eW do
                    let eY = xptr + sY
                    while xptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjY
                        yptr <- yptr + yjY
                    xptr <- xptr + xjW
                    yptr <- yptr + yjW
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member inline private x.CopyToZWXY(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SX * info.DX) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sa
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eW = xptr + sW
            while xptr <> eW do
                let eX = xptr + sX
                while xptr <> eX do
                    let eY = xptr + sY
                    while xptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjY
                        yptr <- yptr + yjY
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjW
                yptr <- yptr + yjW
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member inline private x.CopyToZWYX(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SY * info.DY) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sa
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eW = xptr + sW
            while xptr <> eW do
                let eY = xptr + sY
                while xptr <> eY do
                    let eX = xptr + sX
                    while xptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjX
                        yptr <- yptr + yjX
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjW
                yptr <- yptr + yjW
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member inline private x.CopyToXYWZ(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SW * info.DW) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sa
        let eX = xptr + sX
        while xptr <> eX do
            let eY = xptr + sY
            while xptr <> eY do
                let eW = xptr + sW
                while xptr <> eW do
                    let eZ = xptr + sZ
                    while xptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjZ
                        yptr <- yptr + yjZ
                    xptr <- xptr + xjW
                    yptr <- yptr + yjW
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToYXWZ(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SW * info.DW) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sa
        let eY = xptr + sY
        while xptr <> eY do
            let eX = xptr + sX
            while xptr <> eX do
                let eW = xptr + sW
                while xptr <> eW do
                    let eZ = xptr + sZ
                    while xptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjZ
                        yptr <- yptr + yjZ
                    xptr <- xptr + xjW
                    yptr <- yptr + yjW
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToYWXZ(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SW * info.DW) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SX * info.DX) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sa
        let eY = xptr + sY
        while xptr <> eY do
            let eW = xptr + sW
            while xptr <> eW do
                let eX = xptr + sX
                while xptr <> eX do
                    let eZ = xptr + sZ
                    while xptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjZ
                        yptr <- yptr + yjZ
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjW
                yptr <- yptr + yjW
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToYWZX(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SW * info.DW) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sa
        let eY = xptr + sY
        while xptr <> eY do
            let eW = xptr + sW
            while xptr <> eW do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    let eX = xptr + sX
                    while xptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjX
                        yptr <- yptr + yjX
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjW
                yptr <- yptr + yjW
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToXWYZ(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SW * info.DW) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SY * info.DY) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sa
        let eX = xptr + sX
        while xptr <> eX do
            let eW = xptr + sW
            while xptr <> eW do
                let eY = xptr + sY
                while xptr <> eY do
                    let eZ = xptr + sZ
                    while xptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjZ
                        yptr <- yptr + yjZ
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjW
                yptr <- yptr + yjW
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToWXYZ(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SX * info.DX) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sa
        let eW = xptr + sW
        while xptr <> eW do
            let eX = xptr + sX
            while xptr <> eX do
                let eY = xptr + sY
                while xptr <> eY do
                    let eZ = xptr + sZ
                    while xptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjZ
                        yptr <- yptr + yjZ
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjW
            yptr <- yptr + yjW
    member inline private x.CopyToWYXZ(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SY * info.DY) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sa
        let eW = xptr + sW
        while xptr <> eW do
            let eY = xptr + sY
            while xptr <> eY do
                let eX = xptr + sX
                while xptr <> eX do
                    let eZ = xptr + sZ
                    while xptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjZ
                        yptr <- yptr + yjZ
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjW
            yptr <- yptr + yjW
    member inline private x.CopyToWYZX(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SY * info.DY) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sa
        let eW = xptr + sW
        while xptr <> eW do
            let eY = xptr + sY
            while xptr <> eY do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    let eX = xptr + sX
                    while xptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjX
                        yptr <- yptr + yjX
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjW
            yptr <- yptr + yjW
    member inline private x.CopyToXWZY(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SW * info.DW) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sa
        let eX = xptr + sX
        while xptr <> eX do
            let eW = xptr + sW
            while xptr <> eW do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    let eY = xptr + sY
                    while xptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjY
                        yptr <- yptr + yjY
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjW
                yptr <- yptr + yjW
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToWXZY(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SX * info.DX) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sa
        let eW = xptr + sW
        while xptr <> eW do
            let eX = xptr + sX
            while xptr <> eX do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    let eY = xptr + sY
                    while xptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjY
                        yptr <- yptr + yjY
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjW
            yptr <- yptr + yjW
    member inline private x.CopyToWZXY(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sa
        let eW = xptr + sW
        while xptr <> eW do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eX = xptr + sX
                while xptr <> eX do
                    let eY = xptr + sY
                    while xptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjY
                        yptr <- yptr + yjY
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjW
            yptr <- yptr + yjW
    member inline private x.CopyToWZYX(y : NativeTensor4<'a>) = 
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sa
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sa
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sa
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sa
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sa
        let eW = xptr + sW
        while xptr <> eW do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eY = xptr + sY
                while xptr <> eY do
                    let eX = xptr + sX
                    while xptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'a> yptr) (NativePtr.read (NativePtr.ofNativeInt<'a> xptr))
                        xptr <- xptr + xjX
                        yptr <- yptr + yjX
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjW
            yptr <- yptr + yjW
    member x.CopyTo(y : NativeTensor4<'a>) = 
        if info.Size <> y.Size then
            failwithf "NativeTensor4 size mismatch: { src = %A; dst = %A }" info.Size y.Size
        let cXW = compare (abs info.DX) (abs info.DW)
        let cXY = compare (abs info.DX) (abs info.DY)
        let cXZ = compare (abs info.DX) (abs info.DZ)
        let cYW = compare (abs info.DY) (abs info.DW)
        let cYZ = compare (abs info.DY) (abs info.DZ)
        let cZW = compare (abs info.DZ) (abs info.DW)
        if cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.CopyToXYZW(y)
        elif cXW >= 0  && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.CopyToYXZW(y)
        elif cXW >= 0  && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.CopyToYZXW(y)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.CopyToYZWX(y)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.CopyToXZYW(y)
        elif cXW >= 0  && cXY >= 0  && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.CopyToZXYW(y)
        elif cXW >= 0  && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.CopyToZYXW(y)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.CopyToZYWX(y)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.CopyToXZWY(y)
        elif cXW >= 0  && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.CopyToZXWY(y)
        elif cXW <= 0 && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.CopyToZWXY(y)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.CopyToZWYX(y)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.CopyToXYWZ(y)
        elif cXW >= 0  && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.CopyToYXWZ(y)
        elif cXW <= 0 && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.CopyToYWXZ(y)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.CopyToYWZX(y)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.CopyToXWYZ(y)
        elif cXW <= 0 && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.CopyToWXYZ(y)
        elif cXW <= 0 && cXY <= 0 && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.CopyToWYXZ(y)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.CopyToWYZX(y)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.CopyToXWZY(y)
        elif cXW <= 0 && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.CopyToWXZY(y)
        elif cXW <= 0 && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.CopyToWZXY(y)
        else x.CopyToWZYX(y)
    member inline private x.CopyToXYZW<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW) * sa
        let yjW = nativeint (y.DW) * sb
        let eX = xptr + sX
        while xptr <> eX do
            let eY = xptr + sY
            while xptr <> eY do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    let eW = xptr + sW
                    while xptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjW
                        yptr <- yptr + yjW
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToYXZW<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW) * sa
        let yjW = nativeint (y.DW) * sb
        let eY = xptr + sY
        while xptr <> eY do
            let eX = xptr + sX
            while xptr <> eX do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    let eW = xptr + sW
                    while xptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjW
                        yptr <- yptr + yjW
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToYZXW<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SW * info.DW) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW) * sa
        let yjW = nativeint (y.DW) * sb
        let eY = xptr + sY
        while xptr <> eY do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eX = xptr + sX
                while xptr <> eX do
                    let eW = xptr + sW
                    while xptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjW
                        yptr <- yptr + yjW
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToYZWX<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SX * info.DX) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sb
        let eY = xptr + sY
        while xptr <> eY do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eW = xptr + sW
                while xptr <> eW do
                    let eX = xptr + sX
                    while xptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjX
                        yptr <- yptr + yjX
                    xptr <- xptr + xjW
                    yptr <- yptr + yjW
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToXZYW<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SW * info.DW) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW) * sa
        let yjW = nativeint (y.DW) * sb
        let eX = xptr + sX
        while xptr <> eX do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eY = xptr + sY
                while xptr <> eY do
                    let eW = xptr + sW
                    while xptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjW
                        yptr <- yptr + yjW
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToZXYW<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SW * info.DW) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW) * sa
        let yjW = nativeint (y.DW) * sb
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eX = xptr + sX
            while xptr <> eX do
                let eY = xptr + sY
                while xptr <> eY do
                    let eW = xptr + sW
                    while xptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjW
                        yptr <- yptr + yjW
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member inline private x.CopyToZYXW<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SW * info.DW) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW) * sa
        let yjW = nativeint (y.DW) * sb
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eY = xptr + sY
            while xptr <> eY do
                let eX = xptr + sX
                while xptr <> eX do
                    let eW = xptr + sW
                    while xptr <> eW do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjW
                        yptr <- yptr + yjW
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member inline private x.CopyToZYWX<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SW * info.DW) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SX * info.DX) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sb
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eY = xptr + sY
            while xptr <> eY do
                let eW = xptr + sW
                while xptr <> eW do
                    let eX = xptr + sX
                    while xptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjX
                        yptr <- yptr + yjX
                    xptr <- xptr + xjW
                    yptr <- yptr + yjW
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member inline private x.CopyToXZWY<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SY * info.DY) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sb
        let eX = xptr + sX
        while xptr <> eX do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eW = xptr + sW
                while xptr <> eW do
                    let eY = xptr + sY
                    while xptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjY
                        yptr <- yptr + yjY
                    xptr <- xptr + xjW
                    yptr <- yptr + yjW
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToZXWY<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SW * info.DW) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SY * info.DY) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sb
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eX = xptr + sX
            while xptr <> eX do
                let eW = xptr + sW
                while xptr <> eW do
                    let eY = xptr + sY
                    while xptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjY
                        yptr <- yptr + yjY
                    xptr <- xptr + xjW
                    yptr <- yptr + yjW
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member inline private x.CopyToZWXY<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SX * info.DX) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sb
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eW = xptr + sW
            while xptr <> eW do
                let eX = xptr + sX
                while xptr <> eX do
                    let eY = xptr + sY
                    while xptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjY
                        yptr <- yptr + yjY
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjW
                yptr <- yptr + yjW
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member inline private x.CopyToZWYX<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SW * info.DW) * sa
        let yjZ = nativeint (y.DZ - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SY * info.DY) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sb
        let eZ = xptr + sZ
        while xptr <> eZ do
            let eW = xptr + sW
            while xptr <> eW do
                let eY = xptr + sY
                while xptr <> eY do
                    let eX = xptr + sX
                    while xptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjX
                        yptr <- yptr + yjX
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjW
                yptr <- yptr + yjW
            xptr <- xptr + xjZ
            yptr <- yptr + yjZ
    member inline private x.CopyToXYWZ<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SW * info.DW) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sb
        let eX = xptr + sX
        while xptr <> eX do
            let eY = xptr + sY
            while xptr <> eY do
                let eW = xptr + sW
                while xptr <> eW do
                    let eZ = xptr + sZ
                    while xptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjZ
                        yptr <- yptr + yjZ
                    xptr <- xptr + xjW
                    yptr <- yptr + yjW
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToYXWZ<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SW * info.DW) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sb
        let eY = xptr + sY
        while xptr <> eY do
            let eX = xptr + sX
            while xptr <> eX do
                let eW = xptr + sW
                while xptr <> eW do
                    let eZ = xptr + sZ
                    while xptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjZ
                        yptr <- yptr + yjZ
                    xptr <- xptr + xjW
                    yptr <- yptr + yjW
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToYWXZ<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SW * info.DW) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SX * info.DX) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sb
        let eY = xptr + sY
        while xptr <> eY do
            let eW = xptr + sW
            while xptr <> eW do
                let eX = xptr + sX
                while xptr <> eX do
                    let eZ = xptr + sZ
                    while xptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjZ
                        yptr <- yptr + yjZ
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjW
                yptr <- yptr + yjW
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToYWZX<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SW * info.DW) * sa
        let yjY = nativeint (y.DY - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sb
        let eY = xptr + sY
        while xptr <> eY do
            let eW = xptr + sW
            while xptr <> eW do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    let eX = xptr + sX
                    while xptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjX
                        yptr <- yptr + yjX
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjW
                yptr <- yptr + yjW
            xptr <- xptr + xjY
            yptr <- yptr + yjY
    member inline private x.CopyToXWYZ<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SW * info.DW) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SY * info.DY) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sb
        let eX = xptr + sX
        while xptr <> eX do
            let eW = xptr + sW
            while xptr <> eW do
                let eY = xptr + sY
                while xptr <> eY do
                    let eZ = xptr + sZ
                    while xptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjZ
                        yptr <- yptr + yjZ
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjW
                yptr <- yptr + yjW
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToWXYZ<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SX * info.DX) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sb
        let eW = xptr + sW
        while xptr <> eW do
            let eX = xptr + sX
            while xptr <> eX do
                let eY = xptr + sY
                while xptr <> eY do
                    let eZ = xptr + sZ
                    while xptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjZ
                        yptr <- yptr + yjZ
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjW
            yptr <- yptr + yjW
    member inline private x.CopyToWYXZ<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SY * info.DY) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ) * sa
        let yjZ = nativeint (y.DZ) * sb
        let eW = xptr + sW
        while xptr <> eW do
            let eY = xptr + sY
            while xptr <> eY do
                let eX = xptr + sX
                while xptr <> eX do
                    let eZ = xptr + sZ
                    while xptr <> eZ do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjZ
                        yptr <- yptr + yjZ
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjW
            yptr <- yptr + yjW
    member inline private x.CopyToWYZX<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SY * info.DY) * sa
        let yjW = nativeint (y.DW - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SZ * info.DZ) * sa
        let yjY = nativeint (y.DY - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sb
        let eW = xptr + sW
        while xptr <> eW do
            let eY = xptr + sY
            while xptr <> eY do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    let eX = xptr + sX
                    while xptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjX
                        yptr <- yptr + yjX
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjY
                yptr <- yptr + yjY
            xptr <- xptr + xjW
            yptr <- yptr + yjW
    member inline private x.CopyToXWZY<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SW * info.DW) * sa
        let yjX = nativeint (y.DX - y.SW * y.DW) * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sb
        let eX = xptr + sX
        while xptr <> eX do
            let eW = xptr + sW
            while xptr <> eW do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    let eY = xptr + sY
                    while xptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjY
                        yptr <- yptr + yjY
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjW
                yptr <- yptr + yjW
            xptr <- xptr + xjX
            yptr <- yptr + yjX
    member inline private x.CopyToWXZY<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SX * info.DX) * sa
        let yjW = nativeint (y.DW - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SZ * info.DZ) * sa
        let yjX = nativeint (y.DX - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sb
        let eW = xptr + sW
        while xptr <> eW do
            let eX = xptr + sX
            while xptr <> eX do
                let eZ = xptr + sZ
                while xptr <> eZ do
                    let eY = xptr + sY
                    while xptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjY
                        yptr <- yptr + yjY
                    xptr <- xptr + xjZ
                    yptr <- yptr + yjZ
                xptr <- xptr + xjX
                yptr <- yptr + yjX
            xptr <- xptr + xjW
            yptr <- yptr + yjW
    member inline private x.CopyToWZXY<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SX * info.DX) * sa
        let yjZ = nativeint (y.DZ - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX - info.SY * info.DY) * sa
        let yjX = nativeint (y.DX - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY) * sa
        let yjY = nativeint (y.DY) * sb
        let eW = xptr + sW
        while xptr <> eW do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eX = xptr + sX
                while xptr <> eX do
                    let eY = xptr + sY
                    while xptr <> eY do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjY
                        yptr <- yptr + yjY
                    xptr <- xptr + xjX
                    yptr <- yptr + yjX
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjW
            yptr <- yptr + yjW
    member inline private x.CopyToWZYX<'b when 'b : unmanaged>(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        let sb = nativeint (sizeof<'b>)
        let sa = nativeint (sizeof<'a>)
        let mutable xptr = ptr |> NativePtr.toNativeInt
        xptr <- xptr + nativeint info.Origin * sa
        let mutable yptr = y.Pointer |> NativePtr.toNativeInt
        yptr <- yptr + nativeint y.Info.Origin * sb
        let sW = nativeint (info.SW * info.DW) * sa
        let xjW = nativeint (info.DW - info.SZ * info.DZ) * sa
        let yjW = nativeint (y.DW - y.SZ * y.DZ) * sb
        let sZ = nativeint (info.SZ * info.DZ) * sa
        let xjZ = nativeint (info.DZ - info.SY * info.DY) * sa
        let yjZ = nativeint (y.DZ - y.SY * y.DY) * sb
        let sY = nativeint (info.SY * info.DY) * sa
        let xjY = nativeint (info.DY - info.SX * info.DX) * sa
        let yjY = nativeint (y.DY - y.SX * y.DX) * sb
        let sX = nativeint (info.SX * info.DX) * sa
        let xjX = nativeint (info.DX) * sa
        let yjX = nativeint (y.DX) * sb
        let eW = xptr + sW
        while xptr <> eW do
            let eZ = xptr + sZ
            while xptr <> eZ do
                let eY = xptr + sY
                while xptr <> eY do
                    let eX = xptr + sX
                    while xptr <> eX do
                        NativePtr.write (NativePtr.ofNativeInt<'b> yptr) (f (NativePtr.read (NativePtr.ofNativeInt<'a> xptr)))
                        xptr <- xptr + xjX
                        yptr <- yptr + yjX
                    xptr <- xptr + xjY
                    yptr <- yptr + yjY
                xptr <- xptr + xjZ
                yptr <- yptr + yjZ
            xptr <- xptr + xjW
            yptr <- yptr + yjW
    member x.CopyTo(y : NativeTensor4<'b>, f : 'a -> 'b) = 
        if info.Size <> y.Size then
            failwithf "NativeTensor4 size mismatch: { src = %A; dst = %A }" info.Size y.Size
        let cXW = compare (abs info.DX) (abs info.DW)
        let cXY = compare (abs info.DX) (abs info.DY)
        let cXZ = compare (abs info.DX) (abs info.DZ)
        let cYW = compare (abs info.DY) (abs info.DW)
        let cYZ = compare (abs info.DY) (abs info.DZ)
        let cZW = compare (abs info.DZ) (abs info.DW)
        if cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.CopyToXYZW(y, f)
        elif cXW >= 0  && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.CopyToYXZW(y, f)
        elif cXW >= 0  && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.CopyToYZXW(y, f)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW >= 0  then x.CopyToYZWX(y, f)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.CopyToXZYW(y, f)
        elif cXW >= 0  && cXY >= 0  && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.CopyToZXYW(y, f)
        elif cXW >= 0  && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.CopyToZYXW(y, f)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ <= 0 && cZW >= 0  then x.CopyToZYWX(y, f)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.CopyToXZWY(y, f)
        elif cXW >= 0  && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.CopyToZXWY(y, f)
        elif cXW <= 0 && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.CopyToZWXY(y, f)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW >= 0  then x.CopyToZWYX(y, f)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.CopyToXYWZ(y, f)
        elif cXW >= 0  && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.CopyToYXWZ(y, f)
        elif cXW <= 0 && cXY <= 0 && cXZ >= 0  && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.CopyToYWXZ(y, f)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW >= 0  && cYZ >= 0  && cZW <= 0 then x.CopyToYWZX(y, f)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.CopyToXWYZ(y, f)
        elif cXW <= 0 && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.CopyToWXYZ(y, f)
        elif cXW <= 0 && cXY <= 0 && cXZ >= 0  && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.CopyToWYXZ(y, f)
        elif cXW <= 0 && cXY <= 0 && cXZ <= 0 && cYW <= 0 && cYZ >= 0  && cZW <= 0 then x.CopyToWYZX(y, f)
        elif cXW >= 0  && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.CopyToXWZY(y, f)
        elif cXW <= 0 && cXY >= 0  && cXZ >= 0  && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.CopyToWXZY(y, f)
        elif cXW <= 0 && cXY >= 0  && cXZ <= 0 && cYW <= 0 && cYZ <= 0 && cZW <= 0 then x.CopyToWZXY(y, f)
        else x.CopyToWZYX(y, f)
    member x.SampleNearest(coord : V3d) : 'a[] = 
        let p0f = coord * V3d x.Size.XYZ
        let mutable nearest = V3l(int64 (Fun.Round p0f.X), int64 (Fun.Round p0f.Y), int64 (Fun.Round p0f.Z))
        if nearest.X < 0L then nearest.X <- 0L
        else if nearest.X >= x.SX then nearest.X <- x.SX - 1L
        if nearest.Y < 0L then nearest.Y <- 0L
        else if nearest.Y >= x.SY then nearest.Y <- x.SY - 1L
        if nearest.Z < 0L then nearest.Z <- 0L
        else if nearest.Z >= x.SZ then nearest.Z <- x.SZ - 1L
        let sa = nativeint sizeof<'a>
        let ptr = NativePtr.toNativeInt x.Pointer + nativeint (V3l.Dot(nearest, x.Delta.XYZ)) * sa
        let dW = nativeint x.DW * sa
        Array.init (int x.Size.W) (fun i -> NativePtr.read (NativePtr.ofNativeInt (ptr + nativeint i * dW)))
    member x.SampleLinear(coord : V4d, lerp : float -> 'a -> 'a -> 'a) : 'a = 
        let lerp = OptimizedClosures.FSharpFunc<float, 'a, 'a, 'a>.Adapt(lerp)
        let coord = V4d.Min(V4d.Max(coord, V4d.Zero), V4d.One)
        let p0f = coord * V4d x.Size.XYZW - V4d(0.5, 0.5, 0.5, 0.5)
        let mutable p0 = V4l(int64 (floor p0f.X), int64 (floor p0f.Y), int64 (floor p0f.Z), int64 (floor p0f.W))
        let frac = p0f - V4d p0
        let sa = nativeint sizeof<'a>
        let dX = nativeint x.DX * sa
        let dY = nativeint x.DY * sa
        let dZ = nativeint x.DZ * sa
        let dW = nativeint x.DW * sa
        if p0.X >= 0L && p0.X < x.Size.X - 1L && p0.Y >= 0L && p0.Y < x.Size.Y - 1L && p0.Z >= 0L && p0.Z < x.Size.Z - 1L && p0.W >= 0L && p0.W < x.Size.W - 1L then
            let ptr0 = NativePtr.toNativeInt x.Pointer + nativeint (V4l.Dot(p0, x.Delta.XYZW)) * sa
            let v0000 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0))
            let v0001 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dW))
            let v0010 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dZ))
            let v0011 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dZ + dW))
            let v0100 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dY))
            let v0101 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dY + dW))
            let v0110 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dY + dZ))
            let v0111 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dY + dZ + dW))
            let v1000 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dX))
            let v1001 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dX + dW))
            let v1010 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dX + dZ))
            let v1011 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dX + dZ + dW))
            let v1100 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dX + dY))
            let v1101 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dX + dY + dW))
            let v1110 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dX + dY + dZ))
            let v1111 : 'a =  NativePtr.read (NativePtr.ofNativeInt (ptr0 + dX + dY + dZ + dW))
            let vx000 = lerp.Invoke(frac.X, v0000, v1000)
            let vx001 = lerp.Invoke(frac.X, v0001, v1001)
            let vx010 = lerp.Invoke(frac.X, v0010, v1010)
            let vx011 = lerp.Invoke(frac.X, v0011, v1011)
            let vx100 = lerp.Invoke(frac.X, v0100, v1100)
            let vx101 = lerp.Invoke(frac.X, v0101, v1101)
            let vx110 = lerp.Invoke(frac.X, v0110, v1110)
            let vx111 = lerp.Invoke(frac.X, v0111, v1111)
            let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
            let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
            let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
            let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
            let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
            let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
            let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
            vxxxx
        else
            let max = x.Size - V4l.One
            let v0000 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0), max))) * sa))
            let v0001 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(0L, 0L, 0L, 1L)), max))) * sa))
            let v0010 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(0L, 0L, 1L, 0L)), max))) * sa))
            let v0011 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(0L, 0L, 1L, 1L)), max))) * sa))
            let v0100 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(0L, 1L, 0L, 0L)), max))) * sa))
            let v0101 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(0L, 1L, 0L, 1L)), max))) * sa))
            let v0110 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(0L, 1L, 1L, 0L)), max))) * sa))
            let v0111 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(0L, 1L, 1L, 1L)), max))) * sa))
            let v1000 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(1L, 0L, 0L, 0L)), max))) * sa))
            let v1001 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(1L, 0L, 0L, 1L)), max))) * sa))
            let v1010 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(1L, 0L, 1L, 0L)), max))) * sa))
            let v1011 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(1L, 0L, 1L, 1L)), max))) * sa))
            let v1100 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(1L, 1L, 0L, 0L)), max))) * sa))
            let v1101 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(1L, 1L, 0L, 1L)), max))) * sa))
            let v1110 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(1L, 1L, 1L, 0L)), max))) * sa))
            let v1111 : 'a = NativePtr.read (NativePtr.ofNativeInt (NativePtr.toNativeInt x.Pointer + nativeint(V4l.Dot(x.Delta, V4l.Min(V4l.Max(V4l.Zero, p0 + V4l(1L, 1L, 1L, 1L)), max))) * sa))
            let vx000 = lerp.Invoke(frac.X, v0000, v1000)
            let vx001 = lerp.Invoke(frac.X, v0001, v1001)
            let vx010 = lerp.Invoke(frac.X, v0010, v1010)
            let vx011 = lerp.Invoke(frac.X, v0011, v1011)
            let vx100 = lerp.Invoke(frac.X, v0100, v1100)
            let vx101 = lerp.Invoke(frac.X, v0101, v1101)
            let vx110 = lerp.Invoke(frac.X, v0110, v1110)
            let vx111 = lerp.Invoke(frac.X, v0111, v1111)
            let vxx00 = lerp.Invoke(frac.Y, vx000, vx100)
            let vxx01 = lerp.Invoke(frac.Y, vx001, vx101)
            let vxx10 = lerp.Invoke(frac.Y, vx010, vx110)
            let vxx11 = lerp.Invoke(frac.Y, vx011, vx111)
            let vxxx0 = lerp.Invoke(frac.Z, vxx00, vxx10)
            let vxxx1 = lerp.Invoke(frac.Z, vxx01, vxx11)
            let vxxxx = lerp.Invoke(frac.W, vxxx0, vxxx1)
            vxxxx
    static member Using<'b> (m : Tensor4<'a>, f : NativeTensor4<'a> -> 'b) = 
        let gc = GCHandle.Alloc(m.Data, GCHandleType.Pinned)
        try f (NativeTensor4<'a>(NativePtr.ofNativeInt (gc.AddrOfPinnedObject()), m.Info))
        finally gc.Free()
    member x.SubTensor4(beginX : int64, beginY : int64, beginZ : int64, beginW : int64, sizeX : int64, sizeY : int64, sizeZ : int64, sizeW : int64, deltaX : int64, deltaY : int64, deltaZ : int64, deltaW : int64) = NativeTensor4<'a>(ptr, info.SubTensor4(beginX, beginY, beginZ, beginW, sizeX, sizeY, sizeZ, sizeW, deltaX, deltaY, deltaZ, deltaW))
    member x.SubTensor4(beginX : int64, beginY : int64, beginZ : int64, beginW : int64, sizeX : int64, sizeY : int64, sizeZ : int64, sizeW : int64) = NativeTensor4<'a>(ptr, info.SubTensor4(beginX, beginY, beginZ, beginW, sizeX, sizeY, sizeZ, sizeW))
    member x.SubTensor4(offset : V4l, size : V4l) = NativeTensor4<'a>(ptr, info.SubTensor4(offset, size))
    member x.SubTensor4(offset : V4l, size : V4l, delta : V4l) = NativeTensor4<'a>(ptr, info.SubTensor4(offset, size, delta))
    member x.SubTensor4(offset : V4i, size : V4i) = NativeTensor4<'a>(ptr, info.SubTensor4(offset, size))
    member x.SubTensor4(offset : V4i, size : V4i, delta : V4i) = NativeTensor4<'a>(ptr, info.SubTensor4(offset, size, delta))
    member x.GetSlice(minX : int, minY : int, minZ : int, minW : Option<int>, maxW : Option<int>) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeW, info.DW)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.GetSlice(minX : int64, minY : int64, minZ : int64, minW : Option<int64>, maxW : Option<int64>) = 
        let beginX = minX
        let beginY = minY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeW, info.DW)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.SetSlice(minX : int, minY : int, minZ : int, minW : Option<int>, maxW : Option<int>, value : 'a) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeW, info.DW)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int64, minY : int64, minZ : int64, minW : Option<int64>, maxW : Option<int64>, value : 'a) = 
        let beginX = minX
        let beginY = minY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeW, info.DW)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int, minY : int, minZ : int, minW : Option<int>, maxW : Option<int>, src : NativeVector<'a>) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeW, info.DW)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int64, minY : int64, minZ : int64, minW : Option<int64>, maxW : Option<int64>, src : NativeVector<'a>) = 
        let beginX = minX
        let beginY = minY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeW, info.DW)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int, minY : int, minZ : int, minW : Option<int>, maxW : Option<int>, src : Vector<'a>) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeW, info.DW)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : int64, minY : int64, minZ : int64, minW : Option<int64>, maxW : Option<int64>, src : Vector<'a>) = 
        let beginX = minX
        let beginY = minY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeW, info.DW)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : int, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : int) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.GetSlice(minX : int64, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : int64) = 
        let beginX = minX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.SetSlice(minX : int, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : int, value : 'a) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int64, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : int64, value : 'a) = 
        let beginX = minX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : int, src : NativeVector<'a>) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int64, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : int64, src : NativeVector<'a>) = 
        let beginX = minX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : int, src : Vector<'a>) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : int64, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : int64, src : Vector<'a>) = 
        let beginX = minX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeZ, info.DZ)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : int, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeZ, sizeW), V2l(info.DZ, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.GetSlice(minX : int64, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>) = 
        let beginX = minX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeZ, sizeW), V2l(info.DZ, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.SetSlice(minX : int, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>, value : 'a) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeZ, sizeW), V2l(info.DZ, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int64, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>, value : 'a) = 
        let beginX = minX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeZ, sizeW), V2l(info.DZ, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>, src : NativeMatrix<'a>) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeZ, sizeW), V2l(info.DZ, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int64, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>, src : NativeMatrix<'a>) = 
        let beginX = minX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeZ, sizeW), V2l(info.DZ, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>, src : Matrix<'a>) = 
        let beginX = minX |> int64
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeZ, sizeW), V2l(info.DZ, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : int64, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>, src : Matrix<'a>) = 
        let beginX = minX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeZ, sizeW), V2l(info.DZ, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : int, minW : int) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = minW |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.GetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : int64) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = minW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : int, minW : int, value : 'a) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = minW |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : int64, value : 'a) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = minW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : int, minW : int, src : NativeVector<'a>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = minW |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : int64, src : NativeVector<'a>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = minW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : int, minW : int, src : Vector<'a>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = minW |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : int64, src : Vector<'a>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = minW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeY, info.DY)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : int, minW : Option<int>, maxW : Option<int>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeW), V2l(info.DY, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.GetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : Option<int64>, maxW : Option<int64>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeW), V2l(info.DY, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : int, minW : Option<int>, maxW : Option<int>, value : 'a) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeW), V2l(info.DY, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : Option<int64>, maxW : Option<int64>, value : 'a) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeW), V2l(info.DY, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : int, minW : Option<int>, maxW : Option<int>, src : NativeMatrix<'a>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeW), V2l(info.DY, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : Option<int64>, maxW : Option<int64>, src : NativeMatrix<'a>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeW), V2l(info.DY, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : int, minW : Option<int>, maxW : Option<int>, src : Matrix<'a>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeW), V2l(info.DY, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : Option<int64>, maxW : Option<int64>, src : Matrix<'a>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeW), V2l(info.DY, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : int) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.GetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : int64) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : int, value : 'a) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : int64, value : 'a) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : int, src : NativeMatrix<'a>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : int64, src : NativeMatrix<'a>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : int, src : Matrix<'a>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : int64, src : Matrix<'a>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeY, sizeZ), V2l(info.DY, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeY, sizeZ, sizeW), V3l(info.DY, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        res
    member x.GetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeY, sizeZ, sizeW), V3l(info.DY, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        res
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>, value : 'a) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeY, sizeZ, sizeW), V3l(info.DY, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>, value : 'a) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeY, sizeZ, sizeW), V3l(info.DY, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>, src : NativeVolume<'a>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeY, sizeZ, sizeW), V3l(info.DY, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>, src : NativeVolume<'a>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeY, sizeZ, sizeW), V3l(info.DY, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : int, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>, src : Volume<'a>) = 
        let beginX = minX |> int64
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeY, sizeZ, sizeW), V3l(info.DY, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        NativeVolume<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : int64, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>, src : Volume<'a>) = 
        let beginX = minX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeY, sizeZ, sizeW), V3l(info.DY, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        NativeVolume<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : int, minW : int) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let beginW = minW |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : int64, minW : int64) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = minZ
        let beginW = minW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : int, minW : int, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let beginW = minW |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : int64, minW : int64, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = minZ
        let beginW = minW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : int, minW : int, src : NativeVector<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let beginW = minW |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : int64, minW : int64, src : NativeVector<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = minZ
        let beginW = minW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : int, minW : int, src : Vector<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let beginW = minW |> int64
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : int64, minW : int64, src : Vector<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = minZ
        let beginW = minW
        let info = VectorInfo(info.Index(beginX, beginY, beginZ, beginW), sizeX, info.DX)
        let res = NativeVector<'a>(ptr, info)
        NativeVector<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : int, minW : Option<int>, maxW : Option<int>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeW), V2l(info.DX, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : int64, minW : Option<int64>, maxW : Option<int64>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeW), V2l(info.DX, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : int, minW : Option<int>, maxW : Option<int>, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeW), V2l(info.DX, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : int64, minW : Option<int64>, maxW : Option<int64>, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeW), V2l(info.DX, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : int, minW : Option<int>, maxW : Option<int>, src : NativeMatrix<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeW), V2l(info.DX, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : int64, minW : Option<int64>, maxW : Option<int64>, src : NativeMatrix<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeW), V2l(info.DX, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : int, minW : Option<int>, maxW : Option<int>, src : Matrix<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeW), V2l(info.DX, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : int64, minW : Option<int64>, maxW : Option<int64>, src : Matrix<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeW), V2l(info.DX, info.DW))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : int) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : int64) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : int, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : int64, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : int, src : NativeMatrix<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : int64, src : NativeMatrix<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : int, src : Matrix<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : int64, src : Matrix<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeZ), V2l(info.DX, info.DZ))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeZ, sizeW), V3l(info.DX, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeZ, sizeW), V3l(info.DX, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeZ, sizeW), V3l(info.DX, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeZ, sizeW), V3l(info.DX, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>, src : NativeVolume<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeZ, sizeW), V3l(info.DX, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>, src : NativeVolume<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeZ, sizeW), V3l(info.DX, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : int, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>, src : Volume<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = minY |> int64
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeZ, sizeW), V3l(info.DX, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        NativeVolume<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : int64, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>, src : Volume<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = minY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeZ, sizeW), V3l(info.DX, info.DZ, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        NativeVolume<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : int, minW : int) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = minW |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : int64) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = minW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : int, minW : int, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = minW |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : int64, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = minW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : int, minW : int, src : NativeMatrix<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = minW |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : int64, src : NativeMatrix<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = minW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : int, minW : int, src : Matrix<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = minW |> int64
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : int64, src : Matrix<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = minW
        let info = MatrixInfo(info.Index(beginX, beginY, beginZ, beginW), V2l(sizeX, sizeY), V2l(info.DX, info.DY))
        let res = NativeMatrix<'a>(ptr, info)
        NativeMatrix<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : int, minW : Option<int>, maxW : Option<int>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeW), V3l(info.DX, info.DY, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : Option<int64>, maxW : Option<int64>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeW), V3l(info.DX, info.DY, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : int, minW : Option<int>, maxW : Option<int>, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeW), V3l(info.DX, info.DY, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : Option<int64>, maxW : Option<int64>, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeW), V3l(info.DX, info.DY, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : int, minW : Option<int>, maxW : Option<int>, src : NativeVolume<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeW), V3l(info.DX, info.DY, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : Option<int64>, maxW : Option<int64>, src : NativeVolume<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeW), V3l(info.DX, info.DY, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : int, minW : Option<int>, maxW : Option<int>, src : Volume<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ |> int64
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeW), V3l(info.DX, info.DY, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        NativeVolume<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : int64, minW : Option<int64>, maxW : Option<int64>, src : Volume<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = minZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeW), V3l(info.DX, info.DY, info.DW))
        let res = NativeVolume<'a>(ptr, info)
        NativeVolume<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : int) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : int64) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : int, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : int64, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : int, src : NativeVolume<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : int64, src : NativeVolume<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : int, src : Volume<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW |> int64
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        NativeVolume<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : int64, src : Volume<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = minW
        let info = VolumeInfo(info.Index(beginX, beginY, beginZ, beginW), V3l(sizeX, sizeY, sizeZ), V3l(info.DX, info.DY, info.DZ))
        let res = NativeVolume<'a>(ptr, info)
        NativeVolume<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.GetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = Tensor4Info(info.Index(beginX, beginY, beginZ, beginW), V4l(sizeX, sizeY, sizeZ, sizeW), V4l(info.DX, info.DY, info.DZ, info.DW))
        let res = NativeTensor4<'a>(ptr, info)
        res
    member x.GetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = Tensor4Info(info.Index(beginX, beginY, beginZ, beginW), V4l(sizeX, sizeY, sizeZ, sizeW), V4l(info.DX, info.DY, info.DZ, info.DW))
        let res = NativeTensor4<'a>(ptr, info)
        res
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>, value : 'a) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = Tensor4Info(info.Index(beginX, beginY, beginZ, beginW), V4l(sizeX, sizeY, sizeZ, sizeW), V4l(info.DX, info.DY, info.DZ, info.DW))
        let res = NativeTensor4<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>, value : 'a) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = Tensor4Info(info.Index(beginX, beginY, beginZ, beginW), V4l(sizeX, sizeY, sizeZ, sizeW), V4l(info.DX, info.DY, info.DZ, info.DW))
        let res = NativeTensor4<'a>(ptr, info)
        res.Set(value)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>, src : NativeTensor4<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = Tensor4Info(info.Index(beginX, beginY, beginZ, beginW), V4l(sizeX, sizeY, sizeZ, sizeW), V4l(info.DX, info.DY, info.DZ, info.DW))
        let res = NativeTensor4<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>, src : NativeTensor4<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = Tensor4Info(info.Index(beginX, beginY, beginZ, beginW), V4l(sizeX, sizeY, sizeZ, sizeW), V4l(info.DX, info.DY, info.DZ, info.DW))
        let res = NativeTensor4<'a>(ptr, info)
        src.CopyTo(res)
    member x.SetSlice(minX : Option<int>, maxX : Option<int>, minY : Option<int>, maxY : Option<int>, minZ : Option<int>, maxZ : Option<int>, minW : Option<int>, maxW : Option<int>, src : Tensor4<'a>) = 
        let beginX = defaultArg minX 0 |> int64
        let maxX = defaultArg maxX (int info.SX - 1) |> int64
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0 |> int64
        let maxY = defaultArg maxY (int info.SY - 1) |> int64
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0 |> int64
        let maxZ = defaultArg maxZ (int info.SZ - 1) |> int64
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0 |> int64
        let maxW = defaultArg maxW (int info.SW - 1) |> int64
        let sizeW = 1L + maxW - beginW
        let info = Tensor4Info(info.Index(beginX, beginY, beginZ, beginW), V4l(sizeX, sizeY, sizeZ, sizeW), V4l(info.DX, info.DY, info.DZ, info.DW))
        let res = NativeTensor4<'a>(ptr, info)
        NativeTensor4<'a>.Using(src, fun src -> src.CopyTo(res))
    member x.SetSlice(minX : Option<int64>, maxX : Option<int64>, minY : Option<int64>, maxY : Option<int64>, minZ : Option<int64>, maxZ : Option<int64>, minW : Option<int64>, maxW : Option<int64>, src : Tensor4<'a>) = 
        let beginX = defaultArg minX 0L
        let maxX = defaultArg maxX (info.SX - 1L)
        let sizeX = 1L + maxX - beginX
        let beginY = defaultArg minY 0L
        let maxY = defaultArg maxY (info.SY - 1L)
        let sizeY = 1L + maxY - beginY
        let beginZ = defaultArg minZ 0L
        let maxZ = defaultArg maxZ (info.SZ - 1L)
        let sizeZ = 1L + maxZ - beginZ
        let beginW = defaultArg minW 0L
        let maxW = defaultArg maxW (info.SW - 1L)
        let sizeW = 1L + maxW - beginW
        let info = Tensor4Info(info.Index(beginX, beginY, beginZ, beginW), V4l(sizeX, sizeY, sizeZ, sizeW), V4l(info.DX, info.DY, info.DZ, info.DW))
        let res = NativeTensor4<'a>(ptr, info)
        NativeTensor4<'a>.Using(src, fun src -> src.CopyTo(res))

/// The NativeTensor4 module providers convenient F#-style functions for accessing NativeTensor4s
module NativeTensor4 =
    let inline private lerpy< ^a, ^b when (^a or ^b) : (static member Lerp : float * ^b * ^b -> ^b)> (_ : ^a) (t : float) (a : ^b) (b : ^b) =
        ((^a or ^b) : (static member Lerp : float * ^b * ^b -> ^b) (t, a,b))
    let inline private lerper t a b = lerpy (Unchecked.defaultof<Fun>) t a b
    /// sets the entire Tensor4 to the given value
    let inline set (value : 'a) (dst : NativeTensor4<'a>) = dst.Set(value)
    
    /// sets each entry to the value computed by getValue
    let inline setByCoord (getValue : V4l -> 'a) (m : NativeTensor4<'a>) = m.SetByCoord(getValue)
    
    let inline sample (location : V4d) (m : NativeTensor4<'a>) = m.SampleLinear(location, lerper)
    
    let inline blit (src : NativeTensor4<'a>) (dst : NativeTensor4<'a>) = src.BlitTo(dst, lerper)
    
    /// copies the content of 'src' to 'dst'
    let inline copy (src : NativeTensor4<'a>) (dst : NativeTensor4<'a>) = src.CopyTo(dst)
    
    /// copies the content of 'src' to 'dst' by applying the given function
    let inline copyWith (f : 'a -> 'b) (src : NativeTensor4<'a>) (dst : NativeTensor4<'b>) = src.CopyTo(dst, f)
    
    /// temporarily pins a Tensor4 making it available as NativeTensor4
    let using (m : Tensor4<'a>) (f : NativeTensor4<'a> -> 'b) = NativeTensor4<'a>.Using(m, f)


