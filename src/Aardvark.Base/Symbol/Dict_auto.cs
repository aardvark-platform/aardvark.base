using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;

namespace Aardvark.Base
{
    // AUTO GENERATED CODE - DO NOT CHANGE!

    #region Dict<TKey, TValue>

    /// <summary>
    /// A Dict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class Dict<TKey, TValue>
            : IIntCountable, ICountableDict, IDict<TKey, TValue>,
              IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>,
              ICollection, ICollection<KeyValuePair<TKey, TValue>>
    {
        private uint m_capacity;
        private NextHashKeyValue<TKey, TValue>[] m_firstArray;
        private HashKeyValueNext<TKey, TValue>[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private readonly bool m_doNotStackDuplicateKeys;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a Dict that autmatically grows and shrinks as necessary.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// Dict acts as a stack for all items with the same key.
        /// </summary>
        public Dict(bool stackDuplicateKeys = false)
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a Dict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// Dict acts as a stack for all items with the same key.
        /// </summary>
        public Dict(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, false)
        { }

        /// <summary>
        /// Create a Dict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// Dict acts as a stack for all items with the same key.
        /// </summary>
        public Dict(int initialCapacity, bool stackDuplicateKeys)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a Dict and initialize it to contain the supplied
        /// items.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// Dict acts as a stack for all items with the same key.
        /// </summary>
        public Dict(IEnumerable<KeyValuePair<TKey, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        private Dict(
                uint firstCapacity, uint extraCapacity,
                bool stackDuplicateKeys = false)
        {
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_doNotStackDuplicateKeys = !stackDuplicateKeys;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKeyValue<TKey, TValue>[m_capacity];
            m_extraArray = new HashKeyValueNext<TKey, TValue>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the Dict.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the Dict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the Dict
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the Dict. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Always returns false. Part of the ICollection implementation.
        /// </summary>
        public bool IsReadOnly { get { return false; } }

        public bool IsSynchronized { get { return false; } }

        public object SyncRoot { get { return this; } }
        public IEnumerable<KeyValuePair<TKey, TValue>> Items { get { return KeyValuePairs; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Key;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Key;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        /// <summary>
        /// Returns all values in the Dict.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Value;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Value;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type ValueType { get { return typeof(TValue); } }

        /// <summary>
        /// Returns all key value pairs in the Dict.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairs
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    while (ei > 0)
                    {
                        yield return new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        /// <summary>
        /// Returns all key value pairs in the Dict, in such a way,
        /// that the stack order is correct when the pairs are put into a
        /// new Dict in the order they are returned.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairsForStorage
        {
            get
            {
                var stack = new Stack<int>();
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    while (ei > 0) { stack.Push(ei); ei = m_extraArray[ei].Next; }
                    while (stack.Count > 0)
                    {
                        ei = stack.Pop();
                        yield return new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    }
                    yield return new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                }
            }
        }

        public IEnumerable<(object, object)> ObjectPairs
        {
            get
            {
                foreach (var kvp in KeyValuePairsForStorage)
                    yield return (kvp.Key, kvp.Value);
            }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the Dict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[TKey key]
        {
            get
            {
                var hash = key.GetHashCode();
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                    throw new KeyNotFoundException();
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                    return m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                        return m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
                throw new KeyNotFoundException();
            }
            set
            {
                var hash = key.GetHashCode();
                if (m_count >= m_increaseThreshold) IncreaseCapacity();
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                {
                    ++m_count;
                    m_firstArray[fi].Next = -1;
                    m_firstArray[fi].Item.Hash = hash;
                    m_firstArray[fi].Item.Key = key;
                    m_firstArray[fi].Item.Value = value;
                    return;
                }
                if (m_doNotStackDuplicateKeys)
                {
                    if (m_firstArray[fi].Item.Hash == hash
                        && key.Equals(m_firstArray[fi].Item.Key))
                    {
                        m_firstArray[fi].Item.Value = value;
                        return;
                    }
                    while (ei > 0)
                    {
                        if (m_extraArray[ei].Item.Hash == hash
                            && key.Equals(m_extraArray[ei].Item.Key))
                        {
                            m_extraArray[ei].Item.Value = value;
                            return;
                        }
                        ei = m_extraArray[ei].Next;
                    }
                    ei = m_firstArray[fi].Next;
                }
                ++m_count;
                ++m_extraCount;
                if (m_freeIndex < 0)
                {
                    var length = m_extraArray.Length;
                    m_extraArray = m_extraArray.Resized(length * 2);
                    m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
                }
                var ni = m_freeIndex;
                m_freeIndex = m_extraArray[ni].Next;

                m_extraArray[ni].Item = m_firstArray[fi].Item;
                m_extraArray[ni].Next = ei;

                m_firstArray[fi].Next = ni;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the Dict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the Dict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((TKey)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the Dict.
        /// </summary>
        public void Add(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the Dict.
        /// </summary>
        public void Add(TKey key, int hash, TValue value)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the Dict.
        /// </summary>
        public bool TryAdd(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the Dict.
        /// </summary>
        public bool TryAdd(TKey key, int hash, TValue value)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            return true;
        }

        /// <summary>
        /// Add the supplied item to the Dict.
        /// </summary>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Add the supplied items to the Dict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the Dict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the Dict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, int hash)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the Dict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the Dict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key, int hash)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the Dict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the Dict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, int hash, TValue value)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the Dict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            return Contains(item.Key, item.Value);
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the Dict and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, Func<TKey, TValue> creator)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
        }

        void AddCreated(TKey key, int hash, TValue value)
        {
            ++m_count;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, TValue defaultValue)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key, int hash)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the Dict and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, int hash, Func<TKey, TValue> creator)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, int hash, TValue defaultValue)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(TKey key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, out TValue value)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, int hash, out TValue value)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Return all the value with the given key. This method is only
        /// useful if multiple item with the same key are allowed.
        /// </summary>
        public IEnumerable<TValue> ValuesWithKey(TKey key)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) yield break;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                yield return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    yield return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
        }

        /// <summary>
        /// Gets an enumerator for values with key. It is only useful
        /// if multiple item with the same key are allowed.
        /// Should be preferred over ValuesWithKey enumeration in
        /// performance critical code.
        /// </summary>
        public ValuesWithKeyEnumerator GetValuesWithKeyEnumerator(TKey key)
        {
            return new ValuesWithKeyEnumerator(this, key);
        }

        public struct ValuesWithKeyEnumerator : IEnumerator<TValue>
        {
            readonly Dict<TKey, TValue> m_dict;
            readonly TKey m_key;
            readonly int m_hash;
            int m_extraIndex;
            TValue m_current;

            public ValuesWithKeyEnumerator(Dict<TKey, TValue> dict, TKey key)
            {
                m_dict = dict;
                m_key = key;
                m_hash = key.GetHashCode();
                m_extraIndex = int.MaxValue;
                m_current = default(TValue);
            }

            public readonly TValue Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex == int.MaxValue)
                {
                    var fa = m_dict.m_firstArray;
                    var fi = ((uint)m_hash) % m_dict.m_capacity;
                    m_extraIndex = fa[fi].Next;
                    if (m_extraIndex == 0) return false;
                    if (fa[fi].Item.Hash == m_hash
                        && m_key.Equals(fa[fi].Item.Key))
                    {
                        m_current = fa[fi].Item.Value;
                        return true;
                    }
                }
                if (m_extraIndex > 0)
                {
                    var ea = m_dict.m_extraArray;
                    do
                    {
                        var valid = ea[m_extraIndex].Item.Hash == m_hash
                                    && m_key.Equals(ea[m_extraIndex].Item.Key);
                        if (valid) m_current = ea[m_extraIndex].Item.Value;
                        m_extraIndex = ea[m_extraIndex].Next;
                        if (valid) return true;
                    } while (m_extraIndex > 0);
                }

                return false;
            }

            public void Reset()
            {
                m_extraIndex = int.MaxValue;
                m_current = default(TValue);
            }
        }

        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(TKey key, int skip)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (skip == 0) return m_firstArray[fi].Item.Value;
                --skip;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    if (skip == 0) return m_extraArray[ei].Item.Value;
                    --skip;
                }
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Remove the item with the supplied key from the Dict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(TKey key)
        {
            TValue value;
            if (!TryRemove(key, out value))
                throw new KeyNotFoundException();
            return value;
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the Dict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key)
        {
            TValue value;
            return TryRemove(key, out value);
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the Dict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key, int hash)
        {
            TValue value;
            return TryRemove(key, hash, out value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the Dict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, TValue value)
        {
            return TryRemove(key, value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the Dict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, int hash, TValue value)
        {
            return TryRemove(key, hash, value);
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the Dict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return TryRemove(item.Key, item.Value);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, out TValue value)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, int hash, out TValue value)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, int hash, TValue value)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// </summary>
        public TKey[] KeysToArray()
        {
            var array = new TKey[m_count];
            CopyKeysTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            var array = new TValue[m_count];
            CopyValuesTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// </summary>
        public KeyValuePair<TKey, TValue>[] ToArray()
        {
            var array = new KeyValuePair<TKey, TValue>[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            m_firstArray.Set(default(NextHashKeyValue<TKey, TValue>));
            m_extraArray.Set(default(HashKeyValueNext<TKey, TValue>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyKeysTo(TKey[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyValuesTo(TValue[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = new KeyValuePair<TKey, TValue>(
                                m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                while (ei > 0)
                {
                    array[index++] = new KeyValuePair<TKey, TValue>(
                                    m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copy items into supplied array starting at supplied index.
        /// </summary>
        public void CopyTo(Array array, int index)
        {
            var typedArray = array as KeyValuePair<TKey, TValue>[];
            if (typedArray != null)
                CopyTo(typedArray, index);
            else
                throw new ArgumentException();
        }

        /// <summary>
        /// Retuns a concurrent wrapper around the Dict to enable
        /// concurrent modifications.
        /// </summary>
        public ConcurrentDict<TKey, TValue> AsConcurrent()
        {
            return new ConcurrentDict<TKey, TValue>(this);
        }

        #endregion

        #region IEnumerable<KeyValuePair<TKey, TValue>> Members

        IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion
        
        #region Enumerator

        public Enumerator GetEnumerator() { return new Enumerator(this); }

        public struct Enumerator : IEnumerator<KeyValuePair<TKey, TValue>>
        {
            readonly Dict<TKey, TValue> m_dict;
            int m_index;
            int m_extraIndex;
            KeyValuePair<TKey, TValue> m_current;

            public Enumerator(Dict<TKey, TValue> dict)
            {
                m_dict = dict;
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(KeyValuePair<TKey, TValue>);
            }

            public readonly KeyValuePair<TKey, TValue> Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex < 0)
                {
                    var fa = m_dict.m_firstArray;
                    var cap = fa.Length;
                    while (m_index < cap)
                    {
                        var nxt = fa[m_index].Next;
                        if (nxt != 0)
                        {
                            m_current = new KeyValuePair<TKey, TValue>(fa[m_index].Item.Key, fa[m_index].Item.Value);
                            m_extraIndex = nxt;
                            m_index++;
                            return true;
                        }
                        m_index++;
                    }
                    return false;
                }
                else
                {
                    var ea = m_dict.m_extraArray;
                    m_current = new KeyValuePair<TKey, TValue>(ea[m_extraIndex].Item.Key, ea[m_extraIndex].Item.Value);
                    m_extraIndex = ea[m_extraIndex].Next;
                    return true;
                }
            }

            public void Reset()
            {
                m_index = 0;
                m_extraIndex = -1;
                m_current = default( KeyValuePair<TKey, TValue>);
            }
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                HashKeyValueNext<TKey, TValue>[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKeyValue<TKey, TValue> item,
                NextHashKeyValue<TKey, TValue>[] firstArray,
                uint capacity,
                ref HashKeyValueNext<TKey, TValue>[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKeyValue<TKey, TValue>[newCapacity];
            var extraArray = new HashKeyValueNext<TKey, TValue>[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region DictSet<TKey>

    /// <summary>
    /// A DictSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class DictSet<TKey>
            : IIntCountable, ICountableDictSet, IDictSet<TKey>,
              IEnumerable, IEnumerable<TKey>,
              ICollection, ICollection<TKey>
    {
        private uint m_capacity;
        private NextHashKey<TKey>[] m_firstArray;
        private HashKeyNext<TKey>[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a DictSet that autmatically grows and shrinks as necessary.
        /// </summary>
        public DictSet()
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a DictSet that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// </summary>
        public DictSet(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a DictSet and initialize it to contain the supplied
        /// items.
        /// </summary>
        public DictSet(IEnumerable<TKey> items)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        private DictSet(
                uint firstCapacity, uint extraCapacity)
        {
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKey<TKey>[m_capacity];
            m_extraArray = new HashKeyNext<TKey>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the DictSet.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the DictSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the DictSet
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the DictSet. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Always returns false. Part of the ICollection implementation.
        /// </summary>
        public bool IsReadOnly { get { return false; } }

        public bool IsSynchronized { get { return false; } }

        public object SyncRoot { get { return this; } }
        public IEnumerable<TKey> Items { get { return Keys; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Key;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Key;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        public IEnumerable<object> Objects
        {
            get
            {
                foreach (object obj in Keys)
                    yield return obj;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the DictSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the DictSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((TKey)objkey);
        }

        void ICollection<TKey>.Add(TKey key)
        {
            Add(key);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the DictSet.
        /// </summary>
        public bool Add(TKey key)
        {
            var hash = key.GetHashCode();
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the DictSet.
        /// </summary>
        public bool Add(TKey key, int hash)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the DictSet.
        /// </summary>
        public bool TryAdd(TKey key)
        {
            var hash = key.GetHashCode();
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the DictSet.
        /// </summary>
        public bool TryAdd(TKey key, int hash)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the supplied keys to the DictSet.
        /// </summary>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the DictSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the DictSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, int hash)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the DictSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key)
        {
            return TryRemove(key);
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the DictSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, int hash)
        {
            return TryRemove(key, hash);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKey<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKey<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, int hash)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKey<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKey<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// </summary>
        public TKey[] ToArray()
        {
            var array = new TKey[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            m_firstArray.Set(default(NextHashKey<TKey>));
            m_extraArray.Set(default(HashKeyNext<TKey>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyTo(TKey[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copy items into supplied array starting at supplied index.
        /// </summary>
        public void CopyTo(Array array, int index)
        {
            var typedArray = array as TKey[];
            if (typedArray != null)
                CopyTo(typedArray, index);
            else
                throw new ArgumentException();
        }

        /// <summary>
        /// Retuns a concurrent wrapper around the DictSet to enable
        /// concurrent modifications.
        /// </summary>
        public ConcurrentDictSet<TKey> AsConcurrent()
        {
            return new ConcurrentDictSet<TKey>(this);
        }

        #endregion

        #region IEnumerable<TKey> Members

        IEnumerator<TKey> IEnumerable<TKey>.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion
        
        #region Enumerator

        public Enumerator GetEnumerator() { return new Enumerator(this); }

        public struct Enumerator : IEnumerator<TKey>
        {
            readonly DictSet<TKey> m_dict;
            int m_index;
            int m_extraIndex;
            TKey m_current;

            public Enumerator(DictSet<TKey> dict)
            {
                m_dict = dict;
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(TKey);
            }

            public readonly TKey Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex < 0)
                {
                    var fa = m_dict.m_firstArray;
                    var cap = fa.Length;
                    while (m_index < cap)
                    {
                        var nxt = fa[m_index].Next;
                        if (nxt != 0)
                        {
                            m_current = fa[m_index].Item.Key;
                            m_extraIndex = nxt;
                            m_index++;
                            return true;
                        }
                        m_index++;
                    }
                    return false;
                }
                else
                {
                    var ea = m_dict.m_extraArray;
                    m_current = ea[m_extraIndex].Item.Key;
                    m_extraIndex = ea[m_extraIndex].Next;
                    return true;
                }
            }

            public void Reset()
            {
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(TKey);
            }
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                HashKeyNext<TKey>[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKey<TKey> item,
                NextHashKey<TKey>[] firstArray,
                uint capacity,
                ref HashKeyNext<TKey>[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKey<TKey>[newCapacity];
            var extraArray = new HashKeyNext<TKey>[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region IntDict<TValue>

    /// <summary>
    /// A IntDict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class IntDict<TValue>
            : IIntCountable, ICountableDict, IDict<int, TValue>,
              IEnumerable, IEnumerable<KeyValuePair<int, TValue>>,
              ICollection, ICollection<KeyValuePair<int, TValue>>
    {
        private uint m_capacity;
        private NextIntValue<TValue>[] m_firstArray;
        private IntValueNext<TValue>[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private readonly bool m_doNotStackDuplicateKeys;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a IntDict that autmatically grows and shrinks as necessary.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// IntDict acts as a stack for all items with the same key.
        /// </summary>
        public IntDict(bool stackDuplicateKeys = false)
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a IntDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// IntDict acts as a stack for all items with the same key.
        /// </summary>
        public IntDict(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, false)
        { }

        /// <summary>
        /// Create a IntDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// IntDict acts as a stack for all items with the same key.
        /// </summary>
        public IntDict(int initialCapacity, bool stackDuplicateKeys)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a IntDict and initialize it to contain the supplied
        /// items.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// IntDict acts as a stack for all items with the same key.
        /// </summary>
        public IntDict(IEnumerable<KeyValuePair<int, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        private IntDict(
                uint firstCapacity, uint extraCapacity,
                bool stackDuplicateKeys = false)
        {
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_doNotStackDuplicateKeys = !stackDuplicateKeys;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextIntValue<TValue>[m_capacity];
            m_extraArray = new IntValueNext<TValue>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the IntDict.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the IntDict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the IntDict
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the IntDict. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Always returns false. Part of the ICollection implementation.
        /// </summary>
        public bool IsReadOnly { get { return false; } }

        public bool IsSynchronized { get { return false; } }

        public object SyncRoot { get { return this; } }
        public IEnumerable<KeyValuePair<int, TValue>> Items { get { return KeyValuePairs; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// </summary>
        public IEnumerable<int> Keys
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Key;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Key;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type KeyType { get { return typeof(int); } }

        /// <summary>
        /// Returns all values in the IntDict.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Value;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Value;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type ValueType { get { return typeof(TValue); } }

        /// <summary>
        /// Returns all key value pairs in the IntDict.
        /// </summary>
        public IEnumerable<KeyValuePair<int, TValue>> KeyValuePairs
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return new KeyValuePair<int, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    while (ei > 0)
                    {
                        yield return new KeyValuePair<int, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        /// <summary>
        /// Returns all key value pairs in the IntDict, in such a way,
        /// that the stack order is correct when the pairs are put into a
        /// new IntDict in the order they are returned.
        /// </summary>
        public IEnumerable<KeyValuePair<int, TValue>> KeyValuePairsForStorage
        {
            get
            {
                var stack = new Stack<int>();
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    while (ei > 0) { stack.Push(ei); ei = m_extraArray[ei].Next; }
                    while (stack.Count > 0)
                    {
                        ei = stack.Pop();
                        yield return new KeyValuePair<int, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    }
                    yield return new KeyValuePair<int, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                }
            }
        }

        public IEnumerable<(object, object)> ObjectPairs
        {
            get
            {
                foreach (var kvp in KeyValuePairsForStorage)
                    yield return (kvp.Key, kvp.Value);
            }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the IntDict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[int key]
        {
            get
            {
                var hash = key;
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                    throw new KeyNotFoundException();
                if (m_firstArray[fi].Item.Key == hash)
                    return m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key == hash)
                        return m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
                throw new KeyNotFoundException();
            }
            set
            {
                var hash = key;
                if (m_count >= m_increaseThreshold) IncreaseCapacity();
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                {
                    ++m_count;
                    m_firstArray[fi].Next = -1;
                    m_firstArray[fi].Item.Key = key;
                    m_firstArray[fi].Item.Value = value;
                    return;
                }
                if (m_doNotStackDuplicateKeys)
                {
                    if (m_firstArray[fi].Item.Key == hash)
                    {
                        m_firstArray[fi].Item.Value = value;
                        return;
                    }
                    while (ei > 0)
                    {
                        if (m_extraArray[ei].Item.Key == hash)
                        {
                            m_extraArray[ei].Item.Value = value;
                            return;
                        }
                        ei = m_extraArray[ei].Next;
                    }
                    ei = m_firstArray[fi].Next;
                }
                ++m_count;
                ++m_extraCount;
                if (m_freeIndex < 0)
                {
                    var length = m_extraArray.Length;
                    m_extraArray = m_extraArray.Resized(length * 2);
                    m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
                }
                var ni = m_freeIndex;
                m_freeIndex = m_extraArray[ni].Next;

                m_extraArray[ni].Item = m_firstArray[fi].Item;
                m_extraArray[ni].Next = ei;

                m_firstArray[fi].Next = ni;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the IntDict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the IntDict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((int)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the IntDict.
        /// </summary>
        public void Add(int key, TValue value)
        {
            var hash = key;
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Key == hash)
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key == hash)
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the IntDict.
        /// </summary>
        public bool TryAdd(int key, TValue value)
        {
            var hash = key;
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Key == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            return true;
        }

        /// <summary>
        /// Add the supplied item to the IntDict.
        /// </summary>
        public void Add(KeyValuePair<int, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Add the supplied items to the IntDict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<int, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the IntDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(int key)
        {
            var hash = key;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the IntDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(int key)
        {
            var hash = key;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the IntDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(int key, TValue value)
        {
            var hash = key;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the IntDict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<int, TValue> item)
        {
            return Contains(item.Key, item.Value);
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(int key)
        {
            var hash = key;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Key == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the IntDict and returned.
        /// </summary>
        public TValue GetOrCreate(int key, Func<int, TValue> creator)
        {
            var hash = key;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Key == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
        }

        void AddCreated(int key, int hash, TValue value)
        {
            ++m_count;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(int key, TValue defaultValue)
        {
            var hash = key;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Key == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(int key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(int key, out TValue value)
        {
            var hash = key;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Key == hash)
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Return all the value with the given key. This method is only
        /// useful if multiple item with the same key are allowed.
        /// </summary>
        public IEnumerable<TValue> ValuesWithKey(int key)
        {
            var hash = key;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) yield break;
            if (m_firstArray[fi].Item.Key == hash)
                yield return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    yield return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
        }

        /// <summary>
        /// Gets an enumerator for values with key. It is only useful
        /// if multiple item with the same key are allowed.
        /// Should be preferred over ValuesWithKey enumeration in
        /// performance critical code.
        /// </summary>
        public ValuesWithKeyEnumerator GetValuesWithKeyEnumerator(int key)
        {
            return new ValuesWithKeyEnumerator(this, key);
        }

        public struct ValuesWithKeyEnumerator : IEnumerator<TValue>
        {
            readonly IntDict<TValue> m_dict;
            readonly int m_hash;
            int m_extraIndex;
            TValue m_current;

            public ValuesWithKeyEnumerator(IntDict<TValue> dict, int key)
            {
                m_dict = dict;
                m_hash = key;
                m_extraIndex = int.MaxValue;
                m_current = default(TValue);
            }

            public readonly TValue Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex == int.MaxValue)
                {
                    var fa = m_dict.m_firstArray;
                    var fi = ((uint)m_hash) % m_dict.m_capacity;
                    m_extraIndex = fa[fi].Next;
                    if (m_extraIndex == 0) return false;
                    if (fa[fi].Item.Key == m_hash)
                    {
                        m_current = fa[fi].Item.Value;
                        return true;
                    }
                }
                if (m_extraIndex > 0)
                {
                    var ea = m_dict.m_extraArray;
                    do
                    {
                        var valid = ea[m_extraIndex].Item.Key == m_hash;
                        if (valid) m_current = ea[m_extraIndex].Item.Value;
                        m_extraIndex = ea[m_extraIndex].Next;
                        if (valid) return true;
                    } while (m_extraIndex > 0);
                }

                return false;
            }

            public void Reset()
            {
                m_extraIndex = int.MaxValue;
                m_current = default(TValue);
            }
        }

        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(int key, int skip)
        {
            var hash = key;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Key == hash)
            {
                if (skip == 0) return m_firstArray[fi].Item.Value;
                --skip;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                {
                    if (skip == 0) return m_extraArray[ei].Item.Value;
                    --skip;
                }
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Remove the item with the supplied key from the IntDict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(int key)
        {
            TValue value;
            if (!TryRemove(key, out value))
                throw new KeyNotFoundException();
            return value;
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the IntDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(int key)
        {
            TValue value;
            return TryRemove(key, out value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the IntDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(int key, TValue value)
        {
            return TryRemove(key, value);
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the IntDict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<int, TValue> item)
        {
            return TryRemove(item.Key, item.Value);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(int key, out TValue value)
        {
            var hash = key;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Key == hash)
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(IntValue<TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(IntValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(IntValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Key == hash)
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(IntValue<TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(int key, TValue value)
        {
            var hash = key;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(IntValue<TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(IntValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(IntValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Key == hash
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(IntValue<TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// </summary>
        public int[] KeysToArray()
        {
            var array = new int[m_count];
            CopyKeysTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            var array = new TValue[m_count];
            CopyValuesTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// </summary>
        public KeyValuePair<int, TValue>[] ToArray()
        {
            var array = new KeyValuePair<int, TValue>[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            m_firstArray.Set(default(NextIntValue<TValue>));
            m_extraArray.Set(default(IntValueNext<TValue>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyKeysTo(int[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyValuesTo(TValue[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyTo(KeyValuePair<int, TValue>[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = new KeyValuePair<int, TValue>(
                                m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                while (ei > 0)
                {
                    array[index++] = new KeyValuePair<int, TValue>(
                                    m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copy items into supplied array starting at supplied index.
        /// </summary>
        public void CopyTo(Array array, int index)
        {
            var typedArray = array as KeyValuePair<int, TValue>[];
            if (typedArray != null)
                CopyTo(typedArray, index);
            else
                throw new ArgumentException();
        }

        /// <summary>
        /// Retuns a concurrent wrapper around the IntDict to enable
        /// concurrent modifications.
        /// </summary>
        public ConcurrentIntDict<TValue> AsConcurrent()
        {
            return new ConcurrentIntDict<TValue>(this);
        }

        #endregion

        #region IEnumerable<KeyValuePair<int, TValue>> Members

        IEnumerator<KeyValuePair<int, TValue>> IEnumerable<KeyValuePair<int, TValue>>.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion
        
        #region Enumerator

        public Enumerator GetEnumerator() { return new Enumerator(this); }

        public struct Enumerator : IEnumerator<KeyValuePair<int, TValue>>
        {
            readonly IntDict<TValue> m_dict;
            int m_index;
            int m_extraIndex;
            KeyValuePair<int, TValue> m_current;

            public Enumerator(IntDict<TValue> dict)
            {
                m_dict = dict;
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(KeyValuePair<int, TValue>);
            }

            public readonly KeyValuePair<int, TValue> Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex < 0)
                {
                    var fa = m_dict.m_firstArray;
                    var cap = fa.Length;
                    while (m_index < cap)
                    {
                        var nxt = fa[m_index].Next;
                        if (nxt != 0)
                        {
                            m_current = new KeyValuePair<int, TValue>(fa[m_index].Item.Key, fa[m_index].Item.Value);
                            m_extraIndex = nxt;
                            m_index++;
                            return true;
                        }
                        m_index++;
                    }
                    return false;
                }
                else
                {
                    var ea = m_dict.m_extraArray;
                    m_current = new KeyValuePair<int, TValue>(ea[m_extraIndex].Item.Key, ea[m_extraIndex].Item.Value);
                    m_extraIndex = ea[m_extraIndex].Next;
                    return true;
                }
            }

            public void Reset()
            {
                m_index = 0;
                m_extraIndex = -1;
                m_current = default( KeyValuePair<int, TValue>);
            }
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                IntValueNext<TValue>[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                IntValue<TValue> item,
                NextIntValue<TValue>[] firstArray,
                uint capacity,
                ref IntValueNext<TValue>[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item.Key) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextIntValue<TValue>[newCapacity];
            var extraArray = new IntValueNext<TValue>[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region IntSet

    /// <summary>
    /// A IntSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class IntSet
            : IIntCountable, ICountableDictSet, IDictSet<int>,
              IEnumerable, IEnumerable<int>,
              ICollection, ICollection<int>
    {
        private uint m_capacity;
        private NextInt[] m_firstArray;
        private IntNext[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a IntSet that autmatically grows and shrinks as necessary.
        /// </summary>
        public IntSet()
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a IntSet that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// </summary>
        public IntSet(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a IntSet and initialize it to contain the supplied
        /// items.
        /// </summary>
        public IntSet(IEnumerable<int> items)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        private IntSet(
                uint firstCapacity, uint extraCapacity)
        {
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextInt[m_capacity];
            m_extraArray = new IntNext[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the IntSet.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the IntSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the IntSet
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the IntSet. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Always returns false. Part of the ICollection implementation.
        /// </summary>
        public bool IsReadOnly { get { return false; } }

        public bool IsSynchronized { get { return false; } }

        public object SyncRoot { get { return this; } }
        public IEnumerable<int> Items { get { return Keys; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// </summary>
        public IEnumerable<int> Keys
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type KeyType { get { return typeof(int); } }

        public IEnumerable<object> Objects
        {
            get
            {
                foreach (object obj in Keys)
                    yield return obj;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the IntSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the IntSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((int)objkey);
        }

        void ICollection<int>.Add(int key)
        {
            Add(key);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the IntSet.
        /// </summary>
        public bool Add(int key)
        {
            var hash = key;
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the IntSet.
        /// </summary>
        public bool TryAdd(int key)
        {
            var hash = key;
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item = key;
            return true;
        }

        /// <summary>
        /// Add the supplied keys to the IntSet.
        /// </summary>
        public void AddRange(IEnumerable<int> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the IntSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(int key)
        {
            var hash = key;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the IntSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(int key)
        {
            return TryRemove(key);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(int key)
        {
            var hash = key;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item == hash)
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(int);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(int);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item == hash)
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(int);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item == hash)
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(int);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// </summary>
        public int[] ToArray()
        {
            var array = new int[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            m_firstArray.Set(default(NextInt));
            m_extraArray.Set(default(IntNext));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyTo(int[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copy items into supplied array starting at supplied index.
        /// </summary>
        public void CopyTo(Array array, int index)
        {
            var typedArray = array as int[];
            if (typedArray != null)
                CopyTo(typedArray, index);
            else
                throw new ArgumentException();
        }

        /// <summary>
        /// Retuns a concurrent wrapper around the IntSet to enable
        /// concurrent modifications.
        /// </summary>
        public ConcurrentIntSet AsConcurrent()
        {
            return new ConcurrentIntSet(this);
        }

        #endregion

        #region IEnumerable<int> Members

        IEnumerator<int> IEnumerable<int>.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion
        
        #region Enumerator

        public Enumerator GetEnumerator() { return new Enumerator(this); }

        public struct Enumerator : IEnumerator<int>
        {
            readonly IntSet m_dict;
            int m_index;
            int m_extraIndex;
            int m_current;

            public Enumerator(IntSet dict)
            {
                m_dict = dict;
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(int);
            }

            public readonly int Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex < 0)
                {
                    var fa = m_dict.m_firstArray;
                    var cap = fa.Length;
                    while (m_index < cap)
                    {
                        var nxt = fa[m_index].Next;
                        if (nxt != 0)
                        {
                            m_current = fa[m_index].Item;
                            m_extraIndex = nxt;
                            m_index++;
                            return true;
                        }
                        m_index++;
                    }
                    return false;
                }
                else
                {
                    var ea = m_dict.m_extraArray;
                    m_current = ea[m_extraIndex].Item;
                    m_extraIndex = ea[m_extraIndex].Next;
                    return true;
                }
            }

            public void Reset()
            {
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(int);
            }
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                IntNext[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                int item,
                NextInt[] firstArray,
                uint capacity,
                ref IntNext[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextInt[newCapacity];
            var extraArray = new IntNext[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region SymbolDict<TValue>

    /// <summary>
    /// A SymbolDict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class SymbolDict<TValue>
            : IIntCountable, ICountableDict, IDict<Symbol, TValue>,
              IEnumerable, IEnumerable<KeyValuePair<Symbol, TValue>>,
              ICollection, ICollection<KeyValuePair<Symbol, TValue>>
    {
        private uint m_capacity;
        private NextSymbolValue<TValue>[] m_firstArray;
        private SymbolValueNext<TValue>[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private readonly bool m_doNotStackDuplicateKeys;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a SymbolDict that autmatically grows and shrinks as necessary.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// SymbolDict acts as a stack for all items with the same key.
        /// </summary>
        public SymbolDict(bool stackDuplicateKeys = false)
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a SymbolDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// SymbolDict acts as a stack for all items with the same key.
        /// </summary>
        public SymbolDict(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, false)
        { }

        /// <summary>
        /// Create a SymbolDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// SymbolDict acts as a stack for all items with the same key.
        /// </summary>
        public SymbolDict(int initialCapacity, bool stackDuplicateKeys)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a SymbolDict and initialize it to contain the supplied
        /// items.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// SymbolDict acts as a stack for all items with the same key.
        /// </summary>
        public SymbolDict(IEnumerable<KeyValuePair<Symbol, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Create a SymbolDict and initialize to contain the supplied items.
        /// Note hat this incurs the overhead of converting all string keys
        /// to symbols.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// SymbolDict acts as a stack for all items with the same key.
        /// </summary>
        public SymbolDict(IEnumerable<KeyValuePair<string, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        private SymbolDict(
                uint firstCapacity, uint extraCapacity,
                bool stackDuplicateKeys = false)
        {
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_doNotStackDuplicateKeys = !stackDuplicateKeys;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextSymbolValue<TValue>[m_capacity];
            m_extraArray = new SymbolValueNext<TValue>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the SymbolDict.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the SymbolDict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the SymbolDict
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the SymbolDict. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Always returns false. Part of the ICollection implementation.
        /// </summary>
        public bool IsReadOnly { get { return false; } }

        public bool IsSynchronized { get { return false; } }

        public object SyncRoot { get { return this; } }
        public IEnumerable<KeyValuePair<Symbol, TValue>> Items { get { return KeyValuePairs; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// </summary>
        public IEnumerable<Symbol> Keys
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Key;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Key;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type KeyType { get { return typeof(Symbol); } }

        /// <summary>
        /// Returns all values in the SymbolDict.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Value;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Value;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type ValueType { get { return typeof(TValue); } }

        /// <summary>
        /// Returns all key value pairs in the SymbolDict.
        /// </summary>
        public IEnumerable<KeyValuePair<Symbol, TValue>> KeyValuePairs
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return new KeyValuePair<Symbol, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    while (ei > 0)
                    {
                        yield return new KeyValuePair<Symbol, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        /// <summary>
        /// Returns all key value pairs in the SymbolDict, in such a way,
        /// that the stack order is correct when the pairs are put into a
        /// new SymbolDict in the order they are returned.
        /// </summary>
        public IEnumerable<KeyValuePair<Symbol, TValue>> KeyValuePairsForStorage
        {
            get
            {
                var stack = new Stack<int>();
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    while (ei > 0) { stack.Push(ei); ei = m_extraArray[ei].Next; }
                    while (stack.Count > 0)
                    {
                        ei = stack.Pop();
                        yield return new KeyValuePair<Symbol, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    }
                    yield return new KeyValuePair<Symbol, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                }
            }
        }

        public IEnumerable<(object, object)> ObjectPairs
        {
            get
            {
                foreach (var kvp in KeyValuePairsForStorage)
                    yield return (kvp.Key, kvp.Value);
            }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the SymbolDict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[Symbol key]
        {
            get
            {
                var hash = key.Id;
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                    throw new KeyNotFoundException();
                if (m_firstArray[fi].Item.Key.Id == hash)
                    return m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key.Id == hash)
                        return m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
                throw new KeyNotFoundException();
            }
            set
            {
                var hash = key.Id;
                if (m_count >= m_increaseThreshold) IncreaseCapacity();
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                {
                    ++m_count;
                    m_firstArray[fi].Next = -1;
                    m_firstArray[fi].Item.Key = key;
                    m_firstArray[fi].Item.Value = value;
                    return;
                }
                if (m_doNotStackDuplicateKeys)
                {
                    if (m_firstArray[fi].Item.Key.Id == hash)
                    {
                        m_firstArray[fi].Item.Value = value;
                        return;
                    }
                    while (ei > 0)
                    {
                        if (m_extraArray[ei].Item.Key.Id == hash)
                        {
                            m_extraArray[ei].Item.Value = value;
                            return;
                        }
                        ei = m_extraArray[ei].Next;
                    }
                    ei = m_firstArray[fi].Next;
                }
                ++m_count;
                ++m_extraCount;
                if (m_freeIndex < 0)
                {
                    var length = m_extraArray.Length;
                    m_extraArray = m_extraArray.Resized(length * 2);
                    m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
                }
                var ni = m_freeIndex;
                m_freeIndex = m_extraArray[ni].Next;

                m_extraArray[ni].Item = m_firstArray[fi].Item;
                m_extraArray[ni].Next = ei;

                m_firstArray[fi].Next = ni;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the SymbolDict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the SymbolDict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((Symbol)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the SymbolDict.
        /// </summary>
        public void Add(Symbol key, TValue value)
        {
            var hash = key.Id;
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Key.Id == hash)
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key.Id == hash)
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the SymbolDict.
        /// </summary>
        public bool TryAdd(Symbol key, TValue value)
        {
            var hash = key.Id;
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Key.Id == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key.Id == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            return true;
        }

        /// <summary>
        /// Adds the supplied item to the SymbolDict. Note that this incurs the
        /// overhead of converting the string key to a symbol.
        /// </summary>
        public void Add(string key, TValue value)
        {
            Add(key.ToSymbol(), value);
        }

        /// <summary>
        /// Add the supplied item to the SymbolDict. Note that this incurs the
        /// overhead of converting the string key to a symbol.
        /// </summary>
        public void Add(KeyValuePair<string, TValue> item)
        {
            Add(item.Key.ToSymbol(), item.Value);
        }

        /// <summary>
        /// Add the supplied item to the SymbolDict.
        /// </summary>
        public void Add(KeyValuePair<Symbol, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Add the supplied items to the SymbolDict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<Symbol, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the SymbolDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(Symbol key)
        {
            var hash = key.Id;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key.Id == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the SymbolDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(Symbol key)
        {
            var hash = key.Id;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key.Id == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the SymbolDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(Symbol key, TValue value)
        {
            var hash = key.Id;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key.Id == hash
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the SymbolDict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<Symbol, TValue> item)
        {
            return Contains(item.Key, item.Value);
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(Symbol key)
        {
            var hash = key.Id;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Key.Id == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the SymbolDict and returned.
        /// </summary>
        public TValue GetOrCreate(Symbol key, Func<Symbol, TValue> creator)
        {
            var hash = key.Id;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Key.Id == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
        }

        void AddCreated(Symbol key, int hash, TValue value)
        {
            ++m_count;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(Symbol key, TValue defaultValue)
        {
            var hash = key.Id;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Key.Id == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(Symbol key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(Symbol key, out TValue value)
        {
            var hash = key.Id;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Key.Id == hash)
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Return all the value with the given key. This method is only
        /// useful if multiple item with the same key are allowed.
        /// </summary>
        public IEnumerable<TValue> ValuesWithKey(Symbol key)
        {
            var hash = key.Id;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) yield break;
            if (m_firstArray[fi].Item.Key.Id == hash)
                yield return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                    yield return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
        }

        /// <summary>
        /// Gets an enumerator for values with key. It is only useful
        /// if multiple item with the same key are allowed.
        /// Should be preferred over ValuesWithKey enumeration in
        /// performance critical code.
        /// </summary>
        public ValuesWithKeyEnumerator GetValuesWithKeyEnumerator(Symbol key)
        {
            return new ValuesWithKeyEnumerator(this, key);
        }

        public struct ValuesWithKeyEnumerator : IEnumerator<TValue>
        {
            readonly SymbolDict<TValue> m_dict;
            readonly int m_hash;
            int m_extraIndex;
            TValue m_current;

            public ValuesWithKeyEnumerator(SymbolDict<TValue> dict, Symbol key)
            {
                m_dict = dict;
                m_hash = key.Id;
                m_extraIndex = int.MaxValue;
                m_current = default(TValue);
            }

            public readonly TValue Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex == int.MaxValue)
                {
                    var fa = m_dict.m_firstArray;
                    var fi = ((uint)m_hash) % m_dict.m_capacity;
                    m_extraIndex = fa[fi].Next;
                    if (m_extraIndex == 0) return false;
                    if (fa[fi].Item.Key.Id == m_hash)
                    {
                        m_current = fa[fi].Item.Value;
                        return true;
                    }
                }
                if (m_extraIndex > 0)
                {
                    var ea = m_dict.m_extraArray;
                    do
                    {
                        var valid = ea[m_extraIndex].Item.Key.Id == m_hash;
                        if (valid) m_current = ea[m_extraIndex].Item.Value;
                        m_extraIndex = ea[m_extraIndex].Next;
                        if (valid) return true;
                    } while (m_extraIndex > 0);
                }

                return false;
            }

            public void Reset()
            {
                m_extraIndex = int.MaxValue;
                m_current = default(TValue);
            }
        }

        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(Symbol key, int skip)
        {
            var hash = key.Id;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Key.Id == hash)
            {
                if (skip == 0) return m_firstArray[fi].Item.Value;
                --skip;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                {
                    if (skip == 0) return m_extraArray[ei].Item.Value;
                    --skip;
                }
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Remove the item with the supplied key from the SymbolDict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(Symbol key)
        {
            TValue value;
            if (!TryRemove(key, out value))
                throw new KeyNotFoundException();
            return value;
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the SymbolDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(Symbol key)
        {
            TValue value;
            return TryRemove(key, out value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the SymbolDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(Symbol key, TValue value)
        {
            return TryRemove(key, value);
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the SymbolDict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<Symbol, TValue> item)
        {
            return TryRemove(item.Key, item.Value);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(Symbol key, out TValue value)
        {
            var hash = key.Id;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Key.Id == hash)
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(SymbolValue<TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(SymbolValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(SymbolValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Key.Id == hash)
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(SymbolValue<TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(Symbol key, TValue value)
        {
            var hash = key.Id;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key.Id == hash
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(SymbolValue<TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(SymbolValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(SymbolValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Key.Id == hash
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(SymbolValue<TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// </summary>
        public Symbol[] KeysToArray()
        {
            var array = new Symbol[m_count];
            CopyKeysTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            var array = new TValue[m_count];
            CopyValuesTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// </summary>
        public KeyValuePair<Symbol, TValue>[] ToArray()
        {
            var array = new KeyValuePair<Symbol, TValue>[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            m_firstArray.Set(default(NextSymbolValue<TValue>));
            m_extraArray.Set(default(SymbolValueNext<TValue>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyKeysTo(Symbol[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyValuesTo(TValue[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyTo(KeyValuePair<Symbol, TValue>[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = new KeyValuePair<Symbol, TValue>(
                                m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                while (ei > 0)
                {
                    array[index++] = new KeyValuePair<Symbol, TValue>(
                                    m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copy items into supplied array starting at supplied index.
        /// </summary>
        public void CopyTo(Array array, int index)
        {
            var typedArray = array as KeyValuePair<Symbol, TValue>[];
            if (typedArray != null)
                CopyTo(typedArray, index);
            else
                throw new ArgumentException();
        }

        /// <summary>
        /// Retuns a concurrent wrapper around the SymbolDict to enable
        /// concurrent modifications.
        /// </summary>
        public ConcurrentSymbolDict<TValue> AsConcurrent()
        {
            return new ConcurrentSymbolDict<TValue>(this);
        }

        public void Add<TType>(TypedSymbol<TType> key, TType value)
            where TType : TValue
        {
            this.Add(key.Symbol, value);
        }

        public bool Contains<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            return Contains(key.Symbol);
        }

        public bool ContainsKey<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            return ContainsKey(key.Symbol);
        }

        public TType Get<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            return (TType)this[key.Symbol];
        }

        public TType Get<TType>(TypedSymbol<TType> key, TType defaultValue)
            where TType : TValue
        {
            TType value;
            if (TryGetValue(key, out value)) return value;
            return defaultValue;
        }

        public TType GetOrDefault<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            TType value;
            if (TryGetValue(key, out value)) return value;
            return default(TType);
        }

        public bool Remove<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            return Remove(key.Symbol);
        }

        public void Set<TType>(TypedSymbol<TType> key, TType value)
            where TType : TValue
        {
            this[key.Symbol] = value;
        }

        public bool TryGetValue<TType>(TypedSymbol<TType> key, out TType value)
            where TType : TValue
        {
            TValue val;
            if (TryGetValue(key.Symbol, out val)) { value = (TType)val; return true; }
            value = default(TType);
            return false;
        }

        public TType GetAs<TType>(Symbol key)
            where TType : TValue
        {
            return (TType)this[key];
        }

        public TType GetAs<TType>(Symbol key, TType defaultValue)
            where TType : TValue
        {
            TValue value;
            if (TryGetValue(key, out value)) return (TType)value;
            return defaultValue;
        }

        public TType GetAsOrDefault<TType>(Symbol key)
            where TType : TValue
        {
            TValue value;
            if (TryGetValue(key, out value)) return (TType)value;
            return default(TType);
        }

        #endregion

        #region IEnumerable<KeyValuePair<Symbol, TValue>> Members

        IEnumerator<KeyValuePair<Symbol, TValue>> IEnumerable<KeyValuePair<Symbol, TValue>>.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion
        
        #region Enumerator

        public Enumerator GetEnumerator() { return new Enumerator(this); }

        public struct Enumerator : IEnumerator<KeyValuePair<Symbol, TValue>>
        {
            readonly SymbolDict<TValue> m_dict;
            int m_index;
            int m_extraIndex;
            KeyValuePair<Symbol, TValue> m_current;

            public Enumerator(SymbolDict<TValue> dict)
            {
                m_dict = dict;
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(KeyValuePair<Symbol, TValue>);
            }

            public readonly KeyValuePair<Symbol, TValue> Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex < 0)
                {
                    var fa = m_dict.m_firstArray;
                    var cap = fa.Length;
                    while (m_index < cap)
                    {
                        var nxt = fa[m_index].Next;
                        if (nxt != 0)
                        {
                            m_current = new KeyValuePair<Symbol, TValue>(fa[m_index].Item.Key, fa[m_index].Item.Value);
                            m_extraIndex = nxt;
                            m_index++;
                            return true;
                        }
                        m_index++;
                    }
                    return false;
                }
                else
                {
                    var ea = m_dict.m_extraArray;
                    m_current = new KeyValuePair<Symbol, TValue>(ea[m_extraIndex].Item.Key, ea[m_extraIndex].Item.Value);
                    m_extraIndex = ea[m_extraIndex].Next;
                    return true;
                }
            }

            public void Reset()
            {
                m_index = 0;
                m_extraIndex = -1;
                m_current = default( KeyValuePair<Symbol, TValue>);
            }
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                SymbolValueNext<TValue>[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                SymbolValue<TValue> item,
                NextSymbolValue<TValue>[] firstArray,
                uint capacity,
                ref SymbolValueNext<TValue>[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item.Key.Id) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextSymbolValue<TValue>[newCapacity];
            var extraArray = new SymbolValueNext<TValue>[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region SymbolSet

    /// <summary>
    /// A SymbolSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class SymbolSet
            : IIntCountable, ICountableDictSet, IDictSet<Symbol>,
              IEnumerable, IEnumerable<Symbol>,
              ICollection, ICollection<Symbol>
    {
        private uint m_capacity;
        private NextSymbol[] m_firstArray;
        private SymbolNext[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a SymbolSet that autmatically grows and shrinks as necessary.
        /// </summary>
        public SymbolSet()
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a SymbolSet that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// </summary>
        public SymbolSet(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a SymbolSet and initialize it to contain the supplied
        /// items.
        /// </summary>
        public SymbolSet(IEnumerable<Symbol> items)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Create a SymbolSet and initialize to contain the supplied items.
        /// Note hat this incurs the overhead of converting all string keys
        /// to symbols.
        /// </summary>
        public SymbolSet(IEnumerable<string> items)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        private SymbolSet(
                uint firstCapacity, uint extraCapacity)
        {
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextSymbol[m_capacity];
            m_extraArray = new SymbolNext[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the SymbolSet.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the SymbolSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the SymbolSet
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the SymbolSet. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Always returns false. Part of the ICollection implementation.
        /// </summary>
        public bool IsReadOnly { get { return false; } }

        public bool IsSynchronized { get { return false; } }

        public object SyncRoot { get { return this; } }
        public IEnumerable<Symbol> Items { get { return Keys; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// </summary>
        public IEnumerable<Symbol> Keys
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type KeyType { get { return typeof(Symbol); } }

        public IEnumerable<object> Objects
        {
            get
            {
                foreach (object obj in Keys)
                    yield return obj;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the SymbolSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the SymbolSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((Symbol)objkey);
        }

        void ICollection<Symbol>.Add(Symbol key)
        {
            Add(key);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the SymbolSet.
        /// </summary>
        public bool Add(Symbol key)
        {
            var hash = key.Id;
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Id == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Id == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the SymbolSet.
        /// </summary>
        public bool TryAdd(Symbol key)
        {
            var hash = key.Id;
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Id == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Id == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item = key;
            return true;
        }

        /// <summary>
        /// Adds the supplied item to the SymbolSet. Note that this incurs the
        /// overhead of converting the string key to a symbol.
        /// </summary>
        public void Add(string key)
        {
            Add(key.ToSymbol());
        }

        /// <summary>
        /// Add the supplied keys to the SymbolSet.
        /// </summary>
        public void AddRange(IEnumerable<Symbol> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the SymbolSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(Symbol key)
        {
            var hash = key.Id;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Id == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Id == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the SymbolSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(Symbol key)
        {
            return TryRemove(key);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(Symbol key)
        {
            var hash = key.Id;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Id == hash)
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(Symbol);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(Symbol);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Id == hash)
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(Symbol);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Id == hash)
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(Symbol);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// </summary>
        public Symbol[] ToArray()
        {
            var array = new Symbol[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            m_firstArray.Set(default(NextSymbol));
            m_extraArray.Set(default(SymbolNext));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyTo(Symbol[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copy items into supplied array starting at supplied index.
        /// </summary>
        public void CopyTo(Array array, int index)
        {
            var typedArray = array as Symbol[];
            if (typedArray != null)
                CopyTo(typedArray, index);
            else
                throw new ArgumentException();
        }

        /// <summary>
        /// Retuns a concurrent wrapper around the SymbolSet to enable
        /// concurrent modifications.
        /// </summary>
        public ConcurrentSymbolSet AsConcurrent()
        {
            return new ConcurrentSymbolSet(this);
        }

        #endregion

        #region IEnumerable<Symbol> Members

        IEnumerator<Symbol> IEnumerable<Symbol>.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion
        
        #region Enumerator

        public Enumerator GetEnumerator() { return new Enumerator(this); }

        public struct Enumerator : IEnumerator<Symbol>
        {
            readonly SymbolSet m_dict;
            int m_index;
            int m_extraIndex;
            Symbol m_current;

            public Enumerator(SymbolSet dict)
            {
                m_dict = dict;
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(Symbol);
            }

            public readonly Symbol Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex < 0)
                {
                    var fa = m_dict.m_firstArray;
                    var cap = fa.Length;
                    while (m_index < cap)
                    {
                        var nxt = fa[m_index].Next;
                        if (nxt != 0)
                        {
                            m_current = fa[m_index].Item;
                            m_extraIndex = nxt;
                            m_index++;
                            return true;
                        }
                        m_index++;
                    }
                    return false;
                }
                else
                {
                    var ea = m_dict.m_extraArray;
                    m_current = ea[m_extraIndex].Item;
                    m_extraIndex = ea[m_extraIndex].Next;
                    return true;
                }
            }

            public void Reset()
            {
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(Symbol);
            }
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                SymbolNext[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                Symbol item,
                NextSymbol[] firstArray,
                uint capacity,
                ref SymbolNext[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item.Id) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextSymbol[newCapacity];
            var extraArray = new SymbolNext[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region BigDict<TKey, TValue>

    /// <summary>
    /// A BigDict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class BigDict<TKey, TValue>
            : ICountableDict, IDict<TKey, TValue>,
              IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>
    {
        private readonly Func<TKey, long> m_hfun;
        private ulong m_capacity;
        private NextHashKeyValueLong<TKey, TValue>[] m_firstArray;
        private HashKeyValueNextLong<TKey, TValue>[] m_extraArray;
        private ulong m_count;
        private ulong m_increaseThreshold;
        private ulong m_decreaseThreshold;
        private readonly bool m_doNotStackDuplicateKeys;
        private long m_freeIndex;
        private int m_capacityIndex;
        private ulong m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a BigDict that autmatically grows and shrinks as necessary.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// BigDict acts as a stack for all items with the same key.
        /// </summary>
        public BigDict(Func<TKey, long> hfun, bool stackDuplicateKeys = false)
            : this(hfun, DictConstant.PrimeSizesLong[0], (ulong)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a BigDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// BigDict acts as a stack for all items with the same key.
        /// </summary>
        public BigDict(Func<TKey, long> hfun, long initialCapacity)
            : this(hfun, System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizesLong[0]),
                   (ulong)DictConstant.MinExtraCapacity, false)
        { }

        /// <summary>
        /// Create a BigDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// BigDict acts as a stack for all items with the same key.
        /// </summary>
        public BigDict(Func<TKey, long> hfun, long initialCapacity, bool stackDuplicateKeys)
            : this(hfun, System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizesLong[0]),
                   (ulong)DictConstant.MinExtraCapacity, stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a BigDict and initialize it to contain the supplied
        /// items.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// BigDict acts as a stack for all items with the same key.
        /// </summary>
        public BigDict(Func<TKey, long> hfun, IEnumerable<KeyValuePair<TKey, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(hfun, Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizesLong[0]), (ulong)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        private BigDict(
                Func<TKey, long> hfun, ulong firstCapacity, ulong extraCapacity,
                bool stackDuplicateKeys = false)
        {
            m_hfun = hfun;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_doNotStackDuplicateKeys = !stackDuplicateKeys;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizesLong[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizesLong[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKeyValueLong<TKey, TValue>[m_capacity];
            m_extraArray = new HashKeyValueNextLong<TKey, TValue>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the BigDict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the BigDict
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the BigDict. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Always returns false. Part of the ICollection implementation.
        /// </summary>
        public bool IsReadOnly { get { return false; } }

        public bool IsSynchronized { get { return false; } }

        public object SyncRoot { get { return this; } }
        public IEnumerable<KeyValuePair<TKey, TValue>> Items { get { return KeyValuePairs; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Key;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Key;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        /// <summary>
        /// Returns all values in the BigDict.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Value;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Value;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type ValueType { get { return typeof(TValue); } }

        /// <summary>
        /// Returns all key value pairs in the BigDict.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairs
        {
            get
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    while (ei > 0)
                    {
                        yield return new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        /// <summary>
        /// Returns all key value pairs in the BigDict, in such a way,
        /// that the stack order is correct when the pairs are put into a
        /// new BigDict in the order they are returned.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairsForStorage
        {
            get
            {
                var stack = new Stack<long>();
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    while (ei > 0) { stack.Push(ei); ei = m_extraArray[ei].Next; }
                    while (stack.Count > 0)
                    {
                        ei = stack.Pop();
                        yield return new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    }
                    yield return new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                }
            }
        }

        public IEnumerable<(object, object)> ObjectPairs
        {
            get
            {
                foreach (var kvp in KeyValuePairsForStorage)
                    yield return (kvp.Key, kvp.Value);
            }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the BigDict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[TKey key]
        {
            get
            {
                var hash = m_hfun(key);
                var fi = ((ulong)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                    throw new KeyNotFoundException();
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                    return m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                        return m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
                throw new KeyNotFoundException();
            }
            set
            {
                var hash = m_hfun(key);
                if (m_count >= m_increaseThreshold) IncreaseCapacity();
                var fi = ((ulong)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                {
                    ++m_count;
                    m_firstArray[fi].Next = -1;
                    m_firstArray[fi].Item.Hash = hash;
                    m_firstArray[fi].Item.Key = key;
                    m_firstArray[fi].Item.Value = value;
                    return;
                }
                if (m_doNotStackDuplicateKeys)
                {
                    if (m_firstArray[fi].Item.Hash == hash
                        && key.Equals(m_firstArray[fi].Item.Key))
                    {
                        m_firstArray[fi].Item.Value = value;
                        return;
                    }
                    while (ei > 0)
                    {
                        if (m_extraArray[ei].Item.Hash == hash
                            && key.Equals(m_extraArray[ei].Item.Key))
                        {
                            m_extraArray[ei].Item.Value = value;
                            return;
                        }
                        ei = m_extraArray[ei].Next;
                    }
                    ei = m_firstArray[fi].Next;
                }
                ++m_count;
                ++m_extraCount;
                if (m_freeIndex < 0)
                {
                    var length = m_extraArray.LongLength;
                    m_extraArray = m_extraArray.Resized(length * 2);
                    m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
                }
                var ni = m_freeIndex;
                m_freeIndex = m_extraArray[ni].Next;

                m_extraArray[ni].Item = m_firstArray[fi].Item;
                m_extraArray[ni].Next = ei;

                m_firstArray[fi].Next = ni;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the BigDict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the BigDict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((TKey)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the BigDict.
        /// </summary>
        public void Add(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the BigDict.
        /// </summary>
        public void Add(TKey key, long hash, TValue value)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the BigDict.
        /// </summary>
        public bool TryAdd(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the BigDict.
        /// </summary>
        public bool TryAdd(TKey key, long hash, TValue value)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            return true;
        }

        /// <summary>
        /// Add the supplied item to the BigDict.
        /// </summary>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Add the supplied items to the BigDict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the BigDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the BigDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, long hash)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the BigDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the BigDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key, long hash)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the BigDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the BigDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, long hash, TValue value)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the BigDict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            return Contains(item.Key, item.Value);
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the BigDict and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, Func<TKey, TValue> creator)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
        }

        void AddCreated(TKey key, long hash, TValue value)
        {
            ++m_count;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, TValue defaultValue)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key, long hash)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the BigDict and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, long hash, Func<TKey, TValue> creator)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, long hash, TValue defaultValue)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(TKey key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, out TValue value)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, long hash, out TValue value)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Return all the value with the given key. This method is only
        /// useful if multiple item with the same key are allowed.
        /// </summary>
        public IEnumerable<TValue> ValuesWithKey(TKey key)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) yield break;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                yield return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    yield return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
        }

        /// <summary>
        /// Gets an enumerator for values with key. It is only useful
        /// if multiple item with the same key are allowed.
        /// Should be preferred over ValuesWithKey enumeration in
        /// performance critical code.
        /// </summary>
        public ValuesWithKeyEnumerator GetValuesWithKeyEnumerator(TKey key)
        {
            return new ValuesWithKeyEnumerator(this, key);
        }

        public struct ValuesWithKeyEnumerator : IEnumerator<TValue>
        {
            readonly BigDict<TKey, TValue> m_dict;
            readonly TKey m_key;
            readonly long m_hash;
            long m_extraIndex;
            TValue m_current;

            public ValuesWithKeyEnumerator(BigDict<TKey, TValue> dict, TKey key)
            {
                m_dict = dict;
                m_key = key;
                m_hash = dict.m_hfun(key);
                m_extraIndex = int.MaxValue;
                m_current = default(TValue);
            }

            public readonly TValue Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex == int.MaxValue)
                {
                    var fa = m_dict.m_firstArray;
                    var fi = ((uint)m_hash) % m_dict.m_capacity;
                    m_extraIndex = fa[fi].Next;
                    if (m_extraIndex == 0) return false;
                    if (fa[fi].Item.Hash == m_hash
                        && m_key.Equals(fa[fi].Item.Key))
                    {
                        m_current = fa[fi].Item.Value;
                        return true;
                    }
                }
                if (m_extraIndex > 0)
                {
                    var ea = m_dict.m_extraArray;
                    do
                    {
                        var valid = ea[m_extraIndex].Item.Hash == m_hash
                                    && m_key.Equals(ea[m_extraIndex].Item.Key);
                        if (valid) m_current = ea[m_extraIndex].Item.Value;
                        m_extraIndex = ea[m_extraIndex].Next;
                        if (valid) return true;
                    } while (m_extraIndex > 0);
                }

                return false;
            }

            public void Reset()
            {
                m_extraIndex = int.MaxValue;
                m_current = default(TValue);
            }
        }

        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(TKey key, long skip)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (skip == 0) return m_firstArray[fi].Item.Value;
                --skip;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    if (skip == 0) return m_extraArray[ei].Item.Value;
                    --skip;
                }
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Remove the item with the supplied key from the BigDict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(TKey key)
        {
            TValue value;
            if (!TryRemove(key, out value))
                throw new KeyNotFoundException();
            return value;
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the BigDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key)
        {
            TValue value;
            return TryRemove(key, out value);
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the BigDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key, long hash)
        {
            TValue value;
            return TryRemove(key, hash, out value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the BigDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, TValue value)
        {
            return TryRemove(key, value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the BigDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, long hash, TValue value)
        {
            return TryRemove(key, hash, value);
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the BigDict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return TryRemove(item.Key, item.Value);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, out TValue value)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, long hash, out TValue value)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, long hash, TValue value)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// </summary>
        public TKey[] KeysToArray()
        {
            var array = new TKey[m_count];
            CopyKeysTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            var array = new TValue[m_count];
            CopyValuesTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// </summary>
        public KeyValuePair<TKey, TValue>[] ToArray()
        {
            var array = new KeyValuePair<TKey, TValue>[m_count];
            CopyTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            m_firstArray.Set(default(NextHashKeyValueLong<TKey, TValue>));
            m_extraArray.Set(default(HashKeyValueNextLong<TKey, TValue>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyKeysTo(TKey[] array, long index)
        {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyValuesTo(TValue[] array, long index)
        {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyTo(KeyValuePair<TKey, TValue>[] array, long index)
        {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = new KeyValuePair<TKey, TValue>(
                                m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                while (ei > 0)
                {
                    array[index++] = new KeyValuePair<TKey, TValue>(
                                    m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copy items into supplied array starting at supplied index.
        /// </summary>
        public void CopyTo(Array array, int index)
        {
            var typedArray = array as KeyValuePair<TKey, TValue>[];
            if (typedArray != null)
                CopyTo(typedArray, (long)index);
            else
                throw new ArgumentException();
        }

        /// <summary>
        /// Retuns a concurrent wrapper around the BigDict to enable
        /// concurrent modifications.
        /// </summary>
        public ConcurrentBigDict<TKey, TValue> AsConcurrent()
        {
            return new ConcurrentBigDict<TKey, TValue>(this);
        }

        #endregion

        #region IEnumerable<KeyValuePair<TKey, TValue>> Members

        IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion
        
        #region Enumerator

        public Enumerator GetEnumerator() { return new Enumerator(this); }

        public struct Enumerator : IEnumerator<KeyValuePair<TKey, TValue>>
        {
            readonly BigDict<TKey, TValue> m_dict;
            long m_index;
            long m_extraIndex;
            KeyValuePair<TKey, TValue> m_current;

            public Enumerator(BigDict<TKey, TValue> dict)
            {
                m_dict = dict;
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(KeyValuePair<TKey, TValue>);
            }

            public readonly KeyValuePair<TKey, TValue> Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex < 0)
                {
                    var fa = m_dict.m_firstArray;
                    var cap = fa.Length;
                    while (m_index < cap)
                    {
                        var nxt = fa[m_index].Next;
                        if (nxt != 0)
                        {
                            m_current = new KeyValuePair<TKey, TValue>(fa[m_index].Item.Key, fa[m_index].Item.Value);
                            m_extraIndex = nxt;
                            m_index++;
                            return true;
                        }
                        m_index++;
                    }
                    return false;
                }
                else
                {
                    var ea = m_dict.m_extraArray;
                    m_current = new KeyValuePair<TKey, TValue>(ea[m_extraIndex].Item.Key, ea[m_extraIndex].Item.Value);
                    m_extraIndex = ea[m_extraIndex].Next;
                    return true;
                }
            }

            public void Reset()
            {
                m_index = 0;
                m_extraIndex = -1;
                m_current = default( KeyValuePair<TKey, TValue>);
            }
        }

        #endregion
        
        #region Private Helper Methods

        private ulong ComputeIncreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_maxFillFactor);
        }

        private ulong ComputeDecreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_minFillFactor);
        }

        private static long AddSlotsToFreeList(
                HashKeyValueNextLong<TKey, TValue>[] extraArray, long start)
        {
            var length = extraArray.Length - 1;
            for (long i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizesLong[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizesLong[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKeyValueLong<TKey, TValue> item,
                NextHashKeyValueLong<TKey, TValue>[] firstArray,
                ulong capacity,
                ref HashKeyValueNextLong<TKey, TValue>[] extraArray,
                ref long freeIndex,
                ref ulong extraCount)
        {
            var fi = ((ulong)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(ulong newCapacity, ulong oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKeyValueLong<TKey, TValue>[newCapacity];
            var extraArray = new HashKeyValueNextLong<TKey, TValue>[
                                    System.Math.Max((long)DictConstant.MinExtraCapacity,
                                                    m_extraArray.LongLength / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            ulong newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                ulong fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((ulong)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (ulong)m_extraArray.Length,
                            (ulong)m_count - newExtraCount, newCapacity,
                            newExtraCount, (ulong)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    ulong oldFirstCount, ulong oldCapacity,
                    ulong oldExtraCount, ulong oldExtraCapacity,
                    ulong newFirstCount, ulong newCapacity,
                    ulong newExtraCount, ulong newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region BigDictSet<TKey>

    /// <summary>
    /// A BigDictSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class BigDictSet<TKey>
            : ICountableDictSet, IDictSet<TKey>,
              IEnumerable, IEnumerable<TKey>
    {
        private readonly Func<TKey, long> m_hfun;
        private ulong m_capacity;
        private NextHashKeyLong<TKey>[] m_firstArray;
        private HashKeyNextLong<TKey>[] m_extraArray;
        private ulong m_count;
        private ulong m_increaseThreshold;
        private ulong m_decreaseThreshold;
        private long m_freeIndex;
        private int m_capacityIndex;
        private ulong m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a BigDictSet that autmatically grows and shrinks as necessary.
        /// </summary>
        public BigDictSet(Func<TKey, long> hfun)
            : this(hfun, DictConstant.PrimeSizesLong[0], (ulong)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a BigDictSet that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// </summary>
        public BigDictSet(Func<TKey, long> hfun, long initialCapacity)
            : this(hfun, System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizesLong[0]),
                   (ulong)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a BigDictSet and initialize it to contain the supplied
        /// items.
        /// </summary>
        public BigDictSet(Func<TKey, long> hfun, IEnumerable<TKey> items)
            : this(hfun, Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizesLong[0]), (ulong)DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        private BigDictSet(
                Func<TKey, long> hfun, ulong firstCapacity, ulong extraCapacity)
        {
            m_hfun = hfun;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizesLong[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizesLong[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKeyLong<TKey>[m_capacity];
            m_extraArray = new HashKeyNextLong<TKey>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the BigDictSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the BigDictSet
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the BigDictSet. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Always returns false. Part of the ICollection implementation.
        /// </summary>
        public bool IsReadOnly { get { return false; } }

        public bool IsSynchronized { get { return false; } }

        public object SyncRoot { get { return this; } }
        public IEnumerable<TKey> Items { get { return Keys; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Key;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Key;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        public IEnumerable<object> Objects
        {
            get
            {
                foreach (object obj in Keys)
                    yield return obj;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the BigDictSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the BigDictSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((TKey)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the BigDictSet.
        /// </summary>
        public bool Add(TKey key)
        {
            var hash = m_hfun(key);
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the BigDictSet.
        /// </summary>
        public bool Add(TKey key, long hash)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the BigDictSet.
        /// </summary>
        public bool TryAdd(TKey key)
        {
            var hash = m_hfun(key);
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the BigDictSet.
        /// </summary>
        public bool TryAdd(TKey key, long hash)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the supplied keys to the BigDictSet.
        /// </summary>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the BigDictSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the BigDictSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, long hash)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the BigDictSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key)
        {
            return TryRemove(key);
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the BigDictSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, long hash)
        {
            return TryRemove(key, hash);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyLong<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyLong<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, long hash)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyLong<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyLong<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// </summary>
        public TKey[] ToArray()
        {
            var array = new TKey[m_count];
            CopyTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            m_firstArray.Set(default(NextHashKeyLong<TKey>));
            m_extraArray.Set(default(HashKeyNextLong<TKey>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyTo(TKey[] array, long index)
        {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copy items into supplied array starting at supplied index.
        /// </summary>
        public void CopyTo(Array array, int index)
        {
            var typedArray = array as TKey[];
            if (typedArray != null)
                CopyTo(typedArray, (long)index);
            else
                throw new ArgumentException();
        }

        /// <summary>
        /// Retuns a concurrent wrapper around the BigDictSet to enable
        /// concurrent modifications.
        /// </summary>
        public ConcurrentBigDictSet<TKey> AsConcurrent()
        {
            return new ConcurrentBigDictSet<TKey>(this);
        }

        #endregion

        #region IEnumerable<TKey> Members

        IEnumerator<TKey> IEnumerable<TKey>.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion
        
        #region Enumerator

        public Enumerator GetEnumerator() { return new Enumerator(this); }

        public struct Enumerator : IEnumerator<TKey>
        {
            readonly BigDictSet<TKey> m_dict;
            long m_index;
            long m_extraIndex;
            TKey m_current;

            public Enumerator(BigDictSet<TKey> dict)
            {
                m_dict = dict;
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(TKey);
            }

            public readonly TKey Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex < 0)
                {
                    var fa = m_dict.m_firstArray;
                    var cap = fa.Length;
                    while (m_index < cap)
                    {
                        var nxt = fa[m_index].Next;
                        if (nxt != 0)
                        {
                            m_current = fa[m_index].Item.Key;
                            m_extraIndex = nxt;
                            m_index++;
                            return true;
                        }
                        m_index++;
                    }
                    return false;
                }
                else
                {
                    var ea = m_dict.m_extraArray;
                    m_current = ea[m_extraIndex].Item.Key;
                    m_extraIndex = ea[m_extraIndex].Next;
                    return true;
                }
            }

            public void Reset()
            {
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(TKey);
            }
        }

        #endregion
        
        #region Private Helper Methods

        private ulong ComputeIncreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_maxFillFactor);
        }

        private ulong ComputeDecreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_minFillFactor);
        }

        private static long AddSlotsToFreeList(
                HashKeyNextLong<TKey>[] extraArray, long start)
        {
            var length = extraArray.Length - 1;
            for (long i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizesLong[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizesLong[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKeyLong<TKey> item,
                NextHashKeyLong<TKey>[] firstArray,
                ulong capacity,
                ref HashKeyNextLong<TKey>[] extraArray,
                ref long freeIndex,
                ref ulong extraCount)
        {
            var fi = ((ulong)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(ulong newCapacity, ulong oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKeyLong<TKey>[newCapacity];
            var extraArray = new HashKeyNextLong<TKey>[
                                    System.Math.Max((long)DictConstant.MinExtraCapacity,
                                                    m_extraArray.LongLength / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            ulong newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                ulong fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((ulong)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (ulong)m_extraArray.Length,
                            (ulong)m_count - newExtraCount, newCapacity,
                            newExtraCount, (ulong)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    ulong oldFirstCount, ulong oldCapacity,
                    ulong oldExtraCount, ulong oldExtraCapacity,
                    ulong newFirstCount, ulong newCapacity,
                    ulong newExtraCount, ulong newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region LongDict<TValue>

    /// <summary>
    /// A LongDict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class LongDict<TValue>
            : ICountableDict, IDict<long, TValue>,
              IEnumerable, IEnumerable<KeyValuePair<long, TValue>>
    {
        private ulong m_capacity;
        private NextLongValue<TValue>[] m_firstArray;
        private LongValueNext<TValue>[] m_extraArray;
        private ulong m_count;
        private ulong m_increaseThreshold;
        private ulong m_decreaseThreshold;
        private readonly bool m_doNotStackDuplicateKeys;
        private long m_freeIndex;
        private int m_capacityIndex;
        private ulong m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a LongDict that autmatically grows and shrinks as necessary.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// LongDict acts as a stack for all items with the same key.
        /// </summary>
        public LongDict(bool stackDuplicateKeys = false)
            : this(DictConstant.PrimeSizes[0], (ulong)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a LongDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// LongDict acts as a stack for all items with the same key.
        /// </summary>
        public LongDict(long initialCapacity)
            : this(System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (ulong)DictConstant.MinExtraCapacity, false)
        { }

        /// <summary>
        /// Create a LongDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// LongDict acts as a stack for all items with the same key.
        /// </summary>
        public LongDict(long initialCapacity, bool stackDuplicateKeys)
            : this(System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (ulong)DictConstant.MinExtraCapacity, stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a LongDict and initialize it to contain the supplied
        /// items.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// LongDict acts as a stack for all items with the same key.
        /// </summary>
        public LongDict(IEnumerable<KeyValuePair<long, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (ulong)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        private LongDict(
                ulong firstCapacity, ulong extraCapacity,
                bool stackDuplicateKeys = false)
        {
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_doNotStackDuplicateKeys = !stackDuplicateKeys;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextLongValue<TValue>[m_capacity];
            m_extraArray = new LongValueNext<TValue>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the LongDict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the LongDict
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the LongDict. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Always returns false. Part of the ICollection implementation.
        /// </summary>
        public bool IsReadOnly { get { return false; } }

        public bool IsSynchronized { get { return false; } }

        public object SyncRoot { get { return this; } }
        public IEnumerable<KeyValuePair<long, TValue>> Items { get { return KeyValuePairs; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// </summary>
        public IEnumerable<long> Keys
        {
            get
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Key;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Key;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type KeyType { get { return typeof(long); } }

        /// <summary>
        /// Returns all values in the LongDict.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Value;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Value;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type ValueType { get { return typeof(TValue); } }

        /// <summary>
        /// Returns all key value pairs in the LongDict.
        /// </summary>
        public IEnumerable<KeyValuePair<long, TValue>> KeyValuePairs
        {
            get
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return new KeyValuePair<long, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    while (ei > 0)
                    {
                        yield return new KeyValuePair<long, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        /// <summary>
        /// Returns all key value pairs in the LongDict, in such a way,
        /// that the stack order is correct when the pairs are put into a
        /// new LongDict in the order they are returned.
        /// </summary>
        public IEnumerable<KeyValuePair<long, TValue>> KeyValuePairsForStorage
        {
            get
            {
                var stack = new Stack<long>();
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    while (ei > 0) { stack.Push(ei); ei = m_extraArray[ei].Next; }
                    while (stack.Count > 0)
                    {
                        ei = stack.Pop();
                        yield return new KeyValuePair<long, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    }
                    yield return new KeyValuePair<long, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                }
            }
        }

        public IEnumerable<(object, object)> ObjectPairs
        {
            get
            {
                foreach (var kvp in KeyValuePairsForStorage)
                    yield return (kvp.Key, kvp.Value);
            }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the LongDict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[long key]
        {
            get
            {
                var hash = key;
                var fi = ((ulong)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                    throw new KeyNotFoundException();
                if (m_firstArray[fi].Item.Key == hash)
                    return m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key == hash)
                        return m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
                throw new KeyNotFoundException();
            }
            set
            {
                var hash = key;
                if (m_count >= m_increaseThreshold) IncreaseCapacity();
                var fi = ((ulong)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                {
                    ++m_count;
                    m_firstArray[fi].Next = -1;
                    m_firstArray[fi].Item.Key = key;
                    m_firstArray[fi].Item.Value = value;
                    return;
                }
                if (m_doNotStackDuplicateKeys)
                {
                    if (m_firstArray[fi].Item.Key == hash)
                    {
                        m_firstArray[fi].Item.Value = value;
                        return;
                    }
                    while (ei > 0)
                    {
                        if (m_extraArray[ei].Item.Key == hash)
                        {
                            m_extraArray[ei].Item.Value = value;
                            return;
                        }
                        ei = m_extraArray[ei].Next;
                    }
                    ei = m_firstArray[fi].Next;
                }
                ++m_count;
                ++m_extraCount;
                if (m_freeIndex < 0)
                {
                    var length = m_extraArray.Length;
                    m_extraArray = m_extraArray.Resized(length * 2);
                    m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
                }
                var ni = m_freeIndex;
                m_freeIndex = m_extraArray[ni].Next;

                m_extraArray[ni].Item = m_firstArray[fi].Item;
                m_extraArray[ni].Next = ei;

                m_firstArray[fi].Next = ni;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the LongDict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the LongDict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((long)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the LongDict.
        /// </summary>
        public void Add(long key, TValue value)
        {
            var hash = key;
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Key == hash)
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key == hash)
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the LongDict.
        /// </summary>
        public bool TryAdd(long key, TValue value)
        {
            var hash = key;
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Key == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            return true;
        }

        /// <summary>
        /// Add the supplied item to the LongDict.
        /// </summary>
        public void Add(KeyValuePair<long, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Add the supplied items to the LongDict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<long, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the LongDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(long key)
        {
            var hash = key;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the LongDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(long key)
        {
            var hash = key;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the LongDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(long key, TValue value)
        {
            var hash = key;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the LongDict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<long, TValue> item)
        {
            return Contains(item.Key, item.Value);
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(long key)
        {
            var hash = key;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Key == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the LongDict and returned.
        /// </summary>
        public TValue GetOrCreate(long key, Func<long, TValue> creator)
        {
            var hash = key;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Key == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
        }

        void AddCreated(long key, long hash, TValue value)
        {
            ++m_count;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(long key, TValue defaultValue)
        {
            var hash = key;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Key == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(long key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(long key, out TValue value)
        {
            var hash = key;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Key == hash)
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Return all the value with the given key. This method is only
        /// useful if multiple item with the same key are allowed.
        /// </summary>
        public IEnumerable<TValue> ValuesWithKey(long key)
        {
            var hash = key;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) yield break;
            if (m_firstArray[fi].Item.Key == hash)
                yield return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    yield return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
        }

        /// <summary>
        /// Gets an enumerator for values with key. It is only useful
        /// if multiple item with the same key are allowed.
        /// Should be preferred over ValuesWithKey enumeration in
        /// performance critical code.
        /// </summary>
        public ValuesWithKeyEnumerator GetValuesWithKeyEnumerator(long key)
        {
            return new ValuesWithKeyEnumerator(this, key);
        }

        public struct ValuesWithKeyEnumerator : IEnumerator<TValue>
        {
            readonly LongDict<TValue> m_dict;
            readonly long m_hash;
            long m_extraIndex;
            TValue m_current;

            public ValuesWithKeyEnumerator(LongDict<TValue> dict, long key)
            {
                m_dict = dict;
                m_hash = key;
                m_extraIndex = int.MaxValue;
                m_current = default(TValue);
            }

            public readonly TValue Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex == int.MaxValue)
                {
                    var fa = m_dict.m_firstArray;
                    var fi = ((uint)m_hash) % m_dict.m_capacity;
                    m_extraIndex = fa[fi].Next;
                    if (m_extraIndex == 0) return false;
                    if (fa[fi].Item.Key == m_hash)
                    {
                        m_current = fa[fi].Item.Value;
                        return true;
                    }
                }
                if (m_extraIndex > 0)
                {
                    var ea = m_dict.m_extraArray;
                    do
                    {
                        var valid = ea[m_extraIndex].Item.Key == m_hash;
                        if (valid) m_current = ea[m_extraIndex].Item.Value;
                        m_extraIndex = ea[m_extraIndex].Next;
                        if (valid) return true;
                    } while (m_extraIndex > 0);
                }

                return false;
            }

            public void Reset()
            {
                m_extraIndex = int.MaxValue;
                m_current = default(TValue);
            }
        }

        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(long key, long skip)
        {
            var hash = key;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Key == hash)
            {
                if (skip == 0) return m_firstArray[fi].Item.Value;
                --skip;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                {
                    if (skip == 0) return m_extraArray[ei].Item.Value;
                    --skip;
                }
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Remove the item with the supplied key from the LongDict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(long key)
        {
            TValue value;
            if (!TryRemove(key, out value))
                throw new KeyNotFoundException();
            return value;
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the LongDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(long key)
        {
            TValue value;
            return TryRemove(key, out value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the LongDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(long key, TValue value)
        {
            return TryRemove(key, value);
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the LongDict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<long, TValue> item)
        {
            return TryRemove(item.Key, item.Value);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(long key, out TValue value)
        {
            var hash = key;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Key == hash)
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(LongValue<TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(LongValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(LongValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Key == hash)
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(LongValue<TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(long key, TValue value)
        {
            var hash = key;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(LongValue<TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(LongValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(LongValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Key == hash
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(LongValue<TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// </summary>
        public long[] KeysToArray()
        {
            var array = new long[m_count];
            CopyKeysTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            var array = new TValue[m_count];
            CopyValuesTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// </summary>
        public KeyValuePair<long, TValue>[] ToArray()
        {
            var array = new KeyValuePair<long, TValue>[m_count];
            CopyTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            m_firstArray.Set(default(NextLongValue<TValue>));
            m_extraArray.Set(default(LongValueNext<TValue>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyKeysTo(long[] array, long index)
        {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyValuesTo(TValue[] array, long index)
        {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyTo(KeyValuePair<long, TValue>[] array, long index)
        {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = new KeyValuePair<long, TValue>(
                                m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                while (ei > 0)
                {
                    array[index++] = new KeyValuePair<long, TValue>(
                                    m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copy items into supplied array starting at supplied index.
        /// </summary>
        public void CopyTo(Array array, int index)
        {
            var typedArray = array as KeyValuePair<long, TValue>[];
            if (typedArray != null)
                CopyTo(typedArray, (long)index);
            else
                throw new ArgumentException();
        }

        /// <summary>
        /// Retuns a concurrent wrapper around the LongDict to enable
        /// concurrent modifications.
        /// </summary>
        public ConcurrentLongDict<TValue> AsConcurrent()
        {
            return new ConcurrentLongDict<TValue>(this);
        }

        #endregion

        #region IEnumerable<KeyValuePair<long, TValue>> Members

        IEnumerator<KeyValuePair<long, TValue>> IEnumerable<KeyValuePair<long, TValue>>.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion
        
        #region Enumerator

        public Enumerator GetEnumerator() { return new Enumerator(this); }

        public struct Enumerator : IEnumerator<KeyValuePair<long, TValue>>
        {
            readonly LongDict<TValue> m_dict;
            long m_index;
            long m_extraIndex;
            KeyValuePair<long, TValue> m_current;

            public Enumerator(LongDict<TValue> dict)
            {
                m_dict = dict;
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(KeyValuePair<long, TValue>);
            }

            public readonly KeyValuePair<long, TValue> Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex < 0)
                {
                    var fa = m_dict.m_firstArray;
                    var cap = fa.Length;
                    while (m_index < cap)
                    {
                        var nxt = fa[m_index].Next;
                        if (nxt != 0)
                        {
                            m_current = new KeyValuePair<long, TValue>(fa[m_index].Item.Key, fa[m_index].Item.Value);
                            m_extraIndex = nxt;
                            m_index++;
                            return true;
                        }
                        m_index++;
                    }
                    return false;
                }
                else
                {
                    var ea = m_dict.m_extraArray;
                    m_current = new KeyValuePair<long, TValue>(ea[m_extraIndex].Item.Key, ea[m_extraIndex].Item.Value);
                    m_extraIndex = ea[m_extraIndex].Next;
                    return true;
                }
            }

            public void Reset()
            {
                m_index = 0;
                m_extraIndex = -1;
                m_current = default( KeyValuePair<long, TValue>);
            }
        }

        #endregion
        
        #region Private Helper Methods

        private ulong ComputeIncreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_maxFillFactor);
        }

        private ulong ComputeDecreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_minFillFactor);
        }

        private static long AddSlotsToFreeList(
                LongValueNext<TValue>[] extraArray, long start)
        {
            var length = extraArray.Length - 1;
            for (long i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                LongValue<TValue> item,
                NextLongValue<TValue>[] firstArray,
                ulong capacity,
                ref LongValueNext<TValue>[] extraArray,
                ref long freeIndex,
                ref ulong extraCount)
        {
            var fi = ((ulong)item.Key) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(ulong newCapacity, ulong oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextLongValue<TValue>[newCapacity];
            var extraArray = new LongValueNext<TValue>[
                                    System.Math.Max((long)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            ulong newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                ulong fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((ulong)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (ulong)m_extraArray.Length,
                            (ulong)m_count - newExtraCount, newCapacity,
                            newExtraCount, (ulong)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    ulong oldFirstCount, ulong oldCapacity,
                    ulong oldExtraCount, ulong oldExtraCapacity,
                    ulong newFirstCount, ulong newCapacity,
                    ulong newExtraCount, ulong newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region LongSet

    /// <summary>
    /// A LongSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class LongSet
            : ICountableDictSet, IDictSet<long>,
              IEnumerable, IEnumerable<long>
    {
        private ulong m_capacity;
        private NextLong[] m_firstArray;
        private LongNext[] m_extraArray;
        private ulong m_count;
        private ulong m_increaseThreshold;
        private ulong m_decreaseThreshold;
        private long m_freeIndex;
        private int m_capacityIndex;
        private ulong m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a LongSet that autmatically grows and shrinks as necessary.
        /// </summary>
        public LongSet()
            : this(DictConstant.PrimeSizes[0], (ulong)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a LongSet that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// </summary>
        public LongSet(long initialCapacity)
            : this(System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (ulong)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a LongSet and initialize it to contain the supplied
        /// items.
        /// </summary>
        public LongSet(IEnumerable<long> items)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (ulong)DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        private LongSet(
                ulong firstCapacity, ulong extraCapacity)
        {
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextLong[m_capacity];
            m_extraArray = new LongNext[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the LongSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the LongSet
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the LongSet. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Always returns false. Part of the ICollection implementation.
        /// </summary>
        public bool IsReadOnly { get { return false; } }

        public bool IsSynchronized { get { return false; } }

        public object SyncRoot { get { return this; } }
        public IEnumerable<long> Items { get { return Keys; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// </summary>
        public IEnumerable<long> Keys
        {
            get
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type KeyType { get { return typeof(long); } }

        public IEnumerable<object> Objects
        {
            get
            {
                foreach (object obj in Keys)
                    yield return obj;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the LongSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the LongSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((long)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the LongSet.
        /// </summary>
        public bool Add(long key)
        {
            var hash = key;
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the LongSet.
        /// </summary>
        public bool TryAdd(long key)
        {
            var hash = key;
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item = key;
            return true;
        }

        /// <summary>
        /// Add the supplied keys to the LongSet.
        /// </summary>
        public void AddRange(IEnumerable<long> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the LongSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(long key)
        {
            var hash = key;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the LongSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(long key)
        {
            return TryRemove(key);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(long key)
        {
            var hash = key;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item == hash)
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(long);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(long);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item == hash)
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(long);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item == hash)
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(long);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// </summary>
        public long[] ToArray()
        {
            var array = new long[m_count];
            CopyTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            m_firstArray.Set(default(NextLong));
            m_extraArray.Set(default(LongNext));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyTo(long[] array, long index)
        {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copy items into supplied array starting at supplied index.
        /// </summary>
        public void CopyTo(Array array, int index)
        {
            var typedArray = array as long[];
            if (typedArray != null)
                CopyTo(typedArray, (long)index);
            else
                throw new ArgumentException();
        }

        /// <summary>
        /// Retuns a concurrent wrapper around the LongSet to enable
        /// concurrent modifications.
        /// </summary>
        public ConcurrentLongSet AsConcurrent()
        {
            return new ConcurrentLongSet(this);
        }

        #endregion

        #region IEnumerable<long> Members

        IEnumerator<long> IEnumerable<long>.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion
        
        #region Enumerator

        public Enumerator GetEnumerator() { return new Enumerator(this); }

        public struct Enumerator : IEnumerator<long>
        {
            readonly LongSet m_dict;
            long m_index;
            long m_extraIndex;
            long m_current;

            public Enumerator(LongSet dict)
            {
                m_dict = dict;
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(long);
            }

            public readonly long Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex < 0)
                {
                    var fa = m_dict.m_firstArray;
                    var cap = fa.Length;
                    while (m_index < cap)
                    {
                        var nxt = fa[m_index].Next;
                        if (nxt != 0)
                        {
                            m_current = fa[m_index].Item;
                            m_extraIndex = nxt;
                            m_index++;
                            return true;
                        }
                        m_index++;
                    }
                    return false;
                }
                else
                {
                    var ea = m_dict.m_extraArray;
                    m_current = ea[m_extraIndex].Item;
                    m_extraIndex = ea[m_extraIndex].Next;
                    return true;
                }
            }

            public void Reset()
            {
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(long);
            }
        }

        #endregion
        
        #region Private Helper Methods

        private ulong ComputeIncreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_maxFillFactor);
        }

        private ulong ComputeDecreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_minFillFactor);
        }

        private static long AddSlotsToFreeList(
                LongNext[] extraArray, long start)
        {
            var length = extraArray.Length - 1;
            for (long i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                long item,
                NextLong[] firstArray,
                ulong capacity,
                ref LongNext[] extraArray,
                ref long freeIndex,
                ref ulong extraCount)
        {
            var fi = ((ulong)item) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(ulong newCapacity, ulong oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextLong[newCapacity];
            var extraArray = new LongNext[
                                    System.Math.Max((long)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            ulong newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                ulong fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((ulong)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (ulong)m_extraArray.Length,
                            (ulong)m_count - newExtraCount, newCapacity,
                            newExtraCount, (ulong)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    ulong oldFirstCount, ulong oldCapacity,
                    ulong oldExtraCount, ulong oldExtraCapacity,
                    ulong newFirstCount, ulong newCapacity,
                    ulong newExtraCount, ulong newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region ConcurrentDict<TKey, TValue>

    /// <summary>
    /// A ConcurrentDict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class ConcurrentDict<TKey, TValue>
    {
        private readonly Dict<TKey, TValue> m_dict;

        #region Constructors

        /// <summary>
        /// A ConcurrentDict can only be concstructed by wrapping its non-concurrent
        /// counterpart.
        /// </summary>
        public ConcurrentDict(Dict<TKey, TValue> dict)
        {
            m_dict = dict;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentDict.
        /// </summary>
        public int Count
        {
            get
            {
                return m_dict.Count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentDict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return m_dict.LongCount;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentDict
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_dict.Capacity;
            }
            set
            {
                m_dict.Capacity = value;
            }
        }

        /// <summary>
        /// Return the non-concurrent contained ConcurrentDict.
        /// </summary>
        public Dict<TKey, TValue> NonConcurrent
        {
            get { return m_dict; }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the ConcurrentDict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[TKey key]
        {
            get
            {
                Monitor.Enter(this); try { return m_dict[key]; } finally { Monitor.Exit(this); }
            }
            set
            {
                Monitor.Enter(this); try { m_dict[key] = value; } finally { Monitor.Exit(this); }
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the ConcurrentDict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the ConcurrentDict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((TKey)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentDict.
        /// </summary>
        public void Add(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentDict.
        /// </summary>
        public void Add(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentDict.
        /// </summary>
        public bool TryAdd(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentDict.
        /// </summary>
        public bool TryAdd(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied item to the ConcurrentDict.
        /// </summary>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied items to the ConcurrentDict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the ConcurrentDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, int hash)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key, int hash)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, TValue value)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key, value); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key, value); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentDict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Contains(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the ConcurrentDict and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, Func<TKey, TValue> creator)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetOrCreate(key, creator);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, TValue defaultValue)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key, int hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the ConcurrentDict and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, int hash, Func<TKey, TValue> creator)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetOrCreate(key, hash, creator);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, int hash, TValue defaultValue)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(TKey key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryGetValue(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, int hash, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryGetValue(key, hash, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(TKey key, int skip)
        {
            Monitor.Enter(this); try
            {
                return m_dict.ValueWithKeySkip(key, skip);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key from the ConcurrentDict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetAndRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the ConcurrentDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key)
        {
            TValue value;
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the ConcurrentDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key, int hash)
        {
            TValue value;
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the ConcurrentDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the ConcurrentDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the ConcurrentDict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, int hash, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] KeysToArray()
        {
            return m_dict.KeysToArray();
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            return m_dict.ValuesToArray();
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public KeyValuePair<TKey, TValue>[] ToArray()
        {
            return m_dict.ToArray();
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { m_dict.Clear(); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyKeysTo(TKey[] array, int index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyKeysTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyValuesTo(TValue[] array, int index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyValuesTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int index)
        {
            Monitor.Enter(this); try { m_dict.CopyTo(array, index); } finally { Monitor.Exit(this); }
        }

        #endregion
    }

    #endregion

    #region ConcurrentDictSet<TKey>

    /// <summary>
    /// A ConcurrentDictSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class ConcurrentDictSet<TKey>
    {
        private readonly DictSet<TKey> m_dict;

        #region Constructors

        /// <summary>
        /// A ConcurrentDictSet can only be concstructed by wrapping its non-concurrent
        /// counterpart.
        /// </summary>
        public ConcurrentDictSet(DictSet<TKey> dict)
        {
            m_dict = dict;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentDictSet.
        /// </summary>
        public int Count
        {
            get
            {
                return m_dict.Count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentDictSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return m_dict.LongCount;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentDictSet
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_dict.Capacity;
            }
            set
            {
                m_dict.Capacity = value;
            }
        }

        /// <summary>
        /// Return the non-concurrent contained ConcurrentDictSet.
        /// </summary>
        public DictSet<TKey> NonConcurrent
        {
            get { return m_dict; }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the ConcurrentDictSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the ConcurrentDictSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((TKey)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentDictSet.
        /// </summary>
        public bool Add(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Add(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentDictSet.
        /// </summary>
        public bool Add(TKey key, int hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Add(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentDictSet.
        /// </summary>
        public bool TryAdd(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentDictSet.
        /// </summary>
        public bool TryAdd(TKey key, int hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied keys to the ConcurrentDictSet.
        /// </summary>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the ConcurrentDictSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentDictSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, int hash)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the ConcurrentDictSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the ConcurrentDictSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, int hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, int hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] ToArray()
        {
            return m_dict.ToArray();
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { m_dict.Clear(); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(TKey[] array, int index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        #endregion
    }

    #endregion

    #region ConcurrentIntDict<TValue>

    /// <summary>
    /// A ConcurrentIntDict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class ConcurrentIntDict<TValue>
    {
        private readonly IntDict<TValue> m_dict;

        #region Constructors

        /// <summary>
        /// A ConcurrentIntDict can only be concstructed by wrapping its non-concurrent
        /// counterpart.
        /// </summary>
        public ConcurrentIntDict(IntDict<TValue> dict)
        {
            m_dict = dict;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentIntDict.
        /// </summary>
        public int Count
        {
            get
            {
                return m_dict.Count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentIntDict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return m_dict.LongCount;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentIntDict
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_dict.Capacity;
            }
            set
            {
                m_dict.Capacity = value;
            }
        }

        /// <summary>
        /// Return the non-concurrent contained ConcurrentIntDict.
        /// </summary>
        public IntDict<TValue> NonConcurrent
        {
            get { return m_dict; }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the ConcurrentIntDict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[int key]
        {
            get
            {
                Monitor.Enter(this); try { return m_dict[key]; } finally { Monitor.Exit(this); }
            }
            set
            {
                Monitor.Enter(this); try { m_dict[key] = value; } finally { Monitor.Exit(this); }
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the ConcurrentIntDict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the ConcurrentIntDict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((int)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentIntDict.
        /// </summary>
        public void Add(int key, TValue value)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentIntDict.
        /// </summary>
        public bool TryAdd(int key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied item to the ConcurrentIntDict.
        /// </summary>
        public void Add(KeyValuePair<int, TValue> item)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied items to the ConcurrentIntDict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<int, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the ConcurrentIntDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(int key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentIntDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(int key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentIntDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(int key, TValue value)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key, value); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentIntDict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<int, TValue> item)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Contains(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(int key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the ConcurrentIntDict and returned.
        /// </summary>
        public TValue GetOrCreate(int key, Func<int, TValue> creator)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetOrCreate(key, creator);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(int key, TValue defaultValue)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(int key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(int key, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryGetValue(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(int key, int skip)
        {
            Monitor.Enter(this); try
            {
                return m_dict.ValueWithKeySkip(key, skip);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key from the ConcurrentIntDict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(int key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetAndRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the ConcurrentIntDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(int key)
        {
            TValue value;
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the ConcurrentIntDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(int key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the ConcurrentIntDict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<int, TValue> item)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(int key, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(int key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public int[] KeysToArray()
        {
            return m_dict.KeysToArray();
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            return m_dict.ValuesToArray();
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public KeyValuePair<int, TValue>[] ToArray()
        {
            return m_dict.ToArray();
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { m_dict.Clear(); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyKeysTo(int[] array, int index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyKeysTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyValuesTo(TValue[] array, int index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyValuesTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(KeyValuePair<int, TValue>[] array, int index)
        {
            Monitor.Enter(this); try { m_dict.CopyTo(array, index); } finally { Monitor.Exit(this); }
        }

        #endregion
    }

    #endregion

    #region ConcurrentIntSet

    /// <summary>
    /// A ConcurrentIntSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class ConcurrentIntSet
    {
        private readonly IntSet m_dict;

        #region Constructors

        /// <summary>
        /// A ConcurrentIntSet can only be concstructed by wrapping its non-concurrent
        /// counterpart.
        /// </summary>
        public ConcurrentIntSet(IntSet dict)
        {
            m_dict = dict;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentIntSet.
        /// </summary>
        public int Count
        {
            get
            {
                return m_dict.Count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentIntSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return m_dict.LongCount;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentIntSet
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_dict.Capacity;
            }
            set
            {
                m_dict.Capacity = value;
            }
        }

        /// <summary>
        /// Return the non-concurrent contained ConcurrentIntSet.
        /// </summary>
        public IntSet NonConcurrent
        {
            get { return m_dict; }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the ConcurrentIntSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the ConcurrentIntSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((int)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentIntSet.
        /// </summary>
        public bool Add(int key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Add(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentIntSet.
        /// </summary>
        public bool TryAdd(int key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied keys to the ConcurrentIntSet.
        /// </summary>
        public void AddRange(IEnumerable<int> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the ConcurrentIntSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(int key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the ConcurrentIntSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(int key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(int key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public int[] ToArray()
        {
            return m_dict.ToArray();
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { m_dict.Clear(); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(int[] array, int index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        #endregion
    }

    #endregion

    #region ConcurrentSymbolDict<TValue>

    /// <summary>
    /// A ConcurrentSymbolDict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class ConcurrentSymbolDict<TValue>
    {
        private readonly SymbolDict<TValue> m_dict;

        #region Constructors

        /// <summary>
        /// A ConcurrentSymbolDict can only be concstructed by wrapping its non-concurrent
        /// counterpart.
        /// </summary>
        public ConcurrentSymbolDict(SymbolDict<TValue> dict)
        {
            m_dict = dict;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentSymbolDict.
        /// </summary>
        public int Count
        {
            get
            {
                return m_dict.Count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentSymbolDict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return m_dict.LongCount;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentSymbolDict
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_dict.Capacity;
            }
            set
            {
                m_dict.Capacity = value;
            }
        }

        /// <summary>
        /// Return the non-concurrent contained ConcurrentSymbolDict.
        /// </summary>
        public SymbolDict<TValue> NonConcurrent
        {
            get { return m_dict; }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the ConcurrentSymbolDict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[Symbol key]
        {
            get
            {
                Monitor.Enter(this); try { return m_dict[key]; } finally { Monitor.Exit(this); }
            }
            set
            {
                Monitor.Enter(this); try { m_dict[key] = value; } finally { Monitor.Exit(this); }
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the ConcurrentSymbolDict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the ConcurrentSymbolDict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((Symbol)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentSymbolDict.
        /// </summary>
        public void Add(Symbol key, TValue value)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentSymbolDict.
        /// </summary>
        public bool TryAdd(Symbol key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Adds the supplied item to the ConcurrentSymbolDict. Note that this incurs the
        /// overhead of converting the string key to a symbol.
        /// </summary>
        public void Add(string key, TValue value)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(key.ToSymbol(), value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied item to the ConcurrentSymbolDict. Note that this incurs the
        /// overhead of converting the string key to a symbol.
        /// </summary>
        public void Add(KeyValuePair<string, TValue> item)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(item.Key.ToSymbol(), item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied item to the ConcurrentSymbolDict.
        /// </summary>
        public void Add(KeyValuePair<Symbol, TValue> item)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied items to the ConcurrentSymbolDict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<Symbol, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the ConcurrentSymbolDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(Symbol key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentSymbolDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(Symbol key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentSymbolDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(Symbol key, TValue value)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key, value); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentSymbolDict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<Symbol, TValue> item)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Contains(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(Symbol key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the ConcurrentSymbolDict and returned.
        /// </summary>
        public TValue GetOrCreate(Symbol key, Func<Symbol, TValue> creator)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetOrCreate(key, creator);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(Symbol key, TValue defaultValue)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(Symbol key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(Symbol key, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryGetValue(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(Symbol key, int skip)
        {
            Monitor.Enter(this); try
            {
                return m_dict.ValueWithKeySkip(key, skip);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key from the ConcurrentSymbolDict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(Symbol key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetAndRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the ConcurrentSymbolDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(Symbol key)
        {
            TValue value;
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the ConcurrentSymbolDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(Symbol key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the ConcurrentSymbolDict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<Symbol, TValue> item)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(Symbol key, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(Symbol key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public Symbol[] KeysToArray()
        {
            return m_dict.KeysToArray();
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            return m_dict.ValuesToArray();
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public KeyValuePair<Symbol, TValue>[] ToArray()
        {
            return m_dict.ToArray();
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { m_dict.Clear(); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyKeysTo(Symbol[] array, int index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyKeysTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyValuesTo(TValue[] array, int index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyValuesTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(KeyValuePair<Symbol, TValue>[] array, int index)
        {
            Monitor.Enter(this); try { m_dict.CopyTo(array, index); } finally { Monitor.Exit(this); }
        }

        public void Add<TType>(TypedSymbol<TType> key, TType value)
            where TType : TValue
        {
            this.Add(key.Symbol, value);
        }

        public bool Contains<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            return Contains(key.Symbol);
        }

        public bool ContainsKey<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            return ContainsKey(key.Symbol);
        }

        public TType Get<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            return (TType)this[key.Symbol];
        }

        public TType Get<TType>(TypedSymbol<TType> key, TType defaultValue)
            where TType : TValue
        {
            TType value;
            if (TryGetValue(key, out value)) return value;
            return defaultValue;
        }

        public TType GetOrDefault<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            TType value;
            if (TryGetValue(key, out value)) return value;
            return default(TType);
        }

        public bool Remove<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            return Remove(key.Symbol);
        }

        public void Set<TType>(TypedSymbol<TType> key, TType value)
            where TType : TValue
        {
            this[key.Symbol] = value;
        }

        public bool TryGetValue<TType>(TypedSymbol<TType> key, out TType value)
            where TType : TValue
        {
            TValue val;
            if (TryGetValue(key.Symbol, out val)) { value = (TType)val; return true; }
            value = default(TType);
            return false;
        }

        public TType GetAs<TType>(Symbol key)
            where TType : TValue
        {
            return (TType)this[key];
        }

        public TType GetAs<TType>(Symbol key, TType defaultValue)
            where TType : TValue
        {
            TValue value;
            if (TryGetValue(key, out value)) return (TType)value;
            return defaultValue;
        }

        public TType GetAsOrDefault<TType>(Symbol key)
            where TType : TValue
        {
            TValue value;
            if (TryGetValue(key, out value)) return (TType)value;
            return default(TType);
        }

        #endregion
    }

    #endregion

    #region ConcurrentSymbolSet

    /// <summary>
    /// A ConcurrentSymbolSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class ConcurrentSymbolSet
    {
        private readonly SymbolSet m_dict;

        #region Constructors

        /// <summary>
        /// A ConcurrentSymbolSet can only be concstructed by wrapping its non-concurrent
        /// counterpart.
        /// </summary>
        public ConcurrentSymbolSet(SymbolSet dict)
        {
            m_dict = dict;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentSymbolSet.
        /// </summary>
        public int Count
        {
            get
            {
                return m_dict.Count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentSymbolSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return m_dict.LongCount;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentSymbolSet
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_dict.Capacity;
            }
            set
            {
                m_dict.Capacity = value;
            }
        }

        /// <summary>
        /// Return the non-concurrent contained ConcurrentSymbolSet.
        /// </summary>
        public SymbolSet NonConcurrent
        {
            get { return m_dict; }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the ConcurrentSymbolSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the ConcurrentSymbolSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((Symbol)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentSymbolSet.
        /// </summary>
        public bool Add(Symbol key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Add(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentSymbolSet.
        /// </summary>
        public bool TryAdd(Symbol key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Adds the supplied item to the ConcurrentSymbolSet. Note that this incurs the
        /// overhead of converting the string key to a symbol.
        /// </summary>
        public void Add(string key)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(key.ToSymbol());
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied keys to the ConcurrentSymbolSet.
        /// </summary>
        public void AddRange(IEnumerable<Symbol> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the ConcurrentSymbolSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(Symbol key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the ConcurrentSymbolSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(Symbol key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(Symbol key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public Symbol[] ToArray()
        {
            return m_dict.ToArray();
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { m_dict.Clear(); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(Symbol[] array, int index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        #endregion
    }

    #endregion

    #region ConcurrentBigDict<TKey, TValue>

    /// <summary>
    /// A ConcurrentBigDict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class ConcurrentBigDict<TKey, TValue>
    {
        private readonly BigDict<TKey, TValue> m_dict;

        #region Constructors

        /// <summary>
        /// A ConcurrentBigDict can only be concstructed by wrapping its non-concurrent
        /// counterpart.
        /// </summary>
        public ConcurrentBigDict(BigDict<TKey, TValue> dict)
        {
            m_dict = dict;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentBigDict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return m_dict.LongCount;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentBigDict
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_dict.Capacity;
            }
            set
            {
                m_dict.Capacity = value;
            }
        }

        /// <summary>
        /// Return the non-concurrent contained ConcurrentBigDict.
        /// </summary>
        public BigDict<TKey, TValue> NonConcurrent
        {
            get { return m_dict; }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the ConcurrentBigDict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[TKey key]
        {
            get
            {
                Monitor.Enter(this); try { return m_dict[key]; } finally { Monitor.Exit(this); }
            }
            set
            {
                Monitor.Enter(this); try { m_dict[key] = value; } finally { Monitor.Exit(this); }
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the ConcurrentBigDict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the ConcurrentBigDict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((TKey)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentBigDict.
        /// </summary>
        public void Add(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentBigDict.
        /// </summary>
        public void Add(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentBigDict.
        /// </summary>
        public bool TryAdd(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentBigDict.
        /// </summary>
        public bool TryAdd(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied item to the ConcurrentBigDict.
        /// </summary>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied items to the ConcurrentBigDict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, long hash)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key, long hash)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, TValue value)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key, value); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key, value); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Contains(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the ConcurrentBigDict and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, Func<TKey, TValue> creator)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetOrCreate(key, creator);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, TValue defaultValue)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key, long hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the ConcurrentBigDict and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, long hash, Func<TKey, TValue> creator)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetOrCreate(key, hash, creator);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, long hash, TValue defaultValue)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(TKey key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryGetValue(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, long hash, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryGetValue(key, hash, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(TKey key, long skip)
        {
            Monitor.Enter(this); try
            {
                return m_dict.ValueWithKeySkip(key, skip);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key from the ConcurrentBigDict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetAndRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the ConcurrentBigDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key)
        {
            TValue value;
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the ConcurrentBigDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key, long hash)
        {
            TValue value;
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the ConcurrentBigDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the ConcurrentBigDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the ConcurrentBigDict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, long hash, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] KeysToArray()
        {
            return m_dict.KeysToArray();
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            return m_dict.ValuesToArray();
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public KeyValuePair<TKey, TValue>[] ToArray()
        {
            return m_dict.ToArray();
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { m_dict.Clear(); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyKeysTo(TKey[] array, long index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyKeysTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyValuesTo(TValue[] array, long index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyValuesTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(KeyValuePair<TKey, TValue>[] array, long index)
        {
            Monitor.Enter(this); try { m_dict.CopyTo(array, index); } finally { Monitor.Exit(this); }
        }

        #endregion
    }

    #endregion

    #region ConcurrentBigDictSet<TKey>

    /// <summary>
    /// A ConcurrentBigDictSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class ConcurrentBigDictSet<TKey>
    {
        private readonly BigDictSet<TKey> m_dict;

        #region Constructors

        /// <summary>
        /// A ConcurrentBigDictSet can only be concstructed by wrapping its non-concurrent
        /// counterpart.
        /// </summary>
        public ConcurrentBigDictSet(BigDictSet<TKey> dict)
        {
            m_dict = dict;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentBigDictSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return m_dict.LongCount;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentBigDictSet
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_dict.Capacity;
            }
            set
            {
                m_dict.Capacity = value;
            }
        }

        /// <summary>
        /// Return the non-concurrent contained ConcurrentBigDictSet.
        /// </summary>
        public BigDictSet<TKey> NonConcurrent
        {
            get { return m_dict; }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the ConcurrentBigDictSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the ConcurrentBigDictSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((TKey)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentBigDictSet.
        /// </summary>
        public bool Add(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Add(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentBigDictSet.
        /// </summary>
        public bool Add(TKey key, long hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Add(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentBigDictSet.
        /// </summary>
        public bool TryAdd(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentBigDictSet.
        /// </summary>
        public bool TryAdd(TKey key, long hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied keys to the ConcurrentBigDictSet.
        /// </summary>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDictSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDictSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, long hash)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the ConcurrentBigDictSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the ConcurrentBigDictSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, long hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, long hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] ToArray()
        {
            return m_dict.ToArray();
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { m_dict.Clear(); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(TKey[] array, long index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        #endregion
    }

    #endregion

    #region ConcurrentLongDict<TValue>

    /// <summary>
    /// A ConcurrentLongDict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class ConcurrentLongDict<TValue>
    {
        private readonly LongDict<TValue> m_dict;

        #region Constructors

        /// <summary>
        /// A ConcurrentLongDict can only be concstructed by wrapping its non-concurrent
        /// counterpart.
        /// </summary>
        public ConcurrentLongDict(LongDict<TValue> dict)
        {
            m_dict = dict;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentLongDict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return m_dict.LongCount;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentLongDict
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_dict.Capacity;
            }
            set
            {
                m_dict.Capacity = value;
            }
        }

        /// <summary>
        /// Return the non-concurrent contained ConcurrentLongDict.
        /// </summary>
        public LongDict<TValue> NonConcurrent
        {
            get { return m_dict; }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the ConcurrentLongDict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[long key]
        {
            get
            {
                Monitor.Enter(this); try { return m_dict[key]; } finally { Monitor.Exit(this); }
            }
            set
            {
                Monitor.Enter(this); try { m_dict[key] = value; } finally { Monitor.Exit(this); }
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the ConcurrentLongDict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the ConcurrentLongDict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((long)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentLongDict.
        /// </summary>
        public void Add(long key, TValue value)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentLongDict.
        /// </summary>
        public bool TryAdd(long key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied item to the ConcurrentLongDict.
        /// </summary>
        public void Add(KeyValuePair<long, TValue> item)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied items to the ConcurrentLongDict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<long, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the ConcurrentLongDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(long key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentLongDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(long key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentLongDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(long key, TValue value)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key, value); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentLongDict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<long, TValue> item)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Contains(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(long key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the ConcurrentLongDict and returned.
        /// </summary>
        public TValue GetOrCreate(long key, Func<long, TValue> creator)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetOrCreate(key, creator);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(long key, TValue defaultValue)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(long key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(long key, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryGetValue(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(long key, long skip)
        {
            Monitor.Enter(this); try
            {
                return m_dict.ValueWithKeySkip(key, skip);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key from the ConcurrentLongDict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(long key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetAndRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the ConcurrentLongDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(long key)
        {
            TValue value;
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the ConcurrentLongDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(long key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the ConcurrentLongDict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<long, TValue> item)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(long key, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(long key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public long[] KeysToArray()
        {
            return m_dict.KeysToArray();
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            return m_dict.ValuesToArray();
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public KeyValuePair<long, TValue>[] ToArray()
        {
            return m_dict.ToArray();
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { m_dict.Clear(); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyKeysTo(long[] array, long index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyKeysTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyValuesTo(TValue[] array, long index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyValuesTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(KeyValuePair<long, TValue>[] array, long index)
        {
            Monitor.Enter(this); try { m_dict.CopyTo(array, index); } finally { Monitor.Exit(this); }
        }

        #endregion
    }

    #endregion

    #region ConcurrentLongSet

    /// <summary>
    /// A ConcurrentLongSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class ConcurrentLongSet
    {
        private readonly LongSet m_dict;

        #region Constructors

        /// <summary>
        /// A ConcurrentLongSet can only be concstructed by wrapping its non-concurrent
        /// counterpart.
        /// </summary>
        public ConcurrentLongSet(LongSet dict)
        {
            m_dict = dict;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentLongSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return m_dict.LongCount;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentLongSet
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_dict.Capacity;
            }
            set
            {
                m_dict.Capacity = value;
            }
        }

        /// <summary>
        /// Return the non-concurrent contained ConcurrentLongSet.
        /// </summary>
        public LongSet NonConcurrent
        {
            get { return m_dict; }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the ConcurrentLongSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the ConcurrentLongSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((long)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentLongSet.
        /// </summary>
        public bool Add(long key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Add(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentLongSet.
        /// </summary>
        public bool TryAdd(long key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied keys to the ConcurrentLongSet.
        /// </summary>
        public void AddRange(IEnumerable<long> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the ConcurrentLongSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(long key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the ConcurrentLongSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(long key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(long key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public long[] ToArray()
        {
            return m_dict.ToArray();
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { m_dict.Clear(); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(long[] array, long index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        #endregion
    }

    #endregion

    #region FastConcurrentDict<TKey, TValue>

    /// <summary>
    /// A FastConcurrentDict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class FastConcurrentDict<TKey, TValue>
            : IIntCountable, ICountableDict, IDict<TKey, TValue>,
              IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>
    {
        private long m_version;
        private uint m_capacity;
        private NextHashKeyValue<TKey, TValue>[] m_firstArray;
        private HashKeyValueNext<TKey, TValue>[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private readonly bool m_doNotStackDuplicateKeys;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a FastConcurrentDict that autmatically grows and shrinks as necessary.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentDict(bool stackDuplicateKeys = false)
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a FastConcurrentDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentDict(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, false)
        { }

        /// <summary>
        /// Create a FastConcurrentDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentDict(int initialCapacity, bool stackDuplicateKeys)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a FastConcurrentDict and initialize it to contain the supplied
        /// items.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentDict(IEnumerable<KeyValuePair<TKey, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        private FastConcurrentDict(
                uint firstCapacity, uint extraCapacity,
                bool stackDuplicateKeys = false)
        {
            m_version = 0;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_doNotStackDuplicateKeys = !stackDuplicateKeys;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKeyValue<TKey, TValue>[m_capacity];
            m_extraArray = new HashKeyValueNext<TKey, TValue>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentDict.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentDict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentDict
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the FastConcurrentDict. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<KeyValuePair<TKey, TValue>> Items { get { return KeyValuePairs; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var k = m_firstArray[fi].Item.Key;
                    Monitor.Exit(this); yield return k; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        k = m_extraArray[ei].Item.Key;
                        Monitor.Exit(this); yield return k; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        /// <summary>
        /// Returns all values in the FastConcurrentDict.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var v = m_firstArray[fi].Item.Value;
                    Monitor.Exit(this); yield return v; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        v = m_extraArray[ei].Item.Value;
                        Monitor.Exit(this); yield return v; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type ValueType { get { return typeof(TValue); } }

        /// <summary>
        /// Returns all key value pairs in the FastConcurrentDict.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairs
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var kvp = new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        kvp = new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Returns all key value pairs in the FastConcurrentDict, in such a way,
        /// that the stack order is correct when the pairs are put into a
        /// new FastConcurrentDict in the order they are returned.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairsForStorage
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                var stack = new Stack<int>();
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    while (ei > 0) { stack.Push(ei); ei = m_extraArray[ei].Next; }
                    var kvp = default(KeyValuePair<TKey, TValue>);
                    while (stack.Count > 0)
                    {
                        ei = stack.Pop();
                        kvp = new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                    }
                    kvp = new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<(object, object)> ObjectPairs
        {
            get
            {
                foreach (var kvp in KeyValuePairsForStorage)
                    yield return (kvp.Key, kvp.Value);
            }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the FastConcurrentDict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[TKey key]
        {
            get
            {
                var hash = key.GetHashCode();
                Monitor.Enter(this); try {
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                    throw new KeyNotFoundException();
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                    return m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                        return m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
                } finally { Monitor.Exit(this); }
                throw new KeyNotFoundException();
            }
            set
            {
                var hash = key.GetHashCode();
                Monitor.Enter(this); try { ++m_version;
                if (m_count >= m_increaseThreshold) IncreaseCapacity();
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                {
                    ++m_count;
                    m_firstArray[fi].Next = -1;
                    m_firstArray[fi].Item.Hash = hash;
                    m_firstArray[fi].Item.Key = key;
                    m_firstArray[fi].Item.Value = value;
                    return;
                }
                if (m_doNotStackDuplicateKeys)
                {
                    if (m_firstArray[fi].Item.Hash == hash
                        && key.Equals(m_firstArray[fi].Item.Key))
                    {
                        m_firstArray[fi].Item.Value = value;
                        return;
                    }
                    while (ei > 0)
                    {
                        if (m_extraArray[ei].Item.Hash == hash
                            && key.Equals(m_extraArray[ei].Item.Key))
                        {
                            m_extraArray[ei].Item.Value = value;
                            return;
                        }
                        ei = m_extraArray[ei].Next;
                    }
                    ei = m_firstArray[fi].Next;
                }
                ++m_count;
                ++m_extraCount;
                if (m_freeIndex < 0)
                {
                    var length = m_extraArray.Length;
                    m_extraArray = m_extraArray.Resized(length * 2);
                    m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
                }
                var ni = m_freeIndex;
                m_freeIndex = m_extraArray[ni].Next;

                m_extraArray[ni].Item = m_firstArray[fi].Item;
                m_extraArray[ni].Next = ei;

                m_firstArray[fi].Next = ni;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                } finally { Monitor.Exit(this); }
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the FastConcurrentDict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the FastConcurrentDict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((TKey)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentDict.
        /// </summary>
        public void Add(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentDict.
        /// </summary>
        public void Add(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentDict.
        /// </summary>
        public bool TryAdd(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentDict.
        /// </summary>
        public bool TryAdd(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the supplied item to the FastConcurrentDict.
        /// </summary>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Add the supplied items to the FastConcurrentDict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the FastConcurrentDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, int hash)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key, int hash)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentDict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            return Contains(item.Key, item.Value);
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the FastConcurrentDict and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, Func<TKey, TValue> creator)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                ++m_version;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
            } finally { Monitor.Exit(this); }
        }

        void AddCreated(TKey key, int hash, TValue value)
        {
            ++m_count;
            ++m_version;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, TValue defaultValue)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key, int hash)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the FastConcurrentDict and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, int hash, Func<TKey, TValue> creator)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                ++m_version;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, int hash, TValue defaultValue)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(TKey key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, out TValue value)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, int hash, out TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Return all the value with the given key. This method is only
        /// useful if multiple item with the same key are allowed.
        /// </summary>
        public IEnumerable<TValue> ValuesWithKey(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try { var version = m_version;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) yield break;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                var v = m_firstArray[fi].Item.Value;
                Monitor.Exit(this); yield return v; Monitor.Enter(this);
                if (version != m_version)
                    throw new ConcurrentDataModifiedException();
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    var v = m_extraArray[ei].Item.Value;
                    Monitor.Exit(this); yield return v; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                }
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
        }


        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(TKey key, int skip)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (skip == 0) return m_firstArray[fi].Item.Value;
                --skip;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    if (skip == 0) return m_extraArray[ei].Item.Value;
                    --skip;
                }
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Remove the item with the supplied key from the FastConcurrentDict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(TKey key)
        {
            TValue value;
            if (!TryRemove(key, out value))
                throw new KeyNotFoundException();
            return value;
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the FastConcurrentDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key)
        {
            TValue value;
            return TryRemove(key, out value);
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the FastConcurrentDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key, int hash)
        {
            TValue value;
            return TryRemove(key, hash, out value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the FastConcurrentDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, TValue value)
        {
            return TryRemove(key, value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the FastConcurrentDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, int hash, TValue value)
        {
            return TryRemove(key, hash, value);
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the FastConcurrentDict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return TryRemove(item.Key, item.Value);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, out TValue value)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, int hash, out TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] KeysToArray()
        {
            var array = new TKey[m_count];
            CopyKeysTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            var array = new TValue[m_count];
            CopyValuesTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public KeyValuePair<TKey, TValue>[] ToArray()
        {
            var array = new KeyValuePair<TKey, TValue>[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { ++m_version;
            m_firstArray.Set(default(NextHashKeyValue<TKey, TValue>));
            m_extraArray.Set(default(HashKeyValueNext<TKey, TValue>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyKeysTo(TKey[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyValuesTo(TValue[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = new KeyValuePair<TKey, TValue>(
                                m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                while (ei > 0)
                {
                    array[index++] = new KeyValuePair<TKey, TValue>(
                                    m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        #endregion

        #region IEnumerable<KeyValuePair<TKey, TValue>> Members

        IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator()
        {
            
            return KeyValuePairs.GetEnumerator();
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return KeyValuePairs.GetEnumerator();
            
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                HashKeyValueNext<TKey, TValue>[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKeyValue<TKey, TValue> item,
                NextHashKeyValue<TKey, TValue>[] firstArray,
                uint capacity,
                ref HashKeyValueNext<TKey, TValue>[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKeyValue<TKey, TValue>[newCapacity];
            var extraArray = new HashKeyValueNext<TKey, TValue>[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region FastConcurrentDictSet<TKey>

    /// <summary>
    /// A FastConcurrentDictSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class FastConcurrentDictSet<TKey>
            : IIntCountable, ICountableDictSet, IDictSet<TKey>,
              IEnumerable, IEnumerable<TKey>
    {
        private long m_version;
        private uint m_capacity;
        private NextHashKey<TKey>[] m_firstArray;
        private HashKeyNext<TKey>[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a FastConcurrentDictSet that autmatically grows and shrinks as necessary.
        /// </summary>
        public FastConcurrentDictSet()
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a FastConcurrentDictSet that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// </summary>
        public FastConcurrentDictSet(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a FastConcurrentDictSet and initialize it to contain the supplied
        /// items.
        /// </summary>
        public FastConcurrentDictSet(IEnumerable<TKey> items)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        private FastConcurrentDictSet(
                uint firstCapacity, uint extraCapacity)
        {
            m_version = 0;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKey<TKey>[m_capacity];
            m_extraArray = new HashKeyNext<TKey>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentDictSet.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentDictSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentDictSet
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the FastConcurrentDictSet. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<TKey> Items { get { return Keys; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var k = m_firstArray[fi].Item.Key;
                    Monitor.Exit(this); yield return k; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        k = m_extraArray[ei].Item.Key;
                        Monitor.Exit(this); yield return k; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        public IEnumerable<object> Objects
        {
            get
            {
                foreach (object obj in Keys)
                    yield return obj;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the FastConcurrentDictSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the FastConcurrentDictSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((TKey)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentDictSet.
        /// </summary>
        public bool Add(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentDictSet.
        /// </summary>
        public bool Add(TKey key, int hash)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentDictSet.
        /// </summary>
        public bool TryAdd(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentDictSet.
        /// </summary>
        public bool TryAdd(TKey key, int hash)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the supplied keys to the FastConcurrentDictSet.
        /// </summary>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the FastConcurrentDictSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentDictSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, int hash)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the FastConcurrentDictSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key)
        {
            return TryRemove(key);
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the FastConcurrentDictSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, int hash)
        {
            return TryRemove(key, hash);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKey<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKey<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, int hash)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKey<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKey<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] ToArray()
        {
            var array = new TKey[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { ++m_version;
            m_firstArray.Set(default(NextHashKey<TKey>));
            m_extraArray.Set(default(HashKeyNext<TKey>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(TKey[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        #endregion

        #region IEnumerable<TKey> Members

        IEnumerator<TKey> IEnumerable<TKey>.GetEnumerator()
        {
            
            return Keys.GetEnumerator();
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return Keys.GetEnumerator();
            
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                HashKeyNext<TKey>[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKey<TKey> item,
                NextHashKey<TKey>[] firstArray,
                uint capacity,
                ref HashKeyNext<TKey>[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKey<TKey>[newCapacity];
            var extraArray = new HashKeyNext<TKey>[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region FastConcurrentIntDict<TValue>

    /// <summary>
    /// A FastConcurrentIntDict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class FastConcurrentIntDict<TValue>
            : IIntCountable, ICountableDict, IDict<int, TValue>,
              IEnumerable, IEnumerable<KeyValuePair<int, TValue>>
    {
        private long m_version;
        private uint m_capacity;
        private NextIntValue<TValue>[] m_firstArray;
        private IntValueNext<TValue>[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private readonly bool m_doNotStackDuplicateKeys;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a FastConcurrentIntDict that autmatically grows and shrinks as necessary.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentIntDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentIntDict(bool stackDuplicateKeys = false)
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a FastConcurrentIntDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentIntDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentIntDict(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, false)
        { }

        /// <summary>
        /// Create a FastConcurrentIntDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentIntDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentIntDict(int initialCapacity, bool stackDuplicateKeys)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a FastConcurrentIntDict and initialize it to contain the supplied
        /// items.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentIntDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentIntDict(IEnumerable<KeyValuePair<int, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        private FastConcurrentIntDict(
                uint firstCapacity, uint extraCapacity,
                bool stackDuplicateKeys = false)
        {
            m_version = 0;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_doNotStackDuplicateKeys = !stackDuplicateKeys;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextIntValue<TValue>[m_capacity];
            m_extraArray = new IntValueNext<TValue>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentIntDict.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentIntDict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentIntDict
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the FastConcurrentIntDict. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<KeyValuePair<int, TValue>> Items { get { return KeyValuePairs; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<int> Keys
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var k = m_firstArray[fi].Item.Key;
                    Monitor.Exit(this); yield return k; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        k = m_extraArray[ei].Item.Key;
                        Monitor.Exit(this); yield return k; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type KeyType { get { return typeof(int); } }

        /// <summary>
        /// Returns all values in the FastConcurrentIntDict.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var v = m_firstArray[fi].Item.Value;
                    Monitor.Exit(this); yield return v; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        v = m_extraArray[ei].Item.Value;
                        Monitor.Exit(this); yield return v; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type ValueType { get { return typeof(TValue); } }

        /// <summary>
        /// Returns all key value pairs in the FastConcurrentIntDict.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<KeyValuePair<int, TValue>> KeyValuePairs
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var kvp = new KeyValuePair<int, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        kvp = new KeyValuePair<int, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Returns all key value pairs in the FastConcurrentIntDict, in such a way,
        /// that the stack order is correct when the pairs are put into a
        /// new FastConcurrentIntDict in the order they are returned.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<KeyValuePair<int, TValue>> KeyValuePairsForStorage
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                var stack = new Stack<int>();
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    while (ei > 0) { stack.Push(ei); ei = m_extraArray[ei].Next; }
                    var kvp = default(KeyValuePair<int, TValue>);
                    while (stack.Count > 0)
                    {
                        ei = stack.Pop();
                        kvp = new KeyValuePair<int, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                    }
                    kvp = new KeyValuePair<int, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<(object, object)> ObjectPairs
        {
            get
            {
                foreach (var kvp in KeyValuePairsForStorage)
                    yield return (kvp.Key, kvp.Value);
            }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the FastConcurrentIntDict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[int key]
        {
            get
            {
                var hash = key;
                Monitor.Enter(this); try {
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                    throw new KeyNotFoundException();
                if (m_firstArray[fi].Item.Key == hash)
                    return m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key == hash)
                        return m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
                } finally { Monitor.Exit(this); }
                throw new KeyNotFoundException();
            }
            set
            {
                var hash = key;
                Monitor.Enter(this); try { ++m_version;
                if (m_count >= m_increaseThreshold) IncreaseCapacity();
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                {
                    ++m_count;
                    m_firstArray[fi].Next = -1;
                    m_firstArray[fi].Item.Key = key;
                    m_firstArray[fi].Item.Value = value;
                    return;
                }
                if (m_doNotStackDuplicateKeys)
                {
                    if (m_firstArray[fi].Item.Key == hash)
                    {
                        m_firstArray[fi].Item.Value = value;
                        return;
                    }
                    while (ei > 0)
                    {
                        if (m_extraArray[ei].Item.Key == hash)
                        {
                            m_extraArray[ei].Item.Value = value;
                            return;
                        }
                        ei = m_extraArray[ei].Next;
                    }
                    ei = m_firstArray[fi].Next;
                }
                ++m_count;
                ++m_extraCount;
                if (m_freeIndex < 0)
                {
                    var length = m_extraArray.Length;
                    m_extraArray = m_extraArray.Resized(length * 2);
                    m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
                }
                var ni = m_freeIndex;
                m_freeIndex = m_extraArray[ni].Next;

                m_extraArray[ni].Item = m_firstArray[fi].Item;
                m_extraArray[ni].Next = ei;

                m_firstArray[fi].Next = ni;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                } finally { Monitor.Exit(this); }
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the FastConcurrentIntDict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the FastConcurrentIntDict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((int)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentIntDict.
        /// </summary>
        public void Add(int key, TValue value)
        {
            var hash = key;
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Key == hash)
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key == hash)
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentIntDict.
        /// </summary>
        public bool TryAdd(int key, TValue value)
        {
            var hash = key;
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Key == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the supplied item to the FastConcurrentIntDict.
        /// </summary>
        public void Add(KeyValuePair<int, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Add the supplied items to the FastConcurrentIntDict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<int, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the FastConcurrentIntDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(int key)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentIntDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(int key)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentIntDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(int key, TValue value)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentIntDict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<int, TValue> item)
        {
            return Contains(item.Key, item.Value);
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(int key)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Key == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the FastConcurrentIntDict and returned.
        /// </summary>
        public TValue GetOrCreate(int key, Func<int, TValue> creator)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                ++m_version;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Key == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
            } finally { Monitor.Exit(this); }
        }

        void AddCreated(int key, int hash, TValue value)
        {
            ++m_count;
            ++m_version;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(int key, TValue defaultValue)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Key == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(int key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(int key, out TValue value)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Key == hash)
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Return all the value with the given key. This method is only
        /// useful if multiple item with the same key are allowed.
        /// </summary>
        public IEnumerable<TValue> ValuesWithKey(int key)
        {
            var hash = key;
            Monitor.Enter(this); try { var version = m_version;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) yield break;
            if (m_firstArray[fi].Item.Key == hash)
            {
                var v = m_firstArray[fi].Item.Value;
                Monitor.Exit(this); yield return v; Monitor.Enter(this);
                if (version != m_version)
                    throw new ConcurrentDataModifiedException();
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                {
                    var v = m_extraArray[ei].Item.Value;
                    Monitor.Exit(this); yield return v; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                }
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
        }


        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(int key, int skip)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Key == hash)
            {
                if (skip == 0) return m_firstArray[fi].Item.Value;
                --skip;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                {
                    if (skip == 0) return m_extraArray[ei].Item.Value;
                    --skip;
                }
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Remove the item with the supplied key from the FastConcurrentIntDict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(int key)
        {
            TValue value;
            if (!TryRemove(key, out value))
                throw new KeyNotFoundException();
            return value;
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the FastConcurrentIntDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(int key)
        {
            TValue value;
            return TryRemove(key, out value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the FastConcurrentIntDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(int key, TValue value)
        {
            return TryRemove(key, value);
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the FastConcurrentIntDict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<int, TValue> item)
        {
            return TryRemove(item.Key, item.Value);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(int key, out TValue value)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Key == hash)
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(IntValue<TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(IntValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(IntValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Key == hash)
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(IntValue<TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(int key, TValue value)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(IntValue<TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(IntValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(IntValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Key == hash
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(IntValue<TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public int[] KeysToArray()
        {
            var array = new int[m_count];
            CopyKeysTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            var array = new TValue[m_count];
            CopyValuesTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public KeyValuePair<int, TValue>[] ToArray()
        {
            var array = new KeyValuePair<int, TValue>[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { ++m_version;
            m_firstArray.Set(default(NextIntValue<TValue>));
            m_extraArray.Set(default(IntValueNext<TValue>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyKeysTo(int[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyValuesTo(TValue[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(KeyValuePair<int, TValue>[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = new KeyValuePair<int, TValue>(
                                m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                while (ei > 0)
                {
                    array[index++] = new KeyValuePair<int, TValue>(
                                    m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        #endregion

        #region IEnumerable<KeyValuePair<int, TValue>> Members

        IEnumerator<KeyValuePair<int, TValue>> IEnumerable<KeyValuePair<int, TValue>>.GetEnumerator()
        {
            
            return KeyValuePairs.GetEnumerator();
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return KeyValuePairs.GetEnumerator();
            
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                IntValueNext<TValue>[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                IntValue<TValue> item,
                NextIntValue<TValue>[] firstArray,
                uint capacity,
                ref IntValueNext<TValue>[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item.Key) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextIntValue<TValue>[newCapacity];
            var extraArray = new IntValueNext<TValue>[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region FastConcurrentIntSet

    /// <summary>
    /// A FastConcurrentIntSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class FastConcurrentIntSet
            : IIntCountable, ICountableDictSet, IDictSet<int>,
              IEnumerable, IEnumerable<int>
    {
        private long m_version;
        private uint m_capacity;
        private NextInt[] m_firstArray;
        private IntNext[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a FastConcurrentIntSet that autmatically grows and shrinks as necessary.
        /// </summary>
        public FastConcurrentIntSet()
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a FastConcurrentIntSet that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// </summary>
        public FastConcurrentIntSet(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a FastConcurrentIntSet and initialize it to contain the supplied
        /// items.
        /// </summary>
        public FastConcurrentIntSet(IEnumerable<int> items)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        private FastConcurrentIntSet(
                uint firstCapacity, uint extraCapacity)
        {
            m_version = 0;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextInt[m_capacity];
            m_extraArray = new IntNext[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentIntSet.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentIntSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentIntSet
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the FastConcurrentIntSet. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<int> Items { get { return Keys; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<int> Keys
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var k = m_firstArray[fi].Item;
                    Monitor.Exit(this); yield return k; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        k = m_extraArray[ei].Item;
                        Monitor.Exit(this); yield return k; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type KeyType { get { return typeof(int); } }

        public IEnumerable<object> Objects
        {
            get
            {
                foreach (object obj in Keys)
                    yield return obj;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the FastConcurrentIntSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the FastConcurrentIntSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((int)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentIntSet.
        /// </summary>
        public bool Add(int key)
        {
            var hash = key;
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentIntSet.
        /// </summary>
        public bool TryAdd(int key)
        {
            var hash = key;
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the supplied keys to the FastConcurrentIntSet.
        /// </summary>
        public void AddRange(IEnumerable<int> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the FastConcurrentIntSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(int key)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the FastConcurrentIntSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(int key)
        {
            return TryRemove(key);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(int key)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item == hash)
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(int);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(int);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item == hash)
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(int);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item == hash)
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(int);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public int[] ToArray()
        {
            var array = new int[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { ++m_version;
            m_firstArray.Set(default(NextInt));
            m_extraArray.Set(default(IntNext));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(int[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        #endregion

        #region IEnumerable<int> Members

        IEnumerator<int> IEnumerable<int>.GetEnumerator()
        {
            
            return Keys.GetEnumerator();
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return Keys.GetEnumerator();
            
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                IntNext[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                int item,
                NextInt[] firstArray,
                uint capacity,
                ref IntNext[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextInt[newCapacity];
            var extraArray = new IntNext[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region FastConcurrentSymbolDict<TValue>

    /// <summary>
    /// A FastConcurrentSymbolDict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class FastConcurrentSymbolDict<TValue>
            : IIntCountable, ICountableDict, IDict<Symbol, TValue>,
              IEnumerable, IEnumerable<KeyValuePair<Symbol, TValue>>
    {
        private long m_version;
        private uint m_capacity;
        private NextSymbolValue<TValue>[] m_firstArray;
        private SymbolValueNext<TValue>[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private readonly bool m_doNotStackDuplicateKeys;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a FastConcurrentSymbolDict that autmatically grows and shrinks as necessary.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentSymbolDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentSymbolDict(bool stackDuplicateKeys = false)
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a FastConcurrentSymbolDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentSymbolDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentSymbolDict(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, false)
        { }

        /// <summary>
        /// Create a FastConcurrentSymbolDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentSymbolDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentSymbolDict(int initialCapacity, bool stackDuplicateKeys)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a FastConcurrentSymbolDict and initialize it to contain the supplied
        /// items.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentSymbolDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentSymbolDict(IEnumerable<KeyValuePair<Symbol, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Create a FastConcurrentSymbolDict and initialize to contain the supplied items.
        /// Note hat this incurs the overhead of converting all string keys
        /// to symbols.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentSymbolDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentSymbolDict(IEnumerable<KeyValuePair<string, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        private FastConcurrentSymbolDict(
                uint firstCapacity, uint extraCapacity,
                bool stackDuplicateKeys = false)
        {
            m_version = 0;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_doNotStackDuplicateKeys = !stackDuplicateKeys;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextSymbolValue<TValue>[m_capacity];
            m_extraArray = new SymbolValueNext<TValue>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentSymbolDict.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentSymbolDict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentSymbolDict
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the FastConcurrentSymbolDict. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<KeyValuePair<Symbol, TValue>> Items { get { return KeyValuePairs; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<Symbol> Keys
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var k = m_firstArray[fi].Item.Key;
                    Monitor.Exit(this); yield return k; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        k = m_extraArray[ei].Item.Key;
                        Monitor.Exit(this); yield return k; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type KeyType { get { return typeof(Symbol); } }

        /// <summary>
        /// Returns all values in the FastConcurrentSymbolDict.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var v = m_firstArray[fi].Item.Value;
                    Monitor.Exit(this); yield return v; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        v = m_extraArray[ei].Item.Value;
                        Monitor.Exit(this); yield return v; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type ValueType { get { return typeof(TValue); } }

        /// <summary>
        /// Returns all key value pairs in the FastConcurrentSymbolDict.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<KeyValuePair<Symbol, TValue>> KeyValuePairs
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var kvp = new KeyValuePair<Symbol, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        kvp = new KeyValuePair<Symbol, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Returns all key value pairs in the FastConcurrentSymbolDict, in such a way,
        /// that the stack order is correct when the pairs are put into a
        /// new FastConcurrentSymbolDict in the order they are returned.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<KeyValuePair<Symbol, TValue>> KeyValuePairsForStorage
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                var stack = new Stack<int>();
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    while (ei > 0) { stack.Push(ei); ei = m_extraArray[ei].Next; }
                    var kvp = default(KeyValuePair<Symbol, TValue>);
                    while (stack.Count > 0)
                    {
                        ei = stack.Pop();
                        kvp = new KeyValuePair<Symbol, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                    }
                    kvp = new KeyValuePair<Symbol, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<(object, object)> ObjectPairs
        {
            get
            {
                foreach (var kvp in KeyValuePairsForStorage)
                    yield return (kvp.Key, kvp.Value);
            }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the FastConcurrentSymbolDict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[Symbol key]
        {
            get
            {
                var hash = key.Id;
                Monitor.Enter(this); try {
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                    throw new KeyNotFoundException();
                if (m_firstArray[fi].Item.Key.Id == hash)
                    return m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key.Id == hash)
                        return m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
                } finally { Monitor.Exit(this); }
                throw new KeyNotFoundException();
            }
            set
            {
                var hash = key.Id;
                Monitor.Enter(this); try { ++m_version;
                if (m_count >= m_increaseThreshold) IncreaseCapacity();
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                {
                    ++m_count;
                    m_firstArray[fi].Next = -1;
                    m_firstArray[fi].Item.Key = key;
                    m_firstArray[fi].Item.Value = value;
                    return;
                }
                if (m_doNotStackDuplicateKeys)
                {
                    if (m_firstArray[fi].Item.Key.Id == hash)
                    {
                        m_firstArray[fi].Item.Value = value;
                        return;
                    }
                    while (ei > 0)
                    {
                        if (m_extraArray[ei].Item.Key.Id == hash)
                        {
                            m_extraArray[ei].Item.Value = value;
                            return;
                        }
                        ei = m_extraArray[ei].Next;
                    }
                    ei = m_firstArray[fi].Next;
                }
                ++m_count;
                ++m_extraCount;
                if (m_freeIndex < 0)
                {
                    var length = m_extraArray.Length;
                    m_extraArray = m_extraArray.Resized(length * 2);
                    m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
                }
                var ni = m_freeIndex;
                m_freeIndex = m_extraArray[ni].Next;

                m_extraArray[ni].Item = m_firstArray[fi].Item;
                m_extraArray[ni].Next = ei;

                m_firstArray[fi].Next = ni;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                } finally { Monitor.Exit(this); }
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the FastConcurrentSymbolDict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the FastConcurrentSymbolDict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((Symbol)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentSymbolDict.
        /// </summary>
        public void Add(Symbol key, TValue value)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Key.Id == hash)
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key.Id == hash)
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentSymbolDict.
        /// </summary>
        public bool TryAdd(Symbol key, TValue value)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Key.Id == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key.Id == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Adds the supplied item to the FastConcurrentSymbolDict. Note that this incurs the
        /// overhead of converting the string key to a symbol.
        /// </summary>
        public void Add(string key, TValue value)
        {
            Add(key.ToSymbol(), value);
        }

        /// <summary>
        /// Add the supplied item to the FastConcurrentSymbolDict. Note that this incurs the
        /// overhead of converting the string key to a symbol.
        /// </summary>
        public void Add(KeyValuePair<string, TValue> item)
        {
            Add(item.Key.ToSymbol(), item.Value);
        }

        /// <summary>
        /// Add the supplied item to the FastConcurrentSymbolDict.
        /// </summary>
        public void Add(KeyValuePair<Symbol, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Add the supplied items to the FastConcurrentSymbolDict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<Symbol, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the FastConcurrentSymbolDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(Symbol key)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key.Id == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentSymbolDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(Symbol key)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key.Id == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentSymbolDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(Symbol key, TValue value)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key.Id == hash
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentSymbolDict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<Symbol, TValue> item)
        {
            return Contains(item.Key, item.Value);
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(Symbol key)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Key.Id == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the FastConcurrentSymbolDict and returned.
        /// </summary>
        public TValue GetOrCreate(Symbol key, Func<Symbol, TValue> creator)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                ++m_version;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Key.Id == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
            } finally { Monitor.Exit(this); }
        }

        void AddCreated(Symbol key, int hash, TValue value)
        {
            ++m_count;
            ++m_version;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(Symbol key, TValue defaultValue)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Key.Id == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(Symbol key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(Symbol key, out TValue value)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Key.Id == hash)
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Return all the value with the given key. This method is only
        /// useful if multiple item with the same key are allowed.
        /// </summary>
        public IEnumerable<TValue> ValuesWithKey(Symbol key)
        {
            var hash = key.Id;
            Monitor.Enter(this); try { var version = m_version;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) yield break;
            if (m_firstArray[fi].Item.Key.Id == hash)
            {
                var v = m_firstArray[fi].Item.Value;
                Monitor.Exit(this); yield return v; Monitor.Enter(this);
                if (version != m_version)
                    throw new ConcurrentDataModifiedException();
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                {
                    var v = m_extraArray[ei].Item.Value;
                    Monitor.Exit(this); yield return v; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                }
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
        }


        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(Symbol key, int skip)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Key.Id == hash)
            {
                if (skip == 0) return m_firstArray[fi].Item.Value;
                --skip;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                {
                    if (skip == 0) return m_extraArray[ei].Item.Value;
                    --skip;
                }
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Remove the item with the supplied key from the FastConcurrentSymbolDict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(Symbol key)
        {
            TValue value;
            if (!TryRemove(key, out value))
                throw new KeyNotFoundException();
            return value;
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the FastConcurrentSymbolDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(Symbol key)
        {
            TValue value;
            return TryRemove(key, out value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the FastConcurrentSymbolDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(Symbol key, TValue value)
        {
            return TryRemove(key, value);
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the FastConcurrentSymbolDict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<Symbol, TValue> item)
        {
            return TryRemove(item.Key, item.Value);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(Symbol key, out TValue value)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Key.Id == hash)
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(SymbolValue<TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(SymbolValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash)
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(SymbolValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Key.Id == hash)
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(SymbolValue<TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(Symbol key, TValue value)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key.Id == hash
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(SymbolValue<TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(SymbolValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Key.Id == hash
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(SymbolValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Key.Id == hash
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(SymbolValue<TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public Symbol[] KeysToArray()
        {
            var array = new Symbol[m_count];
            CopyKeysTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            var array = new TValue[m_count];
            CopyValuesTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public KeyValuePair<Symbol, TValue>[] ToArray()
        {
            var array = new KeyValuePair<Symbol, TValue>[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { ++m_version;
            m_firstArray.Set(default(NextSymbolValue<TValue>));
            m_extraArray.Set(default(SymbolValueNext<TValue>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyKeysTo(Symbol[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyValuesTo(TValue[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(KeyValuePair<Symbol, TValue>[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = new KeyValuePair<Symbol, TValue>(
                                m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                while (ei > 0)
                {
                    array[index++] = new KeyValuePair<Symbol, TValue>(
                                    m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        public void Add<TType>(TypedSymbol<TType> key, TType value)
            where TType : TValue
        {
            this.Add(key.Symbol, value);
        }

        public bool Contains<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            return Contains(key.Symbol);
        }

        public bool ContainsKey<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            return ContainsKey(key.Symbol);
        }

        public TType Get<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            return (TType)this[key.Symbol];
        }

        public TType Get<TType>(TypedSymbol<TType> key, TType defaultValue)
            where TType : TValue
        {
            TType value;
            if (TryGetValue(key, out value)) return value;
            return defaultValue;
        }

        public TType GetOrDefault<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            TType value;
            if (TryGetValue(key, out value)) return value;
            return default(TType);
        }

        public bool Remove<TType>(TypedSymbol<TType> key)
            where TType : TValue
        {
            return Remove(key.Symbol);
        }

        public void Set<TType>(TypedSymbol<TType> key, TType value)
            where TType : TValue
        {
            this[key.Symbol] = value;
        }

        public bool TryGetValue<TType>(TypedSymbol<TType> key, out TType value)
            where TType : TValue
        {
            TValue val;
            if (TryGetValue(key.Symbol, out val)) { value = (TType)val; return true; }
            value = default(TType);
            return false;
        }

        public TType GetAs<TType>(Symbol key)
            where TType : TValue
        {
            return (TType)this[key];
        }

        public TType GetAs<TType>(Symbol key, TType defaultValue)
            where TType : TValue
        {
            TValue value;
            if (TryGetValue(key, out value)) return (TType)value;
            return defaultValue;
        }

        public TType GetAsOrDefault<TType>(Symbol key)
            where TType : TValue
        {
            TValue value;
            if (TryGetValue(key, out value)) return (TType)value;
            return default(TType);
        }

        #endregion

        #region IEnumerable<KeyValuePair<Symbol, TValue>> Members

        IEnumerator<KeyValuePair<Symbol, TValue>> IEnumerable<KeyValuePair<Symbol, TValue>>.GetEnumerator()
        {
            
            return KeyValuePairs.GetEnumerator();
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return KeyValuePairs.GetEnumerator();
            
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                SymbolValueNext<TValue>[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                SymbolValue<TValue> item,
                NextSymbolValue<TValue>[] firstArray,
                uint capacity,
                ref SymbolValueNext<TValue>[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item.Key.Id) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextSymbolValue<TValue>[newCapacity];
            var extraArray = new SymbolValueNext<TValue>[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region FastConcurrentSymbolSet

    /// <summary>
    /// A FastConcurrentSymbolSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class FastConcurrentSymbolSet
            : IIntCountable, ICountableDictSet, IDictSet<Symbol>,
              IEnumerable, IEnumerable<Symbol>
    {
        private long m_version;
        private uint m_capacity;
        private NextSymbol[] m_firstArray;
        private SymbolNext[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a FastConcurrentSymbolSet that autmatically grows and shrinks as necessary.
        /// </summary>
        public FastConcurrentSymbolSet()
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a FastConcurrentSymbolSet that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// </summary>
        public FastConcurrentSymbolSet(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a FastConcurrentSymbolSet and initialize it to contain the supplied
        /// items.
        /// </summary>
        public FastConcurrentSymbolSet(IEnumerable<Symbol> items)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Create a FastConcurrentSymbolSet and initialize to contain the supplied items.
        /// Note hat this incurs the overhead of converting all string keys
        /// to symbols.
        /// </summary>
        public FastConcurrentSymbolSet(IEnumerable<string> items)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        private FastConcurrentSymbolSet(
                uint firstCapacity, uint extraCapacity)
        {
            m_version = 0;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextSymbol[m_capacity];
            m_extraArray = new SymbolNext[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentSymbolSet.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentSymbolSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentSymbolSet
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the FastConcurrentSymbolSet. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<Symbol> Items { get { return Keys; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<Symbol> Keys
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var k = m_firstArray[fi].Item;
                    Monitor.Exit(this); yield return k; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        k = m_extraArray[ei].Item;
                        Monitor.Exit(this); yield return k; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type KeyType { get { return typeof(Symbol); } }

        public IEnumerable<object> Objects
        {
            get
            {
                foreach (object obj in Keys)
                    yield return obj;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the FastConcurrentSymbolSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the FastConcurrentSymbolSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((Symbol)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentSymbolSet.
        /// </summary>
        public bool Add(Symbol key)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Id == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Id == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentSymbolSet.
        /// </summary>
        public bool TryAdd(Symbol key)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Id == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Id == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Adds the supplied item to the FastConcurrentSymbolSet. Note that this incurs the
        /// overhead of converting the string key to a symbol.
        /// </summary>
        public void Add(string key)
        {
            Add(key.ToSymbol());
        }

        /// <summary>
        /// Add the supplied keys to the FastConcurrentSymbolSet.
        /// </summary>
        public void AddRange(IEnumerable<Symbol> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the FastConcurrentSymbolSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(Symbol key)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Id == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Id == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the FastConcurrentSymbolSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(Symbol key)
        {
            return TryRemove(key);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(Symbol key)
        {
            var hash = key.Id;
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Id == hash)
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(Symbol);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(Symbol);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Id == hash)
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(Symbol);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Id == hash)
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(Symbol);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public Symbol[] ToArray()
        {
            var array = new Symbol[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { ++m_version;
            m_firstArray.Set(default(NextSymbol));
            m_extraArray.Set(default(SymbolNext));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(Symbol[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        #endregion

        #region IEnumerable<Symbol> Members

        IEnumerator<Symbol> IEnumerable<Symbol>.GetEnumerator()
        {
            
            return Keys.GetEnumerator();
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return Keys.GetEnumerator();
            
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                SymbolNext[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                Symbol item,
                NextSymbol[] firstArray,
                uint capacity,
                ref SymbolNext[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item.Id) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextSymbol[newCapacity];
            var extraArray = new SymbolNext[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region FastConcurrentBigDict<TKey, TValue>

    /// <summary>
    /// A FastConcurrentBigDict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class FastConcurrentBigDict<TKey, TValue>
            : ICountableDict, IDict<TKey, TValue>,
              IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>
    {
        private long m_version;
        private readonly Func<TKey, long> m_hfun;
        private ulong m_capacity;
        private NextHashKeyValueLong<TKey, TValue>[] m_firstArray;
        private HashKeyValueNextLong<TKey, TValue>[] m_extraArray;
        private ulong m_count;
        private ulong m_increaseThreshold;
        private ulong m_decreaseThreshold;
        private readonly bool m_doNotStackDuplicateKeys;
        private long m_freeIndex;
        private int m_capacityIndex;
        private ulong m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a FastConcurrentBigDict that autmatically grows and shrinks as necessary.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentBigDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentBigDict(Func<TKey, long> hfun, bool stackDuplicateKeys = false)
            : this(hfun, DictConstant.PrimeSizesLong[0], (ulong)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a FastConcurrentBigDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentBigDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentBigDict(Func<TKey, long> hfun, long initialCapacity)
            : this(hfun, System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizesLong[0]),
                   (ulong)DictConstant.MinExtraCapacity, false)
        { }

        /// <summary>
        /// Create a FastConcurrentBigDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentBigDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentBigDict(Func<TKey, long> hfun, long initialCapacity, bool stackDuplicateKeys)
            : this(hfun, System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizesLong[0]),
                   (ulong)DictConstant.MinExtraCapacity, stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a FastConcurrentBigDict and initialize it to contain the supplied
        /// items.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentBigDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentBigDict(Func<TKey, long> hfun, IEnumerable<KeyValuePair<TKey, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(hfun, Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizesLong[0]), (ulong)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        private FastConcurrentBigDict(
                Func<TKey, long> hfun, ulong firstCapacity, ulong extraCapacity,
                bool stackDuplicateKeys = false)
        {
            m_version = 0;
            m_hfun = hfun;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_doNotStackDuplicateKeys = !stackDuplicateKeys;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizesLong[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizesLong[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKeyValueLong<TKey, TValue>[m_capacity];
            m_extraArray = new HashKeyValueNextLong<TKey, TValue>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentBigDict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentBigDict
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the FastConcurrentBigDict. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<KeyValuePair<TKey, TValue>> Items { get { return KeyValuePairs; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var k = m_firstArray[fi].Item.Key;
                    Monitor.Exit(this); yield return k; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        k = m_extraArray[ei].Item.Key;
                        Monitor.Exit(this); yield return k; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        /// <summary>
        /// Returns all values in the FastConcurrentBigDict.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var v = m_firstArray[fi].Item.Value;
                    Monitor.Exit(this); yield return v; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        v = m_extraArray[ei].Item.Value;
                        Monitor.Exit(this); yield return v; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type ValueType { get { return typeof(TValue); } }

        /// <summary>
        /// Returns all key value pairs in the FastConcurrentBigDict.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairs
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var kvp = new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        kvp = new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Returns all key value pairs in the FastConcurrentBigDict, in such a way,
        /// that the stack order is correct when the pairs are put into a
        /// new FastConcurrentBigDict in the order they are returned.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairsForStorage
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                var stack = new Stack<long>();
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    while (ei > 0) { stack.Push(ei); ei = m_extraArray[ei].Next; }
                    var kvp = default(KeyValuePair<TKey, TValue>);
                    while (stack.Count > 0)
                    {
                        ei = stack.Pop();
                        kvp = new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                    }
                    kvp = new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<(object, object)> ObjectPairs
        {
            get
            {
                foreach (var kvp in KeyValuePairsForStorage)
                    yield return (kvp.Key, kvp.Value);
            }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the FastConcurrentBigDict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[TKey key]
        {
            get
            {
                var hash = m_hfun(key);
                Monitor.Enter(this); try {
                var fi = ((ulong)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                    throw new KeyNotFoundException();
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                    return m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                        return m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
                } finally { Monitor.Exit(this); }
                throw new KeyNotFoundException();
            }
            set
            {
                var hash = m_hfun(key);
                Monitor.Enter(this); try { ++m_version;
                if (m_count >= m_increaseThreshold) IncreaseCapacity();
                var fi = ((ulong)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                {
                    ++m_count;
                    m_firstArray[fi].Next = -1;
                    m_firstArray[fi].Item.Hash = hash;
                    m_firstArray[fi].Item.Key = key;
                    m_firstArray[fi].Item.Value = value;
                    return;
                }
                if (m_doNotStackDuplicateKeys)
                {
                    if (m_firstArray[fi].Item.Hash == hash
                        && key.Equals(m_firstArray[fi].Item.Key))
                    {
                        m_firstArray[fi].Item.Value = value;
                        return;
                    }
                    while (ei > 0)
                    {
                        if (m_extraArray[ei].Item.Hash == hash
                            && key.Equals(m_extraArray[ei].Item.Key))
                        {
                            m_extraArray[ei].Item.Value = value;
                            return;
                        }
                        ei = m_extraArray[ei].Next;
                    }
                    ei = m_firstArray[fi].Next;
                }
                ++m_count;
                ++m_extraCount;
                if (m_freeIndex < 0)
                {
                    var length = m_extraArray.LongLength;
                    m_extraArray = m_extraArray.Resized(length * 2);
                    m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
                }
                var ni = m_freeIndex;
                m_freeIndex = m_extraArray[ni].Next;

                m_extraArray[ni].Item = m_firstArray[fi].Item;
                m_extraArray[ni].Next = ei;

                m_firstArray[fi].Next = ni;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                } finally { Monitor.Exit(this); }
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the FastConcurrentBigDict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the FastConcurrentBigDict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((TKey)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentBigDict.
        /// </summary>
        public void Add(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentBigDict.
        /// </summary>
        public void Add(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentBigDict.
        /// </summary>
        public bool TryAdd(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentBigDict.
        /// </summary>
        public bool TryAdd(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the supplied item to the FastConcurrentBigDict.
        /// </summary>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Add the supplied items to the FastConcurrentBigDict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, long hash)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key, long hash)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            return Contains(item.Key, item.Value);
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the FastConcurrentBigDict and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, Func<TKey, TValue> creator)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                ++m_version;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
            } finally { Monitor.Exit(this); }
        }

        void AddCreated(TKey key, long hash, TValue value)
        {
            ++m_count;
            ++m_version;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, TValue defaultValue)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key, long hash)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the FastConcurrentBigDict and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, long hash, Func<TKey, TValue> creator)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                ++m_version;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, long hash, TValue defaultValue)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(TKey key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, out TValue value)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, long hash, out TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Return all the value with the given key. This method is only
        /// useful if multiple item with the same key are allowed.
        /// </summary>
        public IEnumerable<TValue> ValuesWithKey(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try { var version = m_version;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) yield break;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                var v = m_firstArray[fi].Item.Value;
                Monitor.Exit(this); yield return v; Monitor.Enter(this);
                if (version != m_version)
                    throw new ConcurrentDataModifiedException();
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    var v = m_extraArray[ei].Item.Value;
                    Monitor.Exit(this); yield return v; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                }
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
        }


        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(TKey key, long skip)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (skip == 0) return m_firstArray[fi].Item.Value;
                --skip;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    if (skip == 0) return m_extraArray[ei].Item.Value;
                    --skip;
                }
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Remove the item with the supplied key from the FastConcurrentBigDict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(TKey key)
        {
            TValue value;
            if (!TryRemove(key, out value))
                throw new KeyNotFoundException();
            return value;
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the FastConcurrentBigDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key)
        {
            TValue value;
            return TryRemove(key, out value);
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the FastConcurrentBigDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key, long hash)
        {
            TValue value;
            return TryRemove(key, hash, out value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the FastConcurrentBigDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, TValue value)
        {
            return TryRemove(key, value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the FastConcurrentBigDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, long hash, TValue value)
        {
            return TryRemove(key, hash, value);
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the FastConcurrentBigDict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return TryRemove(item.Key, item.Value);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, out TValue value)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, long hash, out TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] KeysToArray()
        {
            var array = new TKey[m_count];
            CopyKeysTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            var array = new TValue[m_count];
            CopyValuesTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public KeyValuePair<TKey, TValue>[] ToArray()
        {
            var array = new KeyValuePair<TKey, TValue>[m_count];
            CopyTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { ++m_version;
            m_firstArray.Set(default(NextHashKeyValueLong<TKey, TValue>));
            m_extraArray.Set(default(HashKeyValueNextLong<TKey, TValue>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyKeysTo(TKey[] array, long index)
        {
            Monitor.Enter(this); try {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyValuesTo(TValue[] array, long index)
        {
            Monitor.Enter(this); try {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(KeyValuePair<TKey, TValue>[] array, long index)
        {
            Monitor.Enter(this); try {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = new KeyValuePair<TKey, TValue>(
                                m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                while (ei > 0)
                {
                    array[index++] = new KeyValuePair<TKey, TValue>(
                                    m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        #endregion

        #region IEnumerable<KeyValuePair<TKey, TValue>> Members

        IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator()
        {
            
            return KeyValuePairs.GetEnumerator();
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return KeyValuePairs.GetEnumerator();
            
        }

        #endregion
        
        #region Private Helper Methods

        private ulong ComputeIncreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_maxFillFactor);
        }

        private ulong ComputeDecreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_minFillFactor);
        }

        private static long AddSlotsToFreeList(
                HashKeyValueNextLong<TKey, TValue>[] extraArray, long start)
        {
            var length = extraArray.Length - 1;
            for (long i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizesLong[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizesLong[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKeyValueLong<TKey, TValue> item,
                NextHashKeyValueLong<TKey, TValue>[] firstArray,
                ulong capacity,
                ref HashKeyValueNextLong<TKey, TValue>[] extraArray,
                ref long freeIndex,
                ref ulong extraCount)
        {
            var fi = ((ulong)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(ulong newCapacity, ulong oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKeyValueLong<TKey, TValue>[newCapacity];
            var extraArray = new HashKeyValueNextLong<TKey, TValue>[
                                    System.Math.Max((long)DictConstant.MinExtraCapacity,
                                                    m_extraArray.LongLength / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            ulong newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                ulong fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((ulong)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (ulong)m_extraArray.Length,
                            (ulong)m_count - newExtraCount, newCapacity,
                            newExtraCount, (ulong)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    ulong oldFirstCount, ulong oldCapacity,
                    ulong oldExtraCount, ulong oldExtraCapacity,
                    ulong newFirstCount, ulong newCapacity,
                    ulong newExtraCount, ulong newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region FastConcurrentBigDictSet<TKey>

    /// <summary>
    /// A FastConcurrentBigDictSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class FastConcurrentBigDictSet<TKey>
            : ICountableDictSet, IDictSet<TKey>,
              IEnumerable, IEnumerable<TKey>
    {
        private long m_version;
        private readonly Func<TKey, long> m_hfun;
        private ulong m_capacity;
        private NextHashKeyLong<TKey>[] m_firstArray;
        private HashKeyNextLong<TKey>[] m_extraArray;
        private ulong m_count;
        private ulong m_increaseThreshold;
        private ulong m_decreaseThreshold;
        private long m_freeIndex;
        private int m_capacityIndex;
        private ulong m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a FastConcurrentBigDictSet that autmatically grows and shrinks as necessary.
        /// </summary>
        public FastConcurrentBigDictSet(Func<TKey, long> hfun)
            : this(hfun, DictConstant.PrimeSizesLong[0], (ulong)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a FastConcurrentBigDictSet that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// </summary>
        public FastConcurrentBigDictSet(Func<TKey, long> hfun, long initialCapacity)
            : this(hfun, System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizesLong[0]),
                   (ulong)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a FastConcurrentBigDictSet and initialize it to contain the supplied
        /// items.
        /// </summary>
        public FastConcurrentBigDictSet(Func<TKey, long> hfun, IEnumerable<TKey> items)
            : this(hfun, Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizesLong[0]), (ulong)DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        private FastConcurrentBigDictSet(
                Func<TKey, long> hfun, ulong firstCapacity, ulong extraCapacity)
        {
            m_version = 0;
            m_hfun = hfun;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizesLong[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizesLong[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKeyLong<TKey>[m_capacity];
            m_extraArray = new HashKeyNextLong<TKey>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentBigDictSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentBigDictSet
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the FastConcurrentBigDictSet. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<TKey> Items { get { return Keys; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var k = m_firstArray[fi].Item.Key;
                    Monitor.Exit(this); yield return k; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        k = m_extraArray[ei].Item.Key;
                        Monitor.Exit(this); yield return k; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        public IEnumerable<object> Objects
        {
            get
            {
                foreach (object obj in Keys)
                    yield return obj;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the FastConcurrentBigDictSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the FastConcurrentBigDictSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((TKey)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentBigDictSet.
        /// </summary>
        public bool Add(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentBigDictSet.
        /// </summary>
        public bool Add(TKey key, long hash)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentBigDictSet.
        /// </summary>
        public bool TryAdd(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentBigDictSet.
        /// </summary>
        public bool TryAdd(TKey key, long hash)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the supplied keys to the FastConcurrentBigDictSet.
        /// </summary>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDictSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDictSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, long hash)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the FastConcurrentBigDictSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key)
        {
            return TryRemove(key);
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the FastConcurrentBigDictSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, long hash)
        {
            return TryRemove(key, hash);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyLong<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyLong<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, long hash)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyLong<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyLong<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] ToArray()
        {
            var array = new TKey[m_count];
            CopyTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { ++m_version;
            m_firstArray.Set(default(NextHashKeyLong<TKey>));
            m_extraArray.Set(default(HashKeyNextLong<TKey>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(TKey[] array, long index)
        {
            Monitor.Enter(this); try {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        #endregion

        #region IEnumerable<TKey> Members

        IEnumerator<TKey> IEnumerable<TKey>.GetEnumerator()
        {
            
            return Keys.GetEnumerator();
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return Keys.GetEnumerator();
            
        }

        #endregion
        
        #region Private Helper Methods

        private ulong ComputeIncreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_maxFillFactor);
        }

        private ulong ComputeDecreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_minFillFactor);
        }

        private static long AddSlotsToFreeList(
                HashKeyNextLong<TKey>[] extraArray, long start)
        {
            var length = extraArray.Length - 1;
            for (long i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizesLong[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizesLong[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKeyLong<TKey> item,
                NextHashKeyLong<TKey>[] firstArray,
                ulong capacity,
                ref HashKeyNextLong<TKey>[] extraArray,
                ref long freeIndex,
                ref ulong extraCount)
        {
            var fi = ((ulong)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(ulong newCapacity, ulong oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKeyLong<TKey>[newCapacity];
            var extraArray = new HashKeyNextLong<TKey>[
                                    System.Math.Max((long)DictConstant.MinExtraCapacity,
                                                    m_extraArray.LongLength / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            ulong newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                ulong fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((ulong)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (ulong)m_extraArray.Length,
                            (ulong)m_count - newExtraCount, newCapacity,
                            newExtraCount, (ulong)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    ulong oldFirstCount, ulong oldCapacity,
                    ulong oldExtraCount, ulong oldExtraCapacity,
                    ulong newFirstCount, ulong newCapacity,
                    ulong newExtraCount, ulong newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region FastConcurrentLongDict<TValue>

    /// <summary>
    /// A FastConcurrentLongDict is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class FastConcurrentLongDict<TValue>
            : ICountableDict, IDict<long, TValue>,
              IEnumerable, IEnumerable<KeyValuePair<long, TValue>>
    {
        private long m_version;
        private ulong m_capacity;
        private NextLongValue<TValue>[] m_firstArray;
        private LongValueNext<TValue>[] m_extraArray;
        private ulong m_count;
        private ulong m_increaseThreshold;
        private ulong m_decreaseThreshold;
        private readonly bool m_doNotStackDuplicateKeys;
        private long m_freeIndex;
        private int m_capacityIndex;
        private ulong m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a FastConcurrentLongDict that autmatically grows and shrinks as necessary.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentLongDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentLongDict(bool stackDuplicateKeys = false)
            : this(DictConstant.PrimeSizes[0], (ulong)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a FastConcurrentLongDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentLongDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentLongDict(long initialCapacity)
            : this(System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (ulong)DictConstant.MinExtraCapacity, false)
        { }

        /// <summary>
        /// Create a FastConcurrentLongDict that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentLongDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentLongDict(long initialCapacity, bool stackDuplicateKeys)
            : this(System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (ulong)DictConstant.MinExtraCapacity, stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a FastConcurrentLongDict and initialize it to contain the supplied
        /// items.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentLongDict acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentLongDict(IEnumerable<KeyValuePair<long, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (ulong)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        private FastConcurrentLongDict(
                ulong firstCapacity, ulong extraCapacity,
                bool stackDuplicateKeys = false)
        {
            m_version = 0;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_doNotStackDuplicateKeys = !stackDuplicateKeys;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextLongValue<TValue>[m_capacity];
            m_extraArray = new LongValueNext<TValue>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentLongDict
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentLongDict
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the FastConcurrentLongDict. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<KeyValuePair<long, TValue>> Items { get { return KeyValuePairs; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<long> Keys
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var k = m_firstArray[fi].Item.Key;
                    Monitor.Exit(this); yield return k; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        k = m_extraArray[ei].Item.Key;
                        Monitor.Exit(this); yield return k; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type KeyType { get { return typeof(long); } }

        /// <summary>
        /// Returns all values in the FastConcurrentLongDict.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var v = m_firstArray[fi].Item.Value;
                    Monitor.Exit(this); yield return v; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        v = m_extraArray[ei].Item.Value;
                        Monitor.Exit(this); yield return v; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type ValueType { get { return typeof(TValue); } }

        /// <summary>
        /// Returns all key value pairs in the FastConcurrentLongDict.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<KeyValuePair<long, TValue>> KeyValuePairs
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var kvp = new KeyValuePair<long, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        kvp = new KeyValuePair<long, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Returns all key value pairs in the FastConcurrentLongDict, in such a way,
        /// that the stack order is correct when the pairs are put into a
        /// new FastConcurrentLongDict in the order they are returned.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<KeyValuePair<long, TValue>> KeyValuePairsForStorage
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                var stack = new Stack<long>();
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    while (ei > 0) { stack.Push(ei); ei = m_extraArray[ei].Next; }
                    var kvp = default(KeyValuePair<long, TValue>);
                    while (stack.Count > 0)
                    {
                        ei = stack.Pop();
                        kvp = new KeyValuePair<long, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                    }
                    kvp = new KeyValuePair<long, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<(object, object)> ObjectPairs
        {
            get
            {
                foreach (var kvp in KeyValuePairsForStorage)
                    yield return (kvp.Key, kvp.Value);
            }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the FastConcurrentLongDict acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[long key]
        {
            get
            {
                var hash = key;
                Monitor.Enter(this); try {
                var fi = ((ulong)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                    throw new KeyNotFoundException();
                if (m_firstArray[fi].Item.Key == hash)
                    return m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key == hash)
                        return m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
                } finally { Monitor.Exit(this); }
                throw new KeyNotFoundException();
            }
            set
            {
                var hash = key;
                Monitor.Enter(this); try { ++m_version;
                if (m_count >= m_increaseThreshold) IncreaseCapacity();
                var fi = ((ulong)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                {
                    ++m_count;
                    m_firstArray[fi].Next = -1;
                    m_firstArray[fi].Item.Key = key;
                    m_firstArray[fi].Item.Value = value;
                    return;
                }
                if (m_doNotStackDuplicateKeys)
                {
                    if (m_firstArray[fi].Item.Key == hash)
                    {
                        m_firstArray[fi].Item.Value = value;
                        return;
                    }
                    while (ei > 0)
                    {
                        if (m_extraArray[ei].Item.Key == hash)
                        {
                            m_extraArray[ei].Item.Value = value;
                            return;
                        }
                        ei = m_extraArray[ei].Next;
                    }
                    ei = m_firstArray[fi].Next;
                }
                ++m_count;
                ++m_extraCount;
                if (m_freeIndex < 0)
                {
                    var length = m_extraArray.Length;
                    m_extraArray = m_extraArray.Resized(length * 2);
                    m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
                }
                var ni = m_freeIndex;
                m_freeIndex = m_extraArray[ni].Next;

                m_extraArray[ni].Item = m_firstArray[fi].Item;
                m_extraArray[ni].Next = ei;

                m_firstArray[fi].Next = ni;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                } finally { Monitor.Exit(this); }
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the FastConcurrentLongDict. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the FastConcurrentLongDict
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((long)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentLongDict.
        /// </summary>
        public void Add(long key, TValue value)
        {
            var hash = key;
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Key == hash)
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key == hash)
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentLongDict.
        /// </summary>
        public bool TryAdd(long key, TValue value)
        {
            var hash = key;
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Key == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Key == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the supplied item to the FastConcurrentLongDict.
        /// </summary>
        public void Add(KeyValuePair<long, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Add the supplied items to the FastConcurrentLongDict.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<long, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the FastConcurrentLongDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(long key)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentLongDict contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(long key)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentLongDict contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(long key, TValue value)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentLongDict contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<long, TValue> item)
        {
            return Contains(item.Key, item.Value);
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(long key)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Key == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the FastConcurrentLongDict and returned.
        /// </summary>
        public TValue GetOrCreate(long key, Func<long, TValue> creator)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                ++m_version;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Key == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
            } finally { Monitor.Exit(this); }
        }

        void AddCreated(long key, long hash, TValue value)
        {
            ++m_count;
            ++m_version;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(long key, TValue defaultValue)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Key == hash)
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(long key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(long key, out TValue value)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Key == hash)
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Return all the value with the given key. This method is only
        /// useful if multiple item with the same key are allowed.
        /// </summary>
        public IEnumerable<TValue> ValuesWithKey(long key)
        {
            var hash = key;
            Monitor.Enter(this); try { var version = m_version;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) yield break;
            if (m_firstArray[fi].Item.Key == hash)
            {
                var v = m_firstArray[fi].Item.Value;
                Monitor.Exit(this); yield return v; Monitor.Enter(this);
                if (version != m_version)
                    throw new ConcurrentDataModifiedException();
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                {
                    var v = m_extraArray[ei].Item.Value;
                    Monitor.Exit(this); yield return v; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                }
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
        }


        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(long key, long skip)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Key == hash)
            {
                if (skip == 0) return m_firstArray[fi].Item.Value;
                --skip;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                {
                    if (skip == 0) return m_extraArray[ei].Item.Value;
                    --skip;
                }
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Remove the item with the supplied key from the FastConcurrentLongDict and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(long key)
        {
            TValue value;
            if (!TryRemove(key, out value))
                throw new KeyNotFoundException();
            return value;
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the FastConcurrentLongDict.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(long key)
        {
            TValue value;
            return TryRemove(key, out value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the FastConcurrentLongDict. Returns true if the value was removed.
        /// </summary>
        public bool Remove(long key, TValue value)
        {
            return TryRemove(key, value);
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the FastConcurrentLongDict.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<long, TValue> item)
        {
            return TryRemove(item.Key, item.Value);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(long key, out TValue value)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Key == hash)
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(LongValue<TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(LongValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash)
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(LongValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Key == hash)
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(LongValue<TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(long key, TValue value)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Key == hash
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(LongValue<TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(LongValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Key == hash
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(LongValue<TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Key == hash
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(LongValue<TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public long[] KeysToArray()
        {
            var array = new long[m_count];
            CopyKeysTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            var array = new TValue[m_count];
            CopyValuesTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public KeyValuePair<long, TValue>[] ToArray()
        {
            var array = new KeyValuePair<long, TValue>[m_count];
            CopyTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { ++m_version;
            m_firstArray.Set(default(NextLongValue<TValue>));
            m_extraArray.Set(default(LongValueNext<TValue>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyKeysTo(long[] array, long index)
        {
            Monitor.Enter(this); try {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyValuesTo(TValue[] array, long index)
        {
            Monitor.Enter(this); try {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(KeyValuePair<long, TValue>[] array, long index)
        {
            Monitor.Enter(this); try {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = new KeyValuePair<long, TValue>(
                                m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                while (ei > 0)
                {
                    array[index++] = new KeyValuePair<long, TValue>(
                                    m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        #endregion

        #region IEnumerable<KeyValuePair<long, TValue>> Members

        IEnumerator<KeyValuePair<long, TValue>> IEnumerable<KeyValuePair<long, TValue>>.GetEnumerator()
        {
            
            return KeyValuePairs.GetEnumerator();
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return KeyValuePairs.GetEnumerator();
            
        }

        #endregion
        
        #region Private Helper Methods

        private ulong ComputeIncreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_maxFillFactor);
        }

        private ulong ComputeDecreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_minFillFactor);
        }

        private static long AddSlotsToFreeList(
                LongValueNext<TValue>[] extraArray, long start)
        {
            var length = extraArray.Length - 1;
            for (long i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                LongValue<TValue> item,
                NextLongValue<TValue>[] firstArray,
                ulong capacity,
                ref LongValueNext<TValue>[] extraArray,
                ref long freeIndex,
                ref ulong extraCount)
        {
            var fi = ((ulong)item.Key) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(ulong newCapacity, ulong oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextLongValue<TValue>[newCapacity];
            var extraArray = new LongValueNext<TValue>[
                                    System.Math.Max((long)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            ulong newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                ulong fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((ulong)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (ulong)m_extraArray.Length,
                            (ulong)m_count - newExtraCount, newCapacity,
                            newExtraCount, (ulong)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    ulong oldFirstCount, ulong oldCapacity,
                    ulong oldExtraCount, ulong oldExtraCapacity,
                    ulong newFirstCount, ulong newCapacity,
                    ulong newExtraCount, ulong newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region FastConcurrentLongSet

    /// <summary>
    /// A FastConcurrentLongSet is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class FastConcurrentLongSet
            : ICountableDictSet, IDictSet<long>,
              IEnumerable, IEnumerable<long>
    {
        private long m_version;
        private ulong m_capacity;
        private NextLong[] m_firstArray;
        private LongNext[] m_extraArray;
        private ulong m_count;
        private ulong m_increaseThreshold;
        private ulong m_decreaseThreshold;
        private long m_freeIndex;
        private int m_capacityIndex;
        private ulong m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a FastConcurrentLongSet that autmatically grows and shrinks as necessary.
        /// </summary>
        public FastConcurrentLongSet()
            : this(DictConstant.PrimeSizes[0], (ulong)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a FastConcurrentLongSet that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// </summary>
        public FastConcurrentLongSet(long initialCapacity)
            : this(System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (ulong)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a FastConcurrentLongSet and initialize it to contain the supplied
        /// items.
        /// </summary>
        public FastConcurrentLongSet(IEnumerable<long> items)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (ulong)DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        private FastConcurrentLongSet(
                ulong firstCapacity, ulong extraCapacity)
        {
            m_version = 0;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextLong[m_capacity];
            m_extraArray = new LongNext[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentLongSet
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentLongSet
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the FastConcurrentLongSet. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<long> Items { get { return Keys; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<long> Keys
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var k = m_firstArray[fi].Item;
                    Monitor.Exit(this); yield return k; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        k = m_extraArray[ei].Item;
                        Monitor.Exit(this); yield return k; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type KeyType { get { return typeof(long); } }

        public IEnumerable<object> Objects
        {
            get
            {
                foreach (object obj in Keys)
                    yield return obj;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the FastConcurrentLongSet. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the FastConcurrentLongSet
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((long)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentLongSet.
        /// </summary>
        public bool Add(long key)
        {
            var hash = key;
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentLongSet.
        /// </summary>
        public bool TryAdd(long key)
        {
            var hash = key;
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item == hash)
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item == hash)
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the supplied keys to the FastConcurrentLongSet.
        /// </summary>
        public void AddRange(IEnumerable<long> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the FastConcurrentLongSet contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(long key)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item == hash)
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item == hash)
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the FastConcurrentLongSet. Returns true if the value was removed.
        /// </summary>
        public bool Remove(long key)
        {
            return TryRemove(key);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(long key)
        {
            var hash = key;
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item == hash)
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(long);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(long);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item == hash)
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(long);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item == hash)
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(long);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public long[] ToArray()
        {
            var array = new long[m_count];
            CopyTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { ++m_version;
            m_firstArray.Set(default(NextLong));
            m_extraArray.Set(default(LongNext));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(long[] array, long index)
        {
            Monitor.Enter(this); try {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        #endregion

        #region IEnumerable<long> Members

        IEnumerator<long> IEnumerable<long>.GetEnumerator()
        {
            
            return Keys.GetEnumerator();
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return Keys.GetEnumerator();
            
        }

        #endregion
        
        #region Private Helper Methods

        private ulong ComputeIncreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_maxFillFactor);
        }

        private ulong ComputeDecreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_minFillFactor);
        }

        private static long AddSlotsToFreeList(
                LongNext[] extraArray, long start)
        {
            var length = extraArray.Length - 1;
            for (long i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                long item,
                NextLong[] firstArray,
                ulong capacity,
                ref LongNext[] extraArray,
                ref long freeIndex,
                ref ulong extraCount)
        {
            var fi = ((ulong)item) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(ulong newCapacity, ulong oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextLong[newCapacity];
            var extraArray = new LongNext[
                                    System.Math.Max((long)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            ulong newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                ulong fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((ulong)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (ulong)m_extraArray.Length,
                            (ulong)m_count - newExtraCount, newCapacity,
                            newExtraCount, (ulong)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    ulong oldFirstCount, ulong oldCapacity,
                    ulong oldExtraCount, ulong oldExtraCapacity,
                    ulong newFirstCount, ulong newCapacity,
                    ulong newExtraCount, ulong newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region DictIEq<TKey, TValue>

    /// <summary>
    /// A DictIEq is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class DictIEq<TKey, TValue>
            : IIntCountable, ICountableDict, IDict<TKey, TValue>,
              IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>,
              ICollection, ICollection<KeyValuePair<TKey, TValue>>
        where TKey : IEquatable<TKey>
    {
        private uint m_capacity;
        private NextHashKeyValue<TKey, TValue>[] m_firstArray;
        private HashKeyValueNext<TKey, TValue>[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private readonly bool m_doNotStackDuplicateKeys;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a DictIEq that autmatically grows and shrinks as necessary.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// DictIEq acts as a stack for all items with the same key.
        /// </summary>
        public DictIEq(bool stackDuplicateKeys = false)
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a DictIEq that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// DictIEq acts as a stack for all items with the same key.
        /// </summary>
        public DictIEq(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, false)
        { }

        /// <summary>
        /// Create a DictIEq that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// DictIEq acts as a stack for all items with the same key.
        /// </summary>
        public DictIEq(int initialCapacity, bool stackDuplicateKeys)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a DictIEq and initialize it to contain the supplied
        /// items.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// DictIEq acts as a stack for all items with the same key.
        /// </summary>
        public DictIEq(IEnumerable<KeyValuePair<TKey, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        private DictIEq(
                uint firstCapacity, uint extraCapacity,
                bool stackDuplicateKeys = false)
        {
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_doNotStackDuplicateKeys = !stackDuplicateKeys;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKeyValue<TKey, TValue>[m_capacity];
            m_extraArray = new HashKeyValueNext<TKey, TValue>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the DictIEq.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the DictIEq
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the DictIEq
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the DictIEq. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Always returns false. Part of the ICollection implementation.
        /// </summary>
        public bool IsReadOnly { get { return false; } }

        public bool IsSynchronized { get { return false; } }

        public object SyncRoot { get { return this; } }
        public IEnumerable<KeyValuePair<TKey, TValue>> Items { get { return KeyValuePairs; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Key;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Key;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        /// <summary>
        /// Returns all values in the DictIEq.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Value;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Value;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type ValueType { get { return typeof(TValue); } }

        /// <summary>
        /// Returns all key value pairs in the DictIEq.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairs
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    while (ei > 0)
                    {
                        yield return new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        /// <summary>
        /// Returns all key value pairs in the DictIEq, in such a way,
        /// that the stack order is correct when the pairs are put into a
        /// new DictIEq in the order they are returned.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairsForStorage
        {
            get
            {
                var stack = new Stack<int>();
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    while (ei > 0) { stack.Push(ei); ei = m_extraArray[ei].Next; }
                    while (stack.Count > 0)
                    {
                        ei = stack.Pop();
                        yield return new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    }
                    yield return new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                }
            }
        }

        public IEnumerable<(object, object)> ObjectPairs
        {
            get
            {
                foreach (var kvp in KeyValuePairsForStorage)
                    yield return (kvp.Key, kvp.Value);
            }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the DictIEq acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[TKey key]
        {
            get
            {
                var hash = key.GetHashCode();
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                    throw new KeyNotFoundException();
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                    return m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                        return m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
                throw new KeyNotFoundException();
            }
            set
            {
                var hash = key.GetHashCode();
                if (m_count >= m_increaseThreshold) IncreaseCapacity();
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                {
                    ++m_count;
                    m_firstArray[fi].Next = -1;
                    m_firstArray[fi].Item.Hash = hash;
                    m_firstArray[fi].Item.Key = key;
                    m_firstArray[fi].Item.Value = value;
                    return;
                }
                if (m_doNotStackDuplicateKeys)
                {
                    if (m_firstArray[fi].Item.Hash == hash
                        && key.Equals(m_firstArray[fi].Item.Key))
                    {
                        m_firstArray[fi].Item.Value = value;
                        return;
                    }
                    while (ei > 0)
                    {
                        if (m_extraArray[ei].Item.Hash == hash
                            && key.Equals(m_extraArray[ei].Item.Key))
                        {
                            m_extraArray[ei].Item.Value = value;
                            return;
                        }
                        ei = m_extraArray[ei].Next;
                    }
                    ei = m_firstArray[fi].Next;
                }
                ++m_count;
                ++m_extraCount;
                if (m_freeIndex < 0)
                {
                    var length = m_extraArray.Length;
                    m_extraArray = m_extraArray.Resized(length * 2);
                    m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
                }
                var ni = m_freeIndex;
                m_freeIndex = m_extraArray[ni].Next;

                m_extraArray[ni].Item = m_firstArray[fi].Item;
                m_extraArray[ni].Next = ei;

                m_firstArray[fi].Next = ni;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the DictIEq. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the DictIEq
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((TKey)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the DictIEq.
        /// </summary>
        public void Add(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the DictIEq.
        /// </summary>
        public void Add(TKey key, int hash, TValue value)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the DictIEq.
        /// </summary>
        public bool TryAdd(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the DictIEq.
        /// </summary>
        public bool TryAdd(TKey key, int hash, TValue value)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            return true;
        }

        /// <summary>
        /// Add the supplied item to the DictIEq.
        /// </summary>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Add the supplied items to the DictIEq.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the DictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the DictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, int hash)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the DictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the DictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key, int hash)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the DictIEq contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the DictIEq contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, int hash, TValue value)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the DictIEq contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            return Contains(item.Key, item.Value);
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the DictIEq and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, Func<TKey, TValue> creator)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
        }

        void AddCreated(TKey key, int hash, TValue value)
        {
            ++m_count;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, TValue defaultValue)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key, int hash)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the DictIEq and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, int hash, Func<TKey, TValue> creator)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, int hash, TValue defaultValue)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(TKey key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, out TValue value)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, int hash, out TValue value)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Return all the value with the given key. This method is only
        /// useful if multiple item with the same key are allowed.
        /// </summary>
        public IEnumerable<TValue> ValuesWithKey(TKey key)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) yield break;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                yield return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    yield return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
        }

        /// <summary>
        /// Gets an enumerator for values with key. It is only useful
        /// if multiple item with the same key are allowed.
        /// Should be preferred over ValuesWithKey enumeration in
        /// performance critical code.
        /// </summary>
        public ValuesWithKeyEnumerator GetValuesWithKeyEnumerator(TKey key)
        {
            return new ValuesWithKeyEnumerator(this, key);
        }

        public struct ValuesWithKeyEnumerator : IEnumerator<TValue>
        {
            readonly DictIEq<TKey, TValue> m_dict;
            readonly TKey m_key;
            readonly int m_hash;
            int m_extraIndex;
            TValue m_current;

            public ValuesWithKeyEnumerator(DictIEq<TKey, TValue> dict, TKey key)
            {
                m_dict = dict;
                m_key = key;
                m_hash = key.GetHashCode();
                m_extraIndex = int.MaxValue;
                m_current = default(TValue);
            }

            public readonly TValue Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex == int.MaxValue)
                {
                    var fa = m_dict.m_firstArray;
                    var fi = ((uint)m_hash) % m_dict.m_capacity;
                    m_extraIndex = fa[fi].Next;
                    if (m_extraIndex == 0) return false;
                    if (fa[fi].Item.Hash == m_hash
                        && m_key.Equals(fa[fi].Item.Key))
                    {
                        m_current = fa[fi].Item.Value;
                        return true;
                    }
                }
                if (m_extraIndex > 0)
                {
                    var ea = m_dict.m_extraArray;
                    do
                    {
                        var valid = ea[m_extraIndex].Item.Hash == m_hash
                                    && m_key.Equals(ea[m_extraIndex].Item.Key);
                        if (valid) m_current = ea[m_extraIndex].Item.Value;
                        m_extraIndex = ea[m_extraIndex].Next;
                        if (valid) return true;
                    } while (m_extraIndex > 0);
                }

                return false;
            }

            public void Reset()
            {
                m_extraIndex = int.MaxValue;
                m_current = default(TValue);
            }
        }

        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(TKey key, int skip)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (skip == 0) return m_firstArray[fi].Item.Value;
                --skip;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    if (skip == 0) return m_extraArray[ei].Item.Value;
                    --skip;
                }
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Remove the item with the supplied key from the DictIEq and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(TKey key)
        {
            TValue value;
            if (!TryRemove(key, out value))
                throw new KeyNotFoundException();
            return value;
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the DictIEq.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key)
        {
            TValue value;
            return TryRemove(key, out value);
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the DictIEq.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key, int hash)
        {
            TValue value;
            return TryRemove(key, hash, out value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the DictIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, TValue value)
        {
            return TryRemove(key, value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the DictIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, int hash, TValue value)
        {
            return TryRemove(key, hash, value);
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the DictIEq.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return TryRemove(item.Key, item.Value);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, out TValue value)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, int hash, out TValue value)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, int hash, TValue value)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// </summary>
        public TKey[] KeysToArray()
        {
            var array = new TKey[m_count];
            CopyKeysTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            var array = new TValue[m_count];
            CopyValuesTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// </summary>
        public KeyValuePair<TKey, TValue>[] ToArray()
        {
            var array = new KeyValuePair<TKey, TValue>[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            m_firstArray.Set(default(NextHashKeyValue<TKey, TValue>));
            m_extraArray.Set(default(HashKeyValueNext<TKey, TValue>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyKeysTo(TKey[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyValuesTo(TValue[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = new KeyValuePair<TKey, TValue>(
                                m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                while (ei > 0)
                {
                    array[index++] = new KeyValuePair<TKey, TValue>(
                                    m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copy items into supplied array starting at supplied index.
        /// </summary>
        public void CopyTo(Array array, int index)
        {
            var typedArray = array as KeyValuePair<TKey, TValue>[];
            if (typedArray != null)
                CopyTo(typedArray, index);
            else
                throw new ArgumentException();
        }

        /// <summary>
        /// Retuns a concurrent wrapper around the DictIEq to enable
        /// concurrent modifications.
        /// </summary>
        public ConcurrentDictIEq<TKey, TValue> AsConcurrent()
        {
            return new ConcurrentDictIEq<TKey, TValue>(this);
        }

        #endregion

        #region IEnumerable<KeyValuePair<TKey, TValue>> Members

        IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion
        
        #region Enumerator

        public Enumerator GetEnumerator() { return new Enumerator(this); }

        public struct Enumerator : IEnumerator<KeyValuePair<TKey, TValue>>
        {
            readonly DictIEq<TKey, TValue> m_dict;
            int m_index;
            int m_extraIndex;
            KeyValuePair<TKey, TValue> m_current;

            public Enumerator(DictIEq<TKey, TValue> dict)
            {
                m_dict = dict;
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(KeyValuePair<TKey, TValue>);
            }

            public readonly KeyValuePair<TKey, TValue> Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex < 0)
                {
                    var fa = m_dict.m_firstArray;
                    var cap = fa.Length;
                    while (m_index < cap)
                    {
                        var nxt = fa[m_index].Next;
                        if (nxt != 0)
                        {
                            m_current = new KeyValuePair<TKey, TValue>(fa[m_index].Item.Key, fa[m_index].Item.Value);
                            m_extraIndex = nxt;
                            m_index++;
                            return true;
                        }
                        m_index++;
                    }
                    return false;
                }
                else
                {
                    var ea = m_dict.m_extraArray;
                    m_current = new KeyValuePair<TKey, TValue>(ea[m_extraIndex].Item.Key, ea[m_extraIndex].Item.Value);
                    m_extraIndex = ea[m_extraIndex].Next;
                    return true;
                }
            }

            public void Reset()
            {
                m_index = 0;
                m_extraIndex = -1;
                m_current = default( KeyValuePair<TKey, TValue>);
            }
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                HashKeyValueNext<TKey, TValue>[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKeyValue<TKey, TValue> item,
                NextHashKeyValue<TKey, TValue>[] firstArray,
                uint capacity,
                ref HashKeyValueNext<TKey, TValue>[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKeyValue<TKey, TValue>[newCapacity];
            var extraArray = new HashKeyValueNext<TKey, TValue>[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region DictSetIEq<TKey>

    /// <summary>
    /// A DictSetIEq is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class DictSetIEq<TKey>
            : IIntCountable, ICountableDictSet, IDictSet<TKey>,
              IEnumerable, IEnumerable<TKey>,
              ICollection, ICollection<TKey>
        where TKey : IEquatable<TKey>
    {
        private uint m_capacity;
        private NextHashKey<TKey>[] m_firstArray;
        private HashKeyNext<TKey>[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a DictSetIEq that autmatically grows and shrinks as necessary.
        /// </summary>
        public DictSetIEq()
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a DictSetIEq that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// </summary>
        public DictSetIEq(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a DictSetIEq and initialize it to contain the supplied
        /// items.
        /// </summary>
        public DictSetIEq(IEnumerable<TKey> items)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        private DictSetIEq(
                uint firstCapacity, uint extraCapacity)
        {
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKey<TKey>[m_capacity];
            m_extraArray = new HashKeyNext<TKey>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the DictSetIEq.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the DictSetIEq
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the DictSetIEq
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the DictSetIEq. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Always returns false. Part of the ICollection implementation.
        /// </summary>
        public bool IsReadOnly { get { return false; } }

        public bool IsSynchronized { get { return false; } }

        public object SyncRoot { get { return this; } }
        public IEnumerable<TKey> Items { get { return Keys; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Key;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Key;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        public IEnumerable<object> Objects
        {
            get
            {
                foreach (object obj in Keys)
                    yield return obj;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the DictSetIEq. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the DictSetIEq
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((TKey)objkey);
        }

        void ICollection<TKey>.Add(TKey key)
        {
            Add(key);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the DictSetIEq.
        /// </summary>
        public bool Add(TKey key)
        {
            var hash = key.GetHashCode();
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the DictSetIEq.
        /// </summary>
        public bool Add(TKey key, int hash)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the DictSetIEq.
        /// </summary>
        public bool TryAdd(TKey key)
        {
            var hash = key.GetHashCode();
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the DictSetIEq.
        /// </summary>
        public bool TryAdd(TKey key, int hash)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the supplied keys to the DictSetIEq.
        /// </summary>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the DictSetIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the DictSetIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, int hash)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the DictSetIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key)
        {
            return TryRemove(key);
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the DictSetIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, int hash)
        {
            return TryRemove(key, hash);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key)
        {
            var hash = key.GetHashCode();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKey<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKey<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, int hash)
        {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKey<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKey<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// </summary>
        public TKey[] ToArray()
        {
            var array = new TKey[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            m_firstArray.Set(default(NextHashKey<TKey>));
            m_extraArray.Set(default(HashKeyNext<TKey>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyTo(TKey[] array, int index)
        {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copy items into supplied array starting at supplied index.
        /// </summary>
        public void CopyTo(Array array, int index)
        {
            var typedArray = array as TKey[];
            if (typedArray != null)
                CopyTo(typedArray, index);
            else
                throw new ArgumentException();
        }

        /// <summary>
        /// Retuns a concurrent wrapper around the DictSetIEq to enable
        /// concurrent modifications.
        /// </summary>
        public ConcurrentDictSetIEq<TKey> AsConcurrent()
        {
            return new ConcurrentDictSetIEq<TKey>(this);
        }

        #endregion

        #region IEnumerable<TKey> Members

        IEnumerator<TKey> IEnumerable<TKey>.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion
        
        #region Enumerator

        public Enumerator GetEnumerator() { return new Enumerator(this); }

        public struct Enumerator : IEnumerator<TKey>
        {
            readonly DictSetIEq<TKey> m_dict;
            int m_index;
            int m_extraIndex;
            TKey m_current;

            public Enumerator(DictSetIEq<TKey> dict)
            {
                m_dict = dict;
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(TKey);
            }

            public readonly TKey Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex < 0)
                {
                    var fa = m_dict.m_firstArray;
                    var cap = fa.Length;
                    while (m_index < cap)
                    {
                        var nxt = fa[m_index].Next;
                        if (nxt != 0)
                        {
                            m_current = fa[m_index].Item.Key;
                            m_extraIndex = nxt;
                            m_index++;
                            return true;
                        }
                        m_index++;
                    }
                    return false;
                }
                else
                {
                    var ea = m_dict.m_extraArray;
                    m_current = ea[m_extraIndex].Item.Key;
                    m_extraIndex = ea[m_extraIndex].Next;
                    return true;
                }
            }

            public void Reset()
            {
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(TKey);
            }
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                HashKeyNext<TKey>[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKey<TKey> item,
                NextHashKey<TKey>[] firstArray,
                uint capacity,
                ref HashKeyNext<TKey>[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKey<TKey>[newCapacity];
            var extraArray = new HashKeyNext<TKey>[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region BigDictIEq<TKey, TValue>

    /// <summary>
    /// A BigDictIEq is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class BigDictIEq<TKey, TValue>
            : ICountableDict, IDict<TKey, TValue>,
              IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>
        where TKey : IEquatable<TKey>
    {
        private readonly Func<TKey, long> m_hfun;
        private ulong m_capacity;
        private NextHashKeyValueLong<TKey, TValue>[] m_firstArray;
        private HashKeyValueNextLong<TKey, TValue>[] m_extraArray;
        private ulong m_count;
        private ulong m_increaseThreshold;
        private ulong m_decreaseThreshold;
        private readonly bool m_doNotStackDuplicateKeys;
        private long m_freeIndex;
        private int m_capacityIndex;
        private ulong m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a BigDictIEq that autmatically grows and shrinks as necessary.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// BigDictIEq acts as a stack for all items with the same key.
        /// </summary>
        public BigDictIEq(Func<TKey, long> hfun, bool stackDuplicateKeys = false)
            : this(hfun, DictConstant.PrimeSizesLong[0], (ulong)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a BigDictIEq that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// BigDictIEq acts as a stack for all items with the same key.
        /// </summary>
        public BigDictIEq(Func<TKey, long> hfun, long initialCapacity)
            : this(hfun, System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizesLong[0]),
                   (ulong)DictConstant.MinExtraCapacity, false)
        { }

        /// <summary>
        /// Create a BigDictIEq that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// BigDictIEq acts as a stack for all items with the same key.
        /// </summary>
        public BigDictIEq(Func<TKey, long> hfun, long initialCapacity, bool stackDuplicateKeys)
            : this(hfun, System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizesLong[0]),
                   (ulong)DictConstant.MinExtraCapacity, stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a BigDictIEq and initialize it to contain the supplied
        /// items.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// BigDictIEq acts as a stack for all items with the same key.
        /// </summary>
        public BigDictIEq(Func<TKey, long> hfun, IEnumerable<KeyValuePair<TKey, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(hfun, Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizesLong[0]), (ulong)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        private BigDictIEq(
                Func<TKey, long> hfun, ulong firstCapacity, ulong extraCapacity,
                bool stackDuplicateKeys = false)
        {
            m_hfun = hfun;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_doNotStackDuplicateKeys = !stackDuplicateKeys;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizesLong[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizesLong[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKeyValueLong<TKey, TValue>[m_capacity];
            m_extraArray = new HashKeyValueNextLong<TKey, TValue>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the BigDictIEq
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the BigDictIEq
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the BigDictIEq. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Always returns false. Part of the ICollection implementation.
        /// </summary>
        public bool IsReadOnly { get { return false; } }

        public bool IsSynchronized { get { return false; } }

        public object SyncRoot { get { return this; } }
        public IEnumerable<KeyValuePair<TKey, TValue>> Items { get { return KeyValuePairs; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Key;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Key;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        /// <summary>
        /// Returns all values in the BigDictIEq.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Value;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Value;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type ValueType { get { return typeof(TValue); } }

        /// <summary>
        /// Returns all key value pairs in the BigDictIEq.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairs
        {
            get
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    while (ei > 0)
                    {
                        yield return new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        /// <summary>
        /// Returns all key value pairs in the BigDictIEq, in such a way,
        /// that the stack order is correct when the pairs are put into a
        /// new BigDictIEq in the order they are returned.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairsForStorage
        {
            get
            {
                var stack = new Stack<long>();
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    while (ei > 0) { stack.Push(ei); ei = m_extraArray[ei].Next; }
                    while (stack.Count > 0)
                    {
                        ei = stack.Pop();
                        yield return new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    }
                    yield return new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                }
            }
        }

        public IEnumerable<(object, object)> ObjectPairs
        {
            get
            {
                foreach (var kvp in KeyValuePairsForStorage)
                    yield return (kvp.Key, kvp.Value);
            }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the BigDictIEq acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[TKey key]
        {
            get
            {
                var hash = m_hfun(key);
                var fi = ((ulong)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                    throw new KeyNotFoundException();
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                    return m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                        return m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
                throw new KeyNotFoundException();
            }
            set
            {
                var hash = m_hfun(key);
                if (m_count >= m_increaseThreshold) IncreaseCapacity();
                var fi = ((ulong)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                {
                    ++m_count;
                    m_firstArray[fi].Next = -1;
                    m_firstArray[fi].Item.Hash = hash;
                    m_firstArray[fi].Item.Key = key;
                    m_firstArray[fi].Item.Value = value;
                    return;
                }
                if (m_doNotStackDuplicateKeys)
                {
                    if (m_firstArray[fi].Item.Hash == hash
                        && key.Equals(m_firstArray[fi].Item.Key))
                    {
                        m_firstArray[fi].Item.Value = value;
                        return;
                    }
                    while (ei > 0)
                    {
                        if (m_extraArray[ei].Item.Hash == hash
                            && key.Equals(m_extraArray[ei].Item.Key))
                        {
                            m_extraArray[ei].Item.Value = value;
                            return;
                        }
                        ei = m_extraArray[ei].Next;
                    }
                    ei = m_firstArray[fi].Next;
                }
                ++m_count;
                ++m_extraCount;
                if (m_freeIndex < 0)
                {
                    var length = m_extraArray.LongLength;
                    m_extraArray = m_extraArray.Resized(length * 2);
                    m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
                }
                var ni = m_freeIndex;
                m_freeIndex = m_extraArray[ni].Next;

                m_extraArray[ni].Item = m_firstArray[fi].Item;
                m_extraArray[ni].Next = ei;

                m_firstArray[fi].Next = ni;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the BigDictIEq. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the BigDictIEq
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((TKey)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the BigDictIEq.
        /// </summary>
        public void Add(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the BigDictIEq.
        /// </summary>
        public void Add(TKey key, long hash, TValue value)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the BigDictIEq.
        /// </summary>
        public bool TryAdd(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the BigDictIEq.
        /// </summary>
        public bool TryAdd(TKey key, long hash, TValue value)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            return true;
        }

        /// <summary>
        /// Add the supplied item to the BigDictIEq.
        /// </summary>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Add the supplied items to the BigDictIEq.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the BigDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the BigDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, long hash)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the BigDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the BigDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key, long hash)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the BigDictIEq contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the BigDictIEq contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, long hash, TValue value)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the BigDictIEq contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            return Contains(item.Key, item.Value);
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the BigDictIEq and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, Func<TKey, TValue> creator)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
        }

        void AddCreated(TKey key, long hash, TValue value)
        {
            ++m_count;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, TValue defaultValue)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key, long hash)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the BigDictIEq and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, long hash, Func<TKey, TValue> creator)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, long hash, TValue defaultValue)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(TKey key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, out TValue value)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, long hash, out TValue value)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Return all the value with the given key. This method is only
        /// useful if multiple item with the same key are allowed.
        /// </summary>
        public IEnumerable<TValue> ValuesWithKey(TKey key)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) yield break;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                yield return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    yield return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
        }

        /// <summary>
        /// Gets an enumerator for values with key. It is only useful
        /// if multiple item with the same key are allowed.
        /// Should be preferred over ValuesWithKey enumeration in
        /// performance critical code.
        /// </summary>
        public ValuesWithKeyEnumerator GetValuesWithKeyEnumerator(TKey key)
        {
            return new ValuesWithKeyEnumerator(this, key);
        }

        public struct ValuesWithKeyEnumerator : IEnumerator<TValue>
        {
            readonly BigDictIEq<TKey, TValue> m_dict;
            readonly TKey m_key;
            readonly long m_hash;
            long m_extraIndex;
            TValue m_current;

            public ValuesWithKeyEnumerator(BigDictIEq<TKey, TValue> dict, TKey key)
            {
                m_dict = dict;
                m_key = key;
                m_hash = dict.m_hfun(key);
                m_extraIndex = int.MaxValue;
                m_current = default(TValue);
            }

            public readonly TValue Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex == int.MaxValue)
                {
                    var fa = m_dict.m_firstArray;
                    var fi = ((uint)m_hash) % m_dict.m_capacity;
                    m_extraIndex = fa[fi].Next;
                    if (m_extraIndex == 0) return false;
                    if (fa[fi].Item.Hash == m_hash
                        && m_key.Equals(fa[fi].Item.Key))
                    {
                        m_current = fa[fi].Item.Value;
                        return true;
                    }
                }
                if (m_extraIndex > 0)
                {
                    var ea = m_dict.m_extraArray;
                    do
                    {
                        var valid = ea[m_extraIndex].Item.Hash == m_hash
                                    && m_key.Equals(ea[m_extraIndex].Item.Key);
                        if (valid) m_current = ea[m_extraIndex].Item.Value;
                        m_extraIndex = ea[m_extraIndex].Next;
                        if (valid) return true;
                    } while (m_extraIndex > 0);
                }

                return false;
            }

            public void Reset()
            {
                m_extraIndex = int.MaxValue;
                m_current = default(TValue);
            }
        }

        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(TKey key, long skip)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (skip == 0) return m_firstArray[fi].Item.Value;
                --skip;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    if (skip == 0) return m_extraArray[ei].Item.Value;
                    --skip;
                }
                ei = m_extraArray[ei].Next;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Remove the item with the supplied key from the BigDictIEq and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(TKey key)
        {
            TValue value;
            if (!TryRemove(key, out value))
                throw new KeyNotFoundException();
            return value;
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the BigDictIEq.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key)
        {
            TValue value;
            return TryRemove(key, out value);
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the BigDictIEq.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key, long hash)
        {
            TValue value;
            return TryRemove(key, hash, out value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the BigDictIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, TValue value)
        {
            return TryRemove(key, value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the BigDictIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, long hash, TValue value)
        {
            return TryRemove(key, hash, value);
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the BigDictIEq.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return TryRemove(item.Key, item.Value);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, out TValue value)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, long hash, out TValue value)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            value = default(TValue);
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, long hash, TValue value)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// </summary>
        public TKey[] KeysToArray()
        {
            var array = new TKey[m_count];
            CopyKeysTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            var array = new TValue[m_count];
            CopyValuesTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// </summary>
        public KeyValuePair<TKey, TValue>[] ToArray()
        {
            var array = new KeyValuePair<TKey, TValue>[m_count];
            CopyTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            m_firstArray.Set(default(NextHashKeyValueLong<TKey, TValue>));
            m_extraArray.Set(default(HashKeyValueNextLong<TKey, TValue>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyKeysTo(TKey[] array, long index)
        {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyValuesTo(TValue[] array, long index)
        {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyTo(KeyValuePair<TKey, TValue>[] array, long index)
        {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = new KeyValuePair<TKey, TValue>(
                                m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                while (ei > 0)
                {
                    array[index++] = new KeyValuePair<TKey, TValue>(
                                    m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copy items into supplied array starting at supplied index.
        /// </summary>
        public void CopyTo(Array array, int index)
        {
            var typedArray = array as KeyValuePair<TKey, TValue>[];
            if (typedArray != null)
                CopyTo(typedArray, (long)index);
            else
                throw new ArgumentException();
        }

        /// <summary>
        /// Retuns a concurrent wrapper around the BigDictIEq to enable
        /// concurrent modifications.
        /// </summary>
        public ConcurrentBigDictIEq<TKey, TValue> AsConcurrent()
        {
            return new ConcurrentBigDictIEq<TKey, TValue>(this);
        }

        #endregion

        #region IEnumerable<KeyValuePair<TKey, TValue>> Members

        IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion
        
        #region Enumerator

        public Enumerator GetEnumerator() { return new Enumerator(this); }

        public struct Enumerator : IEnumerator<KeyValuePair<TKey, TValue>>
        {
            readonly BigDictIEq<TKey, TValue> m_dict;
            long m_index;
            long m_extraIndex;
            KeyValuePair<TKey, TValue> m_current;

            public Enumerator(BigDictIEq<TKey, TValue> dict)
            {
                m_dict = dict;
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(KeyValuePair<TKey, TValue>);
            }

            public readonly KeyValuePair<TKey, TValue> Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex < 0)
                {
                    var fa = m_dict.m_firstArray;
                    var cap = fa.Length;
                    while (m_index < cap)
                    {
                        var nxt = fa[m_index].Next;
                        if (nxt != 0)
                        {
                            m_current = new KeyValuePair<TKey, TValue>(fa[m_index].Item.Key, fa[m_index].Item.Value);
                            m_extraIndex = nxt;
                            m_index++;
                            return true;
                        }
                        m_index++;
                    }
                    return false;
                }
                else
                {
                    var ea = m_dict.m_extraArray;
                    m_current = new KeyValuePair<TKey, TValue>(ea[m_extraIndex].Item.Key, ea[m_extraIndex].Item.Value);
                    m_extraIndex = ea[m_extraIndex].Next;
                    return true;
                }
            }

            public void Reset()
            {
                m_index = 0;
                m_extraIndex = -1;
                m_current = default( KeyValuePair<TKey, TValue>);
            }
        }

        #endregion
        
        #region Private Helper Methods

        private ulong ComputeIncreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_maxFillFactor);
        }

        private ulong ComputeDecreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_minFillFactor);
        }

        private static long AddSlotsToFreeList(
                HashKeyValueNextLong<TKey, TValue>[] extraArray, long start)
        {
            var length = extraArray.Length - 1;
            for (long i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizesLong[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizesLong[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKeyValueLong<TKey, TValue> item,
                NextHashKeyValueLong<TKey, TValue>[] firstArray,
                ulong capacity,
                ref HashKeyValueNextLong<TKey, TValue>[] extraArray,
                ref long freeIndex,
                ref ulong extraCount)
        {
            var fi = ((ulong)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(ulong newCapacity, ulong oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKeyValueLong<TKey, TValue>[newCapacity];
            var extraArray = new HashKeyValueNextLong<TKey, TValue>[
                                    System.Math.Max((long)DictConstant.MinExtraCapacity,
                                                    m_extraArray.LongLength / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            ulong newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                ulong fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((ulong)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (ulong)m_extraArray.Length,
                            (ulong)m_count - newExtraCount, newCapacity,
                            newExtraCount, (ulong)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    ulong oldFirstCount, ulong oldCapacity,
                    ulong oldExtraCount, ulong oldExtraCapacity,
                    ulong newFirstCount, ulong newCapacity,
                    ulong newExtraCount, ulong newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region BigDictSetIEq<TKey>

    /// <summary>
    /// A BigDictSetIEq is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class BigDictSetIEq<TKey>
            : ICountableDictSet, IDictSet<TKey>,
              IEnumerable, IEnumerable<TKey>
        where TKey : IEquatable<TKey>
    {
        private readonly Func<TKey, long> m_hfun;
        private ulong m_capacity;
        private NextHashKeyLong<TKey>[] m_firstArray;
        private HashKeyNextLong<TKey>[] m_extraArray;
        private ulong m_count;
        private ulong m_increaseThreshold;
        private ulong m_decreaseThreshold;
        private long m_freeIndex;
        private int m_capacityIndex;
        private ulong m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a BigDictSetIEq that autmatically grows and shrinks as necessary.
        /// </summary>
        public BigDictSetIEq(Func<TKey, long> hfun)
            : this(hfun, DictConstant.PrimeSizesLong[0], (ulong)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a BigDictSetIEq that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// </summary>
        public BigDictSetIEq(Func<TKey, long> hfun, long initialCapacity)
            : this(hfun, System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizesLong[0]),
                   (ulong)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a BigDictSetIEq and initialize it to contain the supplied
        /// items.
        /// </summary>
        public BigDictSetIEq(Func<TKey, long> hfun, IEnumerable<TKey> items)
            : this(hfun, Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizesLong[0]), (ulong)DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        private BigDictSetIEq(
                Func<TKey, long> hfun, ulong firstCapacity, ulong extraCapacity)
        {
            m_hfun = hfun;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizesLong[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizesLong[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKeyLong<TKey>[m_capacity];
            m_extraArray = new HashKeyNextLong<TKey>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the BigDictSetIEq
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the BigDictSetIEq
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the BigDictSetIEq. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            }
        }

        /// <summary>
        /// Always returns false. Part of the ICollection implementation.
        /// </summary>
        public bool IsReadOnly { get { return false; } }

        public bool IsSynchronized { get { return false; } }

        public object SyncRoot { get { return this; } }
        public IEnumerable<TKey> Items { get { return Keys; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    yield return m_firstArray[fi].Item.Key;
                    while (ei > 0)
                    {
                        yield return m_extraArray[ei].Item.Key;
                        ei = m_extraArray[ei].Next;
                    }
                }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        public IEnumerable<object> Objects
        {
            get
            {
                foreach (object obj in Keys)
                    yield return obj;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the BigDictSetIEq. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the BigDictSetIEq
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((TKey)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the BigDictSetIEq.
        /// </summary>
        public bool Add(TKey key)
        {
            var hash = m_hfun(key);
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the BigDictSetIEq.
        /// </summary>
        public bool Add(TKey key, long hash)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the BigDictSetIEq.
        /// </summary>
        public bool TryAdd(TKey key)
        {
            var hash = m_hfun(key);
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the BigDictSetIEq.
        /// </summary>
        public bool TryAdd(TKey key, long hash)
        {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            return true;
        }

        /// <summary>
        /// Add the supplied keys to the BigDictSetIEq.
        /// </summary>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the BigDictSetIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the BigDictSetIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, long hash)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            return false;
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the BigDictSetIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key)
        {
            return TryRemove(key);
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the BigDictSetIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, long hash)
        {
            return TryRemove(key, hash);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key)
        {
            var hash = m_hfun(key);
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyLong<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyLong<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, long hash)
        {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyLong<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyLong<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// </summary>
        public TKey[] ToArray()
        {
            var array = new TKey[m_count];
            CopyTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            m_firstArray.Set(default(NextHashKeyLong<TKey>));
            m_extraArray.Set(default(HashKeyNextLong<TKey>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// </summary>
        public void CopyTo(TKey[] array, long index)
        {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
        }

        /// <summary>
        /// Copy items into supplied array starting at supplied index.
        /// </summary>
        public void CopyTo(Array array, int index)
        {
            var typedArray = array as TKey[];
            if (typedArray != null)
                CopyTo(typedArray, (long)index);
            else
                throw new ArgumentException();
        }

        /// <summary>
        /// Retuns a concurrent wrapper around the BigDictSetIEq to enable
        /// concurrent modifications.
        /// </summary>
        public ConcurrentBigDictSetIEq<TKey> AsConcurrent()
        {
            return new ConcurrentBigDictSetIEq<TKey>(this);
        }

        #endregion

        #region IEnumerable<TKey> Members

        IEnumerator<TKey> IEnumerable<TKey>.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return new Enumerator(this);
            
        }

        #endregion
        
        #region Enumerator

        public Enumerator GetEnumerator() { return new Enumerator(this); }

        public struct Enumerator : IEnumerator<TKey>
        {
            readonly BigDictSetIEq<TKey> m_dict;
            long m_index;
            long m_extraIndex;
            TKey m_current;

            public Enumerator(BigDictSetIEq<TKey> dict)
            {
                m_dict = dict;
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(TKey);
            }

            public readonly TKey Current => m_current;

            readonly object IEnumerator.Current => m_current;

            public readonly void Dispose() { }

            public bool MoveNext()
            {
                if (m_extraIndex < 0)
                {
                    var fa = m_dict.m_firstArray;
                    var cap = fa.Length;
                    while (m_index < cap)
                    {
                        var nxt = fa[m_index].Next;
                        if (nxt != 0)
                        {
                            m_current = fa[m_index].Item.Key;
                            m_extraIndex = nxt;
                            m_index++;
                            return true;
                        }
                        m_index++;
                    }
                    return false;
                }
                else
                {
                    var ea = m_dict.m_extraArray;
                    m_current = ea[m_extraIndex].Item.Key;
                    m_extraIndex = ea[m_extraIndex].Next;
                    return true;
                }
            }

            public void Reset()
            {
                m_index = 0;
                m_extraIndex = -1;
                m_current = default(TKey);
            }
        }

        #endregion
        
        #region Private Helper Methods

        private ulong ComputeIncreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_maxFillFactor);
        }

        private ulong ComputeDecreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_minFillFactor);
        }

        private static long AddSlotsToFreeList(
                HashKeyNextLong<TKey>[] extraArray, long start)
        {
            var length = extraArray.Length - 1;
            for (long i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizesLong[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizesLong[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKeyLong<TKey> item,
                NextHashKeyLong<TKey>[] firstArray,
                ulong capacity,
                ref HashKeyNextLong<TKey>[] extraArray,
                ref long freeIndex,
                ref ulong extraCount)
        {
            var fi = ((ulong)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(ulong newCapacity, ulong oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKeyLong<TKey>[newCapacity];
            var extraArray = new HashKeyNextLong<TKey>[
                                    System.Math.Max((long)DictConstant.MinExtraCapacity,
                                                    m_extraArray.LongLength / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            ulong newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                ulong fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((ulong)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (ulong)m_extraArray.Length,
                            (ulong)m_count - newExtraCount, newCapacity,
                            newExtraCount, (ulong)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    ulong oldFirstCount, ulong oldCapacity,
                    ulong oldExtraCount, ulong oldExtraCapacity,
                    ulong newFirstCount, ulong newCapacity,
                    ulong newExtraCount, ulong newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region ConcurrentDictIEq<TKey, TValue>

    /// <summary>
    /// A ConcurrentDictIEq is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class ConcurrentDictIEq<TKey, TValue>
        where TKey : IEquatable<TKey>
    {
        private readonly DictIEq<TKey, TValue> m_dict;

        #region Constructors

        /// <summary>
        /// A ConcurrentDictIEq can only be concstructed by wrapping its non-concurrent
        /// counterpart.
        /// </summary>
        public ConcurrentDictIEq(DictIEq<TKey, TValue> dict)
        {
            m_dict = dict;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentDictIEq.
        /// </summary>
        public int Count
        {
            get
            {
                return m_dict.Count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentDictIEq
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return m_dict.LongCount;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentDictIEq
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_dict.Capacity;
            }
            set
            {
                m_dict.Capacity = value;
            }
        }

        /// <summary>
        /// Return the non-concurrent contained ConcurrentDictIEq.
        /// </summary>
        public DictIEq<TKey, TValue> NonConcurrent
        {
            get { return m_dict; }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the ConcurrentDictIEq acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[TKey key]
        {
            get
            {
                Monitor.Enter(this); try { return m_dict[key]; } finally { Monitor.Exit(this); }
            }
            set
            {
                Monitor.Enter(this); try { m_dict[key] = value; } finally { Monitor.Exit(this); }
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the ConcurrentDictIEq. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the ConcurrentDictIEq
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((TKey)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentDictIEq.
        /// </summary>
        public void Add(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentDictIEq.
        /// </summary>
        public void Add(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentDictIEq.
        /// </summary>
        public bool TryAdd(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentDictIEq.
        /// </summary>
        public bool TryAdd(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied item to the ConcurrentDictIEq.
        /// </summary>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied items to the ConcurrentDictIEq.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the ConcurrentDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, int hash)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key, int hash)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentDictIEq contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, TValue value)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key, value); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentDictIEq contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key, value); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentDictIEq contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Contains(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the ConcurrentDictIEq and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, Func<TKey, TValue> creator)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetOrCreate(key, creator);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, TValue defaultValue)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key, int hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the ConcurrentDictIEq and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, int hash, Func<TKey, TValue> creator)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetOrCreate(key, hash, creator);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, int hash, TValue defaultValue)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(TKey key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryGetValue(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, int hash, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryGetValue(key, hash, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(TKey key, int skip)
        {
            Monitor.Enter(this); try
            {
                return m_dict.ValueWithKeySkip(key, skip);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key from the ConcurrentDictIEq and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetAndRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the ConcurrentDictIEq.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key)
        {
            TValue value;
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the ConcurrentDictIEq.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key, int hash)
        {
            TValue value;
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the ConcurrentDictIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the ConcurrentDictIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the ConcurrentDictIEq.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, int hash, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] KeysToArray()
        {
            return m_dict.KeysToArray();
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            return m_dict.ValuesToArray();
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public KeyValuePair<TKey, TValue>[] ToArray()
        {
            return m_dict.ToArray();
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { m_dict.Clear(); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyKeysTo(TKey[] array, int index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyKeysTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyValuesTo(TValue[] array, int index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyValuesTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int index)
        {
            Monitor.Enter(this); try { m_dict.CopyTo(array, index); } finally { Monitor.Exit(this); }
        }

        #endregion
    }

    #endregion

    #region ConcurrentDictSetIEq<TKey>

    /// <summary>
    /// A ConcurrentDictSetIEq is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class ConcurrentDictSetIEq<TKey>
        where TKey : IEquatable<TKey>
    {
        private readonly DictSetIEq<TKey> m_dict;

        #region Constructors

        /// <summary>
        /// A ConcurrentDictSetIEq can only be concstructed by wrapping its non-concurrent
        /// counterpart.
        /// </summary>
        public ConcurrentDictSetIEq(DictSetIEq<TKey> dict)
        {
            m_dict = dict;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentDictSetIEq.
        /// </summary>
        public int Count
        {
            get
            {
                return m_dict.Count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentDictSetIEq
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return m_dict.LongCount;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentDictSetIEq
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_dict.Capacity;
            }
            set
            {
                m_dict.Capacity = value;
            }
        }

        /// <summary>
        /// Return the non-concurrent contained ConcurrentDictSetIEq.
        /// </summary>
        public DictSetIEq<TKey> NonConcurrent
        {
            get { return m_dict; }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the ConcurrentDictSetIEq. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the ConcurrentDictSetIEq
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((TKey)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentDictSetIEq.
        /// </summary>
        public bool Add(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Add(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentDictSetIEq.
        /// </summary>
        public bool Add(TKey key, int hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Add(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentDictSetIEq.
        /// </summary>
        public bool TryAdd(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentDictSetIEq.
        /// </summary>
        public bool TryAdd(TKey key, int hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied keys to the ConcurrentDictSetIEq.
        /// </summary>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the ConcurrentDictSetIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentDictSetIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, int hash)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the ConcurrentDictSetIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the ConcurrentDictSetIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, int hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, int hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] ToArray()
        {
            return m_dict.ToArray();
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { m_dict.Clear(); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(TKey[] array, int index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        #endregion
    }

    #endregion

    #region ConcurrentBigDictIEq<TKey, TValue>

    /// <summary>
    /// A ConcurrentBigDictIEq is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class ConcurrentBigDictIEq<TKey, TValue>
        where TKey : IEquatable<TKey>
    {
        private readonly BigDictIEq<TKey, TValue> m_dict;

        #region Constructors

        /// <summary>
        /// A ConcurrentBigDictIEq can only be concstructed by wrapping its non-concurrent
        /// counterpart.
        /// </summary>
        public ConcurrentBigDictIEq(BigDictIEq<TKey, TValue> dict)
        {
            m_dict = dict;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentBigDictIEq
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return m_dict.LongCount;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentBigDictIEq
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_dict.Capacity;
            }
            set
            {
                m_dict.Capacity = value;
            }
        }

        /// <summary>
        /// Return the non-concurrent contained ConcurrentBigDictIEq.
        /// </summary>
        public BigDictIEq<TKey, TValue> NonConcurrent
        {
            get { return m_dict; }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the ConcurrentBigDictIEq acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[TKey key]
        {
            get
            {
                Monitor.Enter(this); try { return m_dict[key]; } finally { Monitor.Exit(this); }
            }
            set
            {
                Monitor.Enter(this); try { m_dict[key] = value; } finally { Monitor.Exit(this); }
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the ConcurrentBigDictIEq. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the ConcurrentBigDictIEq
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((TKey)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentBigDictIEq.
        /// </summary>
        public void Add(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentBigDictIEq.
        /// </summary>
        public void Add(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentBigDictIEq.
        /// </summary>
        public bool TryAdd(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the ConcurrentBigDictIEq.
        /// </summary>
        public bool TryAdd(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied item to the ConcurrentBigDictIEq.
        /// </summary>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Monitor.Enter(this); try
            {
                m_dict.Add(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied items to the ConcurrentBigDictIEq.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, long hash)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key, long hash)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDictIEq contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, TValue value)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key, value); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDictIEq contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key, value); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDictIEq contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Contains(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the ConcurrentBigDictIEq and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, Func<TKey, TValue> creator)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetOrCreate(key, creator);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, TValue defaultValue)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key, long hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the ConcurrentBigDictIEq and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, long hash, Func<TKey, TValue> creator)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetOrCreate(key, hash, creator);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, long hash, TValue defaultValue)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Get(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(TKey key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryGetValue(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, long hash, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryGetValue(key, hash, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(TKey key, long skip)
        {
            Monitor.Enter(this); try
            {
                return m_dict.ValueWithKeySkip(key, skip);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key from the ConcurrentBigDictIEq and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.GetAndRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the ConcurrentBigDictIEq.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key)
        {
            TValue value;
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the ConcurrentBigDictIEq.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key, long hash)
        {
            TValue value;
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the ConcurrentBigDictIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the ConcurrentBigDictIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the ConcurrentBigDictIEq.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(item.Key, item.Value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, long hash, out TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, out value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash, value);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] KeysToArray()
        {
            return m_dict.KeysToArray();
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            return m_dict.ValuesToArray();
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public KeyValuePair<TKey, TValue>[] ToArray()
        {
            return m_dict.ToArray();
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { m_dict.Clear(); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyKeysTo(TKey[] array, long index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyKeysTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyValuesTo(TValue[] array, long index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyValuesTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(KeyValuePair<TKey, TValue>[] array, long index)
        {
            Monitor.Enter(this); try { m_dict.CopyTo(array, index); } finally { Monitor.Exit(this); }
        }

        #endregion
    }

    #endregion

    #region ConcurrentBigDictSetIEq<TKey>

    /// <summary>
    /// A ConcurrentBigDictSetIEq is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class ConcurrentBigDictSetIEq<TKey>
        where TKey : IEquatable<TKey>
    {
        private readonly BigDictSetIEq<TKey> m_dict;

        #region Constructors

        /// <summary>
        /// A ConcurrentBigDictSetIEq can only be concstructed by wrapping its non-concurrent
        /// counterpart.
        /// </summary>
        public ConcurrentBigDictSetIEq(BigDictSetIEq<TKey> dict)
        {
            m_dict = dict;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentBigDictSetIEq
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return m_dict.LongCount;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the ConcurrentBigDictSetIEq
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_dict.Capacity;
            }
            set
            {
                m_dict.Capacity = value;
            }
        }

        /// <summary>
        /// Return the non-concurrent contained ConcurrentBigDictSetIEq.
        /// </summary>
        public BigDictSetIEq<TKey> NonConcurrent
        {
            get { return m_dict; }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the ConcurrentBigDictSetIEq. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the ConcurrentBigDictSetIEq
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((TKey)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentBigDictSetIEq.
        /// </summary>
        public bool Add(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Add(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentBigDictSetIEq.
        /// </summary>
        public bool Add(TKey key, long hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.Add(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentBigDictSetIEq.
        /// </summary>
        public bool TryAdd(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the ConcurrentBigDictSetIEq.
        /// </summary>
        public bool TryAdd(TKey key, long hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryAdd(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the supplied keys to the ConcurrentBigDictSetIEq.
        /// </summary>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDictSetIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns true if the ConcurrentBigDictSetIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, long hash)
        {
            Monitor.Enter(this); try { return m_dict.Contains(key); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the ConcurrentBigDictSetIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the ConcurrentBigDictSetIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, long hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, long hash)
        {
            Monitor.Enter(this); try
            {
                return m_dict.TryRemove(key, hash);
            }
            finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] ToArray()
        {
            return m_dict.ToArray();
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { m_dict.Clear(); } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(TKey[] array, long index)
        {
            Monitor.Enter(this); try
            {
                m_dict.CopyTo(array, index);
            }
            finally { Monitor.Exit(this); }
        }

        #endregion
    }

    #endregion

    #region FastConcurrentDictIEq<TKey, TValue>

    /// <summary>
    /// A FastConcurrentDictIEq is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class FastConcurrentDictIEq<TKey, TValue>
            : IIntCountable, ICountableDict, IDict<TKey, TValue>,
              IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>
        where TKey : IEquatable<TKey>
    {
        private long m_version;
        private uint m_capacity;
        private NextHashKeyValue<TKey, TValue>[] m_firstArray;
        private HashKeyValueNext<TKey, TValue>[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private readonly bool m_doNotStackDuplicateKeys;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a FastConcurrentDictIEq that autmatically grows and shrinks as necessary.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentDictIEq acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentDictIEq(bool stackDuplicateKeys = false)
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a FastConcurrentDictIEq that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentDictIEq acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentDictIEq(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, false)
        { }

        /// <summary>
        /// Create a FastConcurrentDictIEq that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentDictIEq acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentDictIEq(int initialCapacity, bool stackDuplicateKeys)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity, stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a FastConcurrentDictIEq and initialize it to contain the supplied
        /// items.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentDictIEq acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentDictIEq(IEnumerable<KeyValuePair<TKey, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        private FastConcurrentDictIEq(
                uint firstCapacity, uint extraCapacity,
                bool stackDuplicateKeys = false)
        {
            m_version = 0;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_doNotStackDuplicateKeys = !stackDuplicateKeys;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKeyValue<TKey, TValue>[m_capacity];
            m_extraArray = new HashKeyValueNext<TKey, TValue>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentDictIEq.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentDictIEq
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentDictIEq
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the FastConcurrentDictIEq. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<KeyValuePair<TKey, TValue>> Items { get { return KeyValuePairs; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var k = m_firstArray[fi].Item.Key;
                    Monitor.Exit(this); yield return k; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        k = m_extraArray[ei].Item.Key;
                        Monitor.Exit(this); yield return k; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        /// <summary>
        /// Returns all values in the FastConcurrentDictIEq.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var v = m_firstArray[fi].Item.Value;
                    Monitor.Exit(this); yield return v; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        v = m_extraArray[ei].Item.Value;
                        Monitor.Exit(this); yield return v; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type ValueType { get { return typeof(TValue); } }

        /// <summary>
        /// Returns all key value pairs in the FastConcurrentDictIEq.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairs
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var kvp = new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        kvp = new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Returns all key value pairs in the FastConcurrentDictIEq, in such a way,
        /// that the stack order is correct when the pairs are put into a
        /// new FastConcurrentDictIEq in the order they are returned.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairsForStorage
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                var stack = new Stack<int>();
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    while (ei > 0) { stack.Push(ei); ei = m_extraArray[ei].Next; }
                    var kvp = default(KeyValuePair<TKey, TValue>);
                    while (stack.Count > 0)
                    {
                        ei = stack.Pop();
                        kvp = new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                    }
                    kvp = new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<(object, object)> ObjectPairs
        {
            get
            {
                foreach (var kvp in KeyValuePairsForStorage)
                    yield return (kvp.Key, kvp.Value);
            }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the FastConcurrentDictIEq acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[TKey key]
        {
            get
            {
                var hash = key.GetHashCode();
                Monitor.Enter(this); try {
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                    throw new KeyNotFoundException();
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                    return m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                        return m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
                } finally { Monitor.Exit(this); }
                throw new KeyNotFoundException();
            }
            set
            {
                var hash = key.GetHashCode();
                Monitor.Enter(this); try { ++m_version;
                if (m_count >= m_increaseThreshold) IncreaseCapacity();
                var fi = ((uint)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                {
                    ++m_count;
                    m_firstArray[fi].Next = -1;
                    m_firstArray[fi].Item.Hash = hash;
                    m_firstArray[fi].Item.Key = key;
                    m_firstArray[fi].Item.Value = value;
                    return;
                }
                if (m_doNotStackDuplicateKeys)
                {
                    if (m_firstArray[fi].Item.Hash == hash
                        && key.Equals(m_firstArray[fi].Item.Key))
                    {
                        m_firstArray[fi].Item.Value = value;
                        return;
                    }
                    while (ei > 0)
                    {
                        if (m_extraArray[ei].Item.Hash == hash
                            && key.Equals(m_extraArray[ei].Item.Key))
                        {
                            m_extraArray[ei].Item.Value = value;
                            return;
                        }
                        ei = m_extraArray[ei].Next;
                    }
                    ei = m_firstArray[fi].Next;
                }
                ++m_count;
                ++m_extraCount;
                if (m_freeIndex < 0)
                {
                    var length = m_extraArray.Length;
                    m_extraArray = m_extraArray.Resized(length * 2);
                    m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
                }
                var ni = m_freeIndex;
                m_freeIndex = m_extraArray[ni].Next;

                m_extraArray[ni].Item = m_firstArray[fi].Item;
                m_extraArray[ni].Next = ei;

                m_firstArray[fi].Next = ni;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                } finally { Monitor.Exit(this); }
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the FastConcurrentDictIEq. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the FastConcurrentDictIEq
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((TKey)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentDictIEq.
        /// </summary>
        public void Add(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentDictIEq.
        /// </summary>
        public void Add(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentDictIEq.
        /// </summary>
        public bool TryAdd(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentDictIEq.
        /// </summary>
        public bool TryAdd(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the supplied item to the FastConcurrentDictIEq.
        /// </summary>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Add the supplied items to the FastConcurrentDictIEq.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the FastConcurrentDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, int hash)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key, int hash)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentDictIEq contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentDictIEq contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentDictIEq contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            return Contains(item.Key, item.Value);
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the FastConcurrentDictIEq and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, Func<TKey, TValue> creator)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                ++m_version;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
            } finally { Monitor.Exit(this); }
        }

        void AddCreated(TKey key, int hash, TValue value)
        {
            ++m_count;
            ++m_version;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, TValue defaultValue)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key, int hash)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the FastConcurrentDictIEq and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, int hash, Func<TKey, TValue> creator)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                ++m_version;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, int hash, TValue defaultValue)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(TKey key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, out TValue value)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, int hash, out TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Return all the value with the given key. This method is only
        /// useful if multiple item with the same key are allowed.
        /// </summary>
        public IEnumerable<TValue> ValuesWithKey(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try { var version = m_version;
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) yield break;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                var v = m_firstArray[fi].Item.Value;
                Monitor.Exit(this); yield return v; Monitor.Enter(this);
                if (version != m_version)
                    throw new ConcurrentDataModifiedException();
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    var v = m_extraArray[ei].Item.Value;
                    Monitor.Exit(this); yield return v; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                }
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
        }


        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(TKey key, int skip)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (skip == 0) return m_firstArray[fi].Item.Value;
                --skip;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    if (skip == 0) return m_extraArray[ei].Item.Value;
                    --skip;
                }
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Remove the item with the supplied key from the FastConcurrentDictIEq and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(TKey key)
        {
            TValue value;
            if (!TryRemove(key, out value))
                throw new KeyNotFoundException();
            return value;
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the FastConcurrentDictIEq.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key)
        {
            TValue value;
            return TryRemove(key, out value);
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the FastConcurrentDictIEq.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key, int hash)
        {
            TValue value;
            return TryRemove(key, hash, out value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the FastConcurrentDictIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, TValue value)
        {
            return TryRemove(key, value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the FastConcurrentDictIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, int hash, TValue value)
        {
            return TryRemove(key, hash, value);
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the FastConcurrentDictIEq.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return TryRemove(item.Key, item.Value);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, out TValue value)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, int hash, out TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, TValue value)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, int hash, TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValue<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValue<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValue<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] KeysToArray()
        {
            var array = new TKey[m_count];
            CopyKeysTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            var array = new TValue[m_count];
            CopyValuesTo(array, 0);
            return array;
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public KeyValuePair<TKey, TValue>[] ToArray()
        {
            var array = new KeyValuePair<TKey, TValue>[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { ++m_version;
            m_firstArray.Set(default(NextHashKeyValue<TKey, TValue>));
            m_extraArray.Set(default(HashKeyValueNext<TKey, TValue>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyKeysTo(TKey[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyValuesTo(TValue[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(KeyValuePair<TKey, TValue>[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = new KeyValuePair<TKey, TValue>(
                                m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                while (ei > 0)
                {
                    array[index++] = new KeyValuePair<TKey, TValue>(
                                    m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        #endregion

        #region IEnumerable<KeyValuePair<TKey, TValue>> Members

        IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator()
        {
            
            return KeyValuePairs.GetEnumerator();
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return KeyValuePairs.GetEnumerator();
            
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                HashKeyValueNext<TKey, TValue>[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKeyValue<TKey, TValue> item,
                NextHashKeyValue<TKey, TValue>[] firstArray,
                uint capacity,
                ref HashKeyValueNext<TKey, TValue>[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKeyValue<TKey, TValue>[newCapacity];
            var extraArray = new HashKeyValueNext<TKey, TValue>[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region FastConcurrentDictSetIEq<TKey>

    /// <summary>
    /// A FastConcurrentDictSetIEq is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class FastConcurrentDictSetIEq<TKey>
            : IIntCountable, ICountableDictSet, IDictSet<TKey>,
              IEnumerable, IEnumerable<TKey>
        where TKey : IEquatable<TKey>
    {
        private long m_version;
        private uint m_capacity;
        private NextHashKey<TKey>[] m_firstArray;
        private HashKeyNext<TKey>[] m_extraArray;
        private uint m_count;
        private uint m_increaseThreshold;
        private uint m_decreaseThreshold;
        private int m_freeIndex;
        private int m_capacityIndex;
        private uint m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a FastConcurrentDictSetIEq that autmatically grows and shrinks as necessary.
        /// </summary>
        public FastConcurrentDictSetIEq()
            : this(DictConstant.PrimeSizes[0], (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a FastConcurrentDictSetIEq that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// </summary>
        public FastConcurrentDictSetIEq(int initialCapacity)
            : this(System.Math.Max((uint)initialCapacity,
                                         DictConstant.PrimeSizes[0]),
                   (uint)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a FastConcurrentDictSetIEq and initialize it to contain the supplied
        /// items.
        /// </summary>
        public FastConcurrentDictSetIEq(IEnumerable<TKey> items)
            : this(Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizes[0]), (uint)DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        private FastConcurrentDictSetIEq(
                uint firstCapacity, uint extraCapacity)
        {
            m_version = 0;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizes[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizes[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKey<TKey>[m_capacity];
            m_extraArray = new HashKeyNext<TKey>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentDictSetIEq.
        /// </summary>
        public int Count
        {
            get
            {
                return (int)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentDictSetIEq
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentDictSetIEq
        /// as long.
        /// </summary>
        public uint Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the FastConcurrentDictSetIEq. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<TKey> Items { get { return Keys; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var k = m_firstArray[fi].Item.Key;
                    Monitor.Exit(this); yield return k; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        k = m_extraArray[ei].Item.Key;
                        Monitor.Exit(this); yield return k; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        public IEnumerable<object> Objects
        {
            get
            {
                foreach (object obj in Keys)
                    yield return obj;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the FastConcurrentDictSetIEq. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the FastConcurrentDictSetIEq
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((TKey)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentDictSetIEq.
        /// </summary>
        public bool Add(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentDictSetIEq.
        /// </summary>
        public bool Add(TKey key, int hash)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentDictSetIEq.
        /// </summary>
        public bool TryAdd(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentDictSetIEq.
        /// </summary>
        public bool TryAdd(TKey key, int hash)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the supplied keys to the FastConcurrentDictSetIEq.
        /// </summary>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the FastConcurrentDictSetIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentDictSetIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, int hash)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the FastConcurrentDictSetIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key)
        {
            return TryRemove(key);
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the FastConcurrentDictSetIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, int hash)
        {
            return TryRemove(key, hash);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key)
        {
            var hash = key.GetHashCode();
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKey<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKey<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, int hash)
        {
            Monitor.Enter(this); try {
            var fi = ((uint)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKey<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKey<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKey<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] ToArray()
        {
            var array = new TKey[m_count];
            CopyTo(array, 0);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { ++m_version;
            m_firstArray.Set(default(NextHashKey<TKey>));
            m_extraArray.Set(default(HashKeyNext<TKey>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(TKey[] array, int index)
        {
            Monitor.Enter(this); try {
            for (uint fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        #endregion

        #region IEnumerable<TKey> Members

        IEnumerator<TKey> IEnumerable<TKey>.GetEnumerator()
        {
            
            return Keys.GetEnumerator();
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return Keys.GetEnumerator();
            
        }

        #endregion
        
        #region Private Helper Methods

        private uint ComputeIncreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_maxFillFactor);
        }

        private uint ComputeDecreaseThreshold(uint capacity)
        {
            return (uint)(capacity * (double)m_minFillFactor);
        }

        private static int AddSlotsToFreeList(
                HashKeyNext<TKey>[] extraArray, int start)
        {
            var length = extraArray.Length - 1;
            for (int i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizes[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizes[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKey<TKey> item,
                NextHashKey<TKey>[] firstArray,
                uint capacity,
                ref HashKeyNext<TKey>[] extraArray,
                ref int freeIndex,
                ref uint extraCount)
        {
            var fi = ((uint)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(uint newCapacity, uint oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKey<TKey>[newCapacity];
            var extraArray = new HashKeyNext<TKey>[
                                    System.Math.Max((int)DictConstant.MinExtraCapacity,
                                                    m_extraArray.Length / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            uint newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (uint fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                uint fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        int head = -1;
                        do
                        {
                            int next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((uint)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (uint)m_extraArray.Length,
                            (uint)m_count - newExtraCount, newCapacity,
                            newExtraCount, (uint)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    uint oldFirstCount, uint oldCapacity,
                    uint oldExtraCount, uint oldExtraCapacity,
                    uint newFirstCount, uint newCapacity,
                    uint newExtraCount, uint newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region FastConcurrentBigDictIEq<TKey, TValue>

    /// <summary>
    /// A FastConcurrentBigDictIEq is an alternate implementation of a Dictionary that can
    /// optionally act as a stack for all items with the same key.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class FastConcurrentBigDictIEq<TKey, TValue>
            : ICountableDict, IDict<TKey, TValue>,
              IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>
        where TKey : IEquatable<TKey>
    {
        private long m_version;
        private readonly Func<TKey, long> m_hfun;
        private ulong m_capacity;
        private NextHashKeyValueLong<TKey, TValue>[] m_firstArray;
        private HashKeyValueNextLong<TKey, TValue>[] m_extraArray;
        private ulong m_count;
        private ulong m_increaseThreshold;
        private ulong m_decreaseThreshold;
        private readonly bool m_doNotStackDuplicateKeys;
        private long m_freeIndex;
        private int m_capacityIndex;
        private ulong m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a FastConcurrentBigDictIEq that autmatically grows and shrinks as necessary.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentBigDictIEq acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentBigDictIEq(Func<TKey, long> hfun, bool stackDuplicateKeys = false)
            : this(hfun, DictConstant.PrimeSizesLong[0], (ulong)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a FastConcurrentBigDictIEq that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentBigDictIEq acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentBigDictIEq(Func<TKey, long> hfun, long initialCapacity)
            : this(hfun, System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizesLong[0]),
                   (ulong)DictConstant.MinExtraCapacity, false)
        { }

        /// <summary>
        /// Create a FastConcurrentBigDictIEq that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentBigDictIEq acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentBigDictIEq(Func<TKey, long> hfun, long initialCapacity, bool stackDuplicateKeys)
            : this(hfun, System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizesLong[0]),
                   (ulong)DictConstant.MinExtraCapacity, stackDuplicateKeys)
        { }

        /// <summary>
        /// Create a FastConcurrentBigDictIEq and initialize it to contain the supplied
        /// items.
        /// If the optional parameter stackDuplicateKeys is set to true, the
        /// FastConcurrentBigDictIEq acts as a stack for all items with the same key.
        /// </summary>
        public FastConcurrentBigDictIEq(Func<TKey, long> hfun, IEnumerable<KeyValuePair<TKey, TValue>> items,
                bool stackDuplicateKeys = false)
            : this(hfun, Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizesLong[0]), (ulong)DictConstant.MinExtraCapacity,
                   stackDuplicateKeys)
        {
            foreach (var item in items) Add(item);
        }

        private FastConcurrentBigDictIEq(
                Func<TKey, long> hfun, ulong firstCapacity, ulong extraCapacity,
                bool stackDuplicateKeys = false)
        {
            m_version = 0;
            m_hfun = hfun;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_doNotStackDuplicateKeys = !stackDuplicateKeys;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizesLong[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizesLong[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKeyValueLong<TKey, TValue>[m_capacity];
            m_extraArray = new HashKeyValueNextLong<TKey, TValue>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentBigDictIEq
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentBigDictIEq
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the FastConcurrentBigDictIEq. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<KeyValuePair<TKey, TValue>> Items { get { return KeyValuePairs; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var k = m_firstArray[fi].Item.Key;
                    Monitor.Exit(this); yield return k; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        k = m_extraArray[ei].Item.Key;
                        Monitor.Exit(this); yield return k; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        /// <summary>
        /// Returns all values in the FastConcurrentBigDictIEq.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TValue> Values
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var v = m_firstArray[fi].Item.Value;
                    Monitor.Exit(this); yield return v; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        v = m_extraArray[ei].Item.Value;
                        Monitor.Exit(this); yield return v; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type ValueType { get { return typeof(TValue); } }

        /// <summary>
        /// Returns all key value pairs in the FastConcurrentBigDictIEq.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairs
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var kvp = new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        kvp = new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Returns all key value pairs in the FastConcurrentBigDictIEq, in such a way,
        /// that the stack order is correct when the pairs are put into a
        /// new FastConcurrentBigDictIEq in the order they are returned.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<KeyValuePair<TKey, TValue>> KeyValuePairsForStorage
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                var stack = new Stack<long>();
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    while (ei > 0) { stack.Push(ei); ei = m_extraArray[ei].Next; }
                    var kvp = default(KeyValuePair<TKey, TValue>);
                    while (stack.Count > 0)
                    {
                        ei = stack.Pop();
                        kvp = new KeyValuePair<TKey, TValue>(
                                m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                        Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                    }
                    kvp = new KeyValuePair<TKey, TValue>(
                            m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                    Monitor.Exit(this); yield return kvp; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<(object, object)> ObjectPairs
        {
            get
            {
                foreach (var kvp in KeyValuePairsForStorage)
                    yield return (kvp.Key, kvp.Value);
            }
        }

        #endregion

        #region Indexer

        /// <summary>
        /// Get or set the item with the supplied key. If multiple items with
        /// the same key are allowed, the FastConcurrentBigDictIEq acts as a stack.
        /// </summary>
        /// <param name="key"></param>
        /// <returns></returns>
        public TValue this[TKey key]
        {
            get
            {
                var hash = m_hfun(key);
                Monitor.Enter(this); try {
                var fi = ((ulong)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                    throw new KeyNotFoundException();
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                    return m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                        return m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
                } finally { Monitor.Exit(this); }
                throw new KeyNotFoundException();
            }
            set
            {
                var hash = m_hfun(key);
                Monitor.Enter(this); try { ++m_version;
                if (m_count >= m_increaseThreshold) IncreaseCapacity();
                var fi = ((ulong)hash) % m_capacity;
                var ei = m_firstArray[fi].Next;
                if (ei == 0)
                {
                    ++m_count;
                    m_firstArray[fi].Next = -1;
                    m_firstArray[fi].Item.Hash = hash;
                    m_firstArray[fi].Item.Key = key;
                    m_firstArray[fi].Item.Value = value;
                    return;
                }
                if (m_doNotStackDuplicateKeys)
                {
                    if (m_firstArray[fi].Item.Hash == hash
                        && key.Equals(m_firstArray[fi].Item.Key))
                    {
                        m_firstArray[fi].Item.Value = value;
                        return;
                    }
                    while (ei > 0)
                    {
                        if (m_extraArray[ei].Item.Hash == hash
                            && key.Equals(m_extraArray[ei].Item.Key))
                        {
                            m_extraArray[ei].Item.Value = value;
                            return;
                        }
                        ei = m_extraArray[ei].Next;
                    }
                    ei = m_firstArray[fi].Next;
                }
                ++m_count;
                ++m_extraCount;
                if (m_freeIndex < 0)
                {
                    var length = m_extraArray.LongLength;
                    m_extraArray = m_extraArray.Resized(length * 2);
                    m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
                }
                var ni = m_freeIndex;
                m_freeIndex = m_extraArray[ni].Next;

                m_extraArray[ni].Item = m_firstArray[fi].Item;
                m_extraArray[ni].Next = ei;

                m_firstArray[fi].Next = ni;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                } finally { Monitor.Exit(this); }
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key and the supplied value
        /// both supplied as generic objects, to the FastConcurrentBigDictIEq. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the FastConcurrentBigDictIEq
        /// and this will fail if they are of different types.
        /// </summary>
        public void AddObject(object objkey, object objvalue)
        {
            Add((TKey)objkey, (TValue)objvalue);
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentBigDictIEq.
        /// </summary>
        public void Add(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentBigDictIEq.
        /// </summary>
        public void Add(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    throw new ArgumentException("duplicate key");
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        throw new ArgumentException("duplicate key");
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentBigDictIEq.
        /// </summary>
        public bool TryAdd(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key and the supplied value
        /// to the FastConcurrentBigDictIEq.
        /// </summary>
        public bool TryAdd(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return true;
            }
            if (m_doNotStackDuplicateKeys)
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the supplied item to the FastConcurrentBigDictIEq.
        /// </summary>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Add the supplied items to the FastConcurrentBigDictIEq.
        /// </summary>
        public void AddRange(IEnumerable<KeyValuePair<TKey, TValue>> items)
        {
            foreach (var item in items) Add(item);
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, long hash)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDictIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool ContainsKey(TKey key, long hash)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDictIEq contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDictIEq contains the item with the supplied
        /// key and the supplied value.
        /// </summary>
        public bool Contains(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_firstArray[fi].Item.Value))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDictIEq contains the item with the supplied
        /// KeyValuePair.
        /// </summary>
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            return Contains(item.Key, item.Value);
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the FastConcurrentBigDictIEq and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, Func<TKey, TValue> creator)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                ++m_version;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
            } finally { Monitor.Exit(this); }
        }

        void AddCreated(TKey key, long hash, TValue value)
        {
            ++m_count;
            ++m_version;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                m_firstArray[fi].Item.Value = value;
                return;
            }
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            m_firstArray[fi].Item.Value = value;
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, TValue defaultValue)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Throws an exception if the element is not found. This is an alias of the indexer.
        /// </summary>
        public TValue Get(TKey key, long hash)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// If the element is not found, the supplied creator is called to create
        /// a new element that is added to the FastConcurrentBigDictIEq and returned.
        /// </summary>
        public TValue GetOrCreate(TKey key, long hash, Func<TKey, TValue> creator)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                if (m_count >= m_increaseThreshold)
                {
                    IncreaseCapacity();
                    var v0 = creator(key);
                    AddCreated(key, hash, v0);
                    return v0;
                }
                ++m_count;
                ++m_version;
                m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                var value = creator(key);
                m_firstArray[fi].Item.Value = value;
                return value;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            if (m_count >= m_increaseThreshold)
            {
                IncreaseCapacity();
                var v1 = creator(key);
                AddCreated(key, hash, v1);
                return v1;
            }
            ei = m_firstArray[fi].Next;
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            var val = creator(key);
            m_firstArray[fi].Item.Value = val;
            return val;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key.
        /// Returns the supplied default value if the element is not found.
        /// </summary>
        public TValue Get(TKey key, long hash, TValue defaultValue)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                return defaultValue;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return m_firstArray[fi].Item.Value;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return m_extraArray[ei].Item.Value;
                ei = m_extraArray[ei].Next;
            }
            return defaultValue;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Get the element with the supplied key. Returns the default
        /// value of the value type if the element is not found.
        /// </summary>
        public TValue GetOrDefault(TKey key)
        {
            return Get(key, default(TValue));
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, out TValue value)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to retrieve the value with the supplied key, return true if
        /// successful and return the value via the out parameter.
        /// </summary>
        public bool TryGetValue(TKey key, long hash, out TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) { value = default(TValue); return false; }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                return true;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    return true;
                }
                ei = m_extraArray[ei].Next;
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Return all the value with the given key. This method is only
        /// useful if multiple item with the same key are allowed.
        /// </summary>
        public IEnumerable<TValue> ValuesWithKey(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try { var version = m_version;
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) yield break;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                var v = m_firstArray[fi].Item.Value;
                Monitor.Exit(this); yield return v; Monitor.Enter(this);
                if (version != m_version)
                    throw new ConcurrentDataModifiedException();
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    var v = m_extraArray[ei].Item.Value;
                    Monitor.Exit(this); yield return v; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                }
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
        }


        /// <summary>
        /// Return the value with the given key, but skip a supplied number
        /// of entries with this key. This method is only useful if multiple
        /// item with the same key are allowed.
        /// </summary>
        public TValue ValueWithKeySkip(TKey key, long skip)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
                throw new KeyNotFoundException();
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (skip == 0) return m_firstArray[fi].Item.Value;
                --skip;
            }
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    if (skip == 0) return m_extraArray[ei].Item.Value;
                    --skip;
                }
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            throw new KeyNotFoundException();
        }

        /// <summary>
        /// Remove the item with the supplied key from the FastConcurrentBigDictIEq and
        /// return it. If multipe entries have the same key, the one that
        /// was inserted last is removed.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public TValue GetAndRemove(TKey key)
        {
            TValue value;
            if (!TryRemove(key, out value))
                throw new KeyNotFoundException();
            return value;
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the FastConcurrentBigDictIEq.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key)
        {
            TValue value;
            return TryRemove(key, out value);
        }

        /// <summary>
        /// Try to remove the item with the supplied key from the FastConcurrentBigDictIEq.
        /// and return true if it was succesfully removed. If multipe
        /// entries have the same key, the one that was inserted last is
        /// removed. If the item is not found, false is returned.
        /// </summary>
        public bool Remove(TKey key, long hash)
        {
            TValue value;
            return TryRemove(key, hash, out value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the FastConcurrentBigDictIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, TValue value)
        {
            return TryRemove(key, value);
        }

        /// <summary>
        /// Remove the item with the supplied key and the supplied value
        /// from the FastConcurrentBigDictIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, long hash, TValue value)
        {
            return TryRemove(key, hash, value);
        }

        /// <summary>
        /// Remove the item with the supplied KeyValuePair from the FastConcurrentBigDictIEq.
        /// If the item is not found, a KeyNotFoundException is thrown.
        /// </summary>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return TryRemove(item.Key, item.Value);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, out TValue value)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found, which is returned via the out
        /// parameter.
        /// </summary>
        public bool TryRemove(TKey key, long hash, out TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                value = default(TValue); return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                value = m_firstArray[fi].Item.Value;
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    value = m_extraArray[ei].Item.Value;
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        value = m_extraArray[ni].Item.Value;
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            value = default(TValue);
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, TValue value)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key and the supplied
        /// value. If multipe entries match, the one that was inserted last
        /// is removed. Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, long hash, TValue value)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key)
                && value.Equals(m_firstArray[fi].Item.Value))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyValueLong<TKey, TValue>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key)
                    && value.Equals(m_extraArray[ei].Item.Value))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyValueLong<TKey, TValue>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key)
                        && value.Equals(m_extraArray[ni].Item.Value))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyValueLong<TKey, TValue>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] KeysToArray()
        {
            var array = new TKey[m_count];
            CopyKeysTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Returns all values in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TValue[] ValuesToArray()
        {
            var array = new TValue[m_count];
            CopyValuesTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Returns all KeyValuePairs in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public KeyValuePair<TKey, TValue>[] ToArray()
        {
            var array = new KeyValuePair<TKey, TValue>[m_count];
            CopyTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { ++m_version;
            m_firstArray.Set(default(NextHashKeyValueLong<TKey, TValue>));
            m_extraArray.Set(default(HashKeyValueNextLong<TKey, TValue>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyKeysTo(TKey[] array, long index)
        {
            Monitor.Enter(this); try {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all values in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyValuesTo(TValue[] array, long index)
        {
            Monitor.Enter(this); try {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Value;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Value;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all KeyValuePairs in the dictionary into the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(KeyValuePair<TKey, TValue>[] array, long index)
        {
            Monitor.Enter(this); try {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = new KeyValuePair<TKey, TValue>(
                                m_firstArray[fi].Item.Key, m_firstArray[fi].Item.Value);
                while (ei > 0)
                {
                    array[index++] = new KeyValuePair<TKey, TValue>(
                                    m_extraArray[ei].Item.Key, m_extraArray[ei].Item.Value);
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        #endregion

        #region IEnumerable<KeyValuePair<TKey, TValue>> Members

        IEnumerator<KeyValuePair<TKey, TValue>> IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator()
        {
            
            return KeyValuePairs.GetEnumerator();
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return KeyValuePairs.GetEnumerator();
            
        }

        #endregion
        
        #region Private Helper Methods

        private ulong ComputeIncreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_maxFillFactor);
        }

        private ulong ComputeDecreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_minFillFactor);
        }

        private static long AddSlotsToFreeList(
                HashKeyValueNextLong<TKey, TValue>[] extraArray, long start)
        {
            var length = extraArray.Length - 1;
            for (long i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizesLong[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizesLong[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKeyValueLong<TKey, TValue> item,
                NextHashKeyValueLong<TKey, TValue>[] firstArray,
                ulong capacity,
                ref HashKeyValueNextLong<TKey, TValue>[] extraArray,
                ref long freeIndex,
                ref ulong extraCount)
        {
            var fi = ((ulong)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(ulong newCapacity, ulong oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKeyValueLong<TKey, TValue>[newCapacity];
            var extraArray = new HashKeyValueNextLong<TKey, TValue>[
                                    System.Math.Max((long)DictConstant.MinExtraCapacity,
                                                    m_extraArray.LongLength / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            ulong newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                ulong fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((ulong)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (ulong)m_extraArray.Length,
                            (ulong)m_count - newExtraCount, newCapacity,
                            newExtraCount, (ulong)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    ulong oldFirstCount, ulong oldCapacity,
                    ulong oldExtraCount, ulong oldExtraCapacity,
                    ulong newFirstCount, ulong newCapacity,
                    ulong newExtraCount, ulong newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region FastConcurrentBigDictSetIEq<TKey>

    /// <summary>
    /// A FastConcurrentBigDictSetIEq is an alternate implementation of a HashSet.
    /// It is implemented as a hashtable with external linking, that uses
    /// primes as the table size in order to reduce the danger of funneling.
    /// </summary>
    public class FastConcurrentBigDictSetIEq<TKey>
            : ICountableDictSet, IDictSet<TKey>,
              IEnumerable, IEnumerable<TKey>
        where TKey : IEquatable<TKey>
    {
        private long m_version;
        private readonly Func<TKey, long> m_hfun;
        private ulong m_capacity;
        private NextHashKeyLong<TKey>[] m_firstArray;
        private HashKeyNextLong<TKey>[] m_extraArray;
        private ulong m_count;
        private ulong m_increaseThreshold;
        private ulong m_decreaseThreshold;
        private long m_freeIndex;
        private int m_capacityIndex;
        private ulong m_extraCount;
        private float m_maxFillFactor;
        private float m_minFillFactor;
        public DictReport Report;

        #region Constructors

        /// <summary>
        /// Create a FastConcurrentBigDictSetIEq that autmatically grows and shrinks as necessary.
        /// </summary>
        public FastConcurrentBigDictSetIEq(Func<TKey, long> hfun)
            : this(hfun, DictConstant.PrimeSizesLong[0], (ulong)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a FastConcurrentBigDictSetIEq that autmatically grows and shrinks as necessary,
        /// but also specify an initial capacity.
        /// </summary>
        public FastConcurrentBigDictSetIEq(Func<TKey, long> hfun, long initialCapacity)
            : this(hfun, System.Math.Max((ulong)initialCapacity,
                                         DictConstant.PrimeSizesLong[0]),
                   (ulong)DictConstant.MinExtraCapacity)
        { }

        /// <summary>
        /// Create a FastConcurrentBigDictSetIEq and initialize it to contain the supplied
        /// items.
        /// </summary>
        public FastConcurrentBigDictSetIEq(Func<TKey, long> hfun, IEnumerable<TKey> items)
            : this(hfun, Math.Max(items is ICollection c ? (uint)c.Count : 0u, DictConstant.PrimeSizesLong[0]), (ulong)DictConstant.MinExtraCapacity)
        {
            foreach (var item in items) Add(item);
        }

        private FastConcurrentBigDictSetIEq(
                Func<TKey, long> hfun, ulong firstCapacity, ulong extraCapacity)
        {
            m_version = 0;
            m_hfun = hfun;
            m_maxFillFactor = DictConstant.MaxFillFactorDefault;
            m_minFillFactor = DictConstant.MinFillFactorDefault;
            m_capacityIndex = 0;
            m_capacity = DictConstant.PrimeSizesLong[m_capacityIndex];
            m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            while (firstCapacity >= m_increaseThreshold)
            {
                m_capacity = DictConstant.PrimeSizesLong[++m_capacityIndex];
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
            }
            firstCapacity /= 4;
            while (firstCapacity >= extraCapacity) extraCapacity *= 2;
            m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
            m_firstArray = new NextHashKeyLong<TKey>[m_capacity];
            m_extraArray = new HashKeyNextLong<TKey>[extraCapacity];
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            Report = 0;
        }

        #endregion

        #region Properties

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentBigDictSetIEq
        /// as long.
        /// </summary>
        public long LongCount
        {
            get
            {
                return (long)m_count;
            }
        }

        /// <summary>
        /// Returns the number of items currently contained in the FastConcurrentBigDictSetIEq
        /// as long.
        /// </summary>
        public ulong Capacity
        {
            get
            {
                return m_capacity;
            }
            set
            {
                if (value < m_count)
                    throw new System.ArgumentOutOfRangeException("The new capacity is less than the current number of elements.");
                Resize(value, m_capacity);
            }
        }

        /// <summary>
        /// Setting the maximal fill factor makes it possible to fine-tune
        /// the performance for certain applications. Normally this should
        /// not be necessary.
        /// </summary>
        public float MaxFillFactor
        {
            get { return m_maxFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_maxFillFactor = value;
                m_increaseThreshold = ComputeIncreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        /// <summary>
        /// Setting the minimal fill factor makes it possible to influence
        /// the shrinking behaviour of the FastConcurrentBigDictSetIEq. Normally this should
        /// be set to a quater of the maximal fill factor. In order to
        /// completely prevent shrinking it can also be set to 0.0f.
        /// </summary>
        public float MinFillFactor
        {
            get { return m_minFillFactor; }
            set
            {
                Monitor.Enter(this); try {
                m_minFillFactor = value;
                m_decreaseThreshold = ComputeDecreaseThreshold(m_capacity);
                } finally { Monitor.Exit(this); }
            }
        }

        public IEnumerable<TKey> Items { get { return Keys; } }
        /// <summary>
        /// Returns all keys in the dictionary.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the enumeration.
        /// </summary>
        public IEnumerable<TKey> Keys
        {
            get
            {
                Monitor.Enter(this); try { var version = m_version;
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    var k = m_firstArray[fi].Item.Key;
                    Monitor.Exit(this); yield return k; Monitor.Enter(this);
                    if (version != m_version)
                        throw new ConcurrentDataModifiedException();
                    while (ei > 0)
                    {
                        k = m_extraArray[ei].Item.Key;
                        Monitor.Exit(this); yield return k; Monitor.Enter(this);
                        if (version != m_version)
                            throw new ConcurrentDataModifiedException();
                        ei = m_extraArray[ei].Next;
                    }
                }
                } finally { Monitor.Exit(this); }
            }
        }

        public Type KeyType { get { return typeof(TKey); } }

        public IEnumerable<object> Objects
        {
            get
            {
                foreach (object obj in Keys)
                    yield return obj;
            }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Add the item with supplied key
        /// both supplied as generic objects, to the FastConcurrentBigDictSetIEq. Note that the supplied key
        /// and value are cast to the concrete type of the keys and values used in the FastConcurrentBigDictSetIEq
        /// and this will fail if they are of different types.
        /// </summary>
        public bool AddObject(object objkey)
        {
            return Add((TKey)objkey);
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentBigDictSetIEq.
        /// </summary>
        public bool Add(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentBigDictSetIEq.
        /// </summary>
        public bool Add(TKey key, long hash)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentBigDictSetIEq.
        /// </summary>
        public bool TryAdd(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the item with the supplied key
        /// to the FastConcurrentBigDictSetIEq.
        /// </summary>
        public bool TryAdd(TKey key, long hash)
        {
            Monitor.Enter(this); try {
            if (m_count >= m_increaseThreshold) IncreaseCapacity();
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                ++m_count;
                ++m_version;
               m_firstArray[fi].Next = -1;
                m_firstArray[fi].Item.Hash = hash;
                m_firstArray[fi].Item.Key = key;
                return true;
            }
            {
                // no duplicate keys, check for existing entries
                if (m_firstArray[fi].Item.Hash == hash
                    && key.Equals(m_firstArray[fi].Item.Key))
                {
                    return false;
                }
                while (ei > 0)
                {
                    if (m_extraArray[ei].Item.Hash == hash
                        && key.Equals(m_extraArray[ei].Item.Key))
                    {
                        return false;
                    }
                    ei = m_extraArray[ei].Next;
                }
                ei = m_firstArray[fi].Next;
            }
            ++m_count;
            ++m_version;
            ++m_extraCount;
            if (m_freeIndex < 0)
            {
                var length = m_extraArray.Length;
                m_extraArray = m_extraArray.Resized(length * 2);
                m_freeIndex = AddSlotsToFreeList(m_extraArray, length);
            }
            var ni = m_freeIndex;
            m_freeIndex = m_extraArray[ni].Next;
            m_extraArray[ni].Item = m_firstArray[fi].Item;
            m_extraArray[ni].Next = ei;
            m_firstArray[fi].Next = ni;
            m_firstArray[fi].Item.Hash = hash;
            m_firstArray[fi].Item.Key = key;
            } finally { Monitor.Exit(this); }
            return true;
        }

        /// <summary>
        /// Add the supplied keys to the FastConcurrentBigDictSetIEq.
        /// </summary>
        public void AddRange(IEnumerable<TKey> keys)
        {
            foreach (var key in keys) Add(key);
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDictSetIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns true if the FastConcurrentBigDictSetIEq contains the item with the supplied
        /// key.
        /// </summary>
        public bool Contains(TKey key, long hash)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0) return false;
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
                return true;
            while (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                    return true;
                ei = m_extraArray[ei].Next;
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the FastConcurrentBigDictSetIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key)
        {
            return TryRemove(key);
        }

        /// <summary>
        /// Remove the item with the supplied key
        /// from the FastConcurrentBigDictSetIEq. Returns true if the value was removed.
        /// </summary>
        public bool Remove(TKey key, long hash)
        {
            return TryRemove(key, hash);
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key)
        {
            var hash = m_hfun(key);
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyLong<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyLong<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Try to reomve the item with the supplied key. If multipe entries
        /// have the same key, the one that was inserted last is removed.
        /// Returns true if the item was found.
        /// </summary>
        public bool TryRemove(TKey key, long hash)
        {
            Monitor.Enter(this); try {
            var fi = ((ulong)hash) % m_capacity;
            var ei = m_firstArray[fi].Next;
            if (ei == 0)
            {
                return false;
            }
            if (m_firstArray[fi].Item.Hash == hash
                && key.Equals(m_firstArray[fi].Item.Key))
            {
                if (ei < 0)
                {
                    m_firstArray[fi].Next = 0;
                    m_firstArray[fi].Item = default(HashKeyLong<TKey>);
                }
                else
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_firstArray[fi].Item = m_extraArray[ei].Item;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                }
                if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                ++m_version;
                return true;
            }
            if (ei > 0)
            {
                if (m_extraArray[ei].Item.Hash == hash
                    && key.Equals(m_extraArray[ei].Item.Key))
                {
                    m_firstArray[fi].Next = m_extraArray[ei].Next;
                    m_extraArray[ei].Next = m_freeIndex;
                    m_extraArray[ei].Item = default(HashKeyLong<TKey>);
                    m_freeIndex = ei;
                    --m_extraCount;
                    if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                    ++m_version;
                    return true;
                }
                for (var ni = m_extraArray[ei].Next; ni > 0;
                     ei = ni, ni = m_extraArray[ei].Next)
                {
                    if (m_extraArray[ni].Item.Hash == hash
                        && key.Equals(m_extraArray[ni].Item.Key))
                    {
                        m_extraArray[ei].Next = m_extraArray[ni].Next;
                        m_extraArray[ni].Next = m_freeIndex;
                        m_extraArray[ni].Item = default(HashKeyLong<TKey>);
                        m_freeIndex = ni;
                        --m_extraCount;
                        if (--m_count < m_decreaseThreshold) DecreaseCapacity();
                        ++m_version;
                        return true;
                    }
                }
            }
            } finally { Monitor.Exit(this); }
            return false;
        }

        /// <summary>
        /// Returns all keys in the dictionary as an array.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public TKey[] ToArray()
        {
            var array = new TKey[m_count];
            CopyTo(array, 0L);
            return array;
        }

        /// <summary>
        /// Remove all items. Capacity remains unchanged.
        /// </summary>
        public void Clear()
        {
            Monitor.Enter(this); try { ++m_version;
            m_firstArray.Set(default(NextHashKeyLong<TKey>));
            m_extraArray.Set(default(HashKeyNextLong<TKey>));
            m_freeIndex = AddSlotsToFreeList(m_extraArray, 1);
            m_count = 0;
            m_extraCount = 0;
            } finally { Monitor.Exit(this); }
        }

        /// <summary>
        /// Copies all keys in the dictionary to the supplied
        /// array starting at the supplied index.
        /// This may throw a ConcurrentDataModifiedException if data is
        /// modified by another task during the operation.
        /// </summary>
        public void CopyTo(TKey[] array, long index)
        {
            Monitor.Enter(this); try {
            for (ulong fi = 0; fi < m_capacity; fi++)
            {
                var ei = m_firstArray[fi].Next;
                if (ei == 0) continue;
                array[index++] = m_firstArray[fi].Item.Key;
                while (ei > 0)
                {
                    array[index++] = m_extraArray[ei].Item.Key;
                    ei = m_extraArray[ei].Next;
                }
            }
            } finally { Monitor.Exit(this); }
        }

        #endregion

        #region IEnumerable<TKey> Members

        IEnumerator<TKey> IEnumerable<TKey>.GetEnumerator()
        {
            
            return Keys.GetEnumerator();
            
        }

        #endregion

        #region IEnumerable Members

        IEnumerator IEnumerable.GetEnumerator()
        {
            
            return Keys.GetEnumerator();
            
        }

        #endregion
        
        #region Private Helper Methods

        private ulong ComputeIncreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_maxFillFactor);
        }

        private ulong ComputeDecreaseThreshold(ulong capacity)
        {
            return (ulong)(capacity * (double)m_minFillFactor);
        }

        private static long AddSlotsToFreeList(
                HashKeyNextLong<TKey>[] extraArray, long start)
        {
            var length = extraArray.Length - 1;
            for (long i = start; i < length; i++)
                extraArray[i].Next = i + 1;
            extraArray[length].Next = -1;
            return start;
        }

        private void IncreaseCapacity()
        {
            Resize(DictConstant.PrimeSizesLong[++m_capacityIndex], m_capacity);
        }

        private void DecreaseCapacity()
        {
            if (m_capacityIndex > 0)
                Resize(DictConstant.PrimeSizesLong[--m_capacityIndex], m_capacity);
        }

        /// <summary>
        /// Add item to the hashtable supplied in the parameters.
        /// This is used in resizing, therefore no size check is done.
        /// </summary>
        private static void Add(
                HashKeyLong<TKey> item,
                NextHashKeyLong<TKey>[] firstArray,
                ulong capacity,
                ref HashKeyNextLong<TKey>[] extraArray,
                ref long freeIndex,
                ref ulong extraCount)
        {
            var fi = ((ulong)item.Hash) % capacity;
            var ei = firstArray[fi].Next;
            if (ei == 0)
            {
                firstArray[fi].Next = -1;
                firstArray[fi].Item = item;
                return;
            }
            if (freeIndex < 0)
            {
                var length = extraArray.Length;
                extraArray = extraArray.Resized(length * 2);
                freeIndex = AddSlotsToFreeList(extraArray, length);
            }
            var ni = freeIndex;
            freeIndex = extraArray[ni].Next;

            extraArray[ni].Item = firstArray[fi].Item;
            extraArray[ni].Next = ei;

            firstArray[fi].Next = ni;
            firstArray[fi].Item = item;
            ++extraCount;
        }

        /// <summary>
        /// The resize method has to maintain the stack order of the lists in
        /// the extra array. Therefore one list reversal is necessary.
        /// </summary>
        private void Resize(ulong newCapacity, ulong oldCapacity)
        {
            m_increaseThreshold = ComputeIncreaseThreshold(newCapacity);
            m_decreaseThreshold = ComputeDecreaseThreshold(newCapacity);
            var firstArray = new NextHashKeyLong<TKey>[newCapacity];
            var extraArray = new HashKeyNextLong<TKey>[
                                    System.Math.Max((long)DictConstant.MinExtraCapacity,
                                                    m_extraArray.LongLength / 2)];
            var freeIndex = AddSlotsToFreeList(extraArray, 1);
            ulong newExtraCount = 0;
            if ((m_capacityIndex & 1) != 0)
            {
                for (ulong fi = 0; fi < m_capacity; fi++)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }
            else
            {
                ulong fi = m_capacity;
                while (fi-- > 0)
                {
                    var ei = m_firstArray[fi].Next;
                    if (ei == 0) continue;
                    if (ei > 0)
                    {
                        // reverse the extra list
                        long head = -1;
                        do
                        {
                            long next = m_extraArray[ei].Next;
                            m_extraArray[ei].Next = head;
                            head = ei; ei = next;
                        }
                        while (ei > 0);

                        // insert the extras into the new table
                        do
                        {
                            Add(m_extraArray[head].Item, firstArray, newCapacity,
                                ref extraArray, ref freeIndex, ref newExtraCount);
                            head = m_extraArray[head].Next;
                        }
                        while (head > 0);
                    }
                    Add(m_firstArray[fi].Item, firstArray, newCapacity,
                        ref extraArray, ref freeIndex, ref newExtraCount);
                }
            }

            if ((Report & DictReport.Resize) != 0)
                ReportStats((ulong)m_count - m_extraCount, oldCapacity,
                            m_extraCount, (ulong)m_extraArray.Length,
                            (ulong)m_count - newExtraCount, newCapacity,
                            newExtraCount, (ulong)extraArray.Length);

            m_firstArray = firstArray;
            m_capacity = newCapacity;
            m_extraArray = extraArray;
            m_freeIndex = freeIndex;
            m_extraCount = newExtraCount;
        }

        private void ReportStats(
                    ulong oldFirstCount, ulong oldCapacity,
                    ulong oldExtraCount, ulong oldExtraCapacity,
                    ulong newFirstCount, ulong newCapacity,
                    ulong newExtraCount, ulong newExtraCapacity)
        {
            Base.Report.Line("\nresize at {0}:", m_count);
            Base.Report.Line("  old: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    oldFirstCount, oldCapacity, (100.0 * oldFirstCount) / (double)oldCapacity,
                    oldExtraCount, oldExtraCapacity, (100.0 * oldExtraCount) / (double)oldExtraCapacity);
            Base.Report.Line("  new: first {0,9}/{1,-9} [{2:00.0}%] - extra {3,9}/{4,-9} [{5:00.0}%]",
                    newFirstCount, newCapacity, (100.0 * oldFirstCount) / (double)newCapacity,
                    newExtraCount, newExtraCapacity, (100.0 * newExtraCount) / (double)newExtraCapacity);
        }

        #endregion
    }

    #endregion

    #region Support Data Structures

    [Flags]
    public enum DictReport
    {
        Resize = 0x0001,
    }

    public class ConcurrentDataModifiedException : Exception
    {
        public ConcurrentDataModifiedException()
        { }
    }

    #endregion

    #region Internal Helper Structures

    [StructLayout(LayoutKind.Sequential)]
    internal struct HashKeyValue<TKey, Tvalue>
    {
        public int Hash;
        public TKey Key;
        public Tvalue Value;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NextHashKeyValue<TKey, Tvalue>
    {
        public int Next;
        public HashKeyValue<TKey, Tvalue> Item;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct HashKeyValueNext<TKey, Tvalue>
    {
        public HashKeyValue<TKey, Tvalue> Item;
        public int Next;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct HashKey<TKey>
    {
        public int Hash;
        public TKey Key;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NextHashKey<TKey>
    {
        public int Next;
        public HashKey<TKey> Item;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct HashKeyNext<TKey>
    {
        public HashKey<TKey> Item;
        public int Next;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct IntValue<Tvalue>
    {
        public int Key;
        public Tvalue Value;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NextIntValue<Tvalue>
    {
        public int Next;
        public IntValue<Tvalue> Item;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct IntValueNext<Tvalue>
    {
        public IntValue<Tvalue> Item;
        public int Next;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NextInt
    {
        public int Next;
        public int Item;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct IntNext
    {
        public int Item;
        public int Next;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct HashKeyValueLong<TKey, Tvalue>
    {
        public long Hash;
        public TKey Key;
        public Tvalue Value;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NextHashKeyValueLong<TKey, Tvalue>
    {
        public long Next;
        public HashKeyValueLong<TKey, Tvalue> Item;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct HashKeyValueNextLong<TKey, Tvalue>
    {
        public HashKeyValueLong<TKey, Tvalue> Item;
        public long Next;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct HashKeyLong<TKey>
    {
        public long Hash;
        public TKey Key;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NextHashKeyLong<TKey>
    {
        public long Next;
        public HashKeyLong<TKey> Item;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct HashKeyNextLong<TKey>
    {
        public HashKeyLong<TKey> Item;
        public long Next;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct LongValue<Tvalue>
    {
        public long Key;
        public Tvalue Value;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NextLongValue<Tvalue>
    {
        public long Next;
        public LongValue<Tvalue> Item;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct LongValueNext<Tvalue>
    {
        public LongValue<Tvalue> Item;
        public long Next;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NextLong
    {
        public long Next;
        public long Item;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct LongNext
    {
        public long Item;
        public long Next;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct SymbolValue<Tvalue>
    {
        public Symbol Key;
        public Tvalue Value;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NextSymbolValue<Tvalue>
    {
        public int Next;
        public SymbolValue<Tvalue> Item;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct SymbolValueNext<Tvalue>
    {
        public SymbolValue<Tvalue> Item;
        public int Next;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct NextSymbol
    {
        public int Next;
        public Symbol Item;
    }

    [StructLayout(LayoutKind.Sequential)]
    internal struct SymbolNext
    {
        public Symbol Item;
        public int Next;
    }

    public static class DictConstant
    {
        #region Constants

        public const float MaxFillFactorDefault = 0.8f; // growing avg: (0.8 + 0.4)/2 = 0.6
        public const float MinFillFactorDefault = 0.2f; // shrinking avg: (0.4 + 0.2)/2 = 0.3
        public const int MinExtraCapacity = 4;

        public readonly static uint[] PrimeSizes =
        {
            /*    prime no.           prime */
            /*           2                3,       +  1 = 2^2 */
            /*           4 */             7,    // +  1 = 2^3, minimal size
            /*           6 */            13,    // +  3 = 2^4
            /*          11 */            31,    // +  1 = 2^5
            /*          18 */            61,    // +  3 = 2^6
            /*          31 */           127,    // +  1 = 2^7
            /*          54 */           251,    // +  5 = 2^8
            /*          97 */           509,    // +  3 = 2^9
            /*         172 */          1021,    // +  3 = 2^10
            /*         309 */          2039,    // +  9 = 2^11
            /*         564 */          4093,    // +  3 = 2^12
            /*        1028 */          8191,    // +  1 = 2^13
            /*        1900 */         16381,    // +  3 = 2^14
            /*        3512 */         32749,    // + 19 = 2^15
            /*        6542 */         65521,    // + 15 = 2^16
            /*       12251 */        131071,    // +  1 = 2^17
            /*       23000 */        262139,    // +  5 = 2^18
            /*       43390 */        524287,    // +  1 = 2^19
            /*       82025 */       1048573,    // +  3 = 2^20
            /*      155611 */       2097143,    // +  9 = 2^21
            /*      295947 */       4194301,    // +  3 = 2^22
            /*      564163 */       8388593,    // + 15 = 2^23
            /*     1077871 */      16777213,    // +  3 = 2^24
            /*     2063689 */      33554393,    // + 39 = 2^25
            /*     3957809 */      67108859,    // +  5 = 2^26
            /*     7603553 */     134217689,    // + 39 = 2^27
            /*    14630843 */     268435399,    // + 57 = 2^28
            /*    28192750 */     536870909,    // +  3 = 2^29
            /*    54400028 */    1073741789,    // + 35 = 2^30
            /*   105097565 */    2147483647,    // +  1 = 2^31
            /*   203280221 */    4294967291,    // +  5 = 2^32
        };

        public readonly static ulong[] PrimeSizesLong =
        {
            /*        prime no.               prime */
            /*               2                    3,       +  1 = 2^2 */
            /*               4 */                 7,    // +  1 = 2^3, minimal size
            /*               6 */                13,    // +  3 = 2^4
            /*              11 */                31,    // +  1 = 2^5
            /*              18 */                61,    // +  3 = 2^6
            /*              31 */               127,    // +  1 = 2^7
            /*              54 */               251,    // +  5 = 2^8
            /*              97 */               509,    // +  3 = 2^9
            /*             172 */              1021,    // +  3 = 2^10
            /*             309 */              2039,    // +  9 = 2^11
            /*             564 */              4093,    // +  3 = 2^12
            /*            1028 */              8191,    // +  1 = 2^13
            /*            1900 */             16381,    // +  3 = 2^14
            /*            3512 */             32749,    // + 19 = 2^15
            /*            6542 */             65521,    // + 15 = 2^16
            /*           12251 */            131071,    // +  1 = 2^17
            /*           23000 */            262139,    // +  5 = 2^18
            /*           43390 */            524287,    // +  1 = 2^19
            /*           82025 */           1048573,    // +  3 = 2^20
            /*          155611 */           2097143,    // +  9 = 2^21
            /*          295947 */           4194301,    // +  3 = 2^22
            /*          564163 */           8388593,    // + 15 = 2^23
            /*         1077871 */          16777213,    // +  3 = 2^24
            /*         2063689 */          33554393,    // + 39 = 2^25
            /*         3957809 */          67108859,    // +  5 = 2^26
            /*         7603553 */         134217689,    // + 39 = 2^27
            /*        14630843 */         268435399,    // + 57 = 2^28
            /*        28192750 */         536870909,    // +  3 = 2^29
            /*        54400028 */        1073741789,    // + 35 = 2^30
            /*       105097565 */        2147483647,    // +  1 = 2^31
            /*       203280221 */        4294967291,    // +  5 = 2^32
            /*       393615806 */        8589934583,    // +  9 = 2^33
            /*       762939111 */       17179869143,    // + 41 = 2^34
            /*      1480206279 */       34359738337,    // + 31 = 2^35
            /*      2874398515 */       68719476731,    // +  5 = 2^36
            /*      5586502348 */      137438953447,    // + 25 = 2^37
            /*     10866266172 */      274877906899,    // + 45 = 2^38
            /*     21151907950 */      549755813881,    // +  7 = 2^39
            /*     41203088796 */     1099511627689,    // + 87 = 2^40
            /*     80316571436 */     2199023255531,    // + 21 = 2^41
            /*    156661034233 */     4398046511093,    // + 11 = 2^42
            /*    305761713237 */     8796093022151,    // + 57 = 2^43
            /*    597116381732 */    17592186044399,    // + 17 = 2^44
        };

        #endregion

    }

    #endregion
}
