using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    #region M22i

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M22i : IValidity, IMatrix<double>
    {
        public int M00, M01;
        public int M10, M11;

        #region Constructors

        public M22i(
                int m00, int m01, 
                int m10, int m11)
        {
            M00 = m00; M01 = m01; 
            M10 = m10; M11 = m11; 
        }

        public M22i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M10 = a[2];
            M11 = a[3];
        }
        
        public M22i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M10 = a[start + 2];
            M11 = a[start + 3];
        }

        #endregion

        #region Conversions

        public static explicit operator M22i(M23i m)
        {
            return new M22i {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22i(M33i m)
        {
            return new M22i {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22i(M34i m)
        {
            return new M22i {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22i(M44i m)
        {
            return new M22i {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22i(M22l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M23l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M33l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M34l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M44l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M22f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M23f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M33f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M34f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M44f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M22d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M23d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M33d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M34d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M44d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(int[] a)
        {
            return new M22i(
                a[0], a[1], 
                a[2], a[3]);
        }

        public static explicit operator M22i(int[,] a)
        {
            return new M22i (
                a[0, 0], a[0, 1], 
                a[1, 0], a[1, 1]);
        }

        public static explicit operator int[](M22i m)
        {
            return new int[] {
                m.M00, m.M01, 
                m.M10, m.M11
            };
        }

        public static explicit operator int[,](M22i m)
        {
            return new int[,] {
                { m.M00, m.M01 }, 
                { m.M10, m.M11 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M10;
            array[index + 3] = M11;
        }

        public static explicit operator M22i(long[] a)
        {
            return new M22i(
                (int)a[0], (int)a[1], 
                (int)a[2], (int)a[3]);
        }

        public static explicit operator M22i(long[,] a)
        {
            return new M22i (
                (int)a[0, 0], (int)a[0, 1], 
                (int)a[1, 0], (int)a[1, 1]);
        }

        public static explicit operator long[](M22i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, 
                (long)m.M10, (long)m.M11
            };
        }

        public static explicit operator long[,](M22i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01 }, 
                { (long)m.M10, (long)m.M11 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M10;
            array[index + 3] = (long)M11;
        }

        public static explicit operator M22i(float[] a)
        {
            return new M22i(
                (int)a[0], (int)a[1], 
                (int)a[2], (int)a[3]);
        }

        public static explicit operator M22i(float[,] a)
        {
            return new M22i (
                (int)a[0, 0], (int)a[0, 1], 
                (int)a[1, 0], (int)a[1, 1]);
        }

        public static explicit operator float[](M22i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, 
                (float)m.M10, (float)m.M11
            };
        }

        public static explicit operator float[,](M22i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01 }, 
                { (float)m.M10, (float)m.M11 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M10;
            array[index + 3] = (float)M11;
        }

        public static explicit operator M22i(double[] a)
        {
            return new M22i(
                (int)a[0], (int)a[1], 
                (int)a[2], (int)a[3]);
        }

        public static explicit operator M22i(double[,] a)
        {
            return new M22i (
                (int)a[0, 0], (int)a[0, 1], 
                (int)a[1, 0], (int)a[1, 1]);
        }

        public static explicit operator double[](M22i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, 
                (double)m.M10, (double)m.M11
            };
        }

        public static explicit operator double[,](M22i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01 }, 
                { (double)m.M10, (double)m.M11 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M10;
            array[index + 3] = (double)M11;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<int, int> element_fun)
        {
            return new M22i(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M22i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<int, long> element_fun)
        {
            return new M22l(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M22l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<int, float> element_fun)
        {
            return new M22f(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M22f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<int, double> element_fun)
        {
            return new M22d(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M22d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        public int[] ToArray()
        {
            var array = new int[4];
            array[0] = M00;
            array[1] = M01;
            array[2] = M10;
            array[3] = M11;
            return array;
        }

        #endregion

        #region Static Factories

        public static M22i FromCols(V2i col0, V2i col1)
        {
            return new M22i(
                col0.X, col1.X, 
                col0.Y, col1.Y);
        }

        public static M22i FromRows(V2i row0, V2i row1)
        {
            return new M22i(
                row0.X, row0.Y, 
                row1.X, row1.Y);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<int> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M10;
                 yield return M11;
            }
        }

        public IEnumerable<V2i> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2i> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
            }
        }

        public V2i R0
        {                     
            get { return new V2i( M00,  M01); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
            }
        }

        public V2i R1
        {                     
            get { return new V2i( M10,  M11); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
            }
        }

        public V2i C0
        {           
            get { return new V2i( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2i C1
        {           
            get { return new V2i( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public int this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M10;
                    case 3: return M11;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M10 = value; return;
                    case 3: M11 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public int this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 2;
        public const int ElementCount = 2*2;

        public static readonly V2l Dimensions = new V2l(2, 2);

        public static readonly M22i Zero
                = new M22i(0, 0, 0, 0);

        public static readonly M22i Identity
                = new M22i(1, 0, 0, 1);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + 
                    Fun.Abs(M10) + Fun.Abs(M11);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + 
                    M10 * M10 + M11 * M11);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(M22i a, M22i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M22i a, M22i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M22i a, M22i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(M22i a, M22i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(M22i a, M22i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        #endregion

        #region Mathematical Operators

        public static M22i operator +(M22i a, M22i b)
        {
            return new M22i(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22i operator +(M22i m, int s)
        {
            return new M22i(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22i operator +(int s, M22i m)
        {
            return new M22i(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22l operator +(M22i a, M22l b)
        {
            return new M22l(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22l operator +(M22i m, long s)
        {
            return new M22l(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22l operator +(long s, M22i m)
        {
            return new M22l(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22f operator +(M22i a, M22f b)
        {
            return new M22f(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22f operator +(M22i m, float s)
        {
            return new M22f(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22f operator +(float s, M22i m)
        {
            return new M22f(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22d operator +(M22i a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22d operator +(M22i m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22d operator +(double s, M22i m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22i Add(M22i a, M22i b)
        {
            return new M22i(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22i Add(M22i m, int s)
        {
            return new M22i(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22i Add(int s, M22i m)
        {
            return new M22i(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22l Add(M22i a, M22l b)
        {
            return new M22l(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22l Add(M22i m, long s)
        {
            return new M22l(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22l Add(long s, M22i m)
        {
            return new M22l(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22f Add(M22i a, M22f b)
        {
            return new M22f(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22f Add(M22i m, float s)
        {
            return new M22f(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22f Add(float s, M22i m)
        {
            return new M22f(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22d Add(M22i a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22d Add(M22i m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22d Add(double s, M22i m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22i operator -(M22i a, M22i b)
        {
            return new M22i(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22i operator -(M22i m, int s)
        {
            return new M22i(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22i operator -(int s, M22i m)
        {
            return new M22i(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22l operator -(M22i a, M22l b)
        {
            return new M22l(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22l operator -(M22i m, long s)
        {
            return new M22l(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22l operator -(long s, M22i m)
        {
            return new M22l(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22f operator -(M22i a, M22f b)
        {
            return new M22f(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22f operator -(M22i m, float s)
        {
            return new M22f(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22f operator -(float s, M22i m)
        {
            return new M22f(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22d operator -(M22i a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22d operator -(M22i m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22d operator -(double s, M22i m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22i Subtract(M22i a, M22i b)
        {
            return new M22i(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22i Subtract(M22i m, int s)
        {
            return new M22i(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22i Subtract(int s, M22i m)
        {
            return new M22i(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22l Subtract(M22i a, M22l b)
        {
            return new M22l(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22l Subtract(M22i m, long s)
        {
            return new M22l(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22l Subtract(long s, M22i m)
        {
            return new M22l(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22f Subtract(M22i a, M22f b)
        {
            return new M22f(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22f Subtract(M22i m, float s)
        {
            return new M22f(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22f Subtract(float s, M22i m)
        {
            return new M22f(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22d Subtract(M22i a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22d Subtract(M22i m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22d Subtract(double s, M22i m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22i operator %(M22i a, M22i b)
        {
            return new M22i(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22i operator %(M22i m, int s)
        {
            return new M22i(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22i operator %(int s, M22i m)
        {
            return new M22i(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22l operator %(M22i a, M22l b)
        {
            return new M22l(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22l operator %(M22i m, long s)
        {
            return new M22l(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22l operator %(long s, M22i m)
        {
            return new M22l(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22f operator %(M22i a, M22f b)
        {
            return new M22f(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22f operator %(M22i m, float s)
        {
            return new M22f(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22f operator %(float s, M22i m)
        {
            return new M22f(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22d operator %(M22i a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22d operator %(M22i m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22d operator %(double s, M22i m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22i Modulo(M22i a, M22i b)
        {
            return new M22i(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22i Modulo(M22i m, int s)
        {
            return new M22i(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22i Modulo(int s, M22i m)
        {
            return new M22i(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22l Modulo(M22i a, M22l b)
        {
            return new M22l(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22l Modulo(M22i m, long s)
        {
            return new M22l(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22l Modulo(long s, M22i m)
        {
            return new M22l(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22f Modulo(M22i a, M22f b)
        {
            return new M22f(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22f Modulo(M22i m, float s)
        {
            return new M22f(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22f Modulo(float s, M22i m)
        {
            return new M22f(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22d Modulo(M22i a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22d Modulo(M22i m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22d Modulo(double s, M22i m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22i operator /(M22i a, M22i b)
        {
            return new M22i(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22i operator /(M22i m, int s)
        {
            return new M22i(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22i operator /(int s, M22i m)
        {
            return new M22i(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22l operator /(M22i a, M22l b)
        {
            return new M22l(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22l operator /(M22i m, long s)
        {
            return new M22l(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22l operator /(long s, M22i m)
        {
            return new M22l(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22f operator /(M22i a, M22f b)
        {
            return new M22f(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22f operator /(M22i m, float s)
        {
            return new M22f(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22f operator /(float s, M22i m)
        {
            return new M22f(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22d operator /(M22i a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22d operator /(M22i m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22d operator /(double s, M22i m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22i Divide(M22i a, M22i b)
        {
            return new M22i(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22i Divide(M22i m, int s)
        {
            return new M22i(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22i Divide(int s, M22i m)
        {
            return new M22i(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22l Divide(M22i a, M22l b)
        {
            return new M22l(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22l Divide(M22i m, long s)
        {
            return new M22l(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22l Divide(long s, M22i m)
        {
            return new M22l(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22f Divide(M22i a, M22f b)
        {
            return new M22f(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22f Divide(M22i m, float s)
        {
            return new M22f(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22f Divide(float s, M22i m)
        {
            return new M22f(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22d Divide(M22i a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22d Divide(M22i m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22d Divide(double s, M22i m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22i operator *(M22i m, int s)
        {
            return new M22i(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22i operator *(int s, M22i m)
        {
            return new M22i(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22l operator *(M22i m, long s)
        {
            return new M22l(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22l operator *(long s, M22i m)
        {
            return new M22l(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22f operator *(M22i m, float s)
        {
            return new M22f(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22f operator *(float s, M22i m)
        {
            return new M22f(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22d operator *(M22i m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22d operator *(double s, M22i m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22i Multiply(M22i m, int s)
        {
            return new M22i(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22i Multiply(int s, M22i m)
        {
            return new M22i(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22l Multiply(M22i m, long s)
        {
            return new M22l(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22l Multiply(long s, M22i m)
        {
            return new M22l(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22f Multiply(M22i m, float s)
        {
            return new M22f(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22f Multiply(float s, M22i m)
        {
            return new M22f(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22d Multiply(M22i m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22d Multiply(double s, M22i m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V2i Multiply(M22i m, V2i v)
        {
            return new V2i(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        public static V2i operator *(M22i m, V2i v)
        {
            return new V2i(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        public static V2i TransposedMultiply(V2i v, M22i m)
        {
            return new V2i(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M22i a, M22i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11;
        }

        public static bool operator <(M22i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M10 < s && 
                a.M11 < s;
        }

        public static bool operator <(int s, M22i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M10  && 
                s < a.M11 ;
        }

        public static bool operator >(M22i a, M22i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11;
        }

        public static bool operator >(M22i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M10 > s && 
                a.M11 > s;
        }

        public static bool operator >(int s, M22i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M10  && 
                s > a.M11 ;
        }

        public static bool operator ==(M22i a, M22i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11;
        }

        public static bool operator ==(M22i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M10 == s && 
                a.M11 == s;
        }

        public static bool operator ==(int s, M22i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M10  && 
                s == a.M11 ;
        }

        public static bool operator <=(M22i a, M22i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11;
        }

        public static bool operator <=(M22i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M10 <= s && 
                a.M11 <= s;
        }

        public static bool operator <=(int s, M22i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M10  && 
                s <= a.M11 ;
        }

        public static bool operator >=(M22i a, M22i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11;
        }

        public static bool operator >=(M22i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M10 >= s && 
                a.M11 >= s;
        }

        public static bool operator >=(int s, M22i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M10  && 
                s >= a.M11 ;
        }

        public static bool operator !=(M22i a, M22i b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M22i m, int s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(int s, M22i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M22i) ? (this == (M22i)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M22i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M22i.FromRows(
                V2i.Parse(x[0]), 
                V2i.Parse(x[1])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static int TransformDir(M22i m, int v)
        {
            return m.M00 * v;
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static int TransformPos(M22i m, int p)
        {
            return m.M00 * p + m.M01;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m. 
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static int TransformPosProj(M22i m, int p)
        {
            int s = m.M10 * p + m.M11;
            s = 1 / s;
            return (TransformPos(m, p)) * s;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m. 
        /// Projective transform is performed.
        /// </summary>
        public static V2i TransformPosProjFull(M22i m, int p)
        {
            return new V2i(TransformPos(m, p), m.M10 * p + m.M11);
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public int TransformDir(int v)
        {
            return TransformDir(this, v);
        }

        public int TransformPos(int p)
        {
            return TransformPos(this, p);
        }

        public int TransformPosProj(int p)
        {
            return TransformPosProj(this, p);
        }

        public V2i TransformPosProjFull(int p)
        {
            return TransformPosProjFull(this, p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V2i Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V2i Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public int Trace
        {
            get { return M00 + M11 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public int Det
        {
            get
            {
                return M00 * M11 - M10 * M01;
            }
        }
        
        /// <summary>
        /// Returns the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public int Determinant()
        {
            return Det;
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible { get { return Det != 0; } }
        
        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular { get { return Det == 0; } }

        /// <summary>
        /// Transposes this matrix (and returns this).
        /// </summary>
        public void Transpose()
        {
            Fun.Swap(ref M10, ref M01);
        }
        
        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M22i Transposed
        {
            get
            {
                return new M22i {
                    M00 = M00, M01 = M10, 
                    M10 = M01, M11 = M11
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M22i operator *(M22i a, M22i b)
        {
            return new M22i(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        public static M22i Multiply(M22i a, M22i b)
        {
            return new M22i(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M22iEqualityComparer : IEqualityComparer<M22i>
    {
        public static readonly M22iEqualityComparer Default
            = new M22iEqualityComparer();

        #region IEqualityComparer<M22i> Members

        public bool Equals(M22i v0, M22i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M22i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M22l

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M22l : IValidity, IMatrix<double>
    {
        public long M00, M01;
        public long M10, M11;

        #region Constructors

        public M22l(
                long m00, long m01, 
                long m10, long m11)
        {
            M00 = m00; M01 = m01; 
            M10 = m10; M11 = m11; 
        }

        public M22l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M10 = a[2];
            M11 = a[3];
        }
        
        public M22l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M10 = a[start + 2];
            M11 = a[start + 3];
        }

        #endregion

        #region Conversions

        public static explicit operator M22l(M22i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M23i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M33i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M34i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M44i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M23l m)
        {
            return new M22l {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22l(M33l m)
        {
            return new M22l {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22l(M34l m)
        {
            return new M22l {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22l(M44l m)
        {
            return new M22l {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22l(M22f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M23f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M33f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M34f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M44f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M22d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M23d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M33d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M34d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M44d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(int[] a)
        {
            return new M22l(
                (long)a[0], (long)a[1], 
                (long)a[2], (long)a[3]);
        }

        public static explicit operator M22l(int[,] a)
        {
            return new M22l (
                (long)a[0, 0], (long)a[0, 1], 
                (long)a[1, 0], (long)a[1, 1]);
        }

        public static explicit operator int[](M22l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, 
                (int)m.M10, (int)m.M11
            };
        }

        public static explicit operator int[,](M22l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01 }, 
                { (int)m.M10, (int)m.M11 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M10;
            array[index + 3] = (int)M11;
        }

        public static explicit operator M22l(long[] a)
        {
            return new M22l(
                a[0], a[1], 
                a[2], a[3]);
        }

        public static explicit operator M22l(long[,] a)
        {
            return new M22l (
                a[0, 0], a[0, 1], 
                a[1, 0], a[1, 1]);
        }

        public static explicit operator long[](M22l m)
        {
            return new long[] {
                m.M00, m.M01, 
                m.M10, m.M11
            };
        }

        public static explicit operator long[,](M22l m)
        {
            return new long[,] {
                { m.M00, m.M01 }, 
                { m.M10, m.M11 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M10;
            array[index + 3] = M11;
        }

        public static explicit operator M22l(float[] a)
        {
            return new M22l(
                (long)a[0], (long)a[1], 
                (long)a[2], (long)a[3]);
        }

        public static explicit operator M22l(float[,] a)
        {
            return new M22l (
                (long)a[0, 0], (long)a[0, 1], 
                (long)a[1, 0], (long)a[1, 1]);
        }

        public static explicit operator float[](M22l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, 
                (float)m.M10, (float)m.M11
            };
        }

        public static explicit operator float[,](M22l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01 }, 
                { (float)m.M10, (float)m.M11 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M10;
            array[index + 3] = (float)M11;
        }

        public static explicit operator M22l(double[] a)
        {
            return new M22l(
                (long)a[0], (long)a[1], 
                (long)a[2], (long)a[3]);
        }

        public static explicit operator M22l(double[,] a)
        {
            return new M22l (
                (long)a[0, 0], (long)a[0, 1], 
                (long)a[1, 0], (long)a[1, 1]);
        }

        public static explicit operator double[](M22l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, 
                (double)m.M10, (double)m.M11
            };
        }

        public static explicit operator double[,](M22l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01 }, 
                { (double)m.M10, (double)m.M11 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M10;
            array[index + 3] = (double)M11;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<long, int> element_fun)
        {
            return new M22i(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M22i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<long, long> element_fun)
        {
            return new M22l(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M22l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<long, float> element_fun)
        {
            return new M22f(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M22f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<long, double> element_fun)
        {
            return new M22d(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M22d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        public long[] ToArray()
        {
            var array = new long[4];
            array[0] = M00;
            array[1] = M01;
            array[2] = M10;
            array[3] = M11;
            return array;
        }

        #endregion

        #region Static Factories

        public static M22l FromCols(V2l col0, V2l col1)
        {
            return new M22l(
                col0.X, col1.X, 
                col0.Y, col1.Y);
        }

        public static M22l FromRows(V2l row0, V2l row1)
        {
            return new M22l(
                row0.X, row0.Y, 
                row1.X, row1.Y);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<long> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M10;
                 yield return M11;
            }
        }

        public IEnumerable<V2l> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2l> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
            }
        }

        public V2l R0
        {                     
            get { return new V2l( M00,  M01); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
            }
        }

        public V2l R1
        {                     
            get { return new V2l( M10,  M11); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
            }
        }

        public V2l C0
        {           
            get { return new V2l( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2l C1
        {           
            get { return new V2l( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public long this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M10;
                    case 3: return M11;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M10 = value; return;
                    case 3: M11 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public long this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 2;
        public const int ElementCount = 2*2;

        public static readonly V2l Dimensions = new V2l(2, 2);

        public static readonly M22l Zero
                = new M22l(0, 0, 0, 0);

        public static readonly M22l Identity
                = new M22l(1, 0, 0, 1);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + 
                    Fun.Abs(M10) + Fun.Abs(M11);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + 
                    M10 * M10 + M11 * M11);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(M22l a, M22l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M22l a, M22l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M22l a, M22l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(M22l a, M22l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(M22l a, M22l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        #endregion

        #region Mathematical Operators

        public static M22l operator +(M22l a, M22l b)
        {
            return new M22l(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22l operator +(M22l m, long s)
        {
            return new M22l(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22l operator +(long s, M22l m)
        {
            return new M22l(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22f operator +(M22l a, M22f b)
        {
            return new M22f(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22f operator +(M22l m, float s)
        {
            return new M22f(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22f operator +(float s, M22l m)
        {
            return new M22f(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22d operator +(M22l a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22d operator +(M22l m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22d operator +(double s, M22l m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22l Add(M22l a, M22l b)
        {
            return new M22l(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22l Add(M22l m, long s)
        {
            return new M22l(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22l Add(long s, M22l m)
        {
            return new M22l(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22f Add(M22l a, M22f b)
        {
            return new M22f(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22f Add(M22l m, float s)
        {
            return new M22f(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22f Add(float s, M22l m)
        {
            return new M22f(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22d Add(M22l a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22d Add(M22l m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22d Add(double s, M22l m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22l operator -(M22l a, M22l b)
        {
            return new M22l(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22l operator -(M22l m, long s)
        {
            return new M22l(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22l operator -(long s, M22l m)
        {
            return new M22l(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22f operator -(M22l a, M22f b)
        {
            return new M22f(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22f operator -(M22l m, float s)
        {
            return new M22f(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22f operator -(float s, M22l m)
        {
            return new M22f(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22d operator -(M22l a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22d operator -(M22l m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22d operator -(double s, M22l m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22l Subtract(M22l a, M22l b)
        {
            return new M22l(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22l Subtract(M22l m, long s)
        {
            return new M22l(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22l Subtract(long s, M22l m)
        {
            return new M22l(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22f Subtract(M22l a, M22f b)
        {
            return new M22f(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22f Subtract(M22l m, float s)
        {
            return new M22f(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22f Subtract(float s, M22l m)
        {
            return new M22f(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22d Subtract(M22l a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22d Subtract(M22l m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22d Subtract(double s, M22l m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22l operator %(M22l a, M22l b)
        {
            return new M22l(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22l operator %(M22l m, long s)
        {
            return new M22l(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22l operator %(long s, M22l m)
        {
            return new M22l(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22f operator %(M22l a, M22f b)
        {
            return new M22f(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22f operator %(M22l m, float s)
        {
            return new M22f(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22f operator %(float s, M22l m)
        {
            return new M22f(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22d operator %(M22l a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22d operator %(M22l m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22d operator %(double s, M22l m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22l Modulo(M22l a, M22l b)
        {
            return new M22l(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22l Modulo(M22l m, long s)
        {
            return new M22l(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22l Modulo(long s, M22l m)
        {
            return new M22l(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22f Modulo(M22l a, M22f b)
        {
            return new M22f(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22f Modulo(M22l m, float s)
        {
            return new M22f(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22f Modulo(float s, M22l m)
        {
            return new M22f(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22d Modulo(M22l a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22d Modulo(M22l m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22d Modulo(double s, M22l m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22l operator /(M22l a, M22l b)
        {
            return new M22l(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22l operator /(M22l m, long s)
        {
            return new M22l(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22l operator /(long s, M22l m)
        {
            return new M22l(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22f operator /(M22l a, M22f b)
        {
            return new M22f(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22f operator /(M22l m, float s)
        {
            return new M22f(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22f operator /(float s, M22l m)
        {
            return new M22f(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22d operator /(M22l a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22d operator /(M22l m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22d operator /(double s, M22l m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22l Divide(M22l a, M22l b)
        {
            return new M22l(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22l Divide(M22l m, long s)
        {
            return new M22l(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22l Divide(long s, M22l m)
        {
            return new M22l(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22f Divide(M22l a, M22f b)
        {
            return new M22f(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22f Divide(M22l m, float s)
        {
            return new M22f(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22f Divide(float s, M22l m)
        {
            return new M22f(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22d Divide(M22l a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22d Divide(M22l m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22d Divide(double s, M22l m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22l operator *(M22l m, long s)
        {
            return new M22l(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22l operator *(long s, M22l m)
        {
            return new M22l(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22f operator *(M22l m, float s)
        {
            return new M22f(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22f operator *(float s, M22l m)
        {
            return new M22f(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22d operator *(M22l m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22d operator *(double s, M22l m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22l Multiply(M22l m, long s)
        {
            return new M22l(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22l Multiply(long s, M22l m)
        {
            return new M22l(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22f Multiply(M22l m, float s)
        {
            return new M22f(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22f Multiply(float s, M22l m)
        {
            return new M22f(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22d Multiply(M22l m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22d Multiply(double s, M22l m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V2l Multiply(M22l m, V2l v)
        {
            return new V2l(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        public static V2l operator *(M22l m, V2l v)
        {
            return new V2l(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        public static V2l TransposedMultiply(V2l v, M22l m)
        {
            return new V2l(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M22l a, M22l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11;
        }

        public static bool operator <(M22l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M10 < s && 
                a.M11 < s;
        }

        public static bool operator <(long s, M22l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M10  && 
                s < a.M11 ;
        }

        public static bool operator >(M22l a, M22l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11;
        }

        public static bool operator >(M22l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M10 > s && 
                a.M11 > s;
        }

        public static bool operator >(long s, M22l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M10  && 
                s > a.M11 ;
        }

        public static bool operator ==(M22l a, M22l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11;
        }

        public static bool operator ==(M22l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M10 == s && 
                a.M11 == s;
        }

        public static bool operator ==(long s, M22l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M10  && 
                s == a.M11 ;
        }

        public static bool operator <=(M22l a, M22l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11;
        }

        public static bool operator <=(M22l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M10 <= s && 
                a.M11 <= s;
        }

        public static bool operator <=(long s, M22l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M10  && 
                s <= a.M11 ;
        }

        public static bool operator >=(M22l a, M22l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11;
        }

        public static bool operator >=(M22l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M10 >= s && 
                a.M11 >= s;
        }

        public static bool operator >=(long s, M22l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M10  && 
                s >= a.M11 ;
        }

        public static bool operator !=(M22l a, M22l b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M22l m, long s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(long s, M22l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M22l) ? (this == (M22l)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M22l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M22l.FromRows(
                V2l.Parse(x[0]), 
                V2l.Parse(x[1])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static long TransformDir(M22l m, long v)
        {
            return m.M00 * v;
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static long TransformPos(M22l m, long p)
        {
            return m.M00 * p + m.M01;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m. 
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static long TransformPosProj(M22l m, long p)
        {
            long s = m.M10 * p + m.M11;
            s = 1 / s;
            return (TransformPos(m, p)) * s;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m. 
        /// Projective transform is performed.
        /// </summary>
        public static V2l TransformPosProjFull(M22l m, long p)
        {
            return new V2l(TransformPos(m, p), m.M10 * p + m.M11);
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public long TransformDir(long v)
        {
            return TransformDir(this, v);
        }

        public long TransformPos(long p)
        {
            return TransformPos(this, p);
        }

        public long TransformPosProj(long p)
        {
            return TransformPosProj(this, p);
        }

        public V2l TransformPosProjFull(long p)
        {
            return TransformPosProjFull(this, p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V2l Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V2l Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public long Trace
        {
            get { return M00 + M11 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public long Det
        {
            get
            {
                return M00 * M11 - M10 * M01;
            }
        }
        
        /// <summary>
        /// Returns the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public long Determinant()
        {
            return Det;
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible { get { return Det != 0; } }
        
        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular { get { return Det == 0; } }

        /// <summary>
        /// Transposes this matrix (and returns this).
        /// </summary>
        public void Transpose()
        {
            Fun.Swap(ref M10, ref M01);
        }
        
        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M22l Transposed
        {
            get
            {
                return new M22l {
                    M00 = M00, M01 = M10, 
                    M10 = M01, M11 = M11
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M22l operator *(M22l a, M22l b)
        {
            return new M22l(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        public static M22l Multiply(M22l a, M22l b)
        {
            return new M22l(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M22lEqualityComparer : IEqualityComparer<M22l>
    {
        public static readonly M22lEqualityComparer Default
            = new M22lEqualityComparer();

        #region IEqualityComparer<M22l> Members

        public bool Equals(M22l v0, M22l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M22l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M22f

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M22f : IValidity, IMatrix<double>
    {
        public float M00, M01;
        public float M10, M11;

        #region Constructors

        public M22f(
                float m00, float m01, 
                float m10, float m11)
        {
            M00 = m00; M01 = m01; 
            M10 = m10; M11 = m11; 
        }

        public M22f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M10 = a[2];
            M11 = a[3];
        }
        
        public M22f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M10 = a[start + 2];
            M11 = a[start + 3];
        }

        #endregion

        #region Conversions

        public static explicit operator M22f(M22i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M23i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M33i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M34i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M44i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M22l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M23l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M33l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M34l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M44l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M23f m)
        {
            return new M22f {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22f(M33f m)
        {
            return new M22f {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22f(M34f m)
        {
            return new M22f {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22f(M44f m)
        {
            return new M22f {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22f(M22d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M23d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M33d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M34d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M44d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(int[] a)
        {
            return new M22f(
                (float)a[0], (float)a[1], 
                (float)a[2], (float)a[3]);
        }

        public static explicit operator M22f(int[,] a)
        {
            return new M22f (
                (float)a[0, 0], (float)a[0, 1], 
                (float)a[1, 0], (float)a[1, 1]);
        }

        public static explicit operator int[](M22f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, 
                (int)m.M10, (int)m.M11
            };
        }

        public static explicit operator int[,](M22f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01 }, 
                { (int)m.M10, (int)m.M11 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M10;
            array[index + 3] = (int)M11;
        }

        public static explicit operator M22f(long[] a)
        {
            return new M22f(
                (float)a[0], (float)a[1], 
                (float)a[2], (float)a[3]);
        }

        public static explicit operator M22f(long[,] a)
        {
            return new M22f (
                (float)a[0, 0], (float)a[0, 1], 
                (float)a[1, 0], (float)a[1, 1]);
        }

        public static explicit operator long[](M22f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, 
                (long)m.M10, (long)m.M11
            };
        }

        public static explicit operator long[,](M22f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01 }, 
                { (long)m.M10, (long)m.M11 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M10;
            array[index + 3] = (long)M11;
        }

        public static explicit operator M22f(float[] a)
        {
            return new M22f(
                a[0], a[1], 
                a[2], a[3]);
        }

        public static explicit operator M22f(float[,] a)
        {
            return new M22f (
                a[0, 0], a[0, 1], 
                a[1, 0], a[1, 1]);
        }

        public static explicit operator float[](M22f m)
        {
            return new float[] {
                m.M00, m.M01, 
                m.M10, m.M11
            };
        }

        public static explicit operator float[,](M22f m)
        {
            return new float[,] {
                { m.M00, m.M01 }, 
                { m.M10, m.M11 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M10;
            array[index + 3] = M11;
        }

        public static explicit operator M22f(double[] a)
        {
            return new M22f(
                (float)a[0], (float)a[1], 
                (float)a[2], (float)a[3]);
        }

        public static explicit operator M22f(double[,] a)
        {
            return new M22f (
                (float)a[0, 0], (float)a[0, 1], 
                (float)a[1, 0], (float)a[1, 1]);
        }

        public static explicit operator double[](M22f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, 
                (double)m.M10, (double)m.M11
            };
        }

        public static explicit operator double[,](M22f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01 }, 
                { (double)m.M10, (double)m.M11 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M10;
            array[index + 3] = (double)M11;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<float, int> element_fun)
        {
            return new M22i(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M22i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<float, long> element_fun)
        {
            return new M22l(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M22l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<float, float> element_fun)
        {
            return new M22f(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M22f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<float, double> element_fun)
        {
            return new M22d(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M22d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        public float[] ToArray()
        {
            var array = new float[4];
            array[0] = M00;
            array[1] = M01;
            array[2] = M10;
            array[3] = M11;
            return array;
        }

        #endregion

        #region Static Factories

        public static M22f FromCols(V2f col0, V2f col1)
        {
            return new M22f(
                col0.X, col1.X, 
                col0.Y, col1.Y);
        }

        public static M22f FromRows(V2f row0, V2f row1)
        {
            return new M22f(
                row0.X, row0.Y, 
                row1.X, row1.Y);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<float> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M10;
                 yield return M11;
            }
        }

        public IEnumerable<V2f> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2f> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
            }
        }

        public V2f R0
        {                     
            get { return new V2f( M00,  M01); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
            }
        }

        public V2f R1
        {                     
            get { return new V2f( M10,  M11); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
            }
        }

        public V2f C0
        {           
            get { return new V2f( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2f C1
        {           
            get { return new V2f( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M10;
                    case 3: return M11;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M10 = value; return;
                    case 3: M11 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public float this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 2;
        public const int ElementCount = 2*2;

        public static readonly V2l Dimensions = new V2l(2, 2);

        public static readonly M22f Zero
                = new M22f(0, 0, 0, 0);

        public static readonly M22f Identity
                = new M22f(1, 0, 0, 1);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + 
                    Fun.Abs(M10) + Fun.Abs(M11);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + 
                    M10 * M10 + M11 * M11);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public float Norm(float p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(M22f a, M22f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(M22f a, M22f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(M22f a, M22f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(M22f a, M22f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(M22f a, M22f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        #endregion

        #region Mathematical Operators

        public static M22f operator +(M22f a, M22f b)
        {
            return new M22f(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22f operator +(M22f m, float s)
        {
            return new M22f(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22f operator +(float s, M22f m)
        {
            return new M22f(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22d operator +(M22f a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22d operator +(M22f m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22d operator +(double s, M22f m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22f Add(M22f a, M22f b)
        {
            return new M22f(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22f Add(M22f m, float s)
        {
            return new M22f(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22f Add(float s, M22f m)
        {
            return new M22f(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22d Add(M22f a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22d Add(M22f m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22d Add(double s, M22f m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22f operator -(M22f a, M22f b)
        {
            return new M22f(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22f operator -(M22f m, float s)
        {
            return new M22f(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22f operator -(float s, M22f m)
        {
            return new M22f(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22d operator -(M22f a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22d operator -(M22f m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22d operator -(double s, M22f m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22f Subtract(M22f a, M22f b)
        {
            return new M22f(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22f Subtract(M22f m, float s)
        {
            return new M22f(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22f Subtract(float s, M22f m)
        {
            return new M22f(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22d Subtract(M22f a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22d Subtract(M22f m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22d Subtract(double s, M22f m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22f operator %(M22f a, M22f b)
        {
            return new M22f(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22f operator %(M22f m, float s)
        {
            return new M22f(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22f operator %(float s, M22f m)
        {
            return new M22f(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22d operator %(M22f a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22d operator %(M22f m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22d operator %(double s, M22f m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22f Modulo(M22f a, M22f b)
        {
            return new M22f(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22f Modulo(M22f m, float s)
        {
            return new M22f(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22f Modulo(float s, M22f m)
        {
            return new M22f(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22d Modulo(M22f a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22d Modulo(M22f m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22d Modulo(double s, M22f m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22f operator /(M22f a, M22f b)
        {
            return new M22f(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22f operator /(M22f m, float s)
        {
            return new M22f(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22f operator /(float s, M22f m)
        {
            return new M22f(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22d operator /(M22f a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22d operator /(M22f m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22d operator /(double s, M22f m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22f Divide(M22f a, M22f b)
        {
            return new M22f(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22f Divide(M22f m, float s)
        {
            return new M22f(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22f Divide(float s, M22f m)
        {
            return new M22f(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22d Divide(M22f a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22d Divide(M22f m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22d Divide(double s, M22f m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22f operator *(M22f m, float s)
        {
            return new M22f(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22f operator *(float s, M22f m)
        {
            return new M22f(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22d operator *(M22f m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22d operator *(double s, M22f m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22f Multiply(M22f m, float s)
        {
            return new M22f(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22f Multiply(float s, M22f m)
        {
            return new M22f(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22d Multiply(M22f m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22d Multiply(double s, M22f m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V2f Multiply(M22f m, V2f v)
        {
            return new V2f(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        public static V2f operator *(M22f m, V2f v)
        {
            return new V2f(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        public static V2f TransposedMultiply(V2f v, M22f m)
        {
            return new V2f(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M22f a, M22f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11;
        }

        public static bool operator <(M22f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M10 < s && 
                a.M11 < s;
        }

        public static bool operator <(float s, M22f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M10  && 
                s < a.M11 ;
        }

        public static bool operator >(M22f a, M22f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11;
        }

        public static bool operator >(M22f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M10 > s && 
                a.M11 > s;
        }

        public static bool operator >(float s, M22f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M10  && 
                s > a.M11 ;
        }

        public static bool operator ==(M22f a, M22f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11;
        }

        public static bool operator ==(M22f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M10 == s && 
                a.M11 == s;
        }

        public static bool operator ==(float s, M22f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M10  && 
                s == a.M11 ;
        }

        public static bool operator <=(M22f a, M22f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11;
        }

        public static bool operator <=(M22f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M10 <= s && 
                a.M11 <= s;
        }

        public static bool operator <=(float s, M22f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M10  && 
                s <= a.M11 ;
        }

        public static bool operator >=(M22f a, M22f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11;
        }

        public static bool operator >=(M22f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M10 >= s && 
                a.M11 >= s;
        }

        public static bool operator >=(float s, M22f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M10  && 
                s >= a.M11 ;
        }

        public static bool operator !=(M22f a, M22f b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M22f m, float s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(float s, M22f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M22f) ? (this == (M22f)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M22f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M22f.FromRows(
                V2f.Parse(x[0]), 
                V2f.Parse(x[1])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static float TransformDir(M22f m, float v)
        {
            return m.M00 * v;
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static float TransformPos(M22f m, float p)
        {
            return m.M00 * p + m.M01;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m. 
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static float TransformPosProj(M22f m, float p)
        {
            float s = m.M10 * p + m.M11;
            s = 1 / s;
            return (TransformPos(m, p)) * s;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m. 
        /// Projective transform is performed.
        /// </summary>
        public static V2f TransformPosProjFull(M22f m, float p)
        {
            return new V2f(TransformPos(m, p), m.M10 * p + m.M11);
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public float TransformDir(float v)
        {
            return TransformDir(this, v);
        }

        public float TransformPos(float p)
        {
            return TransformPos(this, p);
        }

        public float TransformPosProj(float p)
        {
            return TransformPosProj(this, p);
        }

        public V2f TransformPosProjFull(float p)
        {
            return TransformPosProjFull(this, p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V2f Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V2f Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public float Trace
        {
            get { return M00 + M11 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public float Det
        {
            get
            {
                return M00 * M11 - M10 * M01;
            }
        }
        
        /// <summary>
        /// Returns the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public float Determinant()
        {
            return Det;
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible { get { return Det != 0; } }
        
        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular { get { return Det == 0; } }

        /// <summary>
        /// Transposes this matrix (and returns this).
        /// </summary>
        public void Transpose()
        {
            Fun.Swap(ref M10, ref M01);
        }
        
        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M22f Transposed
        {
            get
            {
                return new M22f {
                    M00 = M00, M01 = M10, 
                    M10 = M01, M11 = M11
                };
            }
        }

        private static V2l s_luSize = new V2l(2, 2);
        private static V2l s_luDelta = new V2l(1, 2);

        /// <summary>
        /// Inverts the matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return false;
            this = (M22f)(lu.LuInverse(p).Data);
            return true;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M22f.Zero is returned.
        /// </summary>
        public M22f LuInverse()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return M22f.Zero;
            return (M22f)(lu.LuInverse(p).Data);
        }

        /// <summary>
        /// Inverts the matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        public bool Invert() { return LuInvert();  }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M22f.Zero is returned.
        /// </summary>
        public M22f Inverse { get { return LuInverse(); } }

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximatelyEquals(M22f a, M22f b, float epsilon)
        {
            return DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        /// <summary>
        /// Returns if the matrix is the identity matrix I.
        /// </summary>
        public bool IsIdentity(float epsilon)
        {
            return ApproximatelyEquals(this, Identity, epsilon);
        }

        /// <summary>
        /// Returns if the matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        public bool IsOrthonormal(float epsilon)
        {
            var i = this * this.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        public bool IsOrthogonal(float epsilon)
        {
            var i = this * this.Transposed;
            for (int j = 0; j < 2; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }
        #endregion

        #region Matrix Multiplication

        public static M22f operator *(M22f a, M22f b)
        {
            return new M22f(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        public static M22f Multiply(M22f a, M22f b)
        {
            return new M22f(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M22fEqualityComparer : IEqualityComparer<M22f>
    {
        public static readonly M22fEqualityComparer Default
            = new M22fEqualityComparer();

        #region IEqualityComparer<M22f> Members

        public bool Equals(M22f v0, M22f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M22f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M22d

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M22d : IValidity, IMatrix<double>
    {
        public double M00, M01;
        public double M10, M11;

        #region Constructors

        public M22d(
                double m00, double m01, 
                double m10, double m11)
        {
            M00 = m00; M01 = m01; 
            M10 = m10; M11 = m11; 
        }

        public M22d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M10 = a[2];
            M11 = a[3];
        }
        
        public M22d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M10 = a[start + 2];
            M11 = a[start + 3];
        }

        #endregion

        #region Conversions

        public static explicit operator M22d(M22i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M23i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M33i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M34i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M44i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M22l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M23l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M33l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M34l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M44l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M22f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M23f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M33f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M34f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M44f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M23d m)
        {
            return new M22d {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22d(M33d m)
        {
            return new M22d {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22d(M34d m)
        {
            return new M22d {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22d(M44d m)
        {
            return new M22d {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22d(int[] a)
        {
            return new M22d(
                (double)a[0], (double)a[1], 
                (double)a[2], (double)a[3]);
        }

        public static explicit operator M22d(int[,] a)
        {
            return new M22d (
                (double)a[0, 0], (double)a[0, 1], 
                (double)a[1, 0], (double)a[1, 1]);
        }

        public static explicit operator int[](M22d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, 
                (int)m.M10, (int)m.M11
            };
        }

        public static explicit operator int[,](M22d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01 }, 
                { (int)m.M10, (int)m.M11 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M10;
            array[index + 3] = (int)M11;
        }

        public static explicit operator M22d(long[] a)
        {
            return new M22d(
                (double)a[0], (double)a[1], 
                (double)a[2], (double)a[3]);
        }

        public static explicit operator M22d(long[,] a)
        {
            return new M22d (
                (double)a[0, 0], (double)a[0, 1], 
                (double)a[1, 0], (double)a[1, 1]);
        }

        public static explicit operator long[](M22d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, 
                (long)m.M10, (long)m.M11
            };
        }

        public static explicit operator long[,](M22d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01 }, 
                { (long)m.M10, (long)m.M11 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M10;
            array[index + 3] = (long)M11;
        }

        public static explicit operator M22d(float[] a)
        {
            return new M22d(
                (double)a[0], (double)a[1], 
                (double)a[2], (double)a[3]);
        }

        public static explicit operator M22d(float[,] a)
        {
            return new M22d (
                (double)a[0, 0], (double)a[0, 1], 
                (double)a[1, 0], (double)a[1, 1]);
        }

        public static explicit operator float[](M22d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, 
                (float)m.M10, (float)m.M11
            };
        }

        public static explicit operator float[,](M22d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01 }, 
                { (float)m.M10, (float)m.M11 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M10;
            array[index + 3] = (float)M11;
        }

        public static explicit operator M22d(double[] a)
        {
            return new M22d(
                a[0], a[1], 
                a[2], a[3]);
        }

        public static explicit operator M22d(double[,] a)
        {
            return new M22d (
                a[0, 0], a[0, 1], 
                a[1, 0], a[1, 1]);
        }

        public static explicit operator double[](M22d m)
        {
            return new double[] {
                m.M00, m.M01, 
                m.M10, m.M11
            };
        }

        public static explicit operator double[,](M22d m)
        {
            return new double[,] {
                { m.M00, m.M01 }, 
                { m.M10, m.M11 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M10;
            array[index + 3] = M11;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<double, int> element_fun)
        {
            return new M22i(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M22i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<double, long> element_fun)
        {
            return new M22l(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M22l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<double, float> element_fun)
        {
            return new M22f(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M22f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<double, double> element_fun)
        {
            return new M22d(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M22d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        public double[] ToArray()
        {
            var array = new double[4];
            array[0] = M00;
            array[1] = M01;
            array[2] = M10;
            array[3] = M11;
            return array;
        }

        #endregion

        #region Static Factories

        public static M22d FromCols(V2d col0, V2d col1)
        {
            return new M22d(
                col0.X, col1.X, 
                col0.Y, col1.Y);
        }

        public static M22d FromRows(V2d row0, V2d row1)
        {
            return new M22d(
                row0.X, row0.Y, 
                row1.X, row1.Y);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<double> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M10;
                 yield return M11;
            }
        }

        public IEnumerable<V2d> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2d> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
            }
        }

        public V2d R0
        {                     
            get { return new V2d( M00,  M01); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
            }
        }

        public V2d R1
        {                     
            get { return new V2d( M10,  M11); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
            }
        }

        public V2d C0
        {           
            get { return new V2d( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2d C1
        {           
            get { return new V2d( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public double this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M10;
                    case 3: return M11;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M10 = value; return;
                    case 3: M11 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public double this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 2;
        public const int ElementCount = 2*2;

        public static readonly V2l Dimensions = new V2l(2, 2);

        public static readonly M22d Zero
                = new M22d(0, 0, 0, 0);

        public static readonly M22d Identity
                = new M22d(1, 0, 0, 1);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + 
                    Fun.Abs(M10) + Fun.Abs(M11);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + 
                    M10 * M10 + M11 * M11);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(M22d a, M22d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M22d a, M22d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M22d a, M22d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(M22d a, M22d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(M22d a, M22d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        #endregion

        #region Mathematical Operators

        public static M22d operator +(M22d a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22d operator +(M22d m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22d operator +(double s, M22d m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22d Add(M22d a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        public static M22d Add(M22d m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }
        
        public static M22d Add(double s, M22d m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        public static M22d operator -(M22d a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22d operator -(M22d m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22d operator -(double s, M22d m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22d Subtract(M22d a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        public static M22d Subtract(M22d m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }
        
        public static M22d Subtract(double s, M22d m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        public static M22d operator %(M22d a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22d operator %(M22d m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22d operator %(double s, M22d m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22d Modulo(M22d a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        public static M22d Modulo(M22d m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }
        
        public static M22d Modulo(double s, M22d m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        public static M22d operator /(M22d a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22d operator /(M22d m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22d operator /(double s, M22d m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22d Divide(M22d a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        public static M22d Divide(M22d m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }
        
        public static M22d Divide(double s, M22d m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        public static M22d operator *(M22d m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22d operator *(double s, M22d m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        public static M22d Multiply(M22d m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }
        
        public static M22d Multiply(double s, M22d m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V2d Multiply(M22d m, V2d v)
        {
            return new V2d(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        public static V2d operator *(M22d m, V2d v)
        {
            return new V2d(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        public static V2d TransposedMultiply(V2d v, M22d m)
        {
            return new V2d(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M22d a, M22d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11;
        }

        public static bool operator <(M22d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M10 < s && 
                a.M11 < s;
        }

        public static bool operator <(double s, M22d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M10  && 
                s < a.M11 ;
        }

        public static bool operator >(M22d a, M22d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11;
        }

        public static bool operator >(M22d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M10 > s && 
                a.M11 > s;
        }

        public static bool operator >(double s, M22d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M10  && 
                s > a.M11 ;
        }

        public static bool operator ==(M22d a, M22d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11;
        }

        public static bool operator ==(M22d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M10 == s && 
                a.M11 == s;
        }

        public static bool operator ==(double s, M22d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M10  && 
                s == a.M11 ;
        }

        public static bool operator <=(M22d a, M22d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11;
        }

        public static bool operator <=(M22d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M10 <= s && 
                a.M11 <= s;
        }

        public static bool operator <=(double s, M22d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M10  && 
                s <= a.M11 ;
        }

        public static bool operator >=(M22d a, M22d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11;
        }

        public static bool operator >=(M22d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M10 >= s && 
                a.M11 >= s;
        }

        public static bool operator >=(double s, M22d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M10  && 
                s >= a.M11 ;
        }

        public static bool operator !=(M22d a, M22d b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M22d m, double s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(double s, M22d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M22d) ? (this == (M22d)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M22d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M22d.FromRows(
                V2d.Parse(x[0]), 
                V2d.Parse(x[1])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static double TransformDir(M22d m, double v)
        {
            return m.M00 * v;
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static double TransformPos(M22d m, double p)
        {
            return m.M00 * p + m.M01;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m. 
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static double TransformPosProj(M22d m, double p)
        {
            double s = m.M10 * p + m.M11;
            s = 1 / s;
            return (TransformPos(m, p)) * s;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m. 
        /// Projective transform is performed.
        /// </summary>
        public static V2d TransformPosProjFull(M22d m, double p)
        {
            return new V2d(TransformPos(m, p), m.M10 * p + m.M11);
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public double TransformDir(double v)
        {
            return TransformDir(this, v);
        }

        public double TransformPos(double p)
        {
            return TransformPos(this, p);
        }

        public double TransformPosProj(double p)
        {
            return TransformPosProj(this, p);
        }

        public V2d TransformPosProjFull(double p)
        {
            return TransformPosProjFull(this, p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V2d Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V2d Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public double Trace
        {
            get { return M00 + M11 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public double Det
        {
            get
            {
                return M00 * M11 - M10 * M01;
            }
        }
        
        /// <summary>
        /// Returns the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public double Determinant()
        {
            return Det;
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible { get { return Det != 0; } }
        
        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular { get { return Det == 0; } }

        /// <summary>
        /// Transposes this matrix (and returns this).
        /// </summary>
        public void Transpose()
        {
            Fun.Swap(ref M10, ref M01);
        }
        
        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M22d Transposed
        {
            get
            {
                return new M22d {
                    M00 = M00, M01 = M10, 
                    M10 = M01, M11 = M11
                };
            }
        }

        private static V2l s_luSize = new V2l(2, 2);
        private static V2l s_luDelta = new V2l(1, 2);

        /// <summary>
        /// Inverts the matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return false;
            this = (M22d)(lu.LuInverse(p).Data);
            return true;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M22d.Zero is returned.
        /// </summary>
        public M22d LuInverse()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return M22d.Zero;
            return (M22d)(lu.LuInverse(p).Data);
        }

        /// <summary>
        /// Inverts the matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        public bool Invert() { return LuInvert();  }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M22d.Zero is returned.
        /// </summary>
        public M22d Inverse { get { return LuInverse(); } }

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximatelyEquals(M22d a, M22d b, double epsilon)
        {
            return DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        /// <summary>
        /// Returns if the matrix is the identity matrix I.
        /// </summary>
        public bool IsIdentity(double epsilon)
        {
            return ApproximatelyEquals(this, Identity, epsilon);
        }

        /// <summary>
        /// Returns if the matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        public bool IsOrthonormal(double epsilon)
        {
            var i = this * this.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        public bool IsOrthogonal(double epsilon)
        {
            var i = this * this.Transposed;
            for (int j = 0; j < 2; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }
        #endregion

        #region Matrix Multiplication

        public static M22d operator *(M22d a, M22d b)
        {
            return new M22d(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        public static M22d Multiply(M22d a, M22d b)
        {
            return new M22d(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M22dEqualityComparer : IEqualityComparer<M22d>
    {
        public static readonly M22dEqualityComparer Default
            = new M22dEqualityComparer();

        #region IEqualityComparer<M22d> Members

        public bool Equals(M22d v0, M22d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M22d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M23i

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M23i : IValidity, IMatrix<double>
    {
        public int M00, M01, M02;
        public int M10, M11, M12;

        #region Constructors

        public M23i(
                int m00, int m01, int m02, 
                int m10, int m11, int m12)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
        }

        public M23i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
        }
        
        public M23i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
        }

        #endregion

        #region Conversions

        public static explicit operator M23i(M22i m)
        {
            return new M23i {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23i(M33i m)
        {
            return new M23i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23i(M34i m)
        {
            return new M23i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23i(M44i m)
        {
            return new M23i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23i(M22l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23i(M23l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M33l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M34l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M44l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M22f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23i(M23f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M33f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M34f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M44f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M22d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23i(M23d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M33d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M34d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M44d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(int[] a)
        {
            return new M23i(
                a[0], a[1], a[2], 
                a[3], a[4], a[5]);
        }

        public static explicit operator M23i(int[,] a)
        {
            return new M23i (
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2]);
        }

        public static explicit operator int[](M23i m)
        {
            return new int[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12
            };
        }

        public static explicit operator int[,](M23i m)
        {
            return new int[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
        }

        public static explicit operator M23i(long[] a)
        {
            return new M23i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5]);
        }

        public static explicit operator M23i(long[,] a)
        {
            return new M23i (
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2]);
        }

        public static explicit operator long[](M23i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12
            };
        }

        public static explicit operator long[,](M23i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
        }

        public static explicit operator M23i(float[] a)
        {
            return new M23i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5]);
        }

        public static explicit operator M23i(float[,] a)
        {
            return new M23i (
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2]);
        }

        public static explicit operator float[](M23i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12
            };
        }

        public static explicit operator float[,](M23i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
        }

        public static explicit operator M23i(double[] a)
        {
            return new M23i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5]);
        }

        public static explicit operator M23i(double[,] a)
        {
            return new M23i (
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2]);
        }

        public static explicit operator double[](M23i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12
            };
        }

        public static explicit operator double[,](M23i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<int, int> element_fun)
        {
            return new M23i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M23i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<int, long> element_fun)
        {
            return new M23l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M23l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<int, float> element_fun)
        {
            return new M23f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M23f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<int, double> element_fun)
        {
            return new M23d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M23d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        public int[] ToArray()
        {
            var array = new int[6];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            return array;
        }

        #endregion

        #region Static Factories

        public static M23i FromCols(V2i col0, V2i col1, V2i col2)
        {
            return new M23i(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y);
        }

        public static M23i FromRows(V3i row0, V3i row1)
        {
            return new M23i(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<int> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M10;
                 yield return M11;
                 yield return M12;
            }
        }

        public IEnumerable<V3i> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2i> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3i R0
        {                     
            get { return new V3i( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3i R1
        {                     
            get { return new V3i( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V2i C0
        {           
            get { return new V2i( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2i C1
        {           
            get { return new V2i( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public V2i C2
        {           
            get { return new V2i( M02,  M12); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
            }
        }

        public int this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public int this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 3;
        public const int ElementCount = 2*3;

        public static readonly V2l Dimensions = new V2l(2, 3);

        public static readonly M23i Zero
                = new M23i(0, 0, 0, 0, 0, 0);

        public static readonly M23i Identity
                = new M23i(1, 0, 0, 0, 1, 0);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(M23i a, M23i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M23i a, M23i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M23i a, M23i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(M23i a, M23i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(M23i a, M23i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        #endregion

        #region Mathematical Operators

        public static M23i operator +(M23i a, M23i b)
        {
            return new M23i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23i operator +(M23i m, int s)
        {
            return new M23i(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23i operator +(int s, M23i m)
        {
            return new M23i(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23l operator +(M23i a, M23l b)
        {
            return new M23l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23l operator +(M23i m, long s)
        {
            return new M23l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23l operator +(long s, M23i m)
        {
            return new M23l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23f operator +(M23i a, M23f b)
        {
            return new M23f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23f operator +(M23i m, float s)
        {
            return new M23f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23f operator +(float s, M23i m)
        {
            return new M23f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23d operator +(M23i a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23d operator +(M23i m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23d operator +(double s, M23i m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23i Add(M23i a, M23i b)
        {
            return new M23i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23i Add(M23i m, int s)
        {
            return new M23i(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23i Add(int s, M23i m)
        {
            return new M23i(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23l Add(M23i a, M23l b)
        {
            return new M23l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23l Add(M23i m, long s)
        {
            return new M23l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23l Add(long s, M23i m)
        {
            return new M23l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23f Add(M23i a, M23f b)
        {
            return new M23f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23f Add(M23i m, float s)
        {
            return new M23f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23f Add(float s, M23i m)
        {
            return new M23f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23d Add(M23i a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23d Add(M23i m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23d Add(double s, M23i m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23i operator -(M23i a, M23i b)
        {
            return new M23i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23i operator -(M23i m, int s)
        {
            return new M23i(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23i operator -(int s, M23i m)
        {
            return new M23i(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23l operator -(M23i a, M23l b)
        {
            return new M23l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23l operator -(M23i m, long s)
        {
            return new M23l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23l operator -(long s, M23i m)
        {
            return new M23l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23f operator -(M23i a, M23f b)
        {
            return new M23f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23f operator -(M23i m, float s)
        {
            return new M23f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23f operator -(float s, M23i m)
        {
            return new M23f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23d operator -(M23i a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23d operator -(M23i m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23d operator -(double s, M23i m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23i Subtract(M23i a, M23i b)
        {
            return new M23i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23i Subtract(M23i m, int s)
        {
            return new M23i(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23i Subtract(int s, M23i m)
        {
            return new M23i(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23l Subtract(M23i a, M23l b)
        {
            return new M23l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23l Subtract(M23i m, long s)
        {
            return new M23l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23l Subtract(long s, M23i m)
        {
            return new M23l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23f Subtract(M23i a, M23f b)
        {
            return new M23f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23f Subtract(M23i m, float s)
        {
            return new M23f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23f Subtract(float s, M23i m)
        {
            return new M23f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23d Subtract(M23i a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23d Subtract(M23i m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23d Subtract(double s, M23i m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23i operator %(M23i a, M23i b)
        {
            return new M23i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23i operator %(M23i m, int s)
        {
            return new M23i(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23i operator %(int s, M23i m)
        {
            return new M23i(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23l operator %(M23i a, M23l b)
        {
            return new M23l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23l operator %(M23i m, long s)
        {
            return new M23l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23l operator %(long s, M23i m)
        {
            return new M23l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23f operator %(M23i a, M23f b)
        {
            return new M23f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23f operator %(M23i m, float s)
        {
            return new M23f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23f operator %(float s, M23i m)
        {
            return new M23f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23d operator %(M23i a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23d operator %(M23i m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23d operator %(double s, M23i m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23i Modulo(M23i a, M23i b)
        {
            return new M23i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23i Modulo(M23i m, int s)
        {
            return new M23i(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23i Modulo(int s, M23i m)
        {
            return new M23i(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23l Modulo(M23i a, M23l b)
        {
            return new M23l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23l Modulo(M23i m, long s)
        {
            return new M23l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23l Modulo(long s, M23i m)
        {
            return new M23l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23f Modulo(M23i a, M23f b)
        {
            return new M23f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23f Modulo(M23i m, float s)
        {
            return new M23f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23f Modulo(float s, M23i m)
        {
            return new M23f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23d Modulo(M23i a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23d Modulo(M23i m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23d Modulo(double s, M23i m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23i operator /(M23i a, M23i b)
        {
            return new M23i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23i operator /(M23i m, int s)
        {
            return new M23i(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23i operator /(int s, M23i m)
        {
            return new M23i(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23l operator /(M23i a, M23l b)
        {
            return new M23l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23l operator /(M23i m, long s)
        {
            return new M23l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23l operator /(long s, M23i m)
        {
            return new M23l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23f operator /(M23i a, M23f b)
        {
            return new M23f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23f operator /(M23i m, float s)
        {
            return new M23f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23f operator /(float s, M23i m)
        {
            return new M23f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23d operator /(M23i a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23d operator /(M23i m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23d operator /(double s, M23i m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23i Divide(M23i a, M23i b)
        {
            return new M23i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23i Divide(M23i m, int s)
        {
            return new M23i(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23i Divide(int s, M23i m)
        {
            return new M23i(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23l Divide(M23i a, M23l b)
        {
            return new M23l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23l Divide(M23i m, long s)
        {
            return new M23l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23l Divide(long s, M23i m)
        {
            return new M23l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23f Divide(M23i a, M23f b)
        {
            return new M23f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23f Divide(M23i m, float s)
        {
            return new M23f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23f Divide(float s, M23i m)
        {
            return new M23f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23d Divide(M23i a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23d Divide(M23i m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23d Divide(double s, M23i m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23i operator *(M23i m, int s)
        {
            return new M23i(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23i operator *(int s, M23i m)
        {
            return new M23i(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23l operator *(M23i m, long s)
        {
            return new M23l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23l operator *(long s, M23i m)
        {
            return new M23l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23f operator *(M23i m, float s)
        {
            return new M23f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23f operator *(float s, M23i m)
        {
            return new M23f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23d operator *(M23i m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23d operator *(double s, M23i m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23i Multiply(M23i m, int s)
        {
            return new M23i(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23i Multiply(int s, M23i m)
        {
            return new M23i(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23l Multiply(M23i m, long s)
        {
            return new M23l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23l Multiply(long s, M23i m)
        {
            return new M23l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23f Multiply(M23i m, float s)
        {
            return new M23f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23f Multiply(float s, M23i m)
        {
            return new M23f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23d Multiply(M23i m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23d Multiply(double s, M23i m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V2i Multiply(M23i m, V3i v)
        {
            return new V2i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        public static V2i operator *(M23i m, V3i v)
        {
            return new V2i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M23i a, M23i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12;
        }

        public static bool operator <(M23i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s;
        }

        public static bool operator <(int s, M23i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12 ;
        }

        public static bool operator >(M23i a, M23i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12;
        }

        public static bool operator >(M23i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s;
        }

        public static bool operator >(int s, M23i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12 ;
        }

        public static bool operator ==(M23i a, M23i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12;
        }

        public static bool operator ==(M23i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s;
        }

        public static bool operator ==(int s, M23i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12 ;
        }

        public static bool operator <=(M23i a, M23i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12;
        }

        public static bool operator <=(M23i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s;
        }

        public static bool operator <=(int s, M23i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12 ;
        }

        public static bool operator >=(M23i a, M23i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12;
        }

        public static bool operator >=(M23i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s;
        }

        public static bool operator >=(int s, M23i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12 ;
        }

        public static bool operator !=(M23i a, M23i b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M23i m, int s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(int s, M23i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M23i) ? (this == (M23i)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M23i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M23i.FromRows(
                V3i.Parse(x[0]), 
                V3i.Parse(x[1])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V2i TransformDir(M23i m, V2i v)
        {
            return new V2i(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2i TransformPos(M23i m, V2i p)
        {
            return new V2i(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V2i TransformDir(V2i v)
        {
            return new V2i(
                M00 * v.X + M01 * v.Y, 
                M10 * v.X + M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V2i TransformPos(V2i p)
        {
            return new V2i(
                M00 * p.X + M01 * p.Y + M02, 
                M10 * p.X + M11 * p.Y + M12
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V2i TransformPosProj(M23i m, V2i p)
        {
            return TransformDir(m, p);
        }
        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V2i TransformPosProj(V2i p)
        {
            return TransformDir(p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V3i Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V2i Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M23i operator *(M22i a, M23i b)
        {
            return new M23i(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23i Multiply(M22i a, M23i b)
        {
            return new M23i(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23i operator *(M23i a, M33i b)
        {
            return new M23i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        public static M23i Multiply(M23i a, M33i b)
        {
            return new M23i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M23iEqualityComparer : IEqualityComparer<M23i>
    {
        public static readonly M23iEqualityComparer Default
            = new M23iEqualityComparer();

        #region IEqualityComparer<M23i> Members

        public bool Equals(M23i v0, M23i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M23i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M23l

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M23l : IValidity, IMatrix<double>
    {
        public long M00, M01, M02;
        public long M10, M11, M12;

        #region Constructors

        public M23l(
                long m00, long m01, long m02, 
                long m10, long m11, long m12)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
        }

        public M23l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
        }
        
        public M23l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
        }

        #endregion

        #region Conversions

        public static explicit operator M23l(M22i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23l(M23i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M33i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M34i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M44i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M22l m)
        {
            return new M23l {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23l(M33l m)
        {
            return new M23l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23l(M34l m)
        {
            return new M23l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23l(M44l m)
        {
            return new M23l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23l(M22f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23l(M23f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M33f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M34f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M44f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M22d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23l(M23d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M33d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M34d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M44d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(int[] a)
        {
            return new M23l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5]);
        }

        public static explicit operator M23l(int[,] a)
        {
            return new M23l (
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2]);
        }

        public static explicit operator int[](M23l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12
            };
        }

        public static explicit operator int[,](M23l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
        }

        public static explicit operator M23l(long[] a)
        {
            return new M23l(
                a[0], a[1], a[2], 
                a[3], a[4], a[5]);
        }

        public static explicit operator M23l(long[,] a)
        {
            return new M23l (
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2]);
        }

        public static explicit operator long[](M23l m)
        {
            return new long[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12
            };
        }

        public static explicit operator long[,](M23l m)
        {
            return new long[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
        }

        public static explicit operator M23l(float[] a)
        {
            return new M23l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5]);
        }

        public static explicit operator M23l(float[,] a)
        {
            return new M23l (
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2]);
        }

        public static explicit operator float[](M23l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12
            };
        }

        public static explicit operator float[,](M23l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
        }

        public static explicit operator M23l(double[] a)
        {
            return new M23l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5]);
        }

        public static explicit operator M23l(double[,] a)
        {
            return new M23l (
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2]);
        }

        public static explicit operator double[](M23l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12
            };
        }

        public static explicit operator double[,](M23l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<long, int> element_fun)
        {
            return new M23i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M23i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<long, long> element_fun)
        {
            return new M23l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M23l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<long, float> element_fun)
        {
            return new M23f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M23f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<long, double> element_fun)
        {
            return new M23d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M23d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        public long[] ToArray()
        {
            var array = new long[6];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            return array;
        }

        #endregion

        #region Static Factories

        public static M23l FromCols(V2l col0, V2l col1, V2l col2)
        {
            return new M23l(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y);
        }

        public static M23l FromRows(V3l row0, V3l row1)
        {
            return new M23l(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<long> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M10;
                 yield return M11;
                 yield return M12;
            }
        }

        public IEnumerable<V3l> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2l> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3l R0
        {                     
            get { return new V3l( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3l R1
        {                     
            get { return new V3l( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V2l C0
        {           
            get { return new V2l( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2l C1
        {           
            get { return new V2l( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public V2l C2
        {           
            get { return new V2l( M02,  M12); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
            }
        }

        public long this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public long this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 3;
        public const int ElementCount = 2*3;

        public static readonly V2l Dimensions = new V2l(2, 3);

        public static readonly M23l Zero
                = new M23l(0, 0, 0, 0, 0, 0);

        public static readonly M23l Identity
                = new M23l(1, 0, 0, 0, 1, 0);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(M23l a, M23l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M23l a, M23l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M23l a, M23l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(M23l a, M23l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(M23l a, M23l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        #endregion

        #region Mathematical Operators

        public static M23l operator +(M23l a, M23l b)
        {
            return new M23l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23l operator +(M23l m, long s)
        {
            return new M23l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23l operator +(long s, M23l m)
        {
            return new M23l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23f operator +(M23l a, M23f b)
        {
            return new M23f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23f operator +(M23l m, float s)
        {
            return new M23f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23f operator +(float s, M23l m)
        {
            return new M23f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23d operator +(M23l a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23d operator +(M23l m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23d operator +(double s, M23l m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23l Add(M23l a, M23l b)
        {
            return new M23l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23l Add(M23l m, long s)
        {
            return new M23l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23l Add(long s, M23l m)
        {
            return new M23l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23f Add(M23l a, M23f b)
        {
            return new M23f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23f Add(M23l m, float s)
        {
            return new M23f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23f Add(float s, M23l m)
        {
            return new M23f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23d Add(M23l a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23d Add(M23l m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23d Add(double s, M23l m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23l operator -(M23l a, M23l b)
        {
            return new M23l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23l operator -(M23l m, long s)
        {
            return new M23l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23l operator -(long s, M23l m)
        {
            return new M23l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23f operator -(M23l a, M23f b)
        {
            return new M23f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23f operator -(M23l m, float s)
        {
            return new M23f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23f operator -(float s, M23l m)
        {
            return new M23f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23d operator -(M23l a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23d operator -(M23l m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23d operator -(double s, M23l m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23l Subtract(M23l a, M23l b)
        {
            return new M23l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23l Subtract(M23l m, long s)
        {
            return new M23l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23l Subtract(long s, M23l m)
        {
            return new M23l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23f Subtract(M23l a, M23f b)
        {
            return new M23f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23f Subtract(M23l m, float s)
        {
            return new M23f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23f Subtract(float s, M23l m)
        {
            return new M23f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23d Subtract(M23l a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23d Subtract(M23l m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23d Subtract(double s, M23l m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23l operator %(M23l a, M23l b)
        {
            return new M23l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23l operator %(M23l m, long s)
        {
            return new M23l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23l operator %(long s, M23l m)
        {
            return new M23l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23f operator %(M23l a, M23f b)
        {
            return new M23f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23f operator %(M23l m, float s)
        {
            return new M23f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23f operator %(float s, M23l m)
        {
            return new M23f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23d operator %(M23l a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23d operator %(M23l m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23d operator %(double s, M23l m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23l Modulo(M23l a, M23l b)
        {
            return new M23l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23l Modulo(M23l m, long s)
        {
            return new M23l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23l Modulo(long s, M23l m)
        {
            return new M23l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23f Modulo(M23l a, M23f b)
        {
            return new M23f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23f Modulo(M23l m, float s)
        {
            return new M23f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23f Modulo(float s, M23l m)
        {
            return new M23f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23d Modulo(M23l a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23d Modulo(M23l m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23d Modulo(double s, M23l m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23l operator /(M23l a, M23l b)
        {
            return new M23l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23l operator /(M23l m, long s)
        {
            return new M23l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23l operator /(long s, M23l m)
        {
            return new M23l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23f operator /(M23l a, M23f b)
        {
            return new M23f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23f operator /(M23l m, float s)
        {
            return new M23f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23f operator /(float s, M23l m)
        {
            return new M23f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23d operator /(M23l a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23d operator /(M23l m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23d operator /(double s, M23l m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23l Divide(M23l a, M23l b)
        {
            return new M23l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23l Divide(M23l m, long s)
        {
            return new M23l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23l Divide(long s, M23l m)
        {
            return new M23l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23f Divide(M23l a, M23f b)
        {
            return new M23f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23f Divide(M23l m, float s)
        {
            return new M23f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23f Divide(float s, M23l m)
        {
            return new M23f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23d Divide(M23l a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23d Divide(M23l m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23d Divide(double s, M23l m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23l operator *(M23l m, long s)
        {
            return new M23l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23l operator *(long s, M23l m)
        {
            return new M23l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23f operator *(M23l m, float s)
        {
            return new M23f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23f operator *(float s, M23l m)
        {
            return new M23f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23d operator *(M23l m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23d operator *(double s, M23l m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23l Multiply(M23l m, long s)
        {
            return new M23l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23l Multiply(long s, M23l m)
        {
            return new M23l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23f Multiply(M23l m, float s)
        {
            return new M23f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23f Multiply(float s, M23l m)
        {
            return new M23f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23d Multiply(M23l m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23d Multiply(double s, M23l m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V2l Multiply(M23l m, V3l v)
        {
            return new V2l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        public static V2l operator *(M23l m, V3l v)
        {
            return new V2l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M23l a, M23l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12;
        }

        public static bool operator <(M23l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s;
        }

        public static bool operator <(long s, M23l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12 ;
        }

        public static bool operator >(M23l a, M23l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12;
        }

        public static bool operator >(M23l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s;
        }

        public static bool operator >(long s, M23l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12 ;
        }

        public static bool operator ==(M23l a, M23l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12;
        }

        public static bool operator ==(M23l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s;
        }

        public static bool operator ==(long s, M23l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12 ;
        }

        public static bool operator <=(M23l a, M23l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12;
        }

        public static bool operator <=(M23l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s;
        }

        public static bool operator <=(long s, M23l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12 ;
        }

        public static bool operator >=(M23l a, M23l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12;
        }

        public static bool operator >=(M23l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s;
        }

        public static bool operator >=(long s, M23l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12 ;
        }

        public static bool operator !=(M23l a, M23l b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M23l m, long s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(long s, M23l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M23l) ? (this == (M23l)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M23l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M23l.FromRows(
                V3l.Parse(x[0]), 
                V3l.Parse(x[1])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V2l TransformDir(M23l m, V2l v)
        {
            return new V2l(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2l TransformPos(M23l m, V2l p)
        {
            return new V2l(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V2l TransformDir(V2l v)
        {
            return new V2l(
                M00 * v.X + M01 * v.Y, 
                M10 * v.X + M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V2l TransformPos(V2l p)
        {
            return new V2l(
                M00 * p.X + M01 * p.Y + M02, 
                M10 * p.X + M11 * p.Y + M12
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V2l TransformPosProj(M23l m, V2l p)
        {
            return TransformDir(m, p);
        }
        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V2l TransformPosProj(V2l p)
        {
            return TransformDir(p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V3l Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V2l Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M23l operator *(M22l a, M23l b)
        {
            return new M23l(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23l Multiply(M22l a, M23l b)
        {
            return new M23l(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23l operator *(M23l a, M33l b)
        {
            return new M23l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        public static M23l Multiply(M23l a, M33l b)
        {
            return new M23l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M23lEqualityComparer : IEqualityComparer<M23l>
    {
        public static readonly M23lEqualityComparer Default
            = new M23lEqualityComparer();

        #region IEqualityComparer<M23l> Members

        public bool Equals(M23l v0, M23l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M23l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M23f

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M23f : IValidity, IMatrix<double>
    {
        public float M00, M01, M02;
        public float M10, M11, M12;

        #region Constructors

        public M23f(
                float m00, float m01, float m02, 
                float m10, float m11, float m12)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
        }

        public M23f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
        }
        
        public M23f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
        }

        #endregion

        #region Conversions

        public static explicit operator M23f(M22i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23f(M23i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M33i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M34i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M44i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M22l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23f(M23l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M33l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M34l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M44l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M22f m)
        {
            return new M23f {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23f(M33f m)
        {
            return new M23f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23f(M34f m)
        {
            return new M23f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23f(M44f m)
        {
            return new M23f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23f(M22d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23f(M23d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M33d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M34d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M44d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(int[] a)
        {
            return new M23f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5]);
        }

        public static explicit operator M23f(int[,] a)
        {
            return new M23f (
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2]);
        }

        public static explicit operator int[](M23f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12
            };
        }

        public static explicit operator int[,](M23f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
        }

        public static explicit operator M23f(long[] a)
        {
            return new M23f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5]);
        }

        public static explicit operator M23f(long[,] a)
        {
            return new M23f (
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2]);
        }

        public static explicit operator long[](M23f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12
            };
        }

        public static explicit operator long[,](M23f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
        }

        public static explicit operator M23f(float[] a)
        {
            return new M23f(
                a[0], a[1], a[2], 
                a[3], a[4], a[5]);
        }

        public static explicit operator M23f(float[,] a)
        {
            return new M23f (
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2]);
        }

        public static explicit operator float[](M23f m)
        {
            return new float[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12
            };
        }

        public static explicit operator float[,](M23f m)
        {
            return new float[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
        }

        public static explicit operator M23f(double[] a)
        {
            return new M23f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5]);
        }

        public static explicit operator M23f(double[,] a)
        {
            return new M23f (
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2]);
        }

        public static explicit operator double[](M23f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12
            };
        }

        public static explicit operator double[,](M23f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<float, int> element_fun)
        {
            return new M23i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M23i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<float, long> element_fun)
        {
            return new M23l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M23l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<float, float> element_fun)
        {
            return new M23f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M23f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<float, double> element_fun)
        {
            return new M23d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M23d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        public float[] ToArray()
        {
            var array = new float[6];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            return array;
        }

        #endregion

        #region Static Factories

        public static M23f FromCols(V2f col0, V2f col1, V2f col2)
        {
            return new M23f(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y);
        }

        public static M23f FromRows(V3f row0, V3f row1)
        {
            return new M23f(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<float> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M10;
                 yield return M11;
                 yield return M12;
            }
        }

        public IEnumerable<V3f> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2f> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3f R0
        {                     
            get { return new V3f( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3f R1
        {                     
            get { return new V3f( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V2f C0
        {           
            get { return new V2f( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2f C1
        {           
            get { return new V2f( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public V2f C2
        {           
            get { return new V2f( M02,  M12); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
            }
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public float this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 3;
        public const int ElementCount = 2*3;

        public static readonly V2l Dimensions = new V2l(2, 3);

        public static readonly M23f Zero
                = new M23f(0, 0, 0, 0, 0, 0);

        public static readonly M23f Identity
                = new M23f(1, 0, 0, 0, 1, 0);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public float Norm(float p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(M23f a, M23f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(M23f a, M23f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(M23f a, M23f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(M23f a, M23f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(M23f a, M23f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        #endregion

        #region Mathematical Operators

        public static M23f operator +(M23f a, M23f b)
        {
            return new M23f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23f operator +(M23f m, float s)
        {
            return new M23f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23f operator +(float s, M23f m)
        {
            return new M23f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23d operator +(M23f a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23d operator +(M23f m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23d operator +(double s, M23f m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23f Add(M23f a, M23f b)
        {
            return new M23f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23f Add(M23f m, float s)
        {
            return new M23f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23f Add(float s, M23f m)
        {
            return new M23f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23d Add(M23f a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23d Add(M23f m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23d Add(double s, M23f m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23f operator -(M23f a, M23f b)
        {
            return new M23f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23f operator -(M23f m, float s)
        {
            return new M23f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23f operator -(float s, M23f m)
        {
            return new M23f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23d operator -(M23f a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23d operator -(M23f m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23d operator -(double s, M23f m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23f Subtract(M23f a, M23f b)
        {
            return new M23f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23f Subtract(M23f m, float s)
        {
            return new M23f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23f Subtract(float s, M23f m)
        {
            return new M23f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23d Subtract(M23f a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23d Subtract(M23f m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23d Subtract(double s, M23f m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23f operator %(M23f a, M23f b)
        {
            return new M23f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23f operator %(M23f m, float s)
        {
            return new M23f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23f operator %(float s, M23f m)
        {
            return new M23f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23d operator %(M23f a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23d operator %(M23f m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23d operator %(double s, M23f m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23f Modulo(M23f a, M23f b)
        {
            return new M23f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23f Modulo(M23f m, float s)
        {
            return new M23f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23f Modulo(float s, M23f m)
        {
            return new M23f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23d Modulo(M23f a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23d Modulo(M23f m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23d Modulo(double s, M23f m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23f operator /(M23f a, M23f b)
        {
            return new M23f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23f operator /(M23f m, float s)
        {
            return new M23f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23f operator /(float s, M23f m)
        {
            return new M23f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23d operator /(M23f a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23d operator /(M23f m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23d operator /(double s, M23f m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23f Divide(M23f a, M23f b)
        {
            return new M23f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23f Divide(M23f m, float s)
        {
            return new M23f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23f Divide(float s, M23f m)
        {
            return new M23f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23d Divide(M23f a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23d Divide(M23f m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23d Divide(double s, M23f m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23f operator *(M23f m, float s)
        {
            return new M23f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23f operator *(float s, M23f m)
        {
            return new M23f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23d operator *(M23f m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23d operator *(double s, M23f m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23f Multiply(M23f m, float s)
        {
            return new M23f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23f Multiply(float s, M23f m)
        {
            return new M23f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23d Multiply(M23f m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23d Multiply(double s, M23f m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V2f Multiply(M23f m, V3f v)
        {
            return new V2f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        public static V2f operator *(M23f m, V3f v)
        {
            return new V2f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M23f a, M23f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12;
        }

        public static bool operator <(M23f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s;
        }

        public static bool operator <(float s, M23f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12 ;
        }

        public static bool operator >(M23f a, M23f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12;
        }

        public static bool operator >(M23f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s;
        }

        public static bool operator >(float s, M23f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12 ;
        }

        public static bool operator ==(M23f a, M23f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12;
        }

        public static bool operator ==(M23f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s;
        }

        public static bool operator ==(float s, M23f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12 ;
        }

        public static bool operator <=(M23f a, M23f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12;
        }

        public static bool operator <=(M23f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s;
        }

        public static bool operator <=(float s, M23f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12 ;
        }

        public static bool operator >=(M23f a, M23f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12;
        }

        public static bool operator >=(M23f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s;
        }

        public static bool operator >=(float s, M23f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12 ;
        }

        public static bool operator !=(M23f a, M23f b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M23f m, float s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(float s, M23f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M23f) ? (this == (M23f)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M23f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M23f.FromRows(
                V3f.Parse(x[0]), 
                V3f.Parse(x[1])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V2f TransformDir(M23f m, V2f v)
        {
            return new V2f(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2f TransformPos(M23f m, V2f p)
        {
            return new V2f(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V2f TransformDir(V2f v)
        {
            return new V2f(
                M00 * v.X + M01 * v.Y, 
                M10 * v.X + M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V2f TransformPos(V2f p)
        {
            return new V2f(
                M00 * p.X + M01 * p.Y + M02, 
                M10 * p.X + M11 * p.Y + M12
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V2f TransformPosProj(M23f m, V2f p)
        {
            return TransformDir(m, p);
        }
        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V2f TransformPosProj(V2f p)
        {
            return TransformDir(p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V3f Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V2f Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M23f operator *(M22f a, M23f b)
        {
            return new M23f(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23f Multiply(M22f a, M23f b)
        {
            return new M23f(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23f operator *(M23f a, M33f b)
        {
            return new M23f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        public static M23f Multiply(M23f a, M33f b)
        {
            return new M23f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M23fEqualityComparer : IEqualityComparer<M23f>
    {
        public static readonly M23fEqualityComparer Default
            = new M23fEqualityComparer();

        #region IEqualityComparer<M23f> Members

        public bool Equals(M23f v0, M23f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M23f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M23d

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M23d : IValidity, IMatrix<double>
    {
        public double M00, M01, M02;
        public double M10, M11, M12;

        #region Constructors

        public M23d(
                double m00, double m01, double m02, 
                double m10, double m11, double m12)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
        }

        public M23d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
        }
        
        public M23d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
        }

        #endregion

        #region Conversions

        public static explicit operator M23d(M22i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23d(M23i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M33i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M34i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M44i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M22l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23d(M23l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M33l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M34l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M44l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M22f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23d(M23f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M33f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M34f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M44f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M22d m)
        {
            return new M23d {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23d(M33d m)
        {
            return new M23d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23d(M34d m)
        {
            return new M23d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23d(M44d m)
        {
            return new M23d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23d(int[] a)
        {
            return new M23d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5]);
        }

        public static explicit operator M23d(int[,] a)
        {
            return new M23d (
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2]);
        }

        public static explicit operator int[](M23d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12
            };
        }

        public static explicit operator int[,](M23d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
        }

        public static explicit operator M23d(long[] a)
        {
            return new M23d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5]);
        }

        public static explicit operator M23d(long[,] a)
        {
            return new M23d (
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2]);
        }

        public static explicit operator long[](M23d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12
            };
        }

        public static explicit operator long[,](M23d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
        }

        public static explicit operator M23d(float[] a)
        {
            return new M23d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5]);
        }

        public static explicit operator M23d(float[,] a)
        {
            return new M23d (
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2]);
        }

        public static explicit operator float[](M23d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12
            };
        }

        public static explicit operator float[,](M23d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
        }

        public static explicit operator M23d(double[] a)
        {
            return new M23d(
                a[0], a[1], a[2], 
                a[3], a[4], a[5]);
        }

        public static explicit operator M23d(double[,] a)
        {
            return new M23d (
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2]);
        }

        public static explicit operator double[](M23d m)
        {
            return new double[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12
            };
        }

        public static explicit operator double[,](M23d m)
        {
            return new double[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<double, int> element_fun)
        {
            return new M23i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M23i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<double, long> element_fun)
        {
            return new M23l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M23l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<double, float> element_fun)
        {
            return new M23f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M23f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<double, double> element_fun)
        {
            return new M23d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M23d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        public double[] ToArray()
        {
            var array = new double[6];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            return array;
        }

        #endregion

        #region Static Factories

        public static M23d FromCols(V2d col0, V2d col1, V2d col2)
        {
            return new M23d(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y);
        }

        public static M23d FromRows(V3d row0, V3d row1)
        {
            return new M23d(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<double> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M10;
                 yield return M11;
                 yield return M12;
            }
        }

        public IEnumerable<V3d> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2d> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3d R0
        {                     
            get { return new V3d( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3d R1
        {                     
            get { return new V3d( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V2d C0
        {           
            get { return new V2d( M00,  M10); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        public V2d C1
        {           
            get { return new V2d( M01,  M11); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public V2d C2
        {           
            get { return new V2d( M02,  M12); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
            }
        }

        public double this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public double this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 3;
        public const int ElementCount = 2*3;

        public static readonly V2l Dimensions = new V2l(2, 3);

        public static readonly M23d Zero
                = new M23d(0, 0, 0, 0, 0, 0);

        public static readonly M23d Identity
                = new M23d(1, 0, 0, 0, 1, 0);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(M23d a, M23d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M23d a, M23d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M23d a, M23d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(M23d a, M23d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(M23d a, M23d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        #endregion

        #region Mathematical Operators

        public static M23d operator +(M23d a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23d operator +(M23d m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23d operator +(double s, M23d m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23d Add(M23d a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        public static M23d Add(M23d m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }
        
        public static M23d Add(double s, M23d m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        public static M23d operator -(M23d a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23d operator -(M23d m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23d operator -(double s, M23d m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23d Subtract(M23d a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        public static M23d Subtract(M23d m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }
        
        public static M23d Subtract(double s, M23d m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        public static M23d operator %(M23d a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23d operator %(M23d m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23d operator %(double s, M23d m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23d Modulo(M23d a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        public static M23d Modulo(M23d m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }
        
        public static M23d Modulo(double s, M23d m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        public static M23d operator /(M23d a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23d operator /(M23d m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23d operator /(double s, M23d m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23d Divide(M23d a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        public static M23d Divide(M23d m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }
        
        public static M23d Divide(double s, M23d m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        public static M23d operator *(M23d m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23d operator *(double s, M23d m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        public static M23d Multiply(M23d m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }
        
        public static M23d Multiply(double s, M23d m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V2d Multiply(M23d m, V3d v)
        {
            return new V2d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        public static V2d operator *(M23d m, V3d v)
        {
            return new V2d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M23d a, M23d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12;
        }

        public static bool operator <(M23d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s;
        }

        public static bool operator <(double s, M23d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12 ;
        }

        public static bool operator >(M23d a, M23d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12;
        }

        public static bool operator >(M23d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s;
        }

        public static bool operator >(double s, M23d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12 ;
        }

        public static bool operator ==(M23d a, M23d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12;
        }

        public static bool operator ==(M23d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s;
        }

        public static bool operator ==(double s, M23d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12 ;
        }

        public static bool operator <=(M23d a, M23d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12;
        }

        public static bool operator <=(M23d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s;
        }

        public static bool operator <=(double s, M23d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12 ;
        }

        public static bool operator >=(M23d a, M23d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12;
        }

        public static bool operator >=(M23d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s;
        }

        public static bool operator >=(double s, M23d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12 ;
        }

        public static bool operator !=(M23d a, M23d b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M23d m, double s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(double s, M23d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M23d) ? (this == (M23d)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M23d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M23d.FromRows(
                V3d.Parse(x[0]), 
                V3d.Parse(x[1])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V2d TransformDir(M23d m, V2d v)
        {
            return new V2d(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2d TransformPos(M23d m, V2d p)
        {
            return new V2d(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V2d TransformDir(V2d v)
        {
            return new V2d(
                M00 * v.X + M01 * v.Y, 
                M10 * v.X + M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V2d TransformPos(V2d p)
        {
            return new V2d(
                M00 * p.X + M01 * p.Y + M02, 
                M10 * p.X + M11 * p.Y + M12
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V2d TransformPosProj(M23d m, V2d p)
        {
            return TransformDir(m, p);
        }
        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V2d TransformPosProj(V2d p)
        {
            return TransformDir(p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V3d Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V2d Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M23d operator *(M22d a, M23d b)
        {
            return new M23d(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23d Multiply(M22d a, M23d b)
        {
            return new M23d(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23d operator *(M23d a, M33d b)
        {
            return new M23d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        public static M23d Multiply(M23d a, M33d b)
        {
            return new M23d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M23dEqualityComparer : IEqualityComparer<M23d>
    {
        public static readonly M23dEqualityComparer Default
            = new M23dEqualityComparer();

        #region IEqualityComparer<M23d> Members

        public bool Equals(M23d v0, M23d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M23d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M33i

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M33i : IValidity, IMatrix<double>
    {
        public int M00, M01, M02;
        public int M10, M11, M12;
        public int M20, M21, M22;

        #region Constructors

        public M33i(
                int m00, int m01, int m02, 
                int m10, int m11, int m12, 
                int m20, int m21, int m22)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
            M20 = m20; M21 = m21; M22 = m22; 
        }

        public M33i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
            M20 = a[6];
            M21 = a[7];
            M22 = a[8];
        }
        
        public M33i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
            M20 = a[start + 6];
            M21 = a[start + 7];
            M22 = a[start + 8];
        }

        #endregion

        #region Conversions

        public static explicit operator M33i(M22i m)
        {
            return new M33i {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M23i m)
        {
            return new M33i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M34i m)
        {
            return new M33i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33i(M44i m)
        {
            return new M33i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33i(M22l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M23l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M33l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M34l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M44l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M22f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M23f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M33f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M34f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M44f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M22d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M23d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M33d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M34d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M44d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(int[] a)
        {
            return new M33i(
                a[0], a[1], a[2], 
                a[3], a[4], a[5], 
                a[6], a[7], a[8]);
        }

        public static explicit operator M33i(int[,] a)
        {
            return new M33i (
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2], 
                a[2, 0], a[2, 1], a[2, 2]);
        }

        public static explicit operator int[](M33i m)
        {
            return new int[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12, 
                m.M20, m.M21, m.M22
            };
        }

        public static explicit operator int[,](M33i m)
        {
            return new int[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }, 
                { m.M20, m.M21, m.M22 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
            array[index + 6] = M20;
            array[index + 7] = M21;
            array[index + 8] = M22;
        }

        public static explicit operator M33i(long[] a)
        {
            return new M33i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5], 
                (int)a[6], (int)a[7], (int)a[8]);
        }

        public static explicit operator M33i(long[,] a)
        {
            return new M33i (
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2]);
        }

        public static explicit operator long[](M33i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12, 
                (long)m.M20, (long)m.M21, (long)m.M22
            };
        }

        public static explicit operator long[,](M33i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
            array[index + 6] = (long)M20;
            array[index + 7] = (long)M21;
            array[index + 8] = (long)M22;
        }

        public static explicit operator M33i(float[] a)
        {
            return new M33i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5], 
                (int)a[6], (int)a[7], (int)a[8]);
        }

        public static explicit operator M33i(float[,] a)
        {
            return new M33i (
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2]);
        }

        public static explicit operator float[](M33i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12, 
                (float)m.M20, (float)m.M21, (float)m.M22
            };
        }

        public static explicit operator float[,](M33i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
            array[index + 6] = (float)M20;
            array[index + 7] = (float)M21;
            array[index + 8] = (float)M22;
        }

        public static explicit operator M33i(double[] a)
        {
            return new M33i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5], 
                (int)a[6], (int)a[7], (int)a[8]);
        }

        public static explicit operator M33i(double[,] a)
        {
            return new M33i (
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2]);
        }

        public static explicit operator double[](M33i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12, 
                (double)m.M20, (double)m.M21, (double)m.M22
            };
        }

        public static explicit operator double[,](M33i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
            array[index + 6] = (double)M20;
            array[index + 7] = (double)M21;
            array[index + 8] = (double)M22;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<int, int> element_fun)
        {
            return new M33i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M33i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<int, long> element_fun)
        {
            return new M33l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M33l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<int, float> element_fun)
        {
            return new M33f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M33f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<int, double> element_fun)
        {
            return new M33d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M33d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M22i UpperLeftM22()
        {
            return (M22i)this;
        }

        public int[] ToArray()
        {
            var array = new int[9];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            array[6] = M20;
            array[7] = M21;
            array[8] = M22;
            return array;
        }

        #endregion

        #region Static Factories

        public static M33i FromCols(V3i col0, V3i col1, V3i col2)
        {
            return new M33i(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y, 
                col0.Z, col1.Z, col2.Z);
        }

        public static M33i FromRows(V3i row0, V3i row1, V3i row2)
        {
            return new M33i(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z, 
                row2.X, row2.Y, row2.Z);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<int> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M10;
                 yield return M11;
                 yield return M12;
                 yield return M20;
                 yield return M21;
                 yield return M22;
            }
        }

        public IEnumerable<V3i> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3i> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3i R0
        {                     
            get { return new V3i( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3i R1
        {                     
            get { return new V3i( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V3i R2
        {                     
            get { return new V3i( M20,  M21,  M22); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
            }
        }

        public V3i C0
        {           
            get { return new V3i( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3i C1
        {           
            get { return new V3i( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3i C2
        {           
            get { return new V3i( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public int this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    case 6: return M20;
                    case 7: return M21;
                    case 8: return M22;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    case 6: M20 = value; return;
                    case 7: M21 = value; return;
                    case 8: M22 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public int this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: return M20;
                                case 1: return M21;
                                case 2: return M22;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: M20 = value; return;
                                case 1: M21 = value; return;
                                case 2: M22 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 3;
        public const int ElementCount = 3*3;

        public static readonly V2l Dimensions = new V2l(3, 3);

        public static readonly M33i Zero
                = new M33i(0, 0, 0, 0, 0, 0, 0, 0, 0);

        public static readonly M33i Identity
                = new M33i(1, 0, 0, 0, 1, 0, 0, 0, 1);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + 
                    M20 * M20 + M21 * M21 + M22 * M22);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p) + 
                Fun.Abs(M20).Pow(p) + 
                Fun.Abs(M21).Pow(p) + 
                Fun.Abs(M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(M33i a, M33i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M33i a, M33i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M33i a, M33i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(M33i a, M33i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(M33i a, M33i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        #endregion

        #region Mathematical Operators

        public static M33i operator +(M33i a, M33i b)
        {
            return new M33i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33i operator +(M33i m, int s)
        {
            return new M33i(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33i operator +(int s, M33i m)
        {
            return new M33i(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33l operator +(M33i a, M33l b)
        {
            return new M33l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33l operator +(M33i m, long s)
        {
            return new M33l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33l operator +(long s, M33i m)
        {
            return new M33l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33f operator +(M33i a, M33f b)
        {
            return new M33f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33f operator +(M33i m, float s)
        {
            return new M33f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33f operator +(float s, M33i m)
        {
            return new M33f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33d operator +(M33i a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33d operator +(M33i m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33d operator +(double s, M33i m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33i Add(M33i a, M33i b)
        {
            return new M33i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33i Add(M33i m, int s)
        {
            return new M33i(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33i Add(int s, M33i m)
        {
            return new M33i(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33l Add(M33i a, M33l b)
        {
            return new M33l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33l Add(M33i m, long s)
        {
            return new M33l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33l Add(long s, M33i m)
        {
            return new M33l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33f Add(M33i a, M33f b)
        {
            return new M33f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33f Add(M33i m, float s)
        {
            return new M33f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33f Add(float s, M33i m)
        {
            return new M33f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33d Add(M33i a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33d Add(M33i m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33d Add(double s, M33i m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33i operator -(M33i a, M33i b)
        {
            return new M33i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33i operator -(M33i m, int s)
        {
            return new M33i(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33i operator -(int s, M33i m)
        {
            return new M33i(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33l operator -(M33i a, M33l b)
        {
            return new M33l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33l operator -(M33i m, long s)
        {
            return new M33l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33l operator -(long s, M33i m)
        {
            return new M33l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33f operator -(M33i a, M33f b)
        {
            return new M33f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33f operator -(M33i m, float s)
        {
            return new M33f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33f operator -(float s, M33i m)
        {
            return new M33f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33d operator -(M33i a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33d operator -(M33i m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33d operator -(double s, M33i m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33i Subtract(M33i a, M33i b)
        {
            return new M33i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33i Subtract(M33i m, int s)
        {
            return new M33i(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33i Subtract(int s, M33i m)
        {
            return new M33i(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33l Subtract(M33i a, M33l b)
        {
            return new M33l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33l Subtract(M33i m, long s)
        {
            return new M33l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33l Subtract(long s, M33i m)
        {
            return new M33l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33f Subtract(M33i a, M33f b)
        {
            return new M33f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33f Subtract(M33i m, float s)
        {
            return new M33f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33f Subtract(float s, M33i m)
        {
            return new M33f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33d Subtract(M33i a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33d Subtract(M33i m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33d Subtract(double s, M33i m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33i operator %(M33i a, M33i b)
        {
            return new M33i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33i operator %(M33i m, int s)
        {
            return new M33i(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33i operator %(int s, M33i m)
        {
            return new M33i(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33l operator %(M33i a, M33l b)
        {
            return new M33l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33l operator %(M33i m, long s)
        {
            return new M33l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33l operator %(long s, M33i m)
        {
            return new M33l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33f operator %(M33i a, M33f b)
        {
            return new M33f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33f operator %(M33i m, float s)
        {
            return new M33f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33f operator %(float s, M33i m)
        {
            return new M33f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33d operator %(M33i a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33d operator %(M33i m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33d operator %(double s, M33i m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33i Modulo(M33i a, M33i b)
        {
            return new M33i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33i Modulo(M33i m, int s)
        {
            return new M33i(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33i Modulo(int s, M33i m)
        {
            return new M33i(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33l Modulo(M33i a, M33l b)
        {
            return new M33l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33l Modulo(M33i m, long s)
        {
            return new M33l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33l Modulo(long s, M33i m)
        {
            return new M33l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33f Modulo(M33i a, M33f b)
        {
            return new M33f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33f Modulo(M33i m, float s)
        {
            return new M33f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33f Modulo(float s, M33i m)
        {
            return new M33f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33d Modulo(M33i a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33d Modulo(M33i m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33d Modulo(double s, M33i m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33i operator /(M33i a, M33i b)
        {
            return new M33i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33i operator /(M33i m, int s)
        {
            return new M33i(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33i operator /(int s, M33i m)
        {
            return new M33i(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33l operator /(M33i a, M33l b)
        {
            return new M33l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33l operator /(M33i m, long s)
        {
            return new M33l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33l operator /(long s, M33i m)
        {
            return new M33l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33f operator /(M33i a, M33f b)
        {
            return new M33f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33f operator /(M33i m, float s)
        {
            return new M33f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33f operator /(float s, M33i m)
        {
            return new M33f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33d operator /(M33i a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33d operator /(M33i m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33d operator /(double s, M33i m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33i Divide(M33i a, M33i b)
        {
            return new M33i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33i Divide(M33i m, int s)
        {
            return new M33i(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33i Divide(int s, M33i m)
        {
            return new M33i(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33l Divide(M33i a, M33l b)
        {
            return new M33l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33l Divide(M33i m, long s)
        {
            return new M33l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33l Divide(long s, M33i m)
        {
            return new M33l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33f Divide(M33i a, M33f b)
        {
            return new M33f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33f Divide(M33i m, float s)
        {
            return new M33f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33f Divide(float s, M33i m)
        {
            return new M33f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33d Divide(M33i a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33d Divide(M33i m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33d Divide(double s, M33i m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33i operator *(M33i m, int s)
        {
            return new M33i(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33i operator *(int s, M33i m)
        {
            return new M33i(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33l operator *(M33i m, long s)
        {
            return new M33l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33l operator *(long s, M33i m)
        {
            return new M33l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33f operator *(M33i m, float s)
        {
            return new M33f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33f operator *(float s, M33i m)
        {
            return new M33f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33d operator *(M33i m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33d operator *(double s, M33i m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33i Multiply(M33i m, int s)
        {
            return new M33i(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33i Multiply(int s, M33i m)
        {
            return new M33i(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33l Multiply(M33i m, long s)
        {
            return new M33l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33l Multiply(long s, M33i m)
        {
            return new M33l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33f Multiply(M33i m, float s)
        {
            return new M33f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33f Multiply(float s, M33i m)
        {
            return new M33f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33d Multiply(M33i m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33d Multiply(double s, M33i m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V3i Multiply(M33i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        public static V3i operator *(M33i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        public static V3i TransposedMultiply(V3i v, M33i m)
        {
            return new V3i(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M33i a, M33i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22;
        }

        public static bool operator <(M33i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s;
        }

        public static bool operator <(int s, M33i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22 ;
        }

        public static bool operator >(M33i a, M33i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22;
        }

        public static bool operator >(M33i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s;
        }

        public static bool operator >(int s, M33i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22 ;
        }

        public static bool operator ==(M33i a, M33i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22;
        }

        public static bool operator ==(M33i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s;
        }

        public static bool operator ==(int s, M33i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22 ;
        }

        public static bool operator <=(M33i a, M33i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22;
        }

        public static bool operator <=(M33i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s;
        }

        public static bool operator <=(int s, M33i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22 ;
        }

        public static bool operator >=(M33i a, M33i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22;
        }

        public static bool operator >=(M33i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s;
        }

        public static bool operator >=(int s, M33i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22 ;
        }

        public static bool operator !=(M33i a, M33i b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M33i m, int s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(int s, M33i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M33i) ? (this == (M33i)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M33i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M33i.FromRows(
                V3i.Parse(x[0]), 
                V3i.Parse(x[1]), 
                V3i.Parse(x[2])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V2i TransformDir(M33i m, V2i v)
        {
            return new V2i(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2i TransformPos(M33i m, V2i p)
        {
            return new V2i(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V2i TransformDir(V2i v)
        {
            return new V2i(
                M00 * v.X + M01 * v.Y, 
                M10 * v.X + M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V2i TransformPos(V2i p)
        {
            return new V2i(
                M00 * p.X + M01 * p.Y + M02, 
                M10 * p.X + M11 * p.Y + M12
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V2i TransposedTransformDir(M33i m, V2i v)
        {
            return new V2i(
                m.M00 * v.X + m.M10 * v.Y, 
                m.M01 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2i TransposedTransformPos(M33i m, V2i p)
        {
            return new V2i(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of this matrix.
        /// </summary>
        public V2i TransposedTransformDir(V2i v)
        {
            return new V2i(
                M00 * v.X + M10 * v.Y, 
                M01 * v.X + M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by transposed version of this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V2i TransposedTransformPos(V2i p)
        {
            return new V2i(
                M00 * p.X + M10 * p.Y + M20, 
                M01 * p.X + M11 * p.Y + M21
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2i TransformPosProj(M33i m, V2i p)
        {
            int s = (m.M20 * p.X  + m.M21 * p.Y + m.M22);
            s = 1 / s;
            return (TransformPos(m, p)) * s;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3i TransformPosProjFull(M33i m, V2i p)
        {
            return new V3i(
                (m.M00 * p.X + m.M01 * p.Y+ m.M02), 
                (m.M10 * p.X + m.M11 * p.Y+ m.M12), 
                (m.M20 * p.X + m.M21 * p.Y+ m.M22)
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public V2i TransformPosProj(V2i p)
        {
            return TransformPosProj(this, p);
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V3i TransformPosProjFull(V2i p)
        {
            return TransformPosProjFull(this, p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V3i Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                case 2: return R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V3i Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public int Trace
        {
            get { return M00 + M11 + M22 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public int Det
        {
            get
            {
                if (M10 == 0 && M20 == 0 && M21 == 0)
                {
                    return M00 * M11 * M22;
                }
                return
                M00 * M11 * M22 - M00 * M12 * M21 +
                M01 * M12 * M20 - M01 * M10 * M22 +
                M02 * M10 * M21 - M02 * M11 * M20;
            }
        }
        
        /// <summary>
        /// Returns the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public int Determinant()
        {
            return Det;
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible { get { return Det != 0; } }
        
        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular { get { return Det == 0; } }

        /// <summary>
        /// Transposes this matrix (and returns this).
        /// </summary>
        public void Transpose()
        {
            Fun.Swap(ref M10, ref M01);
            Fun.Swap(ref M20, ref M02);
            Fun.Swap(ref M21, ref M12);
        }
        
        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M33i Transposed
        {
            get
            {
                return new M33i {
                    M00 = M00, M01 = M10, M02 = M20, 
                    M10 = M01, M11 = M11, M12 = M21, 
                    M20 = M02, M21 = M12, M22 = M22
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M33i operator *(M33i a, M33i b)
        {
            return new M33i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        public static M33i Multiply(M33i a, M33i b)
        {
            return new M33i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M33iEqualityComparer : IEqualityComparer<M33i>
    {
        public static readonly M33iEqualityComparer Default
            = new M33iEqualityComparer();

        #region IEqualityComparer<M33i> Members

        public bool Equals(M33i v0, M33i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M33i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M33l

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M33l : IValidity, IMatrix<double>
    {
        public long M00, M01, M02;
        public long M10, M11, M12;
        public long M20, M21, M22;

        #region Constructors

        public M33l(
                long m00, long m01, long m02, 
                long m10, long m11, long m12, 
                long m20, long m21, long m22)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
            M20 = m20; M21 = m21; M22 = m22; 
        }

        public M33l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
            M20 = a[6];
            M21 = a[7];
            M22 = a[8];
        }
        
        public M33l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
            M20 = a[start + 6];
            M21 = a[start + 7];
            M22 = a[start + 8];
        }

        #endregion

        #region Conversions

        public static explicit operator M33l(M22i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M23i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M33i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M34i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M44i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M22l m)
        {
            return new M33l {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M23l m)
        {
            return new M33l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M34l m)
        {
            return new M33l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33l(M44l m)
        {
            return new M33l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33l(M22f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M23f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M33f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M34f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M44f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M22d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M23d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M33d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M34d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M44d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(int[] a)
        {
            return new M33l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5], 
                (long)a[6], (long)a[7], (long)a[8]);
        }

        public static explicit operator M33l(int[,] a)
        {
            return new M33l (
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2]);
        }

        public static explicit operator int[](M33l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12, 
                (int)m.M20, (int)m.M21, (int)m.M22
            };
        }

        public static explicit operator int[,](M33l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
            array[index + 6] = (int)M20;
            array[index + 7] = (int)M21;
            array[index + 8] = (int)M22;
        }

        public static explicit operator M33l(long[] a)
        {
            return new M33l(
                a[0], a[1], a[2], 
                a[3], a[4], a[5], 
                a[6], a[7], a[8]);
        }

        public static explicit operator M33l(long[,] a)
        {
            return new M33l (
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2], 
                a[2, 0], a[2, 1], a[2, 2]);
        }

        public static explicit operator long[](M33l m)
        {
            return new long[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12, 
                m.M20, m.M21, m.M22
            };
        }

        public static explicit operator long[,](M33l m)
        {
            return new long[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }, 
                { m.M20, m.M21, m.M22 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
            array[index + 6] = M20;
            array[index + 7] = M21;
            array[index + 8] = M22;
        }

        public static explicit operator M33l(float[] a)
        {
            return new M33l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5], 
                (long)a[6], (long)a[7], (long)a[8]);
        }

        public static explicit operator M33l(float[,] a)
        {
            return new M33l (
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2]);
        }

        public static explicit operator float[](M33l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12, 
                (float)m.M20, (float)m.M21, (float)m.M22
            };
        }

        public static explicit operator float[,](M33l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
            array[index + 6] = (float)M20;
            array[index + 7] = (float)M21;
            array[index + 8] = (float)M22;
        }

        public static explicit operator M33l(double[] a)
        {
            return new M33l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5], 
                (long)a[6], (long)a[7], (long)a[8]);
        }

        public static explicit operator M33l(double[,] a)
        {
            return new M33l (
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2]);
        }

        public static explicit operator double[](M33l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12, 
                (double)m.M20, (double)m.M21, (double)m.M22
            };
        }

        public static explicit operator double[,](M33l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
            array[index + 6] = (double)M20;
            array[index + 7] = (double)M21;
            array[index + 8] = (double)M22;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<long, int> element_fun)
        {
            return new M33i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M33i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<long, long> element_fun)
        {
            return new M33l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M33l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<long, float> element_fun)
        {
            return new M33f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M33f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<long, double> element_fun)
        {
            return new M33d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M33d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M22l UpperLeftM22()
        {
            return (M22l)this;
        }

        public long[] ToArray()
        {
            var array = new long[9];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            array[6] = M20;
            array[7] = M21;
            array[8] = M22;
            return array;
        }

        #endregion

        #region Static Factories

        public static M33l FromCols(V3l col0, V3l col1, V3l col2)
        {
            return new M33l(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y, 
                col0.Z, col1.Z, col2.Z);
        }

        public static M33l FromRows(V3l row0, V3l row1, V3l row2)
        {
            return new M33l(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z, 
                row2.X, row2.Y, row2.Z);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<long> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M10;
                 yield return M11;
                 yield return M12;
                 yield return M20;
                 yield return M21;
                 yield return M22;
            }
        }

        public IEnumerable<V3l> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3l> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3l R0
        {                     
            get { return new V3l( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3l R1
        {                     
            get { return new V3l( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V3l R2
        {                     
            get { return new V3l( M20,  M21,  M22); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
            }
        }

        public V3l C0
        {           
            get { return new V3l( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3l C1
        {           
            get { return new V3l( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3l C2
        {           
            get { return new V3l( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public long this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    case 6: return M20;
                    case 7: return M21;
                    case 8: return M22;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    case 6: M20 = value; return;
                    case 7: M21 = value; return;
                    case 8: M22 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public long this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: return M20;
                                case 1: return M21;
                                case 2: return M22;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: M20 = value; return;
                                case 1: M21 = value; return;
                                case 2: M22 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 3;
        public const int ElementCount = 3*3;

        public static readonly V2l Dimensions = new V2l(3, 3);

        public static readonly M33l Zero
                = new M33l(0, 0, 0, 0, 0, 0, 0, 0, 0);

        public static readonly M33l Identity
                = new M33l(1, 0, 0, 0, 1, 0, 0, 0, 1);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + 
                    M20 * M20 + M21 * M21 + M22 * M22);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p) + 
                Fun.Abs(M20).Pow(p) + 
                Fun.Abs(M21).Pow(p) + 
                Fun.Abs(M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(M33l a, M33l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M33l a, M33l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M33l a, M33l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(M33l a, M33l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(M33l a, M33l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        #endregion

        #region Mathematical Operators

        public static M33l operator +(M33l a, M33l b)
        {
            return new M33l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33l operator +(M33l m, long s)
        {
            return new M33l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33l operator +(long s, M33l m)
        {
            return new M33l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33f operator +(M33l a, M33f b)
        {
            return new M33f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33f operator +(M33l m, float s)
        {
            return new M33f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33f operator +(float s, M33l m)
        {
            return new M33f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33d operator +(M33l a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33d operator +(M33l m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33d operator +(double s, M33l m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33l Add(M33l a, M33l b)
        {
            return new M33l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33l Add(M33l m, long s)
        {
            return new M33l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33l Add(long s, M33l m)
        {
            return new M33l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33f Add(M33l a, M33f b)
        {
            return new M33f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33f Add(M33l m, float s)
        {
            return new M33f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33f Add(float s, M33l m)
        {
            return new M33f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33d Add(M33l a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33d Add(M33l m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33d Add(double s, M33l m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33l operator -(M33l a, M33l b)
        {
            return new M33l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33l operator -(M33l m, long s)
        {
            return new M33l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33l operator -(long s, M33l m)
        {
            return new M33l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33f operator -(M33l a, M33f b)
        {
            return new M33f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33f operator -(M33l m, float s)
        {
            return new M33f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33f operator -(float s, M33l m)
        {
            return new M33f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33d operator -(M33l a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33d operator -(M33l m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33d operator -(double s, M33l m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33l Subtract(M33l a, M33l b)
        {
            return new M33l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33l Subtract(M33l m, long s)
        {
            return new M33l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33l Subtract(long s, M33l m)
        {
            return new M33l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33f Subtract(M33l a, M33f b)
        {
            return new M33f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33f Subtract(M33l m, float s)
        {
            return new M33f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33f Subtract(float s, M33l m)
        {
            return new M33f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33d Subtract(M33l a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33d Subtract(M33l m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33d Subtract(double s, M33l m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33l operator %(M33l a, M33l b)
        {
            return new M33l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33l operator %(M33l m, long s)
        {
            return new M33l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33l operator %(long s, M33l m)
        {
            return new M33l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33f operator %(M33l a, M33f b)
        {
            return new M33f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33f operator %(M33l m, float s)
        {
            return new M33f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33f operator %(float s, M33l m)
        {
            return new M33f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33d operator %(M33l a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33d operator %(M33l m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33d operator %(double s, M33l m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33l Modulo(M33l a, M33l b)
        {
            return new M33l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33l Modulo(M33l m, long s)
        {
            return new M33l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33l Modulo(long s, M33l m)
        {
            return new M33l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33f Modulo(M33l a, M33f b)
        {
            return new M33f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33f Modulo(M33l m, float s)
        {
            return new M33f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33f Modulo(float s, M33l m)
        {
            return new M33f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33d Modulo(M33l a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33d Modulo(M33l m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33d Modulo(double s, M33l m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33l operator /(M33l a, M33l b)
        {
            return new M33l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33l operator /(M33l m, long s)
        {
            return new M33l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33l operator /(long s, M33l m)
        {
            return new M33l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33f operator /(M33l a, M33f b)
        {
            return new M33f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33f operator /(M33l m, float s)
        {
            return new M33f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33f operator /(float s, M33l m)
        {
            return new M33f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33d operator /(M33l a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33d operator /(M33l m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33d operator /(double s, M33l m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33l Divide(M33l a, M33l b)
        {
            return new M33l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33l Divide(M33l m, long s)
        {
            return new M33l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33l Divide(long s, M33l m)
        {
            return new M33l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33f Divide(M33l a, M33f b)
        {
            return new M33f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33f Divide(M33l m, float s)
        {
            return new M33f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33f Divide(float s, M33l m)
        {
            return new M33f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33d Divide(M33l a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33d Divide(M33l m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33d Divide(double s, M33l m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33l operator *(M33l m, long s)
        {
            return new M33l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33l operator *(long s, M33l m)
        {
            return new M33l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33f operator *(M33l m, float s)
        {
            return new M33f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33f operator *(float s, M33l m)
        {
            return new M33f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33d operator *(M33l m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33d operator *(double s, M33l m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33l Multiply(M33l m, long s)
        {
            return new M33l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33l Multiply(long s, M33l m)
        {
            return new M33l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33f Multiply(M33l m, float s)
        {
            return new M33f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33f Multiply(float s, M33l m)
        {
            return new M33f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33d Multiply(M33l m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33d Multiply(double s, M33l m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V3l Multiply(M33l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        public static V3l operator *(M33l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        public static V3l TransposedMultiply(V3l v, M33l m)
        {
            return new V3l(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M33l a, M33l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22;
        }

        public static bool operator <(M33l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s;
        }

        public static bool operator <(long s, M33l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22 ;
        }

        public static bool operator >(M33l a, M33l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22;
        }

        public static bool operator >(M33l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s;
        }

        public static bool operator >(long s, M33l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22 ;
        }

        public static bool operator ==(M33l a, M33l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22;
        }

        public static bool operator ==(M33l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s;
        }

        public static bool operator ==(long s, M33l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22 ;
        }

        public static bool operator <=(M33l a, M33l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22;
        }

        public static bool operator <=(M33l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s;
        }

        public static bool operator <=(long s, M33l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22 ;
        }

        public static bool operator >=(M33l a, M33l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22;
        }

        public static bool operator >=(M33l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s;
        }

        public static bool operator >=(long s, M33l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22 ;
        }

        public static bool operator !=(M33l a, M33l b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M33l m, long s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(long s, M33l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M33l) ? (this == (M33l)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M33l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M33l.FromRows(
                V3l.Parse(x[0]), 
                V3l.Parse(x[1]), 
                V3l.Parse(x[2])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V2l TransformDir(M33l m, V2l v)
        {
            return new V2l(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2l TransformPos(M33l m, V2l p)
        {
            return new V2l(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V2l TransformDir(V2l v)
        {
            return new V2l(
                M00 * v.X + M01 * v.Y, 
                M10 * v.X + M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V2l TransformPos(V2l p)
        {
            return new V2l(
                M00 * p.X + M01 * p.Y + M02, 
                M10 * p.X + M11 * p.Y + M12
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V2l TransposedTransformDir(M33l m, V2l v)
        {
            return new V2l(
                m.M00 * v.X + m.M10 * v.Y, 
                m.M01 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2l TransposedTransformPos(M33l m, V2l p)
        {
            return new V2l(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of this matrix.
        /// </summary>
        public V2l TransposedTransformDir(V2l v)
        {
            return new V2l(
                M00 * v.X + M10 * v.Y, 
                M01 * v.X + M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by transposed version of this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V2l TransposedTransformPos(V2l p)
        {
            return new V2l(
                M00 * p.X + M10 * p.Y + M20, 
                M01 * p.X + M11 * p.Y + M21
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2l TransformPosProj(M33l m, V2l p)
        {
            long s = (m.M20 * p.X  + m.M21 * p.Y + m.M22);
            s = 1 / s;
            return (TransformPos(m, p)) * s;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3l TransformPosProjFull(M33l m, V2l p)
        {
            return new V3l(
                (m.M00 * p.X + m.M01 * p.Y+ m.M02), 
                (m.M10 * p.X + m.M11 * p.Y+ m.M12), 
                (m.M20 * p.X + m.M21 * p.Y+ m.M22)
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public V2l TransformPosProj(V2l p)
        {
            return TransformPosProj(this, p);
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V3l TransformPosProjFull(V2l p)
        {
            return TransformPosProjFull(this, p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V3l Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                case 2: return R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V3l Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public long Trace
        {
            get { return M00 + M11 + M22 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public long Det
        {
            get
            {
                if (M10 == 0 && M20 == 0 && M21 == 0)
                {
                    return M00 * M11 * M22;
                }
                return
                M00 * M11 * M22 - M00 * M12 * M21 +
                M01 * M12 * M20 - M01 * M10 * M22 +
                M02 * M10 * M21 - M02 * M11 * M20;
            }
        }
        
        /// <summary>
        /// Returns the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public long Determinant()
        {
            return Det;
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible { get { return Det != 0; } }
        
        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular { get { return Det == 0; } }

        /// <summary>
        /// Transposes this matrix (and returns this).
        /// </summary>
        public void Transpose()
        {
            Fun.Swap(ref M10, ref M01);
            Fun.Swap(ref M20, ref M02);
            Fun.Swap(ref M21, ref M12);
        }
        
        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M33l Transposed
        {
            get
            {
                return new M33l {
                    M00 = M00, M01 = M10, M02 = M20, 
                    M10 = M01, M11 = M11, M12 = M21, 
                    M20 = M02, M21 = M12, M22 = M22
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M33l operator *(M33l a, M33l b)
        {
            return new M33l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        public static M33l Multiply(M33l a, M33l b)
        {
            return new M33l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M33lEqualityComparer : IEqualityComparer<M33l>
    {
        public static readonly M33lEqualityComparer Default
            = new M33lEqualityComparer();

        #region IEqualityComparer<M33l> Members

        public bool Equals(M33l v0, M33l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M33l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M33f

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M33f : IValidity, IMatrix<double>
    {
        public float M00, M01, M02;
        public float M10, M11, M12;
        public float M20, M21, M22;

        #region Constructors

        public M33f(
                float m00, float m01, float m02, 
                float m10, float m11, float m12, 
                float m20, float m21, float m22)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
            M20 = m20; M21 = m21; M22 = m22; 
        }

        public M33f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
            M20 = a[6];
            M21 = a[7];
            M22 = a[8];
        }
        
        public M33f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
            M20 = a[start + 6];
            M21 = a[start + 7];
            M22 = a[start + 8];
        }

        #endregion

        #region Conversions

        public static explicit operator M33f(M22i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M23i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M33i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M34i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M44i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M22l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M23l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M33l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M34l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M44l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M22f m)
        {
            return new M33f {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M23f m)
        {
            return new M33f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M34f m)
        {
            return new M33f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33f(M44f m)
        {
            return new M33f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33f(M22d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M23d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M33d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M34d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M44d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(int[] a)
        {
            return new M33f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5], 
                (float)a[6], (float)a[7], (float)a[8]);
        }

        public static explicit operator M33f(int[,] a)
        {
            return new M33f (
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2]);
        }

        public static explicit operator int[](M33f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12, 
                (int)m.M20, (int)m.M21, (int)m.M22
            };
        }

        public static explicit operator int[,](M33f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
            array[index + 6] = (int)M20;
            array[index + 7] = (int)M21;
            array[index + 8] = (int)M22;
        }

        public static explicit operator M33f(long[] a)
        {
            return new M33f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5], 
                (float)a[6], (float)a[7], (float)a[8]);
        }

        public static explicit operator M33f(long[,] a)
        {
            return new M33f (
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2]);
        }

        public static explicit operator long[](M33f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12, 
                (long)m.M20, (long)m.M21, (long)m.M22
            };
        }

        public static explicit operator long[,](M33f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
            array[index + 6] = (long)M20;
            array[index + 7] = (long)M21;
            array[index + 8] = (long)M22;
        }

        public static explicit operator M33f(float[] a)
        {
            return new M33f(
                a[0], a[1], a[2], 
                a[3], a[4], a[5], 
                a[6], a[7], a[8]);
        }

        public static explicit operator M33f(float[,] a)
        {
            return new M33f (
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2], 
                a[2, 0], a[2, 1], a[2, 2]);
        }

        public static explicit operator float[](M33f m)
        {
            return new float[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12, 
                m.M20, m.M21, m.M22
            };
        }

        public static explicit operator float[,](M33f m)
        {
            return new float[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }, 
                { m.M20, m.M21, m.M22 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
            array[index + 6] = M20;
            array[index + 7] = M21;
            array[index + 8] = M22;
        }

        public static explicit operator M33f(double[] a)
        {
            return new M33f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5], 
                (float)a[6], (float)a[7], (float)a[8]);
        }

        public static explicit operator M33f(double[,] a)
        {
            return new M33f (
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2]);
        }

        public static explicit operator double[](M33f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12, 
                (double)m.M20, (double)m.M21, (double)m.M22
            };
        }

        public static explicit operator double[,](M33f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
            array[index + 6] = (double)M20;
            array[index + 7] = (double)M21;
            array[index + 8] = (double)M22;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<float, int> element_fun)
        {
            return new M33i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M33i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<float, long> element_fun)
        {
            return new M33l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M33l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<float, float> element_fun)
        {
            return new M33f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M33f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<float, double> element_fun)
        {
            return new M33d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M33d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M22f UpperLeftM22()
        {
            return (M22f)this;
        }

        public float[] ToArray()
        {
            var array = new float[9];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            array[6] = M20;
            array[7] = M21;
            array[8] = M22;
            return array;
        }

        #endregion

        #region Static Factories

        public static M33f FromCols(V3f col0, V3f col1, V3f col2)
        {
            return new M33f(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y, 
                col0.Z, col1.Z, col2.Z);
        }

        public static M33f FromRows(V3f row0, V3f row1, V3f row2)
        {
            return new M33f(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z, 
                row2.X, row2.Y, row2.Z);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<float> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M10;
                 yield return M11;
                 yield return M12;
                 yield return M20;
                 yield return M21;
                 yield return M22;
            }
        }

        public IEnumerable<V3f> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3f> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3f R0
        {                     
            get { return new V3f( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3f R1
        {                     
            get { return new V3f( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V3f R2
        {                     
            get { return new V3f( M20,  M21,  M22); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
            }
        }

        public V3f C0
        {           
            get { return new V3f( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3f C1
        {           
            get { return new V3f( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3f C2
        {           
            get { return new V3f( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    case 6: return M20;
                    case 7: return M21;
                    case 8: return M22;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    case 6: M20 = value; return;
                    case 7: M21 = value; return;
                    case 8: M22 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public float this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: return M20;
                                case 1: return M21;
                                case 2: return M22;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: M20 = value; return;
                                case 1: M21 = value; return;
                                case 2: M22 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 3;
        public const int ElementCount = 3*3;

        public static readonly V2l Dimensions = new V2l(3, 3);

        public static readonly M33f Zero
                = new M33f(0, 0, 0, 0, 0, 0, 0, 0, 0);

        public static readonly M33f Identity
                = new M33f(1, 0, 0, 0, 1, 0, 0, 0, 1);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + 
                    M20 * M20 + M21 * M21 + M22 * M22);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public float Norm(float p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p) + 
                Fun.Abs(M20).Pow(p) + 
                Fun.Abs(M21).Pow(p) + 
                Fun.Abs(M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(M33f a, M33f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(M33f a, M33f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(M33f a, M33f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(M33f a, M33f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(M33f a, M33f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        #endregion

        #region Mathematical Operators

        public static M33f operator +(M33f a, M33f b)
        {
            return new M33f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33f operator +(M33f m, float s)
        {
            return new M33f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33f operator +(float s, M33f m)
        {
            return new M33f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33d operator +(M33f a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33d operator +(M33f m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33d operator +(double s, M33f m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33f Add(M33f a, M33f b)
        {
            return new M33f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33f Add(M33f m, float s)
        {
            return new M33f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33f Add(float s, M33f m)
        {
            return new M33f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33d Add(M33f a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33d Add(M33f m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33d Add(double s, M33f m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33f operator -(M33f a, M33f b)
        {
            return new M33f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33f operator -(M33f m, float s)
        {
            return new M33f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33f operator -(float s, M33f m)
        {
            return new M33f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33d operator -(M33f a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33d operator -(M33f m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33d operator -(double s, M33f m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33f Subtract(M33f a, M33f b)
        {
            return new M33f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33f Subtract(M33f m, float s)
        {
            return new M33f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33f Subtract(float s, M33f m)
        {
            return new M33f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33d Subtract(M33f a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33d Subtract(M33f m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33d Subtract(double s, M33f m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33f operator %(M33f a, M33f b)
        {
            return new M33f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33f operator %(M33f m, float s)
        {
            return new M33f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33f operator %(float s, M33f m)
        {
            return new M33f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33d operator %(M33f a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33d operator %(M33f m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33d operator %(double s, M33f m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33f Modulo(M33f a, M33f b)
        {
            return new M33f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33f Modulo(M33f m, float s)
        {
            return new M33f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33f Modulo(float s, M33f m)
        {
            return new M33f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33d Modulo(M33f a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33d Modulo(M33f m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33d Modulo(double s, M33f m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33f operator /(M33f a, M33f b)
        {
            return new M33f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33f operator /(M33f m, float s)
        {
            return new M33f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33f operator /(float s, M33f m)
        {
            return new M33f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33d operator /(M33f a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33d operator /(M33f m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33d operator /(double s, M33f m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33f Divide(M33f a, M33f b)
        {
            return new M33f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33f Divide(M33f m, float s)
        {
            return new M33f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33f Divide(float s, M33f m)
        {
            return new M33f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33d Divide(M33f a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33d Divide(M33f m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33d Divide(double s, M33f m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33f operator *(M33f m, float s)
        {
            return new M33f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33f operator *(float s, M33f m)
        {
            return new M33f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33d operator *(M33f m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33d operator *(double s, M33f m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33f Multiply(M33f m, float s)
        {
            return new M33f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33f Multiply(float s, M33f m)
        {
            return new M33f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33d Multiply(M33f m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33d Multiply(double s, M33f m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V3f Multiply(M33f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        public static V3f operator *(M33f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        public static V3f TransposedMultiply(V3f v, M33f m)
        {
            return new V3f(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M33f a, M33f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22;
        }

        public static bool operator <(M33f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s;
        }

        public static bool operator <(float s, M33f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22 ;
        }

        public static bool operator >(M33f a, M33f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22;
        }

        public static bool operator >(M33f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s;
        }

        public static bool operator >(float s, M33f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22 ;
        }

        public static bool operator ==(M33f a, M33f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22;
        }

        public static bool operator ==(M33f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s;
        }

        public static bool operator ==(float s, M33f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22 ;
        }

        public static bool operator <=(M33f a, M33f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22;
        }

        public static bool operator <=(M33f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s;
        }

        public static bool operator <=(float s, M33f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22 ;
        }

        public static bool operator >=(M33f a, M33f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22;
        }

        public static bool operator >=(M33f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s;
        }

        public static bool operator >=(float s, M33f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22 ;
        }

        public static bool operator !=(M33f a, M33f b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M33f m, float s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(float s, M33f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M33f) ? (this == (M33f)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M33f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M33f.FromRows(
                V3f.Parse(x[0]), 
                V3f.Parse(x[1]), 
                V3f.Parse(x[2])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V2f TransformDir(M33f m, V2f v)
        {
            return new V2f(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2f TransformPos(M33f m, V2f p)
        {
            return new V2f(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V2f TransformDir(V2f v)
        {
            return new V2f(
                M00 * v.X + M01 * v.Y, 
                M10 * v.X + M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V2f TransformPos(V2f p)
        {
            return new V2f(
                M00 * p.X + M01 * p.Y + M02, 
                M10 * p.X + M11 * p.Y + M12
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V2f TransposedTransformDir(M33f m, V2f v)
        {
            return new V2f(
                m.M00 * v.X + m.M10 * v.Y, 
                m.M01 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2f TransposedTransformPos(M33f m, V2f p)
        {
            return new V2f(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of this matrix.
        /// </summary>
        public V2f TransposedTransformDir(V2f v)
        {
            return new V2f(
                M00 * v.X + M10 * v.Y, 
                M01 * v.X + M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by transposed version of this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V2f TransposedTransformPos(V2f p)
        {
            return new V2f(
                M00 * p.X + M10 * p.Y + M20, 
                M01 * p.X + M11 * p.Y + M21
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2f TransformPosProj(M33f m, V2f p)
        {
            float s = (m.M20 * p.X  + m.M21 * p.Y + m.M22);
            s = 1 / s;
            return (TransformPos(m, p)) * s;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3f TransformPosProjFull(M33f m, V2f p)
        {
            return new V3f(
                (m.M00 * p.X + m.M01 * p.Y+ m.M02), 
                (m.M10 * p.X + m.M11 * p.Y+ m.M12), 
                (m.M20 * p.X + m.M21 * p.Y+ m.M22)
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public V2f TransformPosProj(V2f p)
        {
            return TransformPosProj(this, p);
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V3f TransformPosProjFull(V2f p)
        {
            return TransformPosProjFull(this, p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V3f Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                case 2: return R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V3f Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public float Trace
        {
            get { return M00 + M11 + M22 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public float Det
        {
            get
            {
                if (M10 == 0 && M20 == 0 && M21 == 0)
                {
                    return M00 * M11 * M22;
                }
                return
                M00 * M11 * M22 - M00 * M12 * M21 +
                M01 * M12 * M20 - M01 * M10 * M22 +
                M02 * M10 * M21 - M02 * M11 * M20;
            }
        }
        
        /// <summary>
        /// Returns the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public float Determinant()
        {
            return Det;
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible { get { return Det != 0; } }
        
        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular { get { return Det == 0; } }

        /// <summary>
        /// Transposes this matrix (and returns this).
        /// </summary>
        public void Transpose()
        {
            Fun.Swap(ref M10, ref M01);
            Fun.Swap(ref M20, ref M02);
            Fun.Swap(ref M21, ref M12);
        }
        
        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M33f Transposed
        {
            get
            {
                return new M33f {
                    M00 = M00, M01 = M10, M02 = M20, 
                    M10 = M01, M11 = M11, M12 = M21, 
                    M20 = M02, M21 = M12, M22 = M22
                };
            }
        }

        private static V2l s_luSize = new V2l(3, 3);
        private static V2l s_luDelta = new V2l(1, 3);

        /// <summary>
        /// Inverts the matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return false;
            this = (M33f)(lu.LuInverse(p).Data);
            return true;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M33f.Zero is returned.
        /// </summary>
        public M33f LuInverse()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return M33f.Zero;
            return (M33f)(lu.LuInverse(p).Data);
        }

        /// <summary>
        /// Inverts the matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        public bool Invert() { return LuInvert();  }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M33f.Zero is returned.
        /// </summary>
        public M33f Inverse { get { return LuInverse(); } }

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximatelyEquals(M33f a, M33f b, float epsilon)
        {
            return DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        /// <summary>
        /// Returns if the matrix is the identity matrix I.
        /// </summary>
        public bool IsIdentity(float epsilon)
        {
            return ApproximatelyEquals(this, Identity, epsilon);
        }

        /// <summary>
        /// Returns if the matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        public bool IsOrthonormal(float epsilon)
        {
            var i = this * this.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        public bool IsOrthogonal(float epsilon)
        {
            var i = this * this.Transposed;
            for (int j = 0; j < 3; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }
        #endregion

        #region Matrix Multiplication

        public static M33f operator *(M33f a, M33f b)
        {
            return new M33f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        public static M33f Multiply(M33f a, M33f b)
        {
            return new M33f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M33fEqualityComparer : IEqualityComparer<M33f>
    {
        public static readonly M33fEqualityComparer Default
            = new M33fEqualityComparer();

        #region IEqualityComparer<M33f> Members

        public bool Equals(M33f v0, M33f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M33f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M33d

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M33d : IValidity, IMatrix<double>
    {
        public double M00, M01, M02;
        public double M10, M11, M12;
        public double M20, M21, M22;

        #region Constructors

        public M33d(
                double m00, double m01, double m02, 
                double m10, double m11, double m12, 
                double m20, double m21, double m22)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
            M20 = m20; M21 = m21; M22 = m22; 
        }

        public M33d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
            M20 = a[6];
            M21 = a[7];
            M22 = a[8];
        }
        
        public M33d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
            M20 = a[start + 6];
            M21 = a[start + 7];
            M22 = a[start + 8];
        }

        #endregion

        #region Conversions

        public static explicit operator M33d(M22i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M23i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M33i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M34i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M44i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M22l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M23l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M33l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M34l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M44l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M22f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M23f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M33f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M34f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M44f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M22d m)
        {
            return new M33d {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M23d m)
        {
            return new M33d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M34d m)
        {
            return new M33d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33d(M44d m)
        {
            return new M33d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33d(int[] a)
        {
            return new M33d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5], 
                (double)a[6], (double)a[7], (double)a[8]);
        }

        public static explicit operator M33d(int[,] a)
        {
            return new M33d (
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2]);
        }

        public static explicit operator int[](M33d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12, 
                (int)m.M20, (int)m.M21, (int)m.M22
            };
        }

        public static explicit operator int[,](M33d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
            array[index + 6] = (int)M20;
            array[index + 7] = (int)M21;
            array[index + 8] = (int)M22;
        }

        public static explicit operator M33d(long[] a)
        {
            return new M33d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5], 
                (double)a[6], (double)a[7], (double)a[8]);
        }

        public static explicit operator M33d(long[,] a)
        {
            return new M33d (
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2]);
        }

        public static explicit operator long[](M33d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12, 
                (long)m.M20, (long)m.M21, (long)m.M22
            };
        }

        public static explicit operator long[,](M33d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
            array[index + 6] = (long)M20;
            array[index + 7] = (long)M21;
            array[index + 8] = (long)M22;
        }

        public static explicit operator M33d(float[] a)
        {
            return new M33d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5], 
                (double)a[6], (double)a[7], (double)a[8]);
        }

        public static explicit operator M33d(float[,] a)
        {
            return new M33d (
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2]);
        }

        public static explicit operator float[](M33d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12, 
                (float)m.M20, (float)m.M21, (float)m.M22
            };
        }

        public static explicit operator float[,](M33d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
            array[index + 6] = (float)M20;
            array[index + 7] = (float)M21;
            array[index + 8] = (float)M22;
        }

        public static explicit operator M33d(double[] a)
        {
            return new M33d(
                a[0], a[1], a[2], 
                a[3], a[4], a[5], 
                a[6], a[7], a[8]);
        }

        public static explicit operator M33d(double[,] a)
        {
            return new M33d (
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2], 
                a[2, 0], a[2, 1], a[2, 2]);
        }

        public static explicit operator double[](M33d m)
        {
            return new double[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12, 
                m.M20, m.M21, m.M22
            };
        }

        public static explicit operator double[,](M33d m)
        {
            return new double[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }, 
                { m.M20, m.M21, m.M22 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
            array[index + 6] = M20;
            array[index + 7] = M21;
            array[index + 8] = M22;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<double, int> element_fun)
        {
            return new M33i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M33i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<double, long> element_fun)
        {
            return new M33l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M33l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<double, float> element_fun)
        {
            return new M33f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M33f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<double, double> element_fun)
        {
            return new M33d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M33d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M22d UpperLeftM22()
        {
            return (M22d)this;
        }

        public double[] ToArray()
        {
            var array = new double[9];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            array[6] = M20;
            array[7] = M21;
            array[8] = M22;
            return array;
        }

        #endregion

        #region Static Factories

        public static M33d FromCols(V3d col0, V3d col1, V3d col2)
        {
            return new M33d(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y, 
                col0.Z, col1.Z, col2.Z);
        }

        public static M33d FromRows(V3d row0, V3d row1, V3d row2)
        {
            return new M33d(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z, 
                row2.X, row2.Y, row2.Z);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<double> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M10;
                 yield return M11;
                 yield return M12;
                 yield return M20;
                 yield return M21;
                 yield return M22;
            }
        }

        public IEnumerable<V3d> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3d> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        public V3d R0
        {                     
            get { return new V3d( M00,  M01,  M02); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        public V3d R1
        {                     
            get { return new V3d( M10,  M11,  M12); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        public V3d R2
        {                     
            get { return new V3d( M20,  M21,  M22); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
            }
        }

        public V3d C0
        {           
            get { return new V3d( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3d C1
        {           
            get { return new V3d( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3d C2
        {           
            get { return new V3d( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public double this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M10;
                    case 4: return M11;
                    case 5: return M12;
                    case 6: return M20;
                    case 7: return M21;
                    case 8: return M22;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M10 = value; return;
                    case 4: M11 = value; return;
                    case 5: M12 = value; return;
                    case 6: M20 = value; return;
                    case 7: M21 = value; return;
                    case 8: M22 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public double this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: return M20;
                                case 1: return M21;
                                case 2: return M22;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: M20 = value; return;
                                case 1: M21 = value; return;
                                case 2: M22 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 3;
        public const int ElementCount = 3*3;

        public static readonly V2l Dimensions = new V2l(3, 3);

        public static readonly M33d Zero
                = new M33d(0, 0, 0, 0, 0, 0, 0, 0, 0);

        public static readonly M33d Identity
                = new M33d(1, 0, 0, 0, 1, 0, 0, 0, 1);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + 
                    M20 * M20 + M21 * M21 + M22 * M22);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p) + 
                Fun.Abs(M20).Pow(p) + 
                Fun.Abs(M21).Pow(p) + 
                Fun.Abs(M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(M33d a, M33d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M33d a, M33d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M33d a, M33d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(M33d a, M33d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(M33d a, M33d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        #endregion

        #region Mathematical Operators

        public static M33d operator +(M33d a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33d operator +(M33d m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33d operator +(double s, M33d m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33d Add(M33d a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        public static M33d Add(M33d m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }
        
        public static M33d Add(double s, M33d m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        public static M33d operator -(M33d a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33d operator -(M33d m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33d operator -(double s, M33d m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33d Subtract(M33d a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        public static M33d Subtract(M33d m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }
        
        public static M33d Subtract(double s, M33d m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        public static M33d operator %(M33d a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33d operator %(M33d m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33d operator %(double s, M33d m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33d Modulo(M33d a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        public static M33d Modulo(M33d m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }
        
        public static M33d Modulo(double s, M33d m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        public static M33d operator /(M33d a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33d operator /(M33d m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33d operator /(double s, M33d m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33d Divide(M33d a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        public static M33d Divide(M33d m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }
        
        public static M33d Divide(double s, M33d m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        public static M33d operator *(M33d m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33d operator *(double s, M33d m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        public static M33d Multiply(M33d m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }
        
        public static M33d Multiply(double s, M33d m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V3d Multiply(M33d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        public static V3d operator *(M33d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        public static V3d TransposedMultiply(V3d v, M33d m)
        {
            return new V3d(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M33d a, M33d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22;
        }

        public static bool operator <(M33d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s;
        }

        public static bool operator <(double s, M33d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22 ;
        }

        public static bool operator >(M33d a, M33d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22;
        }

        public static bool operator >(M33d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s;
        }

        public static bool operator >(double s, M33d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22 ;
        }

        public static bool operator ==(M33d a, M33d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22;
        }

        public static bool operator ==(M33d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s;
        }

        public static bool operator ==(double s, M33d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22 ;
        }

        public static bool operator <=(M33d a, M33d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22;
        }

        public static bool operator <=(M33d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s;
        }

        public static bool operator <=(double s, M33d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22 ;
        }

        public static bool operator >=(M33d a, M33d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22;
        }

        public static bool operator >=(M33d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s;
        }

        public static bool operator >=(double s, M33d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22 ;
        }

        public static bool operator !=(M33d a, M33d b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M33d m, double s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(double s, M33d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M33d) ? (this == (M33d)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M33d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M33d.FromRows(
                V3d.Parse(x[0]), 
                V3d.Parse(x[1]), 
                V3d.Parse(x[2])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V2d TransformDir(M33d m, V2d v)
        {
            return new V2d(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2d TransformPos(M33d m, V2d p)
        {
            return new V2d(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V2d TransformDir(V2d v)
        {
            return new V2d(
                M00 * v.X + M01 * v.Y, 
                M10 * v.X + M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V2d TransformPos(V2d p)
        {
            return new V2d(
                M00 * p.X + M01 * p.Y + M02, 
                M10 * p.X + M11 * p.Y + M12
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V2d TransposedTransformDir(M33d m, V2d v)
        {
            return new V2d(
                m.M00 * v.X + m.M10 * v.Y, 
                m.M01 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2d TransposedTransformPos(M33d m, V2d p)
        {
            return new V2d(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of this matrix.
        /// </summary>
        public V2d TransposedTransformDir(V2d v)
        {
            return new V2d(
                M00 * v.X + M10 * v.Y, 
                M01 * v.X + M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by transposed version of this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V2d TransposedTransformPos(V2d p)
        {
            return new V2d(
                M00 * p.X + M10 * p.Y + M20, 
                M01 * p.X + M11 * p.Y + M21
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2d TransformPosProj(M33d m, V2d p)
        {
            double s = (m.M20 * p.X  + m.M21 * p.Y + m.M22);
            s = 1 / s;
            return (TransformPos(m, p)) * s;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3d TransformPosProjFull(M33d m, V2d p)
        {
            return new V3d(
                (m.M00 * p.X + m.M01 * p.Y+ m.M02), 
                (m.M10 * p.X + m.M11 * p.Y+ m.M12), 
                (m.M20 * p.X + m.M21 * p.Y+ m.M22)
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public V2d TransformPosProj(V2d p)
        {
            return TransformPosProj(this, p);
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V3d TransformPosProjFull(V2d p)
        {
            return TransformPosProjFull(this, p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V3d Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                case 2: return R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V3d Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public double Trace
        {
            get { return M00 + M11 + M22 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public double Det
        {
            get
            {
                if (M10 == 0 && M20 == 0 && M21 == 0)
                {
                    return M00 * M11 * M22;
                }
                return
                M00 * M11 * M22 - M00 * M12 * M21 +
                M01 * M12 * M20 - M01 * M10 * M22 +
                M02 * M10 * M21 - M02 * M11 * M20;
            }
        }
        
        /// <summary>
        /// Returns the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public double Determinant()
        {
            return Det;
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible { get { return Det != 0; } }
        
        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular { get { return Det == 0; } }

        /// <summary>
        /// Transposes this matrix (and returns this).
        /// </summary>
        public void Transpose()
        {
            Fun.Swap(ref M10, ref M01);
            Fun.Swap(ref M20, ref M02);
            Fun.Swap(ref M21, ref M12);
        }
        
        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M33d Transposed
        {
            get
            {
                return new M33d {
                    M00 = M00, M01 = M10, M02 = M20, 
                    M10 = M01, M11 = M11, M12 = M21, 
                    M20 = M02, M21 = M12, M22 = M22
                };
            }
        }

        private static V2l s_luSize = new V2l(3, 3);
        private static V2l s_luDelta = new V2l(1, 3);

        /// <summary>
        /// Inverts the matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return false;
            this = (M33d)(lu.LuInverse(p).Data);
            return true;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M33d.Zero is returned.
        /// </summary>
        public M33d LuInverse()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return M33d.Zero;
            return (M33d)(lu.LuInverse(p).Data);
        }

        /// <summary>
        /// Inverts the matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        public bool Invert() { return LuInvert();  }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M33d.Zero is returned.
        /// </summary>
        public M33d Inverse { get { return LuInverse(); } }

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximatelyEquals(M33d a, M33d b, double epsilon)
        {
            return DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        /// <summary>
        /// Returns if the matrix is the identity matrix I.
        /// </summary>
        public bool IsIdentity(double epsilon)
        {
            return ApproximatelyEquals(this, Identity, epsilon);
        }

        /// <summary>
        /// Returns if the matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        public bool IsOrthonormal(double epsilon)
        {
            var i = this * this.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        public bool IsOrthogonal(double epsilon)
        {
            var i = this * this.Transposed;
            for (int j = 0; j < 3; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }
        #endregion

        #region Matrix Multiplication

        public static M33d operator *(M33d a, M33d b)
        {
            return new M33d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        public static M33d Multiply(M33d a, M33d b)
        {
            return new M33d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M33dEqualityComparer : IEqualityComparer<M33d>
    {
        public static readonly M33dEqualityComparer Default
            = new M33dEqualityComparer();

        #region IEqualityComparer<M33d> Members

        public bool Equals(M33d v0, M33d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M33d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M34i

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M34i : IValidity, IMatrix<double>
    {
        public int M00, M01, M02, M03;
        public int M10, M11, M12, M13;
        public int M20, M21, M22, M23;

        #region Constructors

        public M34i(
                int m00, int m01, int m02, int m03, 
                int m10, int m11, int m12, int m13, 
                int m20, int m21, int m22, int m23)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
        }

        public M34i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
        }
        
        public M34i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
        }

        #endregion

        #region Conversions

        public static explicit operator M34i(M22i m)
        {
            return new M34i {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M23i m)
        {
            return new M34i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M33i m)
        {
            return new M34i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34i(M44i m)
        {
            return new M34i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
            };
        }

        public static explicit operator M34i(M22l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M23l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M33l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34i(M34l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M44l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M22f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M23f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M33f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34i(M34f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M44f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M22d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M23d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M33d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34i(M34d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M44d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(int[] a)
        {
            return new M34i(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11]);
        }

        public static explicit operator M34i(int[,] a)
        {
            return new M34i (
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3]);
        }

        public static explicit operator int[](M34i m)
        {
            return new int[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23
            };
        }

        public static explicit operator int[,](M34i m)
        {
            return new int[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
        }

        public static explicit operator M34i(long[] a)
        {
            return new M34i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11]);
        }

        public static explicit operator M34i(long[,] a)
        {
            return new M34i (
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3]);
        }

        public static explicit operator long[](M34i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23
            };
        }

        public static explicit operator long[,](M34i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
        }

        public static explicit operator M34i(float[] a)
        {
            return new M34i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11]);
        }

        public static explicit operator M34i(float[,] a)
        {
            return new M34i (
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3]);
        }

        public static explicit operator float[](M34i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23
            };
        }

        public static explicit operator float[,](M34i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
        }

        public static explicit operator M34i(double[] a)
        {
            return new M34i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11]);
        }

        public static explicit operator M34i(double[,] a)
        {
            return new M34i (
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3]);
        }

        public static explicit operator double[](M34i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23
            };
        }

        public static explicit operator double[,](M34i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<int, int> element_fun)
        {
            return new M34i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M34i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<int, long> element_fun)
        {
            return new M34l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M34l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<int, float> element_fun)
        {
            return new M34f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M34f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<int, double> element_fun)
        {
            return new M34d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M34d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        public int[] ToArray()
        {
            var array = new int[12];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            return array;
        }

        #endregion

        #region Static Factories

        public static M34i FromCols(V3i col0, V3i col1, V3i col2, V3i col3)
        {
            return new M34i(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z);
        }

        public static M34i FromRows(V4i row0, V4i row1, V4i row2)
        {
            return new M34i(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<int> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M03;
                 yield return M10;
                 yield return M11;
                 yield return M12;
                 yield return M13;
                 yield return M20;
                 yield return M21;
                 yield return M22;
                 yield return M23;
            }
        }

        public IEnumerable<V4i> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3i> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4i R0
        {                     
            get { return new V4i( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4i R1
        {                     
            get { return new V4i( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4i R2
        {                     
            get { return new V4i( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V3i C0
        {           
            get { return new V3i( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3i C1
        {           
            get { return new V3i( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3i C2
        {           
            get { return new V3i( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public V3i C3
        {           
            get { return new V3i( M03,  M13,  M23); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
            }
        }

        public int this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public int this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                case 3: return M03;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                case 3: return M13;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: return M20;
                                case 1: return M21;
                                case 2: return M22;
                                case 3: return M23;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                case 3: M03 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                case 3: M13 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: M20 = value; return;
                                case 1: M21 = value; return;
                                case 2: M22 = value; return;
                                case 3: M23 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 4;
        public const int ElementCount = 3*4;

        public static readonly V2l Dimensions = new V2l(3, 4);

        public static readonly M34i Zero
                = new M34i(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

        public static readonly M34i Identity
                = new M34i(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M03).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p) + 
                Fun.Abs(M13).Pow(p) + 
                Fun.Abs(M20).Pow(p) + 
                Fun.Abs(M21).Pow(p) + 
                Fun.Abs(M22).Pow(p) + 
                Fun.Abs(M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(M34i a, M34i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M34i a, M34i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M34i a, M34i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(M34i a, M34i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(M34i a, M34i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        #endregion

        #region Mathematical Operators

        public static M34i operator +(M34i a, M34i b)
        {
            return new M34i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34i operator +(M34i m, int s)
        {
            return new M34i(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34i operator +(int s, M34i m)
        {
            return new M34i(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34l operator +(M34i a, M34l b)
        {
            return new M34l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34l operator +(M34i m, long s)
        {
            return new M34l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34l operator +(long s, M34i m)
        {
            return new M34l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34f operator +(M34i a, M34f b)
        {
            return new M34f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34f operator +(M34i m, float s)
        {
            return new M34f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34f operator +(float s, M34i m)
        {
            return new M34f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34d operator +(M34i a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34d operator +(M34i m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34d operator +(double s, M34i m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34i Add(M34i a, M34i b)
        {
            return new M34i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34i Add(M34i m, int s)
        {
            return new M34i(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34i Add(int s, M34i m)
        {
            return new M34i(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34l Add(M34i a, M34l b)
        {
            return new M34l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34l Add(M34i m, long s)
        {
            return new M34l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34l Add(long s, M34i m)
        {
            return new M34l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34f Add(M34i a, M34f b)
        {
            return new M34f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34f Add(M34i m, float s)
        {
            return new M34f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34f Add(float s, M34i m)
        {
            return new M34f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34d Add(M34i a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34d Add(M34i m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34d Add(double s, M34i m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34i operator -(M34i a, M34i b)
        {
            return new M34i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34i operator -(M34i m, int s)
        {
            return new M34i(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34i operator -(int s, M34i m)
        {
            return new M34i(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34l operator -(M34i a, M34l b)
        {
            return new M34l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34l operator -(M34i m, long s)
        {
            return new M34l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34l operator -(long s, M34i m)
        {
            return new M34l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34f operator -(M34i a, M34f b)
        {
            return new M34f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34f operator -(M34i m, float s)
        {
            return new M34f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34f operator -(float s, M34i m)
        {
            return new M34f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34d operator -(M34i a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34d operator -(M34i m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34d operator -(double s, M34i m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34i Subtract(M34i a, M34i b)
        {
            return new M34i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34i Subtract(M34i m, int s)
        {
            return new M34i(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34i Subtract(int s, M34i m)
        {
            return new M34i(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34l Subtract(M34i a, M34l b)
        {
            return new M34l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34l Subtract(M34i m, long s)
        {
            return new M34l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34l Subtract(long s, M34i m)
        {
            return new M34l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34f Subtract(M34i a, M34f b)
        {
            return new M34f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34f Subtract(M34i m, float s)
        {
            return new M34f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34f Subtract(float s, M34i m)
        {
            return new M34f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34d Subtract(M34i a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34d Subtract(M34i m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34d Subtract(double s, M34i m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34i operator %(M34i a, M34i b)
        {
            return new M34i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34i operator %(M34i m, int s)
        {
            return new M34i(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34i operator %(int s, M34i m)
        {
            return new M34i(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34l operator %(M34i a, M34l b)
        {
            return new M34l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34l operator %(M34i m, long s)
        {
            return new M34l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34l operator %(long s, M34i m)
        {
            return new M34l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34f operator %(M34i a, M34f b)
        {
            return new M34f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34f operator %(M34i m, float s)
        {
            return new M34f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34f operator %(float s, M34i m)
        {
            return new M34f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34d operator %(M34i a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34d operator %(M34i m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34d operator %(double s, M34i m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34i Modulo(M34i a, M34i b)
        {
            return new M34i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34i Modulo(M34i m, int s)
        {
            return new M34i(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34i Modulo(int s, M34i m)
        {
            return new M34i(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34l Modulo(M34i a, M34l b)
        {
            return new M34l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34l Modulo(M34i m, long s)
        {
            return new M34l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34l Modulo(long s, M34i m)
        {
            return new M34l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34f Modulo(M34i a, M34f b)
        {
            return new M34f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34f Modulo(M34i m, float s)
        {
            return new M34f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34f Modulo(float s, M34i m)
        {
            return new M34f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34d Modulo(M34i a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34d Modulo(M34i m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34d Modulo(double s, M34i m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34i operator /(M34i a, M34i b)
        {
            return new M34i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34i operator /(M34i m, int s)
        {
            return new M34i(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34i operator /(int s, M34i m)
        {
            return new M34i(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34l operator /(M34i a, M34l b)
        {
            return new M34l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34l operator /(M34i m, long s)
        {
            return new M34l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34l operator /(long s, M34i m)
        {
            return new M34l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34f operator /(M34i a, M34f b)
        {
            return new M34f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34f operator /(M34i m, float s)
        {
            return new M34f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34f operator /(float s, M34i m)
        {
            return new M34f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34d operator /(M34i a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34d operator /(M34i m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34d operator /(double s, M34i m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34i Divide(M34i a, M34i b)
        {
            return new M34i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34i Divide(M34i m, int s)
        {
            return new M34i(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34i Divide(int s, M34i m)
        {
            return new M34i(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34l Divide(M34i a, M34l b)
        {
            return new M34l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34l Divide(M34i m, long s)
        {
            return new M34l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34l Divide(long s, M34i m)
        {
            return new M34l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34f Divide(M34i a, M34f b)
        {
            return new M34f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34f Divide(M34i m, float s)
        {
            return new M34f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34f Divide(float s, M34i m)
        {
            return new M34f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34d Divide(M34i a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34d Divide(M34i m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34d Divide(double s, M34i m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34i operator *(M34i m, int s)
        {
            return new M34i(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34i operator *(int s, M34i m)
        {
            return new M34i(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34l operator *(M34i m, long s)
        {
            return new M34l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34l operator *(long s, M34i m)
        {
            return new M34l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34f operator *(M34i m, float s)
        {
            return new M34f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34f operator *(float s, M34i m)
        {
            return new M34f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34d operator *(M34i m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34d operator *(double s, M34i m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34i Multiply(M34i m, int s)
        {
            return new M34i(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34i Multiply(int s, M34i m)
        {
            return new M34i(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34l Multiply(M34i m, long s)
        {
            return new M34l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34l Multiply(long s, M34i m)
        {
            return new M34l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34f Multiply(M34i m, float s)
        {
            return new M34f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34f Multiply(float s, M34i m)
        {
            return new M34f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34d Multiply(M34i m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34d Multiply(double s, M34i m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V3i Multiply(M34i m, V4i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        public static V3i operator *(M34i m, V4i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M34i a, M34i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23;
        }

        public static bool operator <(M34i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s;
        }

        public static bool operator <(int s, M34i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23 ;
        }

        public static bool operator >(M34i a, M34i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23;
        }

        public static bool operator >(M34i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s;
        }

        public static bool operator >(int s, M34i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23 ;
        }

        public static bool operator ==(M34i a, M34i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23;
        }

        public static bool operator ==(M34i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s;
        }

        public static bool operator ==(int s, M34i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23 ;
        }

        public static bool operator <=(M34i a, M34i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23;
        }

        public static bool operator <=(M34i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s;
        }

        public static bool operator <=(int s, M34i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23 ;
        }

        public static bool operator >=(M34i a, M34i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23;
        }

        public static bool operator >=(M34i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s;
        }

        public static bool operator >=(int s, M34i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23 ;
        }

        public static bool operator !=(M34i a, M34i b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M34i m, int s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(int s, M34i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M34i) ? (this == (M34i)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M34i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M34i.FromRows(
                V4i.Parse(x[0]), 
                V4i.Parse(x[1]), 
                V4i.Parse(x[2])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V3i TransformDir(M34i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3i TransformPos(M34i m, V3i p)
        {
            return new V3i(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V3i TransformDir(V3i v)
        {
            return new V3i(
                M00 * v.X + M01 * v.Y + M02 * v.Z, 
                M10 * v.X + M11 * v.Y + M12 * v.Z, 
                M20 * v.X + M21 * v.Y + M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V3i TransformPos(V3i p)
        {
            return new V3i(
                M00 * p.X + M01 * p.Y + M02 * p.Z + M03, 
                M10 * p.X + M11 * p.Y + M12 * p.Z + M13, 
                M20 * p.X + M21 * p.Y + M22 * p.Z + M23
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3i TransformPosProj(M34i m, V3i p)
        {
            return TransformDir(m, p);
        }
        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V3i TransformPosProj(V3i p)
        {
            return TransformDir(p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V4i Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                case 2: return R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V3i Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                case 3: return C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M34i operator *(M33i a, M34i b)
        {
            return new M34i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34i Multiply(M33i a, M34i b)
        {
            return new M34i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34i operator *(M34i a, M44i b)
        {
            return new M34i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        public static M34i Multiply(M34i a, M44i b)
        {
            return new M34i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M34iEqualityComparer : IEqualityComparer<M34i>
    {
        public static readonly M34iEqualityComparer Default
            = new M34iEqualityComparer();

        #region IEqualityComparer<M34i> Members

        public bool Equals(M34i v0, M34i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M34i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M34l

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M34l : IValidity, IMatrix<double>
    {
        public long M00, M01, M02, M03;
        public long M10, M11, M12, M13;
        public long M20, M21, M22, M23;

        #region Constructors

        public M34l(
                long m00, long m01, long m02, long m03, 
                long m10, long m11, long m12, long m13, 
                long m20, long m21, long m22, long m23)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
        }

        public M34l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
        }
        
        public M34l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
        }

        #endregion

        #region Conversions

        public static explicit operator M34l(M22i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M23i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M33i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34l(M34i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M44i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M22l m)
        {
            return new M34l {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M23l m)
        {
            return new M34l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M33l m)
        {
            return new M34l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34l(M44l m)
        {
            return new M34l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
            };
        }

        public static explicit operator M34l(M22f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M23f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M33f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34l(M34f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M44f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M22d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M23d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M33d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34l(M34d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M44d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(int[] a)
        {
            return new M34l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11]);
        }

        public static explicit operator M34l(int[,] a)
        {
            return new M34l (
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3]);
        }

        public static explicit operator int[](M34l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23
            };
        }

        public static explicit operator int[,](M34l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
        }

        public static explicit operator M34l(long[] a)
        {
            return new M34l(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11]);
        }

        public static explicit operator M34l(long[,] a)
        {
            return new M34l (
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3]);
        }

        public static explicit operator long[](M34l m)
        {
            return new long[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23
            };
        }

        public static explicit operator long[,](M34l m)
        {
            return new long[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
        }

        public static explicit operator M34l(float[] a)
        {
            return new M34l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11]);
        }

        public static explicit operator M34l(float[,] a)
        {
            return new M34l (
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3]);
        }

        public static explicit operator float[](M34l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23
            };
        }

        public static explicit operator float[,](M34l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
        }

        public static explicit operator M34l(double[] a)
        {
            return new M34l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11]);
        }

        public static explicit operator M34l(double[,] a)
        {
            return new M34l (
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3]);
        }

        public static explicit operator double[](M34l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23
            };
        }

        public static explicit operator double[,](M34l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<long, int> element_fun)
        {
            return new M34i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M34i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<long, long> element_fun)
        {
            return new M34l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M34l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<long, float> element_fun)
        {
            return new M34f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M34f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<long, double> element_fun)
        {
            return new M34d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M34d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        public long[] ToArray()
        {
            var array = new long[12];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            return array;
        }

        #endregion

        #region Static Factories

        public static M34l FromCols(V3l col0, V3l col1, V3l col2, V3l col3)
        {
            return new M34l(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z);
        }

        public static M34l FromRows(V4l row0, V4l row1, V4l row2)
        {
            return new M34l(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<long> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M03;
                 yield return M10;
                 yield return M11;
                 yield return M12;
                 yield return M13;
                 yield return M20;
                 yield return M21;
                 yield return M22;
                 yield return M23;
            }
        }

        public IEnumerable<V4l> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3l> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4l R0
        {                     
            get { return new V4l( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4l R1
        {                     
            get { return new V4l( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4l R2
        {                     
            get { return new V4l( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V3l C0
        {           
            get { return new V3l( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3l C1
        {           
            get { return new V3l( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3l C2
        {           
            get { return new V3l( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public V3l C3
        {           
            get { return new V3l( M03,  M13,  M23); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
            }
        }

        public long this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public long this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                case 3: return M03;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                case 3: return M13;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: return M20;
                                case 1: return M21;
                                case 2: return M22;
                                case 3: return M23;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                case 3: M03 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                case 3: M13 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: M20 = value; return;
                                case 1: M21 = value; return;
                                case 2: M22 = value; return;
                                case 3: M23 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 4;
        public const int ElementCount = 3*4;

        public static readonly V2l Dimensions = new V2l(3, 4);

        public static readonly M34l Zero
                = new M34l(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

        public static readonly M34l Identity
                = new M34l(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M03).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p) + 
                Fun.Abs(M13).Pow(p) + 
                Fun.Abs(M20).Pow(p) + 
                Fun.Abs(M21).Pow(p) + 
                Fun.Abs(M22).Pow(p) + 
                Fun.Abs(M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(M34l a, M34l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M34l a, M34l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M34l a, M34l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(M34l a, M34l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(M34l a, M34l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        #endregion

        #region Mathematical Operators

        public static M34l operator +(M34l a, M34l b)
        {
            return new M34l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34l operator +(M34l m, long s)
        {
            return new M34l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34l operator +(long s, M34l m)
        {
            return new M34l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34f operator +(M34l a, M34f b)
        {
            return new M34f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34f operator +(M34l m, float s)
        {
            return new M34f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34f operator +(float s, M34l m)
        {
            return new M34f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34d operator +(M34l a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34d operator +(M34l m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34d operator +(double s, M34l m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34l Add(M34l a, M34l b)
        {
            return new M34l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34l Add(M34l m, long s)
        {
            return new M34l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34l Add(long s, M34l m)
        {
            return new M34l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34f Add(M34l a, M34f b)
        {
            return new M34f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34f Add(M34l m, float s)
        {
            return new M34f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34f Add(float s, M34l m)
        {
            return new M34f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34d Add(M34l a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34d Add(M34l m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34d Add(double s, M34l m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34l operator -(M34l a, M34l b)
        {
            return new M34l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34l operator -(M34l m, long s)
        {
            return new M34l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34l operator -(long s, M34l m)
        {
            return new M34l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34f operator -(M34l a, M34f b)
        {
            return new M34f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34f operator -(M34l m, float s)
        {
            return new M34f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34f operator -(float s, M34l m)
        {
            return new M34f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34d operator -(M34l a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34d operator -(M34l m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34d operator -(double s, M34l m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34l Subtract(M34l a, M34l b)
        {
            return new M34l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34l Subtract(M34l m, long s)
        {
            return new M34l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34l Subtract(long s, M34l m)
        {
            return new M34l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34f Subtract(M34l a, M34f b)
        {
            return new M34f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34f Subtract(M34l m, float s)
        {
            return new M34f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34f Subtract(float s, M34l m)
        {
            return new M34f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34d Subtract(M34l a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34d Subtract(M34l m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34d Subtract(double s, M34l m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34l operator %(M34l a, M34l b)
        {
            return new M34l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34l operator %(M34l m, long s)
        {
            return new M34l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34l operator %(long s, M34l m)
        {
            return new M34l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34f operator %(M34l a, M34f b)
        {
            return new M34f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34f operator %(M34l m, float s)
        {
            return new M34f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34f operator %(float s, M34l m)
        {
            return new M34f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34d operator %(M34l a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34d operator %(M34l m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34d operator %(double s, M34l m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34l Modulo(M34l a, M34l b)
        {
            return new M34l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34l Modulo(M34l m, long s)
        {
            return new M34l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34l Modulo(long s, M34l m)
        {
            return new M34l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34f Modulo(M34l a, M34f b)
        {
            return new M34f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34f Modulo(M34l m, float s)
        {
            return new M34f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34f Modulo(float s, M34l m)
        {
            return new M34f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34d Modulo(M34l a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34d Modulo(M34l m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34d Modulo(double s, M34l m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34l operator /(M34l a, M34l b)
        {
            return new M34l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34l operator /(M34l m, long s)
        {
            return new M34l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34l operator /(long s, M34l m)
        {
            return new M34l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34f operator /(M34l a, M34f b)
        {
            return new M34f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34f operator /(M34l m, float s)
        {
            return new M34f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34f operator /(float s, M34l m)
        {
            return new M34f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34d operator /(M34l a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34d operator /(M34l m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34d operator /(double s, M34l m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34l Divide(M34l a, M34l b)
        {
            return new M34l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34l Divide(M34l m, long s)
        {
            return new M34l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34l Divide(long s, M34l m)
        {
            return new M34l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34f Divide(M34l a, M34f b)
        {
            return new M34f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34f Divide(M34l m, float s)
        {
            return new M34f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34f Divide(float s, M34l m)
        {
            return new M34f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34d Divide(M34l a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34d Divide(M34l m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34d Divide(double s, M34l m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34l operator *(M34l m, long s)
        {
            return new M34l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34l operator *(long s, M34l m)
        {
            return new M34l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34f operator *(M34l m, float s)
        {
            return new M34f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34f operator *(float s, M34l m)
        {
            return new M34f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34d operator *(M34l m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34d operator *(double s, M34l m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34l Multiply(M34l m, long s)
        {
            return new M34l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34l Multiply(long s, M34l m)
        {
            return new M34l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34f Multiply(M34l m, float s)
        {
            return new M34f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34f Multiply(float s, M34l m)
        {
            return new M34f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34d Multiply(M34l m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34d Multiply(double s, M34l m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V3l Multiply(M34l m, V4l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        public static V3l operator *(M34l m, V4l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M34l a, M34l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23;
        }

        public static bool operator <(M34l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s;
        }

        public static bool operator <(long s, M34l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23 ;
        }

        public static bool operator >(M34l a, M34l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23;
        }

        public static bool operator >(M34l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s;
        }

        public static bool operator >(long s, M34l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23 ;
        }

        public static bool operator ==(M34l a, M34l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23;
        }

        public static bool operator ==(M34l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s;
        }

        public static bool operator ==(long s, M34l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23 ;
        }

        public static bool operator <=(M34l a, M34l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23;
        }

        public static bool operator <=(M34l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s;
        }

        public static bool operator <=(long s, M34l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23 ;
        }

        public static bool operator >=(M34l a, M34l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23;
        }

        public static bool operator >=(M34l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s;
        }

        public static bool operator >=(long s, M34l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23 ;
        }

        public static bool operator !=(M34l a, M34l b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M34l m, long s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(long s, M34l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M34l) ? (this == (M34l)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M34l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M34l.FromRows(
                V4l.Parse(x[0]), 
                V4l.Parse(x[1]), 
                V4l.Parse(x[2])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V3l TransformDir(M34l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3l TransformPos(M34l m, V3l p)
        {
            return new V3l(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V3l TransformDir(V3l v)
        {
            return new V3l(
                M00 * v.X + M01 * v.Y + M02 * v.Z, 
                M10 * v.X + M11 * v.Y + M12 * v.Z, 
                M20 * v.X + M21 * v.Y + M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V3l TransformPos(V3l p)
        {
            return new V3l(
                M00 * p.X + M01 * p.Y + M02 * p.Z + M03, 
                M10 * p.X + M11 * p.Y + M12 * p.Z + M13, 
                M20 * p.X + M21 * p.Y + M22 * p.Z + M23
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3l TransformPosProj(M34l m, V3l p)
        {
            return TransformDir(m, p);
        }
        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V3l TransformPosProj(V3l p)
        {
            return TransformDir(p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V4l Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                case 2: return R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V3l Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                case 3: return C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M34l operator *(M33l a, M34l b)
        {
            return new M34l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34l Multiply(M33l a, M34l b)
        {
            return new M34l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34l operator *(M34l a, M44l b)
        {
            return new M34l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        public static M34l Multiply(M34l a, M44l b)
        {
            return new M34l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M34lEqualityComparer : IEqualityComparer<M34l>
    {
        public static readonly M34lEqualityComparer Default
            = new M34lEqualityComparer();

        #region IEqualityComparer<M34l> Members

        public bool Equals(M34l v0, M34l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M34l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M34f

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M34f : IValidity, IMatrix<double>
    {
        public float M00, M01, M02, M03;
        public float M10, M11, M12, M13;
        public float M20, M21, M22, M23;

        #region Constructors

        public M34f(
                float m00, float m01, float m02, float m03, 
                float m10, float m11, float m12, float m13, 
                float m20, float m21, float m22, float m23)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
        }

        public M34f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
        }
        
        public M34f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
        }

        #endregion

        #region Conversions

        public static explicit operator M34f(M22i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M23i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M33i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34f(M34i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M44i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M22l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M23l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M33l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34f(M34l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M44l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M22f m)
        {
            return new M34f {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M23f m)
        {
            return new M34f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M33f m)
        {
            return new M34f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34f(M44f m)
        {
            return new M34f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
            };
        }

        public static explicit operator M34f(M22d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M23d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M33d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34f(M34d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M44d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(int[] a)
        {
            return new M34f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11]);
        }

        public static explicit operator M34f(int[,] a)
        {
            return new M34f (
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3]);
        }

        public static explicit operator int[](M34f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23
            };
        }

        public static explicit operator int[,](M34f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
        }

        public static explicit operator M34f(long[] a)
        {
            return new M34f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11]);
        }

        public static explicit operator M34f(long[,] a)
        {
            return new M34f (
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3]);
        }

        public static explicit operator long[](M34f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23
            };
        }

        public static explicit operator long[,](M34f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
        }

        public static explicit operator M34f(float[] a)
        {
            return new M34f(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11]);
        }

        public static explicit operator M34f(float[,] a)
        {
            return new M34f (
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3]);
        }

        public static explicit operator float[](M34f m)
        {
            return new float[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23
            };
        }

        public static explicit operator float[,](M34f m)
        {
            return new float[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
        }

        public static explicit operator M34f(double[] a)
        {
            return new M34f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11]);
        }

        public static explicit operator M34f(double[,] a)
        {
            return new M34f (
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3]);
        }

        public static explicit operator double[](M34f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23
            };
        }

        public static explicit operator double[,](M34f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<float, int> element_fun)
        {
            return new M34i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M34i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<float, long> element_fun)
        {
            return new M34l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M34l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<float, float> element_fun)
        {
            return new M34f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M34f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<float, double> element_fun)
        {
            return new M34d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M34d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        public float[] ToArray()
        {
            var array = new float[12];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            return array;
        }

        #endregion

        #region Static Factories

        public static M34f FromCols(V3f col0, V3f col1, V3f col2, V3f col3)
        {
            return new M34f(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z);
        }

        public static M34f FromRows(V4f row0, V4f row1, V4f row2)
        {
            return new M34f(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<float> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M03;
                 yield return M10;
                 yield return M11;
                 yield return M12;
                 yield return M13;
                 yield return M20;
                 yield return M21;
                 yield return M22;
                 yield return M23;
            }
        }

        public IEnumerable<V4f> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3f> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4f R0
        {                     
            get { return new V4f( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4f R1
        {                     
            get { return new V4f( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4f R2
        {                     
            get { return new V4f( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V3f C0
        {           
            get { return new V3f( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3f C1
        {           
            get { return new V3f( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3f C2
        {           
            get { return new V3f( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public V3f C3
        {           
            get { return new V3f( M03,  M13,  M23); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
            }
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public float this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                case 3: return M03;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                case 3: return M13;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: return M20;
                                case 1: return M21;
                                case 2: return M22;
                                case 3: return M23;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                case 3: M03 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                case 3: M13 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: M20 = value; return;
                                case 1: M21 = value; return;
                                case 2: M22 = value; return;
                                case 3: M23 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 4;
        public const int ElementCount = 3*4;

        public static readonly V2l Dimensions = new V2l(3, 4);

        public static readonly M34f Zero
                = new M34f(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

        public static readonly M34f Identity
                = new M34f(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public float Norm(float p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M03).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p) + 
                Fun.Abs(M13).Pow(p) + 
                Fun.Abs(M20).Pow(p) + 
                Fun.Abs(M21).Pow(p) + 
                Fun.Abs(M22).Pow(p) + 
                Fun.Abs(M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(M34f a, M34f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(M34f a, M34f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(M34f a, M34f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(M34f a, M34f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(M34f a, M34f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        #endregion

        #region Mathematical Operators

        public static M34f operator +(M34f a, M34f b)
        {
            return new M34f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34f operator +(M34f m, float s)
        {
            return new M34f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34f operator +(float s, M34f m)
        {
            return new M34f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34d operator +(M34f a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34d operator +(M34f m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34d operator +(double s, M34f m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34f Add(M34f a, M34f b)
        {
            return new M34f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34f Add(M34f m, float s)
        {
            return new M34f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34f Add(float s, M34f m)
        {
            return new M34f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34d Add(M34f a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34d Add(M34f m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34d Add(double s, M34f m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34f operator -(M34f a, M34f b)
        {
            return new M34f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34f operator -(M34f m, float s)
        {
            return new M34f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34f operator -(float s, M34f m)
        {
            return new M34f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34d operator -(M34f a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34d operator -(M34f m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34d operator -(double s, M34f m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34f Subtract(M34f a, M34f b)
        {
            return new M34f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34f Subtract(M34f m, float s)
        {
            return new M34f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34f Subtract(float s, M34f m)
        {
            return new M34f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34d Subtract(M34f a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34d Subtract(M34f m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34d Subtract(double s, M34f m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34f operator %(M34f a, M34f b)
        {
            return new M34f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34f operator %(M34f m, float s)
        {
            return new M34f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34f operator %(float s, M34f m)
        {
            return new M34f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34d operator %(M34f a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34d operator %(M34f m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34d operator %(double s, M34f m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34f Modulo(M34f a, M34f b)
        {
            return new M34f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34f Modulo(M34f m, float s)
        {
            return new M34f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34f Modulo(float s, M34f m)
        {
            return new M34f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34d Modulo(M34f a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34d Modulo(M34f m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34d Modulo(double s, M34f m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34f operator /(M34f a, M34f b)
        {
            return new M34f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34f operator /(M34f m, float s)
        {
            return new M34f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34f operator /(float s, M34f m)
        {
            return new M34f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34d operator /(M34f a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34d operator /(M34f m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34d operator /(double s, M34f m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34f Divide(M34f a, M34f b)
        {
            return new M34f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34f Divide(M34f m, float s)
        {
            return new M34f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34f Divide(float s, M34f m)
        {
            return new M34f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34d Divide(M34f a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34d Divide(M34f m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34d Divide(double s, M34f m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34f operator *(M34f m, float s)
        {
            return new M34f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34f operator *(float s, M34f m)
        {
            return new M34f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34d operator *(M34f m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34d operator *(double s, M34f m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34f Multiply(M34f m, float s)
        {
            return new M34f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34f Multiply(float s, M34f m)
        {
            return new M34f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34d Multiply(M34f m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34d Multiply(double s, M34f m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V3f Multiply(M34f m, V4f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        public static V3f operator *(M34f m, V4f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M34f a, M34f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23;
        }

        public static bool operator <(M34f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s;
        }

        public static bool operator <(float s, M34f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23 ;
        }

        public static bool operator >(M34f a, M34f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23;
        }

        public static bool operator >(M34f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s;
        }

        public static bool operator >(float s, M34f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23 ;
        }

        public static bool operator ==(M34f a, M34f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23;
        }

        public static bool operator ==(M34f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s;
        }

        public static bool operator ==(float s, M34f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23 ;
        }

        public static bool operator <=(M34f a, M34f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23;
        }

        public static bool operator <=(M34f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s;
        }

        public static bool operator <=(float s, M34f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23 ;
        }

        public static bool operator >=(M34f a, M34f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23;
        }

        public static bool operator >=(M34f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s;
        }

        public static bool operator >=(float s, M34f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23 ;
        }

        public static bool operator !=(M34f a, M34f b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M34f m, float s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(float s, M34f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M34f) ? (this == (M34f)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M34f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M34f.FromRows(
                V4f.Parse(x[0]), 
                V4f.Parse(x[1]), 
                V4f.Parse(x[2])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V3f TransformDir(M34f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3f TransformPos(M34f m, V3f p)
        {
            return new V3f(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V3f TransformDir(V3f v)
        {
            return new V3f(
                M00 * v.X + M01 * v.Y + M02 * v.Z, 
                M10 * v.X + M11 * v.Y + M12 * v.Z, 
                M20 * v.X + M21 * v.Y + M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V3f TransformPos(V3f p)
        {
            return new V3f(
                M00 * p.X + M01 * p.Y + M02 * p.Z + M03, 
                M10 * p.X + M11 * p.Y + M12 * p.Z + M13, 
                M20 * p.X + M21 * p.Y + M22 * p.Z + M23
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3f TransformPosProj(M34f m, V3f p)
        {
            return TransformDir(m, p);
        }
        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V3f TransformPosProj(V3f p)
        {
            return TransformDir(p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V4f Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                case 2: return R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V3f Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                case 3: return C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M34f operator *(M33f a, M34f b)
        {
            return new M34f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34f Multiply(M33f a, M34f b)
        {
            return new M34f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34f operator *(M34f a, M44f b)
        {
            return new M34f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        public static M34f Multiply(M34f a, M44f b)
        {
            return new M34f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M34fEqualityComparer : IEqualityComparer<M34f>
    {
        public static readonly M34fEqualityComparer Default
            = new M34fEqualityComparer();

        #region IEqualityComparer<M34f> Members

        public bool Equals(M34f v0, M34f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M34f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M34d

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M34d : IValidity, IMatrix<double>
    {
        public double M00, M01, M02, M03;
        public double M10, M11, M12, M13;
        public double M20, M21, M22, M23;

        #region Constructors

        public M34d(
                double m00, double m01, double m02, double m03, 
                double m10, double m11, double m12, double m13, 
                double m20, double m21, double m22, double m23)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
        }

        public M34d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
        }
        
        public M34d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
        }

        #endregion

        #region Conversions

        public static explicit operator M34d(M22i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M23i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M33i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34d(M34i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M44i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M22l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M23l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M33l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34d(M34l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M44l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M22f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M23f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M33f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34d(M34f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M44f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M22d m)
        {
            return new M34d {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M23d m)
        {
            return new M34d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M33d m)
        {
            return new M34d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34d(M44d m)
        {
            return new M34d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
            };
        }

        public static explicit operator M34d(int[] a)
        {
            return new M34d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11]);
        }

        public static explicit operator M34d(int[,] a)
        {
            return new M34d (
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3]);
        }

        public static explicit operator int[](M34d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23
            };
        }

        public static explicit operator int[,](M34d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
        }

        public static explicit operator M34d(long[] a)
        {
            return new M34d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11]);
        }

        public static explicit operator M34d(long[,] a)
        {
            return new M34d (
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3]);
        }

        public static explicit operator long[](M34d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23
            };
        }

        public static explicit operator long[,](M34d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
        }

        public static explicit operator M34d(float[] a)
        {
            return new M34d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11]);
        }

        public static explicit operator M34d(float[,] a)
        {
            return new M34d (
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3]);
        }

        public static explicit operator float[](M34d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23
            };
        }

        public static explicit operator float[,](M34d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
        }

        public static explicit operator M34d(double[] a)
        {
            return new M34d(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11]);
        }

        public static explicit operator M34d(double[,] a)
        {
            return new M34d (
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3]);
        }

        public static explicit operator double[](M34d m)
        {
            return new double[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23
            };
        }

        public static explicit operator double[,](M34d m)
        {
            return new double[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<double, int> element_fun)
        {
            return new M34i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M34i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<double, long> element_fun)
        {
            return new M34l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M34l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<double, float> element_fun)
        {
            return new M34f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M34f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<double, double> element_fun)
        {
            return new M34d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M34d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        public double[] ToArray()
        {
            var array = new double[12];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            return array;
        }

        #endregion

        #region Static Factories

        public static M34d FromCols(V3d col0, V3d col1, V3d col2, V3d col3)
        {
            return new M34d(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z);
        }

        public static M34d FromRows(V4d row0, V4d row1, V4d row2)
        {
            return new M34d(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<double> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M03;
                 yield return M10;
                 yield return M11;
                 yield return M12;
                 yield return M13;
                 yield return M20;
                 yield return M21;
                 yield return M22;
                 yield return M23;
            }
        }

        public IEnumerable<V4d> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3d> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4d R0
        {                     
            get { return new V4d( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4d R1
        {                     
            get { return new V4d( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4d R2
        {                     
            get { return new V4d( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V3d C0
        {           
            get { return new V3d( M00,  M10,  M20); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        public V3d C1
        {           
            get { return new V3d( M01,  M11,  M21); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        public V3d C2
        {           
            get { return new V3d( M02,  M12,  M22); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public V3d C3
        {           
            get { return new V3d( M03,  M13,  M23); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
            }
        }

        public double this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public double this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                case 3: return M03;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                case 3: return M13;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: return M20;
                                case 1: return M21;
                                case 2: return M22;
                                case 3: return M23;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                case 3: M03 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                case 3: M13 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: M20 = value; return;
                                case 1: M21 = value; return;
                                case 2: M22 = value; return;
                                case 3: M23 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 4;
        public const int ElementCount = 3*4;

        public static readonly V2l Dimensions = new V2l(3, 4);

        public static readonly M34d Zero
                = new M34d(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

        public static readonly M34d Identity
                = new M34d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M03).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p) + 
                Fun.Abs(M13).Pow(p) + 
                Fun.Abs(M20).Pow(p) + 
                Fun.Abs(M21).Pow(p) + 
                Fun.Abs(M22).Pow(p) + 
                Fun.Abs(M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(M34d a, M34d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M34d a, M34d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M34d a, M34d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(M34d a, M34d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(M34d a, M34d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        #endregion

        #region Mathematical Operators

        public static M34d operator +(M34d a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34d operator +(M34d m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34d operator +(double s, M34d m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34d Add(M34d a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        public static M34d Add(M34d m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }
        
        public static M34d Add(double s, M34d m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        public static M34d operator -(M34d a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34d operator -(M34d m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34d operator -(double s, M34d m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34d Subtract(M34d a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        public static M34d Subtract(M34d m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }
        
        public static M34d Subtract(double s, M34d m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        public static M34d operator %(M34d a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34d operator %(M34d m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34d operator %(double s, M34d m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34d Modulo(M34d a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        public static M34d Modulo(M34d m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }
        
        public static M34d Modulo(double s, M34d m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        public static M34d operator /(M34d a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34d operator /(M34d m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34d operator /(double s, M34d m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34d Divide(M34d a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        public static M34d Divide(M34d m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }
        
        public static M34d Divide(double s, M34d m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        public static M34d operator *(M34d m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34d operator *(double s, M34d m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        public static M34d Multiply(M34d m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }
        
        public static M34d Multiply(double s, M34d m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V3d Multiply(M34d m, V4d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        public static V3d operator *(M34d m, V4d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M34d a, M34d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23;
        }

        public static bool operator <(M34d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s;
        }

        public static bool operator <(double s, M34d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23 ;
        }

        public static bool operator >(M34d a, M34d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23;
        }

        public static bool operator >(M34d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s;
        }

        public static bool operator >(double s, M34d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23 ;
        }

        public static bool operator ==(M34d a, M34d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23;
        }

        public static bool operator ==(M34d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s;
        }

        public static bool operator ==(double s, M34d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23 ;
        }

        public static bool operator <=(M34d a, M34d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23;
        }

        public static bool operator <=(M34d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s;
        }

        public static bool operator <=(double s, M34d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23 ;
        }

        public static bool operator >=(M34d a, M34d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23;
        }

        public static bool operator >=(M34d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s;
        }

        public static bool operator >=(double s, M34d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23 ;
        }

        public static bool operator !=(M34d a, M34d b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M34d m, double s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(double s, M34d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M34d) ? (this == (M34d)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M34d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M34d.FromRows(
                V4d.Parse(x[0]), 
                V4d.Parse(x[1]), 
                V4d.Parse(x[2])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V3d TransformDir(M34d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3d TransformPos(M34d m, V3d p)
        {
            return new V3d(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V3d TransformDir(V3d v)
        {
            return new V3d(
                M00 * v.X + M01 * v.Y + M02 * v.Z, 
                M10 * v.X + M11 * v.Y + M12 * v.Z, 
                M20 * v.X + M21 * v.Y + M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V3d TransformPos(V3d p)
        {
            return new V3d(
                M00 * p.X + M01 * p.Y + M02 * p.Z + M03, 
                M10 * p.X + M11 * p.Y + M12 * p.Z + M13, 
                M20 * p.X + M21 * p.Y + M22 * p.Z + M23
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3d TransformPosProj(M34d m, V3d p)
        {
            return TransformDir(m, p);
        }
        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V3d TransformPosProj(V3d p)
        {
            return TransformDir(p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V4d Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                case 2: return R2;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V3d Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                case 3: return C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M34d operator *(M33d a, M34d b)
        {
            return new M34d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34d Multiply(M33d a, M34d b)
        {
            return new M34d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34d operator *(M34d a, M44d b)
        {
            return new M34d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        public static M34d Multiply(M34d a, M44d b)
        {
            return new M34d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M34dEqualityComparer : IEqualityComparer<M34d>
    {
        public static readonly M34dEqualityComparer Default
            = new M34dEqualityComparer();

        #region IEqualityComparer<M34d> Members

        public bool Equals(M34d v0, M34d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M34d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M44i

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M44i : IValidity, IMatrix<double>
    {
        public int M00, M01, M02, M03;
        public int M10, M11, M12, M13;
        public int M20, M21, M22, M23;
        public int M30, M31, M32, M33;

        #region Constructors

        public M44i(
                int m00, int m01, int m02, int m03, 
                int m10, int m11, int m12, int m13, 
                int m20, int m21, int m22, int m23, 
                int m30, int m31, int m32, int m33)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
            M30 = m30; M31 = m31; M32 = m32; M33 = m33; 
        }

        public M44i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
            M30 = a[12];
            M31 = a[13];
            M32 = a[14];
            M33 = a[15];
        }
        
        public M44i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
            M30 = a[start + 12];
            M31 = a[start + 13];
            M32 = a[start + 14];
            M33 = a[start + 15];
        }

        #endregion

        #region Conversions

        public static explicit operator M44i(M22i m)
        {
            return new M44i {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M23i m)
        {
            return new M44i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M33i m)
        {
            return new M44i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M34i m)
        {
            return new M44i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M22l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M23l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M33l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M34l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M44l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = (int)m.M30, M31 = (int)m.M31, M32 = (int)m.M32, M33 = (int)m.M33, 
            };
        }

        public static explicit operator M44i(M22f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M23f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M33f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M34f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M44f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = (int)m.M30, M31 = (int)m.M31, M32 = (int)m.M32, M33 = (int)m.M33, 
            };
        }

        public static explicit operator M44i(M22d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M23d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M33d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M34d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M44d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = (int)m.M30, M31 = (int)m.M31, M32 = (int)m.M32, M33 = (int)m.M33, 
            };
        }

        public static explicit operator M44i(int[] a)
        {
            return new M44i(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11], 
                a[12], a[13], a[14], a[15]);
        }

        public static explicit operator M44i(int[,] a)
        {
            return new M44i (
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3], 
                a[3, 0], a[3, 1], a[3, 2], a[3, 3]);
        }

        public static explicit operator int[](M44i m)
        {
            return new int[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23, 
                m.M30, m.M31, m.M32, m.M33
            };
        }

        public static explicit operator int[,](M44i m)
        {
            return new int[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }, 
                { m.M30, m.M31, m.M32, m.M33 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
            array[index + 12] = M30;
            array[index + 13] = M31;
            array[index + 14] = M32;
            array[index + 15] = M33;
        }

        public static explicit operator M44i(long[] a)
        {
            return new M44i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11], 
                (int)a[12], (int)a[13], (int)a[14], (int)a[15]);
        }

        public static explicit operator M44i(long[,] a)
        {
            return new M44i (
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3], 
                (int)a[3, 0], (int)a[3, 1], (int)a[3, 2], (int)a[3, 3]);
        }

        public static explicit operator long[](M44i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23, 
                (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33
            };
        }

        public static explicit operator long[,](M44i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }, 
                { (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
            array[index + 12] = (long)M30;
            array[index + 13] = (long)M31;
            array[index + 14] = (long)M32;
            array[index + 15] = (long)M33;
        }

        public static explicit operator M44i(float[] a)
        {
            return new M44i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11], 
                (int)a[12], (int)a[13], (int)a[14], (int)a[15]);
        }

        public static explicit operator M44i(float[,] a)
        {
            return new M44i (
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3], 
                (int)a[3, 0], (int)a[3, 1], (int)a[3, 2], (int)a[3, 3]);
        }

        public static explicit operator float[](M44i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23, 
                (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33
            };
        }

        public static explicit operator float[,](M44i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }, 
                { (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
            array[index + 12] = (float)M30;
            array[index + 13] = (float)M31;
            array[index + 14] = (float)M32;
            array[index + 15] = (float)M33;
        }

        public static explicit operator M44i(double[] a)
        {
            return new M44i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11], 
                (int)a[12], (int)a[13], (int)a[14], (int)a[15]);
        }

        public static explicit operator M44i(double[,] a)
        {
            return new M44i (
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3], 
                (int)a[3, 0], (int)a[3, 1], (int)a[3, 2], (int)a[3, 3]);
        }

        public static explicit operator double[](M44i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23, 
                (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33
            };
        }

        public static explicit operator double[,](M44i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }, 
                { (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
            array[index + 12] = (double)M30;
            array[index + 13] = (double)M31;
            array[index + 14] = (double)M32;
            array[index + 15] = (double)M33;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<int, int> element_fun)
        {
            return new M44i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M44i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<int, long> element_fun)
        {
            return new M44l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M44l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<int, float> element_fun)
        {
            return new M44f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M44f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<int, double> element_fun)
        {
            return new M44d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M44d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M33i UpperLeftM33()
        {
            return (M33i)this;
        }

        public int[] ToArray()
        {
            var array = new int[16];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            array[12] = M30;
            array[13] = M31;
            array[14] = M32;
            array[15] = M33;
            return array;
        }

        #endregion

        #region Static Factories

        public static M44i FromCols(V4i col0, V4i col1, V4i col2, V4i col3)
        {
            return new M44i(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z, 
                col0.W, col1.W, col2.W, col3.W);
        }

        public static M44i FromRows(V4i row0, V4i row1, V4i row2, V4i row3)
        {
            return new M44i(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W, 
                row3.X, row3.Y, row3.Z, row3.W);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<int> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M03;
                 yield return M10;
                 yield return M11;
                 yield return M12;
                 yield return M13;
                 yield return M20;
                 yield return M21;
                 yield return M22;
                 yield return M23;
                 yield return M30;
                 yield return M31;
                 yield return M32;
                 yield return M33;
            }
        }

        public IEnumerable<V4i> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
                yield return R3;
            }
        }

        public IEnumerable<V4i> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4i R0
        {                     
            get { return new V4i( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4i R1
        {                     
            get { return new V4i( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4i R2
        {                     
            get { return new V4i( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V4i R3
        {                     
            get { return new V4i( M30,  M31,  M32,  M33); }
            set
            {
                M30 = value.X;
                M31 = value.Y;
                M32 = value.Z;
                M33 = value.W;
            }
        }

        public V4i C0
        {           
            get { return new V4i( M00,  M10,  M20,  M30); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
                M30 = value.W;
            }
        }

        public V4i C1
        {           
            get { return new V4i( M01,  M11,  M21,  M31); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
                M31 = value.W;
            }
        }

        public V4i C2
        {           
            get { return new V4i( M02,  M12,  M22,  M32); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
                M32 = value.W;
            }
        }

        public V4i C3
        {           
            get { return new V4i( M03,  M13,  M23,  M33); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
                M33 = value.W;
            }
        }

        public int this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    case 12: return M30;
                    case 13: return M31;
                    case 14: return M32;
                    case 15: return M33;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    case 12: M30 = value; return;
                    case 13: M31 = value; return;
                    case 14: M32 = value; return;
                    case 15: M33 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public int this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                case 3: return M03;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                case 3: return M13;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: return M20;
                                case 1: return M21;
                                case 2: return M22;
                                case 3: return M23;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 3: switch (column)
                            {
                                case 0: return M30;
                                case 1: return M31;
                                case 2: return M32;
                                case 3: return M33;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                case 3: M03 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                case 3: M13 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: M20 = value; return;
                                case 1: M21 = value; return;
                                case 2: M22 = value; return;
                                case 3: M23 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 3: switch (column)
                            {
                                case 0: M30 = value; return;
                                case 1: M31 = value; return;
                                case 2: M32 = value; return;
                                case 3: M33 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 4;
        public const int ColumnCount = 4;
        public const int ElementCount = 4*4;

        public static readonly V2l Dimensions = new V2l(4, 4);

        public static readonly M44i Zero
                = new M44i(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

        public static readonly M44i Identity
                = new M44i(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23) + 
                    Fun.Abs(M30) + Fun.Abs(M31) + Fun.Abs(M32) + Fun.Abs(M33);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23 + 
                    M30 * M30 + M31 * M31 + M32 * M32 + M33 * M33);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M03).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p) + 
                Fun.Abs(M13).Pow(p) + 
                Fun.Abs(M20).Pow(p) + 
                Fun.Abs(M21).Pow(p) + 
                Fun.Abs(M22).Pow(p) + 
                Fun.Abs(M23).Pow(p) + 
                Fun.Abs(M30).Pow(p) + 
                Fun.Abs(M31).Pow(p) + 
                Fun.Abs(M32).Pow(p) + 
                Fun.Abs(M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Max(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Min(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(M44i a, M44i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23) + 
                Fun.Abs(b.M30 - a.M30) + 
                Fun.Abs(b.M31 - a.M31) + 
                Fun.Abs(b.M32 - a.M32) + 
                Fun.Abs(b.M33 - a.M33);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M44i a, M44i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23) + 
                        Fun.Square(b.M30 - a.M30) + 
                        Fun.Square(b.M31 - a.M31) + 
                        Fun.Square(b.M32 - a.M32) + 
                        Fun.Square(b.M33 - a.M33));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M44i a, M44i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p) + 
                Fun.Abs(b.M30 - a.M30).Pow(p) + 
                Fun.Abs(b.M31 - a.M31).Pow(p) + 
                Fun.Abs(b.M32 - a.M32).Pow(p) + 
                Fun.Abs(b.M33 - a.M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(M44i a, M44i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Max(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(M44i a, M44i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Min(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        #endregion

        #region Mathematical Operators

        public static M44i operator +(M44i a, M44i b)
        {
            return new M44i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44i operator +(M44i m, int s)
        {
            return new M44i(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44i operator +(int s, M44i m)
        {
            return new M44i(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44l operator +(M44i a, M44l b)
        {
            return new M44l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44l operator +(M44i m, long s)
        {
            return new M44l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44l operator +(long s, M44i m)
        {
            return new M44l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44f operator +(M44i a, M44f b)
        {
            return new M44f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44f operator +(M44i m, float s)
        {
            return new M44f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44f operator +(float s, M44i m)
        {
            return new M44f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44d operator +(M44i a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44d operator +(M44i m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44d operator +(double s, M44i m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44i Add(M44i a, M44i b)
        {
            return new M44i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44i Add(M44i m, int s)
        {
            return new M44i(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44i Add(int s, M44i m)
        {
            return new M44i(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44l Add(M44i a, M44l b)
        {
            return new M44l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44l Add(M44i m, long s)
        {
            return new M44l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44l Add(long s, M44i m)
        {
            return new M44l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44f Add(M44i a, M44f b)
        {
            return new M44f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44f Add(M44i m, float s)
        {
            return new M44f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44f Add(float s, M44i m)
        {
            return new M44f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44d Add(M44i a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44d Add(M44i m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44d Add(double s, M44i m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44i operator -(M44i a, M44i b)
        {
            return new M44i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44i operator -(M44i m, int s)
        {
            return new M44i(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44i operator -(int s, M44i m)
        {
            return new M44i(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44l operator -(M44i a, M44l b)
        {
            return new M44l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44l operator -(M44i m, long s)
        {
            return new M44l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44l operator -(long s, M44i m)
        {
            return new M44l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44f operator -(M44i a, M44f b)
        {
            return new M44f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44f operator -(M44i m, float s)
        {
            return new M44f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44f operator -(float s, M44i m)
        {
            return new M44f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44d operator -(M44i a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44d operator -(M44i m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44d operator -(double s, M44i m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44i Subtract(M44i a, M44i b)
        {
            return new M44i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44i Subtract(M44i m, int s)
        {
            return new M44i(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44i Subtract(int s, M44i m)
        {
            return new M44i(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44l Subtract(M44i a, M44l b)
        {
            return new M44l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44l Subtract(M44i m, long s)
        {
            return new M44l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44l Subtract(long s, M44i m)
        {
            return new M44l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44f Subtract(M44i a, M44f b)
        {
            return new M44f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44f Subtract(M44i m, float s)
        {
            return new M44f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44f Subtract(float s, M44i m)
        {
            return new M44f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44d Subtract(M44i a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44d Subtract(M44i m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44d Subtract(double s, M44i m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44i operator %(M44i a, M44i b)
        {
            return new M44i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44i operator %(M44i m, int s)
        {
            return new M44i(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44i operator %(int s, M44i m)
        {
            return new M44i(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44l operator %(M44i a, M44l b)
        {
            return new M44l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44l operator %(M44i m, long s)
        {
            return new M44l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44l operator %(long s, M44i m)
        {
            return new M44l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44f operator %(M44i a, M44f b)
        {
            return new M44f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44f operator %(M44i m, float s)
        {
            return new M44f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44f operator %(float s, M44i m)
        {
            return new M44f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44d operator %(M44i a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44d operator %(M44i m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44d operator %(double s, M44i m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44i Modulo(M44i a, M44i b)
        {
            return new M44i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44i Modulo(M44i m, int s)
        {
            return new M44i(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44i Modulo(int s, M44i m)
        {
            return new M44i(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44l Modulo(M44i a, M44l b)
        {
            return new M44l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44l Modulo(M44i m, long s)
        {
            return new M44l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44l Modulo(long s, M44i m)
        {
            return new M44l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44f Modulo(M44i a, M44f b)
        {
            return new M44f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44f Modulo(M44i m, float s)
        {
            return new M44f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44f Modulo(float s, M44i m)
        {
            return new M44f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44d Modulo(M44i a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44d Modulo(M44i m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44d Modulo(double s, M44i m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44i operator /(M44i a, M44i b)
        {
            return new M44i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44i operator /(M44i m, int s)
        {
            return new M44i(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44i operator /(int s, M44i m)
        {
            return new M44i(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44l operator /(M44i a, M44l b)
        {
            return new M44l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44l operator /(M44i m, long s)
        {
            return new M44l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44l operator /(long s, M44i m)
        {
            return new M44l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44f operator /(M44i a, M44f b)
        {
            return new M44f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44f operator /(M44i m, float s)
        {
            return new M44f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44f operator /(float s, M44i m)
        {
            return new M44f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44d operator /(M44i a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44d operator /(M44i m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44d operator /(double s, M44i m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44i Divide(M44i a, M44i b)
        {
            return new M44i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44i Divide(M44i m, int s)
        {
            return new M44i(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44i Divide(int s, M44i m)
        {
            return new M44i(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44l Divide(M44i a, M44l b)
        {
            return new M44l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44l Divide(M44i m, long s)
        {
            return new M44l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44l Divide(long s, M44i m)
        {
            return new M44l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44f Divide(M44i a, M44f b)
        {
            return new M44f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44f Divide(M44i m, float s)
        {
            return new M44f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44f Divide(float s, M44i m)
        {
            return new M44f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44d Divide(M44i a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44d Divide(M44i m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44d Divide(double s, M44i m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44i operator *(M44i m, int s)
        {
            return new M44i(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44i operator *(int s, M44i m)
        {
            return new M44i(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44l operator *(M44i m, long s)
        {
            return new M44l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44l operator *(long s, M44i m)
        {
            return new M44l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44f operator *(M44i m, float s)
        {
            return new M44f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44f operator *(float s, M44i m)
        {
            return new M44f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44d operator *(M44i m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44d operator *(double s, M44i m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44i Multiply(M44i m, int s)
        {
            return new M44i(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44i Multiply(int s, M44i m)
        {
            return new M44i(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44l Multiply(M44i m, long s)
        {
            return new M44l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44l Multiply(long s, M44i m)
        {
            return new M44l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44f Multiply(M44i m, float s)
        {
            return new M44f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44f Multiply(float s, M44i m)
        {
            return new M44f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44d Multiply(M44i m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44d Multiply(double s, M44i m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V4i Multiply(M44i m, V4i v)
        {
            return new V4i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        public static V4i operator *(M44i m, V4i v)
        {
            return new V4i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        public static V4i TransposedMultiply(V4i v, M44i m)
        {
            return new V4i(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20 + v.W * m.M30, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21 + v.W * m.M31, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22 + v.W * m.M32, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23 + v.W * m.M33);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M44i a, M44i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23 && 
                a.M30 < b.M30 && 
                a.M31 < b.M31 && 
                a.M32 < b.M32 && 
                a.M33 < b.M33;
        }

        public static bool operator <(M44i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s && 
                a.M30 < s && 
                a.M31 < s && 
                a.M32 < s && 
                a.M33 < s;
        }

        public static bool operator <(int s, M44i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23  && 
                s < a.M30  && 
                s < a.M31  && 
                s < a.M32  && 
                s < a.M33 ;
        }

        public static bool operator >(M44i a, M44i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23 && 
                a.M30 > b.M30 && 
                a.M31 > b.M31 && 
                a.M32 > b.M32 && 
                a.M33 > b.M33;
        }

        public static bool operator >(M44i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s && 
                a.M30 > s && 
                a.M31 > s && 
                a.M32 > s && 
                a.M33 > s;
        }

        public static bool operator >(int s, M44i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23  && 
                s > a.M30  && 
                s > a.M31  && 
                s > a.M32  && 
                s > a.M33 ;
        }

        public static bool operator ==(M44i a, M44i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23 && 
                a.M30 == b.M30 && 
                a.M31 == b.M31 && 
                a.M32 == b.M32 && 
                a.M33 == b.M33;
        }

        public static bool operator ==(M44i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s && 
                a.M30 == s && 
                a.M31 == s && 
                a.M32 == s && 
                a.M33 == s;
        }

        public static bool operator ==(int s, M44i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23  && 
                s == a.M30  && 
                s == a.M31  && 
                s == a.M32  && 
                s == a.M33 ;
        }

        public static bool operator <=(M44i a, M44i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23 && 
                a.M30 <= b.M30 && 
                a.M31 <= b.M31 && 
                a.M32 <= b.M32 && 
                a.M33 <= b.M33;
        }

        public static bool operator <=(M44i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s && 
                a.M30 <= s && 
                a.M31 <= s && 
                a.M32 <= s && 
                a.M33 <= s;
        }

        public static bool operator <=(int s, M44i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23  && 
                s <= a.M30  && 
                s <= a.M31  && 
                s <= a.M32  && 
                s <= a.M33 ;
        }

        public static bool operator >=(M44i a, M44i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23 && 
                a.M30 >= b.M30 && 
                a.M31 >= b.M31 && 
                a.M32 >= b.M32 && 
                a.M33 >= b.M33;
        }

        public static bool operator >=(M44i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s && 
                a.M30 >= s && 
                a.M31 >= s && 
                a.M32 >= s && 
                a.M33 >= s;
        }

        public static bool operator >=(int s, M44i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23  && 
                s >= a.M30  && 
                s >= a.M31  && 
                s >= a.M32  && 
                s >= a.M33 ;
        }

        public static bool operator !=(M44i a, M44i b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M44i m, int s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(int s, M44i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode(), 
                M30.GetHashCode(), M31.GetHashCode(), M32.GetHashCode(), M33.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M44i) ? (this == (M44i)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R3.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M44i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M44i.FromRows(
                V4i.Parse(x[0]), 
                V4i.Parse(x[1]), 
                V4i.Parse(x[2]), 
                V4i.Parse(x[3])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V3i TransformDir(M44i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3i TransformPos(M44i m, V3i p)
        {
            return new V3i(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V3i TransformDir(V3i v)
        {
            return new V3i(
                M00 * v.X + M01 * v.Y + M02 * v.Z, 
                M10 * v.X + M11 * v.Y + M12 * v.Z, 
                M20 * v.X + M21 * v.Y + M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V3i TransformPos(V3i p)
        {
            return new V3i(
                M00 * p.X + M01 * p.Y + M02 * p.Z + M03, 
                M10 * p.X + M11 * p.Y + M12 * p.Z + M13, 
                M20 * p.X + M21 * p.Y + M22 * p.Z + M23
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V3i TransposedTransformDir(M44i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M10 * v.Y + m.M20 * v.Z, 
                m.M01 * v.X + m.M11 * v.Y + m.M21 * v.Z, 
                m.M02 * v.X + m.M12 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3i TransposedTransformPos(M44i m, V3i p)
        {
            return new V3i(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of this matrix.
        /// </summary>
        public V3i TransposedTransformDir(V3i v)
        {
            return new V3i(
                M00 * v.X + M10 * v.Y + M20 * v.Z, 
                M01 * v.X + M11 * v.Y + M21 * v.Z, 
                M02 * v.X + M12 * v.Y + M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by transposed version of this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V3i TransposedTransformPos(V3i p)
        {
            return new V3i(
                M00 * p.X + M10 * p.Y + M20 * p.Z + M30, 
                M01 * p.X + M11 * p.Y + M21 * p.Z + M31, 
                M02 * p.X + M12 * p.Y + M22 * p.Z + M32
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3i TransformPosProj(M44i m, V3i p)
        {
            int s = (m.M30 * p.X  + m.M31 * p.Y  + m.M32 * p.Z + m.M33);
            s = 1 / s;
            return (TransformPos(m, p)) * s;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V4i TransformPosProjFull(M44i m, V3i p)
        {
            return new V4i(
                (m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z+ m.M03), 
                (m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z+ m.M13), 
                (m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z+ m.M23), 
                (m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z+ m.M33)
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public V3i TransformPosProj(V3i p)
        {
            return TransformPosProj(this, p);
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V4i TransformPosProjFull(V3i p)
        {
            return TransformPosProjFull(this, p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V4i Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                case 2: return R2;
                case 3: return R3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V4i Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                case 3: return C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public int Trace
        {
            get { return M00 + M11 + M22 + M33 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public int Det
        {
            get
            {
                // using bottom row because elements M30, M31, and M32
                // are zero most of the time.
                int d = 0;
                if (M30 != 0.0f) d -= M30 * (
                M01 * M12 * M23 + M02 * M13 * M21 + M03 * M11 * M22
                - M21 * M12 * M03 - M22 * M13 * M01 - M23 * M11 * M02
                );
                if (M31 != 0.0f) d += M31 * (
                M00 * M12 * M23 + M02 * M13 * M20 + M03 * M10 * M22
                - M20 * M12 * M03 - M22 * M13 * M00 - M23 * M10 * M02
                );
                if (M32 != 0.0f) d -= M32 * (
                M00 * M11 * M23 + M01 * M13 * M20 + M03 * M10 * M21
                - M20 * M11 * M03 - M21 * M13 * M00 - M23 * M10 * M01
                );
                if (M33 != 0.0f) d += M33 * (
                M00 * M11 * M22 + M01 * M12 * M20 + M02 * M10 * M21
                - M20 * M11 * M02 - M21 * M12 * M00 - M22 * M10 * M01
                );
                return d;
            }
        }
        
        /// <summary>
        /// Returns the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public int Determinant()
        {
            return Det;
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible { get { return Det != 0; } }
        
        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular { get { return Det == 0; } }

        /// <summary>
        /// Transposes this matrix (and returns this).
        /// </summary>
        public void Transpose()
        {
            Fun.Swap(ref M10, ref M01);
            Fun.Swap(ref M20, ref M02);
            Fun.Swap(ref M21, ref M12);
            Fun.Swap(ref M30, ref M03);
            Fun.Swap(ref M31, ref M13);
            Fun.Swap(ref M32, ref M23);
        }
        
        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M44i Transposed
        {
            get
            {
                return new M44i {
                    M00 = M00, M01 = M10, M02 = M20, M03 = M30, 
                    M10 = M01, M11 = M11, M12 = M21, M13 = M31, 
                    M20 = M02, M21 = M12, M22 = M22, M23 = M32, 
                    M30 = M03, M31 = M13, M32 = M23, M33 = M33
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M44i operator *(M44i a, M44i b)
        {
            return new M44i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        public static M44i Multiply(M44i a, M44i b)
        {
            return new M44i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M44iEqualityComparer : IEqualityComparer<M44i>
    {
        public static readonly M44iEqualityComparer Default
            = new M44iEqualityComparer();

        #region IEqualityComparer<M44i> Members

        public bool Equals(M44i v0, M44i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M44i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M44l

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M44l : IValidity, IMatrix<double>
    {
        public long M00, M01, M02, M03;
        public long M10, M11, M12, M13;
        public long M20, M21, M22, M23;
        public long M30, M31, M32, M33;

        #region Constructors

        public M44l(
                long m00, long m01, long m02, long m03, 
                long m10, long m11, long m12, long m13, 
                long m20, long m21, long m22, long m23, 
                long m30, long m31, long m32, long m33)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
            M30 = m30; M31 = m31; M32 = m32; M33 = m33; 
        }

        public M44l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
            M30 = a[12];
            M31 = a[13];
            M32 = a[14];
            M33 = a[15];
        }
        
        public M44l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
            M30 = a[start + 12];
            M31 = a[start + 13];
            M32 = a[start + 14];
            M33 = a[start + 15];
        }

        #endregion

        #region Conversions

        public static explicit operator M44l(M22i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M23i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M33i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M34i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M44i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = (long)m.M30, M31 = (long)m.M31, M32 = (long)m.M32, M33 = (long)m.M33, 
            };
        }

        public static explicit operator M44l(M22l m)
        {
            return new M44l {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M23l m)
        {
            return new M44l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M33l m)
        {
            return new M44l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M34l m)
        {
            return new M44l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M22f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M23f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M33f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M34f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M44f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = (long)m.M30, M31 = (long)m.M31, M32 = (long)m.M32, M33 = (long)m.M33, 
            };
        }

        public static explicit operator M44l(M22d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M23d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M33d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M34d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M44d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = (long)m.M30, M31 = (long)m.M31, M32 = (long)m.M32, M33 = (long)m.M33, 
            };
        }

        public static explicit operator M44l(int[] a)
        {
            return new M44l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11], 
                (long)a[12], (long)a[13], (long)a[14], (long)a[15]);
        }

        public static explicit operator M44l(int[,] a)
        {
            return new M44l (
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3], 
                (long)a[3, 0], (long)a[3, 1], (long)a[3, 2], (long)a[3, 3]);
        }

        public static explicit operator int[](M44l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23, 
                (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33
            };
        }

        public static explicit operator int[,](M44l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }, 
                { (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
            array[index + 12] = (int)M30;
            array[index + 13] = (int)M31;
            array[index + 14] = (int)M32;
            array[index + 15] = (int)M33;
        }

        public static explicit operator M44l(long[] a)
        {
            return new M44l(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11], 
                a[12], a[13], a[14], a[15]);
        }

        public static explicit operator M44l(long[,] a)
        {
            return new M44l (
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3], 
                a[3, 0], a[3, 1], a[3, 2], a[3, 3]);
        }

        public static explicit operator long[](M44l m)
        {
            return new long[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23, 
                m.M30, m.M31, m.M32, m.M33
            };
        }

        public static explicit operator long[,](M44l m)
        {
            return new long[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }, 
                { m.M30, m.M31, m.M32, m.M33 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
            array[index + 12] = M30;
            array[index + 13] = M31;
            array[index + 14] = M32;
            array[index + 15] = M33;
        }

        public static explicit operator M44l(float[] a)
        {
            return new M44l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11], 
                (long)a[12], (long)a[13], (long)a[14], (long)a[15]);
        }

        public static explicit operator M44l(float[,] a)
        {
            return new M44l (
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3], 
                (long)a[3, 0], (long)a[3, 1], (long)a[3, 2], (long)a[3, 3]);
        }

        public static explicit operator float[](M44l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23, 
                (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33
            };
        }

        public static explicit operator float[,](M44l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }, 
                { (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
            array[index + 12] = (float)M30;
            array[index + 13] = (float)M31;
            array[index + 14] = (float)M32;
            array[index + 15] = (float)M33;
        }

        public static explicit operator M44l(double[] a)
        {
            return new M44l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11], 
                (long)a[12], (long)a[13], (long)a[14], (long)a[15]);
        }

        public static explicit operator M44l(double[,] a)
        {
            return new M44l (
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3], 
                (long)a[3, 0], (long)a[3, 1], (long)a[3, 2], (long)a[3, 3]);
        }

        public static explicit operator double[](M44l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23, 
                (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33
            };
        }

        public static explicit operator double[,](M44l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }, 
                { (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
            array[index + 12] = (double)M30;
            array[index + 13] = (double)M31;
            array[index + 14] = (double)M32;
            array[index + 15] = (double)M33;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<long, int> element_fun)
        {
            return new M44i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M44i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<long, long> element_fun)
        {
            return new M44l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M44l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<long, float> element_fun)
        {
            return new M44f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M44f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<long, double> element_fun)
        {
            return new M44d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M44d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M33l UpperLeftM33()
        {
            return (M33l)this;
        }

        public long[] ToArray()
        {
            var array = new long[16];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            array[12] = M30;
            array[13] = M31;
            array[14] = M32;
            array[15] = M33;
            return array;
        }

        #endregion

        #region Static Factories

        public static M44l FromCols(V4l col0, V4l col1, V4l col2, V4l col3)
        {
            return new M44l(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z, 
                col0.W, col1.W, col2.W, col3.W);
        }

        public static M44l FromRows(V4l row0, V4l row1, V4l row2, V4l row3)
        {
            return new M44l(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W, 
                row3.X, row3.Y, row3.Z, row3.W);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<long> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M03;
                 yield return M10;
                 yield return M11;
                 yield return M12;
                 yield return M13;
                 yield return M20;
                 yield return M21;
                 yield return M22;
                 yield return M23;
                 yield return M30;
                 yield return M31;
                 yield return M32;
                 yield return M33;
            }
        }

        public IEnumerable<V4l> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
                yield return R3;
            }
        }

        public IEnumerable<V4l> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4l R0
        {                     
            get { return new V4l( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4l R1
        {                     
            get { return new V4l( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4l R2
        {                     
            get { return new V4l( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V4l R3
        {                     
            get { return new V4l( M30,  M31,  M32,  M33); }
            set
            {
                M30 = value.X;
                M31 = value.Y;
                M32 = value.Z;
                M33 = value.W;
            }
        }

        public V4l C0
        {           
            get { return new V4l( M00,  M10,  M20,  M30); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
                M30 = value.W;
            }
        }

        public V4l C1
        {           
            get { return new V4l( M01,  M11,  M21,  M31); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
                M31 = value.W;
            }
        }

        public V4l C2
        {           
            get { return new V4l( M02,  M12,  M22,  M32); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
                M32 = value.W;
            }
        }

        public V4l C3
        {           
            get { return new V4l( M03,  M13,  M23,  M33); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
                M33 = value.W;
            }
        }

        public long this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    case 12: return M30;
                    case 13: return M31;
                    case 14: return M32;
                    case 15: return M33;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    case 12: M30 = value; return;
                    case 13: M31 = value; return;
                    case 14: M32 = value; return;
                    case 15: M33 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public long this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                case 3: return M03;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                case 3: return M13;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: return M20;
                                case 1: return M21;
                                case 2: return M22;
                                case 3: return M23;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 3: switch (column)
                            {
                                case 0: return M30;
                                case 1: return M31;
                                case 2: return M32;
                                case 3: return M33;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                case 3: M03 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                case 3: M13 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: M20 = value; return;
                                case 1: M21 = value; return;
                                case 2: M22 = value; return;
                                case 3: M23 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 3: switch (column)
                            {
                                case 0: M30 = value; return;
                                case 1: M31 = value; return;
                                case 2: M32 = value; return;
                                case 3: M33 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 4;
        public const int ColumnCount = 4;
        public const int ElementCount = 4*4;

        public static readonly V2l Dimensions = new V2l(4, 4);

        public static readonly M44l Zero
                = new M44l(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

        public static readonly M44l Identity
                = new M44l(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23) + 
                    Fun.Abs(M30) + Fun.Abs(M31) + Fun.Abs(M32) + Fun.Abs(M33);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23 + 
                    M30 * M30 + M31 * M31 + M32 * M32 + M33 * M33);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M03).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p) + 
                Fun.Abs(M13).Pow(p) + 
                Fun.Abs(M20).Pow(p) + 
                Fun.Abs(M21).Pow(p) + 
                Fun.Abs(M22).Pow(p) + 
                Fun.Abs(M23).Pow(p) + 
                Fun.Abs(M30).Pow(p) + 
                Fun.Abs(M31).Pow(p) + 
                Fun.Abs(M32).Pow(p) + 
                Fun.Abs(M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Max(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Min(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(M44l a, M44l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23) + 
                Fun.Abs(b.M30 - a.M30) + 
                Fun.Abs(b.M31 - a.M31) + 
                Fun.Abs(b.M32 - a.M32) + 
                Fun.Abs(b.M33 - a.M33);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M44l a, M44l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23) + 
                        Fun.Square(b.M30 - a.M30) + 
                        Fun.Square(b.M31 - a.M31) + 
                        Fun.Square(b.M32 - a.M32) + 
                        Fun.Square(b.M33 - a.M33));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M44l a, M44l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p) + 
                Fun.Abs(b.M30 - a.M30).Pow(p) + 
                Fun.Abs(b.M31 - a.M31).Pow(p) + 
                Fun.Abs(b.M32 - a.M32).Pow(p) + 
                Fun.Abs(b.M33 - a.M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(M44l a, M44l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Max(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(M44l a, M44l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Min(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        #endregion

        #region Mathematical Operators

        public static M44l operator +(M44l a, M44l b)
        {
            return new M44l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44l operator +(M44l m, long s)
        {
            return new M44l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44l operator +(long s, M44l m)
        {
            return new M44l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44f operator +(M44l a, M44f b)
        {
            return new M44f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44f operator +(M44l m, float s)
        {
            return new M44f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44f operator +(float s, M44l m)
        {
            return new M44f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44d operator +(M44l a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44d operator +(M44l m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44d operator +(double s, M44l m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44l Add(M44l a, M44l b)
        {
            return new M44l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44l Add(M44l m, long s)
        {
            return new M44l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44l Add(long s, M44l m)
        {
            return new M44l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44f Add(M44l a, M44f b)
        {
            return new M44f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44f Add(M44l m, float s)
        {
            return new M44f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44f Add(float s, M44l m)
        {
            return new M44f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44d Add(M44l a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44d Add(M44l m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44d Add(double s, M44l m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44l operator -(M44l a, M44l b)
        {
            return new M44l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44l operator -(M44l m, long s)
        {
            return new M44l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44l operator -(long s, M44l m)
        {
            return new M44l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44f operator -(M44l a, M44f b)
        {
            return new M44f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44f operator -(M44l m, float s)
        {
            return new M44f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44f operator -(float s, M44l m)
        {
            return new M44f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44d operator -(M44l a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44d operator -(M44l m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44d operator -(double s, M44l m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44l Subtract(M44l a, M44l b)
        {
            return new M44l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44l Subtract(M44l m, long s)
        {
            return new M44l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44l Subtract(long s, M44l m)
        {
            return new M44l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44f Subtract(M44l a, M44f b)
        {
            return new M44f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44f Subtract(M44l m, float s)
        {
            return new M44f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44f Subtract(float s, M44l m)
        {
            return new M44f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44d Subtract(M44l a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44d Subtract(M44l m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44d Subtract(double s, M44l m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44l operator %(M44l a, M44l b)
        {
            return new M44l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44l operator %(M44l m, long s)
        {
            return new M44l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44l operator %(long s, M44l m)
        {
            return new M44l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44f operator %(M44l a, M44f b)
        {
            return new M44f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44f operator %(M44l m, float s)
        {
            return new M44f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44f operator %(float s, M44l m)
        {
            return new M44f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44d operator %(M44l a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44d operator %(M44l m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44d operator %(double s, M44l m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44l Modulo(M44l a, M44l b)
        {
            return new M44l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44l Modulo(M44l m, long s)
        {
            return new M44l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44l Modulo(long s, M44l m)
        {
            return new M44l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44f Modulo(M44l a, M44f b)
        {
            return new M44f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44f Modulo(M44l m, float s)
        {
            return new M44f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44f Modulo(float s, M44l m)
        {
            return new M44f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44d Modulo(M44l a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44d Modulo(M44l m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44d Modulo(double s, M44l m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44l operator /(M44l a, M44l b)
        {
            return new M44l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44l operator /(M44l m, long s)
        {
            return new M44l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44l operator /(long s, M44l m)
        {
            return new M44l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44f operator /(M44l a, M44f b)
        {
            return new M44f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44f operator /(M44l m, float s)
        {
            return new M44f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44f operator /(float s, M44l m)
        {
            return new M44f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44d operator /(M44l a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44d operator /(M44l m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44d operator /(double s, M44l m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44l Divide(M44l a, M44l b)
        {
            return new M44l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44l Divide(M44l m, long s)
        {
            return new M44l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44l Divide(long s, M44l m)
        {
            return new M44l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44f Divide(M44l a, M44f b)
        {
            return new M44f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44f Divide(M44l m, float s)
        {
            return new M44f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44f Divide(float s, M44l m)
        {
            return new M44f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44d Divide(M44l a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44d Divide(M44l m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44d Divide(double s, M44l m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44l operator *(M44l m, long s)
        {
            return new M44l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44l operator *(long s, M44l m)
        {
            return new M44l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44f operator *(M44l m, float s)
        {
            return new M44f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44f operator *(float s, M44l m)
        {
            return new M44f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44d operator *(M44l m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44d operator *(double s, M44l m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44l Multiply(M44l m, long s)
        {
            return new M44l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44l Multiply(long s, M44l m)
        {
            return new M44l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44f Multiply(M44l m, float s)
        {
            return new M44f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44f Multiply(float s, M44l m)
        {
            return new M44f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44d Multiply(M44l m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44d Multiply(double s, M44l m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V4l Multiply(M44l m, V4l v)
        {
            return new V4l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        public static V4l operator *(M44l m, V4l v)
        {
            return new V4l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        public static V4l TransposedMultiply(V4l v, M44l m)
        {
            return new V4l(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20 + v.W * m.M30, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21 + v.W * m.M31, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22 + v.W * m.M32, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23 + v.W * m.M33);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M44l a, M44l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23 && 
                a.M30 < b.M30 && 
                a.M31 < b.M31 && 
                a.M32 < b.M32 && 
                a.M33 < b.M33;
        }

        public static bool operator <(M44l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s && 
                a.M30 < s && 
                a.M31 < s && 
                a.M32 < s && 
                a.M33 < s;
        }

        public static bool operator <(long s, M44l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23  && 
                s < a.M30  && 
                s < a.M31  && 
                s < a.M32  && 
                s < a.M33 ;
        }

        public static bool operator >(M44l a, M44l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23 && 
                a.M30 > b.M30 && 
                a.M31 > b.M31 && 
                a.M32 > b.M32 && 
                a.M33 > b.M33;
        }

        public static bool operator >(M44l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s && 
                a.M30 > s && 
                a.M31 > s && 
                a.M32 > s && 
                a.M33 > s;
        }

        public static bool operator >(long s, M44l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23  && 
                s > a.M30  && 
                s > a.M31  && 
                s > a.M32  && 
                s > a.M33 ;
        }

        public static bool operator ==(M44l a, M44l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23 && 
                a.M30 == b.M30 && 
                a.M31 == b.M31 && 
                a.M32 == b.M32 && 
                a.M33 == b.M33;
        }

        public static bool operator ==(M44l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s && 
                a.M30 == s && 
                a.M31 == s && 
                a.M32 == s && 
                a.M33 == s;
        }

        public static bool operator ==(long s, M44l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23  && 
                s == a.M30  && 
                s == a.M31  && 
                s == a.M32  && 
                s == a.M33 ;
        }

        public static bool operator <=(M44l a, M44l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23 && 
                a.M30 <= b.M30 && 
                a.M31 <= b.M31 && 
                a.M32 <= b.M32 && 
                a.M33 <= b.M33;
        }

        public static bool operator <=(M44l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s && 
                a.M30 <= s && 
                a.M31 <= s && 
                a.M32 <= s && 
                a.M33 <= s;
        }

        public static bool operator <=(long s, M44l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23  && 
                s <= a.M30  && 
                s <= a.M31  && 
                s <= a.M32  && 
                s <= a.M33 ;
        }

        public static bool operator >=(M44l a, M44l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23 && 
                a.M30 >= b.M30 && 
                a.M31 >= b.M31 && 
                a.M32 >= b.M32 && 
                a.M33 >= b.M33;
        }

        public static bool operator >=(M44l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s && 
                a.M30 >= s && 
                a.M31 >= s && 
                a.M32 >= s && 
                a.M33 >= s;
        }

        public static bool operator >=(long s, M44l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23  && 
                s >= a.M30  && 
                s >= a.M31  && 
                s >= a.M32  && 
                s >= a.M33 ;
        }

        public static bool operator !=(M44l a, M44l b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M44l m, long s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(long s, M44l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode(), 
                M30.GetHashCode(), M31.GetHashCode(), M32.GetHashCode(), M33.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M44l) ? (this == (M44l)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R3.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M44l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M44l.FromRows(
                V4l.Parse(x[0]), 
                V4l.Parse(x[1]), 
                V4l.Parse(x[2]), 
                V4l.Parse(x[3])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V3l TransformDir(M44l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3l TransformPos(M44l m, V3l p)
        {
            return new V3l(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V3l TransformDir(V3l v)
        {
            return new V3l(
                M00 * v.X + M01 * v.Y + M02 * v.Z, 
                M10 * v.X + M11 * v.Y + M12 * v.Z, 
                M20 * v.X + M21 * v.Y + M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V3l TransformPos(V3l p)
        {
            return new V3l(
                M00 * p.X + M01 * p.Y + M02 * p.Z + M03, 
                M10 * p.X + M11 * p.Y + M12 * p.Z + M13, 
                M20 * p.X + M21 * p.Y + M22 * p.Z + M23
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V3l TransposedTransformDir(M44l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M10 * v.Y + m.M20 * v.Z, 
                m.M01 * v.X + m.M11 * v.Y + m.M21 * v.Z, 
                m.M02 * v.X + m.M12 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3l TransposedTransformPos(M44l m, V3l p)
        {
            return new V3l(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of this matrix.
        /// </summary>
        public V3l TransposedTransformDir(V3l v)
        {
            return new V3l(
                M00 * v.X + M10 * v.Y + M20 * v.Z, 
                M01 * v.X + M11 * v.Y + M21 * v.Z, 
                M02 * v.X + M12 * v.Y + M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by transposed version of this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V3l TransposedTransformPos(V3l p)
        {
            return new V3l(
                M00 * p.X + M10 * p.Y + M20 * p.Z + M30, 
                M01 * p.X + M11 * p.Y + M21 * p.Z + M31, 
                M02 * p.X + M12 * p.Y + M22 * p.Z + M32
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3l TransformPosProj(M44l m, V3l p)
        {
            long s = (m.M30 * p.X  + m.M31 * p.Y  + m.M32 * p.Z + m.M33);
            s = 1 / s;
            return (TransformPos(m, p)) * s;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V4l TransformPosProjFull(M44l m, V3l p)
        {
            return new V4l(
                (m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z+ m.M03), 
                (m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z+ m.M13), 
                (m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z+ m.M23), 
                (m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z+ m.M33)
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public V3l TransformPosProj(V3l p)
        {
            return TransformPosProj(this, p);
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V4l TransformPosProjFull(V3l p)
        {
            return TransformPosProjFull(this, p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V4l Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                case 2: return R2;
                case 3: return R3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V4l Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                case 3: return C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public long Trace
        {
            get { return M00 + M11 + M22 + M33 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public long Det
        {
            get
            {
                // using bottom row because elements M30, M31, and M32
                // are zero most of the time.
                long d = 0;
                if (M30 != 0.0f) d -= M30 * (
                M01 * M12 * M23 + M02 * M13 * M21 + M03 * M11 * M22
                - M21 * M12 * M03 - M22 * M13 * M01 - M23 * M11 * M02
                );
                if (M31 != 0.0f) d += M31 * (
                M00 * M12 * M23 + M02 * M13 * M20 + M03 * M10 * M22
                - M20 * M12 * M03 - M22 * M13 * M00 - M23 * M10 * M02
                );
                if (M32 != 0.0f) d -= M32 * (
                M00 * M11 * M23 + M01 * M13 * M20 + M03 * M10 * M21
                - M20 * M11 * M03 - M21 * M13 * M00 - M23 * M10 * M01
                );
                if (M33 != 0.0f) d += M33 * (
                M00 * M11 * M22 + M01 * M12 * M20 + M02 * M10 * M21
                - M20 * M11 * M02 - M21 * M12 * M00 - M22 * M10 * M01
                );
                return d;
            }
        }
        
        /// <summary>
        /// Returns the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public long Determinant()
        {
            return Det;
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible { get { return Det != 0; } }
        
        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular { get { return Det == 0; } }

        /// <summary>
        /// Transposes this matrix (and returns this).
        /// </summary>
        public void Transpose()
        {
            Fun.Swap(ref M10, ref M01);
            Fun.Swap(ref M20, ref M02);
            Fun.Swap(ref M21, ref M12);
            Fun.Swap(ref M30, ref M03);
            Fun.Swap(ref M31, ref M13);
            Fun.Swap(ref M32, ref M23);
        }
        
        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M44l Transposed
        {
            get
            {
                return new M44l {
                    M00 = M00, M01 = M10, M02 = M20, M03 = M30, 
                    M10 = M01, M11 = M11, M12 = M21, M13 = M31, 
                    M20 = M02, M21 = M12, M22 = M22, M23 = M32, 
                    M30 = M03, M31 = M13, M32 = M23, M33 = M33
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M44l operator *(M44l a, M44l b)
        {
            return new M44l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        public static M44l Multiply(M44l a, M44l b)
        {
            return new M44l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M44lEqualityComparer : IEqualityComparer<M44l>
    {
        public static readonly M44lEqualityComparer Default
            = new M44lEqualityComparer();

        #region IEqualityComparer<M44l> Members

        public bool Equals(M44l v0, M44l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M44l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M44f

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M44f : IValidity, IMatrix<double>
    {
        public float M00, M01, M02, M03;
        public float M10, M11, M12, M13;
        public float M20, M21, M22, M23;
        public float M30, M31, M32, M33;

        #region Constructors

        public M44f(
                float m00, float m01, float m02, float m03, 
                float m10, float m11, float m12, float m13, 
                float m20, float m21, float m22, float m23, 
                float m30, float m31, float m32, float m33)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
            M30 = m30; M31 = m31; M32 = m32; M33 = m33; 
        }

        public M44f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
            M30 = a[12];
            M31 = a[13];
            M32 = a[14];
            M33 = a[15];
        }
        
        public M44f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
            M30 = a[start + 12];
            M31 = a[start + 13];
            M32 = a[start + 14];
            M33 = a[start + 15];
        }

        #endregion

        #region Conversions

        public static explicit operator M44f(M22i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M23i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M33i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M34i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M44i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = (float)m.M30, M31 = (float)m.M31, M32 = (float)m.M32, M33 = (float)m.M33, 
            };
        }

        public static explicit operator M44f(M22l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M23l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M33l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M34l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M44l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = (float)m.M30, M31 = (float)m.M31, M32 = (float)m.M32, M33 = (float)m.M33, 
            };
        }

        public static explicit operator M44f(M22f m)
        {
            return new M44f {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M23f m)
        {
            return new M44f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M33f m)
        {
            return new M44f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M34f m)
        {
            return new M44f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M22d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M23d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M33d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M34d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M44d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = (float)m.M30, M31 = (float)m.M31, M32 = (float)m.M32, M33 = (float)m.M33, 
            };
        }

        public static explicit operator M44f(int[] a)
        {
            return new M44f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11], 
                (float)a[12], (float)a[13], (float)a[14], (float)a[15]);
        }

        public static explicit operator M44f(int[,] a)
        {
            return new M44f (
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3], 
                (float)a[3, 0], (float)a[3, 1], (float)a[3, 2], (float)a[3, 3]);
        }

        public static explicit operator int[](M44f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23, 
                (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33
            };
        }

        public static explicit operator int[,](M44f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }, 
                { (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
            array[index + 12] = (int)M30;
            array[index + 13] = (int)M31;
            array[index + 14] = (int)M32;
            array[index + 15] = (int)M33;
        }

        public static explicit operator M44f(long[] a)
        {
            return new M44f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11], 
                (float)a[12], (float)a[13], (float)a[14], (float)a[15]);
        }

        public static explicit operator M44f(long[,] a)
        {
            return new M44f (
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3], 
                (float)a[3, 0], (float)a[3, 1], (float)a[3, 2], (float)a[3, 3]);
        }

        public static explicit operator long[](M44f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23, 
                (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33
            };
        }

        public static explicit operator long[,](M44f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }, 
                { (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
            array[index + 12] = (long)M30;
            array[index + 13] = (long)M31;
            array[index + 14] = (long)M32;
            array[index + 15] = (long)M33;
        }

        public static explicit operator M44f(float[] a)
        {
            return new M44f(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11], 
                a[12], a[13], a[14], a[15]);
        }

        public static explicit operator M44f(float[,] a)
        {
            return new M44f (
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3], 
                a[3, 0], a[3, 1], a[3, 2], a[3, 3]);
        }

        public static explicit operator float[](M44f m)
        {
            return new float[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23, 
                m.M30, m.M31, m.M32, m.M33
            };
        }

        public static explicit operator float[,](M44f m)
        {
            return new float[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }, 
                { m.M30, m.M31, m.M32, m.M33 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
            array[index + 12] = M30;
            array[index + 13] = M31;
            array[index + 14] = M32;
            array[index + 15] = M33;
        }

        public static explicit operator M44f(double[] a)
        {
            return new M44f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11], 
                (float)a[12], (float)a[13], (float)a[14], (float)a[15]);
        }

        public static explicit operator M44f(double[,] a)
        {
            return new M44f (
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3], 
                (float)a[3, 0], (float)a[3, 1], (float)a[3, 2], (float)a[3, 3]);
        }

        public static explicit operator double[](M44f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23, 
                (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33
            };
        }

        public static explicit operator double[,](M44f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }, 
                { (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
            array[index + 12] = (double)M30;
            array[index + 13] = (double)M31;
            array[index + 14] = (double)M32;
            array[index + 15] = (double)M33;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<float, int> element_fun)
        {
            return new M44i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M44i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<float, long> element_fun)
        {
            return new M44l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M44l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<float, float> element_fun)
        {
            return new M44f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M44f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<float, double> element_fun)
        {
            return new M44d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M44d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M33f UpperLeftM33()
        {
            return (M33f)this;
        }

        public float[] ToArray()
        {
            var array = new float[16];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            array[12] = M30;
            array[13] = M31;
            array[14] = M32;
            array[15] = M33;
            return array;
        }

        #endregion

        #region Static Factories

        public static M44f FromCols(V4f col0, V4f col1, V4f col2, V4f col3)
        {
            return new M44f(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z, 
                col0.W, col1.W, col2.W, col3.W);
        }

        public static M44f FromRows(V4f row0, V4f row1, V4f row2, V4f row3)
        {
            return new M44f(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W, 
                row3.X, row3.Y, row3.Z, row3.W);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<float> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M03;
                 yield return M10;
                 yield return M11;
                 yield return M12;
                 yield return M13;
                 yield return M20;
                 yield return M21;
                 yield return M22;
                 yield return M23;
                 yield return M30;
                 yield return M31;
                 yield return M32;
                 yield return M33;
            }
        }

        public IEnumerable<V4f> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
                yield return R3;
            }
        }

        public IEnumerable<V4f> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4f R0
        {                     
            get { return new V4f( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4f R1
        {                     
            get { return new V4f( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4f R2
        {                     
            get { return new V4f( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V4f R3
        {                     
            get { return new V4f( M30,  M31,  M32,  M33); }
            set
            {
                M30 = value.X;
                M31 = value.Y;
                M32 = value.Z;
                M33 = value.W;
            }
        }

        public V4f C0
        {           
            get { return new V4f( M00,  M10,  M20,  M30); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
                M30 = value.W;
            }
        }

        public V4f C1
        {           
            get { return new V4f( M01,  M11,  M21,  M31); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
                M31 = value.W;
            }
        }

        public V4f C2
        {           
            get { return new V4f( M02,  M12,  M22,  M32); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
                M32 = value.W;
            }
        }

        public V4f C3
        {           
            get { return new V4f( M03,  M13,  M23,  M33); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
                M33 = value.W;
            }
        }

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    case 12: return M30;
                    case 13: return M31;
                    case 14: return M32;
                    case 15: return M33;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    case 12: M30 = value; return;
                    case 13: M31 = value; return;
                    case 14: M32 = value; return;
                    case 15: M33 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public float this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                case 3: return M03;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                case 3: return M13;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: return M20;
                                case 1: return M21;
                                case 2: return M22;
                                case 3: return M23;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 3: switch (column)
                            {
                                case 0: return M30;
                                case 1: return M31;
                                case 2: return M32;
                                case 3: return M33;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                case 3: M03 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                case 3: M13 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: M20 = value; return;
                                case 1: M21 = value; return;
                                case 2: M22 = value; return;
                                case 3: M23 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 3: switch (column)
                            {
                                case 0: M30 = value; return;
                                case 1: M31 = value; return;
                                case 2: M32 = value; return;
                                case 3: M33 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 4;
        public const int ColumnCount = 4;
        public const int ElementCount = 4*4;

        public static readonly V2l Dimensions = new V2l(4, 4);

        public static readonly M44f Zero
                = new M44f(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

        public static readonly M44f Identity
                = new M44f(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23) + 
                    Fun.Abs(M30) + Fun.Abs(M31) + Fun.Abs(M32) + Fun.Abs(M33);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23 + 
                    M30 * M30 + M31 * M31 + M32 * M32 + M33 * M33);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public float Norm(float p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M03).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p) + 
                Fun.Abs(M13).Pow(p) + 
                Fun.Abs(M20).Pow(p) + 
                Fun.Abs(M21).Pow(p) + 
                Fun.Abs(M22).Pow(p) + 
                Fun.Abs(M23).Pow(p) + 
                Fun.Abs(M30).Pow(p) + 
                Fun.Abs(M31).Pow(p) + 
                Fun.Abs(M32).Pow(p) + 
                Fun.Abs(M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Max(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Min(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(M44f a, M44f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23) + 
                Fun.Abs(b.M30 - a.M30) + 
                Fun.Abs(b.M31 - a.M31) + 
                Fun.Abs(b.M32 - a.M32) + 
                Fun.Abs(b.M33 - a.M33);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(M44f a, M44f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23) + 
                        Fun.Square(b.M30 - a.M30) + 
                        Fun.Square(b.M31 - a.M31) + 
                        Fun.Square(b.M32 - a.M32) + 
                        Fun.Square(b.M33 - a.M33));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(M44f a, M44f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p) + 
                Fun.Abs(b.M30 - a.M30).Pow(p) + 
                Fun.Abs(b.M31 - a.M31).Pow(p) + 
                Fun.Abs(b.M32 - a.M32).Pow(p) + 
                Fun.Abs(b.M33 - a.M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(M44f a, M44f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Max(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(M44f a, M44f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Min(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        #endregion

        #region Mathematical Operators

        public static M44f operator +(M44f a, M44f b)
        {
            return new M44f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44f operator +(M44f m, float s)
        {
            return new M44f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44f operator +(float s, M44f m)
        {
            return new M44f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44d operator +(M44f a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44d operator +(M44f m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44d operator +(double s, M44f m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44f Add(M44f a, M44f b)
        {
            return new M44f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44f Add(M44f m, float s)
        {
            return new M44f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44f Add(float s, M44f m)
        {
            return new M44f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44d Add(M44f a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44d Add(M44f m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44d Add(double s, M44f m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44f operator -(M44f a, M44f b)
        {
            return new M44f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44f operator -(M44f m, float s)
        {
            return new M44f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44f operator -(float s, M44f m)
        {
            return new M44f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44d operator -(M44f a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44d operator -(M44f m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44d operator -(double s, M44f m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44f Subtract(M44f a, M44f b)
        {
            return new M44f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44f Subtract(M44f m, float s)
        {
            return new M44f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44f Subtract(float s, M44f m)
        {
            return new M44f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44d Subtract(M44f a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44d Subtract(M44f m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44d Subtract(double s, M44f m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44f operator %(M44f a, M44f b)
        {
            return new M44f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44f operator %(M44f m, float s)
        {
            return new M44f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44f operator %(float s, M44f m)
        {
            return new M44f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44d operator %(M44f a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44d operator %(M44f m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44d operator %(double s, M44f m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44f Modulo(M44f a, M44f b)
        {
            return new M44f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44f Modulo(M44f m, float s)
        {
            return new M44f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44f Modulo(float s, M44f m)
        {
            return new M44f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44d Modulo(M44f a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44d Modulo(M44f m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44d Modulo(double s, M44f m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44f operator /(M44f a, M44f b)
        {
            return new M44f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44f operator /(M44f m, float s)
        {
            return new M44f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44f operator /(float s, M44f m)
        {
            return new M44f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44d operator /(M44f a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44d operator /(M44f m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44d operator /(double s, M44f m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44f Divide(M44f a, M44f b)
        {
            return new M44f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44f Divide(M44f m, float s)
        {
            return new M44f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44f Divide(float s, M44f m)
        {
            return new M44f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44d Divide(M44f a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44d Divide(M44f m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44d Divide(double s, M44f m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44f operator *(M44f m, float s)
        {
            return new M44f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44f operator *(float s, M44f m)
        {
            return new M44f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44d operator *(M44f m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44d operator *(double s, M44f m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44f Multiply(M44f m, float s)
        {
            return new M44f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44f Multiply(float s, M44f m)
        {
            return new M44f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44d Multiply(M44f m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44d Multiply(double s, M44f m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V4f Multiply(M44f m, V4f v)
        {
            return new V4f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        public static V4f operator *(M44f m, V4f v)
        {
            return new V4f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        public static V4f TransposedMultiply(V4f v, M44f m)
        {
            return new V4f(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20 + v.W * m.M30, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21 + v.W * m.M31, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22 + v.W * m.M32, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23 + v.W * m.M33);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M44f a, M44f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23 && 
                a.M30 < b.M30 && 
                a.M31 < b.M31 && 
                a.M32 < b.M32 && 
                a.M33 < b.M33;
        }

        public static bool operator <(M44f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s && 
                a.M30 < s && 
                a.M31 < s && 
                a.M32 < s && 
                a.M33 < s;
        }

        public static bool operator <(float s, M44f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23  && 
                s < a.M30  && 
                s < a.M31  && 
                s < a.M32  && 
                s < a.M33 ;
        }

        public static bool operator >(M44f a, M44f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23 && 
                a.M30 > b.M30 && 
                a.M31 > b.M31 && 
                a.M32 > b.M32 && 
                a.M33 > b.M33;
        }

        public static bool operator >(M44f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s && 
                a.M30 > s && 
                a.M31 > s && 
                a.M32 > s && 
                a.M33 > s;
        }

        public static bool operator >(float s, M44f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23  && 
                s > a.M30  && 
                s > a.M31  && 
                s > a.M32  && 
                s > a.M33 ;
        }

        public static bool operator ==(M44f a, M44f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23 && 
                a.M30 == b.M30 && 
                a.M31 == b.M31 && 
                a.M32 == b.M32 && 
                a.M33 == b.M33;
        }

        public static bool operator ==(M44f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s && 
                a.M30 == s && 
                a.M31 == s && 
                a.M32 == s && 
                a.M33 == s;
        }

        public static bool operator ==(float s, M44f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23  && 
                s == a.M30  && 
                s == a.M31  && 
                s == a.M32  && 
                s == a.M33 ;
        }

        public static bool operator <=(M44f a, M44f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23 && 
                a.M30 <= b.M30 && 
                a.M31 <= b.M31 && 
                a.M32 <= b.M32 && 
                a.M33 <= b.M33;
        }

        public static bool operator <=(M44f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s && 
                a.M30 <= s && 
                a.M31 <= s && 
                a.M32 <= s && 
                a.M33 <= s;
        }

        public static bool operator <=(float s, M44f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23  && 
                s <= a.M30  && 
                s <= a.M31  && 
                s <= a.M32  && 
                s <= a.M33 ;
        }

        public static bool operator >=(M44f a, M44f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23 && 
                a.M30 >= b.M30 && 
                a.M31 >= b.M31 && 
                a.M32 >= b.M32 && 
                a.M33 >= b.M33;
        }

        public static bool operator >=(M44f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s && 
                a.M30 >= s && 
                a.M31 >= s && 
                a.M32 >= s && 
                a.M33 >= s;
        }

        public static bool operator >=(float s, M44f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23  && 
                s >= a.M30  && 
                s >= a.M31  && 
                s >= a.M32  && 
                s >= a.M33 ;
        }

        public static bool operator !=(M44f a, M44f b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M44f m, float s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(float s, M44f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode(), 
                M30.GetHashCode(), M31.GetHashCode(), M32.GetHashCode(), M33.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M44f) ? (this == (M44f)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R3.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M44f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M44f.FromRows(
                V4f.Parse(x[0]), 
                V4f.Parse(x[1]), 
                V4f.Parse(x[2]), 
                V4f.Parse(x[3])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V3f TransformDir(M44f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3f TransformPos(M44f m, V3f p)
        {
            return new V3f(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V3f TransformDir(V3f v)
        {
            return new V3f(
                M00 * v.X + M01 * v.Y + M02 * v.Z, 
                M10 * v.X + M11 * v.Y + M12 * v.Z, 
                M20 * v.X + M21 * v.Y + M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V3f TransformPos(V3f p)
        {
            return new V3f(
                M00 * p.X + M01 * p.Y + M02 * p.Z + M03, 
                M10 * p.X + M11 * p.Y + M12 * p.Z + M13, 
                M20 * p.X + M21 * p.Y + M22 * p.Z + M23
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V3f TransposedTransformDir(M44f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M10 * v.Y + m.M20 * v.Z, 
                m.M01 * v.X + m.M11 * v.Y + m.M21 * v.Z, 
                m.M02 * v.X + m.M12 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3f TransposedTransformPos(M44f m, V3f p)
        {
            return new V3f(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of this matrix.
        /// </summary>
        public V3f TransposedTransformDir(V3f v)
        {
            return new V3f(
                M00 * v.X + M10 * v.Y + M20 * v.Z, 
                M01 * v.X + M11 * v.Y + M21 * v.Z, 
                M02 * v.X + M12 * v.Y + M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by transposed version of this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V3f TransposedTransformPos(V3f p)
        {
            return new V3f(
                M00 * p.X + M10 * p.Y + M20 * p.Z + M30, 
                M01 * p.X + M11 * p.Y + M21 * p.Z + M31, 
                M02 * p.X + M12 * p.Y + M22 * p.Z + M32
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3f TransformPosProj(M44f m, V3f p)
        {
            float s = (m.M30 * p.X  + m.M31 * p.Y  + m.M32 * p.Z + m.M33);
            s = 1 / s;
            return (TransformPos(m, p)) * s;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V4f TransformPosProjFull(M44f m, V3f p)
        {
            return new V4f(
                (m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z+ m.M03), 
                (m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z+ m.M13), 
                (m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z+ m.M23), 
                (m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z+ m.M33)
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public V3f TransformPosProj(V3f p)
        {
            return TransformPosProj(this, p);
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V4f TransformPosProjFull(V3f p)
        {
            return TransformPosProjFull(this, p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V4f Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                case 2: return R2;
                case 3: return R3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V4f Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                case 3: return C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public float Trace
        {
            get { return M00 + M11 + M22 + M33 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public float Det
        {
            get
            {
                // using bottom row because elements M30, M31, and M32
                // are zero most of the time.
                float d = 0;
                if (M30 != 0.0f) d -= M30 * (
                M01 * M12 * M23 + M02 * M13 * M21 + M03 * M11 * M22
                - M21 * M12 * M03 - M22 * M13 * M01 - M23 * M11 * M02
                );
                if (M31 != 0.0f) d += M31 * (
                M00 * M12 * M23 + M02 * M13 * M20 + M03 * M10 * M22
                - M20 * M12 * M03 - M22 * M13 * M00 - M23 * M10 * M02
                );
                if (M32 != 0.0f) d -= M32 * (
                M00 * M11 * M23 + M01 * M13 * M20 + M03 * M10 * M21
                - M20 * M11 * M03 - M21 * M13 * M00 - M23 * M10 * M01
                );
                if (M33 != 0.0f) d += M33 * (
                M00 * M11 * M22 + M01 * M12 * M20 + M02 * M10 * M21
                - M20 * M11 * M02 - M21 * M12 * M00 - M22 * M10 * M01
                );
                return d;
            }
        }
        
        /// <summary>
        /// Returns the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public float Determinant()
        {
            return Det;
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible { get { return Det != 0; } }
        
        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular { get { return Det == 0; } }

        /// <summary>
        /// Transposes this matrix (and returns this).
        /// </summary>
        public void Transpose()
        {
            Fun.Swap(ref M10, ref M01);
            Fun.Swap(ref M20, ref M02);
            Fun.Swap(ref M21, ref M12);
            Fun.Swap(ref M30, ref M03);
            Fun.Swap(ref M31, ref M13);
            Fun.Swap(ref M32, ref M23);
        }
        
        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M44f Transposed
        {
            get
            {
                return new M44f {
                    M00 = M00, M01 = M10, M02 = M20, M03 = M30, 
                    M10 = M01, M11 = M11, M12 = M21, M13 = M31, 
                    M20 = M02, M21 = M12, M22 = M22, M23 = M32, 
                    M30 = M03, M31 = M13, M32 = M23, M33 = M33
                };
            }
        }

        private static V2l s_luSize = new V2l(4, 4);
        private static V2l s_luDelta = new V2l(1, 4);

        /// <summary>
        /// Inverts the matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return false;
            this = (M44f)(lu.LuInverse(p).Data);
            return true;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M44f.Zero is returned.
        /// </summary>
        public M44f LuInverse()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return M44f.Zero;
            return (M44f)(lu.LuInverse(p).Data);
        }

        /// <summary>
        /// Inverts the matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        public bool Invert() { return LuInvert();  }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M44f.Zero is returned.
        /// </summary>
        public M44f Inverse { get { return LuInverse(); } }

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximatelyEquals(M44f a, M44f b, float epsilon)
        {
            return DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        /// <summary>
        /// Returns if the matrix is the identity matrix I.
        /// </summary>
        public bool IsIdentity(float epsilon)
        {
            return ApproximatelyEquals(this, Identity, epsilon);
        }

        /// <summary>
        /// Returns if the matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        public bool IsOrthonormal(float epsilon)
        {
            var i = this * this.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        public bool IsOrthogonal(float epsilon)
        {
            var i = this * this.Transposed;
            for (int j = 0; j < 4; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }
        #endregion

        #region Matrix Multiplication

        public static M44f operator *(M44f a, M44f b)
        {
            return new M44f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        public static M44f Multiply(M44f a, M44f b)
        {
            return new M44f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M44fEqualityComparer : IEqualityComparer<M44f>
    {
        public static readonly M44fEqualityComparer Default
            = new M44fEqualityComparer();

        #region IEqualityComparer<M44f> Members

        public bool Equals(M44f v0, M44f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M44f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

    #region M44d

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M44d : IValidity, IMatrix<double>
    {
        public double M00, M01, M02, M03;
        public double M10, M11, M12, M13;
        public double M20, M21, M22, M23;
        public double M30, M31, M32, M33;

        #region Constructors

        public M44d(
                double m00, double m01, double m02, double m03, 
                double m10, double m11, double m12, double m13, 
                double m20, double m21, double m22, double m23, 
                double m30, double m31, double m32, double m33)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
            M30 = m30; M31 = m31; M32 = m32; M33 = m33; 
        }

        public M44d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
            M30 = a[12];
            M31 = a[13];
            M32 = a[14];
            M33 = a[15];
        }
        
        public M44d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
            M30 = a[start + 12];
            M31 = a[start + 13];
            M32 = a[start + 14];
            M33 = a[start + 15];
        }

        #endregion

        #region Conversions

        public static explicit operator M44d(M22i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M23i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M33i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M34i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M44i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = (double)m.M30, M31 = (double)m.M31, M32 = (double)m.M32, M33 = (double)m.M33, 
            };
        }

        public static explicit operator M44d(M22l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M23l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M33l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M34l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M44l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = (double)m.M30, M31 = (double)m.M31, M32 = (double)m.M32, M33 = (double)m.M33, 
            };
        }

        public static explicit operator M44d(M22f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M23f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M33f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M34f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M44f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = (double)m.M30, M31 = (double)m.M31, M32 = (double)m.M32, M33 = (double)m.M33, 
            };
        }

        public static explicit operator M44d(M22d m)
        {
            return new M44d {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M23d m)
        {
            return new M44d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M33d m)
        {
            return new M44d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M34d m)
        {
            return new M44d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(int[] a)
        {
            return new M44d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11], 
                (double)a[12], (double)a[13], (double)a[14], (double)a[15]);
        }

        public static explicit operator M44d(int[,] a)
        {
            return new M44d (
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3], 
                (double)a[3, 0], (double)a[3, 1], (double)a[3, 2], (double)a[3, 3]);
        }

        public static explicit operator int[](M44d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23, 
                (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33
            };
        }

        public static explicit operator int[,](M44d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }, 
                { (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
            array[index + 12] = (int)M30;
            array[index + 13] = (int)M31;
            array[index + 14] = (int)M32;
            array[index + 15] = (int)M33;
        }

        public static explicit operator M44d(long[] a)
        {
            return new M44d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11], 
                (double)a[12], (double)a[13], (double)a[14], (double)a[15]);
        }

        public static explicit operator M44d(long[,] a)
        {
            return new M44d (
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3], 
                (double)a[3, 0], (double)a[3, 1], (double)a[3, 2], (double)a[3, 3]);
        }

        public static explicit operator long[](M44d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23, 
                (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33
            };
        }

        public static explicit operator long[,](M44d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }, 
                { (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
            array[index + 12] = (long)M30;
            array[index + 13] = (long)M31;
            array[index + 14] = (long)M32;
            array[index + 15] = (long)M33;
        }

        public static explicit operator M44d(float[] a)
        {
            return new M44d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11], 
                (double)a[12], (double)a[13], (double)a[14], (double)a[15]);
        }

        public static explicit operator M44d(float[,] a)
        {
            return new M44d (
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3], 
                (double)a[3, 0], (double)a[3, 1], (double)a[3, 2], (double)a[3, 3]);
        }

        public static explicit operator float[](M44d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23, 
                (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33
            };
        }

        public static explicit operator float[,](M44d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }, 
                { (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
            array[index + 12] = (float)M30;
            array[index + 13] = (float)M31;
            array[index + 14] = (float)M32;
            array[index + 15] = (float)M33;
        }

        public static explicit operator M44d(double[] a)
        {
            return new M44d(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11], 
                a[12], a[13], a[14], a[15]);
        }

        public static explicit operator M44d(double[,] a)
        {
            return new M44d (
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3], 
                a[3, 0], a[3, 1], a[3, 2], a[3, 3]);
        }

        public static explicit operator double[](M44d m)
        {
            return new double[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23, 
                m.M30, m.M31, m.M32, m.M33
            };
        }

        public static explicit operator double[,](M44d m)
        {
            return new double[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }, 
                { m.M30, m.M31, m.M32, m.M33 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
            array[index + 12] = M30;
            array[index + 13] = M31;
            array[index + 14] = M32;
            array[index + 15] = M33;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<double, int> element_fun)
        {
            return new M44i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M44i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<double, long> element_fun)
        {
            return new M44l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M44l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<double, float> element_fun)
        {
            return new M44f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M44f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<double, double> element_fun)
        {
            return new M44d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M44d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M33d UpperLeftM33()
        {
            return (M33d)this;
        }

        public double[] ToArray()
        {
            var array = new double[16];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            array[12] = M30;
            array[13] = M31;
            array[14] = M32;
            array[15] = M33;
            return array;
        }

        #endregion

        #region Static Factories

        public static M44d FromCols(V4d col0, V4d col1, V4d col2, V4d col3)
        {
            return new M44d(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z, 
                col0.W, col1.W, col2.W, col3.W);
        }

        public static M44d FromRows(V4d row0, V4d row1, V4d row2, V4d row3)
        {
            return new M44d(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W, 
                row3.X, row3.Y, row3.Z, row3.W);
        }

        #endregion

        #region Properties and Indexers

        public bool IsValid { get { return true; } }
        public bool IsInvalid { get { return false; } }

        public IEnumerable<double> Elements
        {
            get
            {
                 yield return M00;
                 yield return M01;
                 yield return M02;
                 yield return M03;
                 yield return M10;
                 yield return M11;
                 yield return M12;
                 yield return M13;
                 yield return M20;
                 yield return M21;
                 yield return M22;
                 yield return M23;
                 yield return M30;
                 yield return M31;
                 yield return M32;
                 yield return M33;
            }
        }

        public IEnumerable<V4d> Rows
        {
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
                yield return R3;
            }
        }

        public IEnumerable<V4d> Columns
        {
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        public V4d R0
        {                     
            get { return new V4d( M00,  M01,  M02,  M03); }
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        public V4d R1
        {                     
            get { return new V4d( M10,  M11,  M12,  M13); }
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        public V4d R2
        {                     
            get { return new V4d( M20,  M21,  M22,  M23); }
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        public V4d R3
        {                     
            get { return new V4d( M30,  M31,  M32,  M33); }
            set
            {
                M30 = value.X;
                M31 = value.Y;
                M32 = value.Z;
                M33 = value.W;
            }
        }

        public V4d C0
        {           
            get { return new V4d( M00,  M10,  M20,  M30); }
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
                M30 = value.W;
            }
        }

        public V4d C1
        {           
            get { return new V4d( M01,  M11,  M21,  M31); }
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
                M31 = value.W;
            }
        }

        public V4d C2
        {           
            get { return new V4d( M02,  M12,  M22,  M32); }
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
                M32 = value.W;
            }
        }

        public V4d C3
        {           
            get { return new V4d( M03,  M13,  M23,  M33); }
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
                M33 = value.W;
            }
        }

        public double this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return M00;
                    case 1: return M01;
                    case 2: return M02;
                    case 3: return M03;
                    case 4: return M10;
                    case 5: return M11;
                    case 6: return M12;
                    case 7: return M13;
                    case 8: return M20;
                    case 9: return M21;
                    case 10: return M22;
                    case 11: return M23;
                    case 12: return M30;
                    case 13: return M31;
                    case 14: return M32;
                    case 15: return M33;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (index)
                {
                    case 0: M00 = value; return;
                    case 1: M01 = value; return;
                    case 2: M02 = value; return;
                    case 3: M03 = value; return;
                    case 4: M10 = value; return;
                    case 5: M11 = value; return;
                    case 6: M12 = value; return;
                    case 7: M13 = value; return;
                    case 8: M20 = value; return;
                    case 9: M21 = value; return;
                    case 10: M22 = value; return;
                    case 11: M23 = value; return;
                    case 12: M30 = value; return;
                    case 13: M31 = value; return;
                    case 14: M32 = value; return;
                    case 15: M33 = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        public double this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: return M00;
                                case 1: return M01;
                                case 2: return M02;
                                case 3: return M03;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: return M10;
                                case 1: return M11;
                                case 2: return M12;
                                case 3: return M13;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: return M20;
                                case 1: return M21;
                                case 2: return M22;
                                case 3: return M23;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 3: switch (column)
                            {
                                case 0: return M30;
                                case 1: return M31;
                                case 2: return M32;
                                case 3: return M33;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
                switch (row)
                {
                    case 0: switch (column)
                            {
                                case 0: M00 = value; return;
                                case 1: M01 = value; return;
                                case 2: M02 = value; return;
                                case 3: M03 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 1: switch (column)
                            {
                                case 0: M10 = value; return;
                                case 1: M11 = value; return;
                                case 2: M12 = value; return;
                                case 3: M13 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 2: switch (column)
                            {
                                case 0: M20 = value; return;
                                case 1: M21 = value; return;
                                case 2: M22 = value; return;
                                case 3: M23 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    case 3: switch (column)
                            {
                                case 0: M30 = value; return;
                                case 1: M31 = value; return;
                                case 2: M32 = value; return;
                                case 3: M33 = value; return;
                                default: throw new IndexOutOfRangeException();
                            }
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 4;
        public const int ColumnCount = 4;
        public const int ElementCount = 4*4;

        public static readonly V2l Dimensions = new V2l(4, 4);

        public static readonly M44d Zero
                = new M44d(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

        public static readonly M44d Identity
                = new M44d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23) + 
                    Fun.Abs(M30) + Fun.Abs(M31) + Fun.Abs(M32) + Fun.Abs(M33);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23 + 
                    M30 * M30 + M31 * M31 + M32 * M32 + M33 * M33);
            }
        }

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        public double Norm(double p)
        {
            return (
                Fun.Abs(M00).Pow(p) + 
                Fun.Abs(M01).Pow(p) + 
                Fun.Abs(M02).Pow(p) + 
                Fun.Abs(M03).Pow(p) + 
                Fun.Abs(M10).Pow(p) + 
                Fun.Abs(M11).Pow(p) + 
                Fun.Abs(M12).Pow(p) + 
                Fun.Abs(M13).Pow(p) + 
                Fun.Abs(M20).Pow(p) + 
                Fun.Abs(M21).Pow(p) + 
                Fun.Abs(M22).Pow(p) + 
                Fun.Abs(M23).Pow(p) + 
                Fun.Abs(M30).Pow(p) + 
                Fun.Abs(M31).Pow(p) + 
                Fun.Abs(M32).Pow(p) + 
                Fun.Abs(M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Max(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Min(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(M44d a, M44d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23) + 
                Fun.Abs(b.M30 - a.M30) + 
                Fun.Abs(b.M31 - a.M31) + 
                Fun.Abs(b.M32 - a.M32) + 
                Fun.Abs(b.M33 - a.M33);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(M44d a, M44d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23) + 
                        Fun.Square(b.M30 - a.M30) + 
                        Fun.Square(b.M31 - a.M31) + 
                        Fun.Square(b.M32 - a.M32) + 
                        Fun.Square(b.M33 - a.M33));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(M44d a, M44d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p) + 
                Fun.Abs(b.M30 - a.M30).Pow(p) + 
                Fun.Abs(b.M31 - a.M31).Pow(p) + 
                Fun.Abs(b.M32 - a.M32).Pow(p) + 
                Fun.Abs(b.M33 - a.M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(M44d a, M44d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Max(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(M44d a, M44d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Min(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        #endregion

        #region Mathematical Operators

        public static M44d operator +(M44d a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44d operator +(M44d m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44d operator +(double s, M44d m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44d Add(M44d a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        public static M44d Add(M44d m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }
        
        public static M44d Add(double s, M44d m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        public static M44d operator -(M44d a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44d operator -(M44d m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44d operator -(double s, M44d m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44d Subtract(M44d a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        public static M44d Subtract(M44d m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }
        
        public static M44d Subtract(double s, M44d m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        public static M44d operator %(M44d a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44d operator %(M44d m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44d operator %(double s, M44d m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44d Modulo(M44d a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        public static M44d Modulo(M44d m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }
        
        public static M44d Modulo(double s, M44d m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        public static M44d operator /(M44d a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44d operator /(M44d m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44d operator /(double s, M44d m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44d Divide(M44d a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        public static M44d Divide(M44d m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }
        
        public static M44d Divide(double s, M44d m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        public static M44d operator *(M44d m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44d operator *(double s, M44d m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        public static M44d Multiply(M44d m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }
        
        public static M44d Multiply(double s, M44d m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        #endregion

        #region Matrix/Vector Multiplication

        public static V4d Multiply(M44d m, V4d v)
        {
            return new V4d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        public static V4d operator *(M44d m, V4d v)
        {
            return new V4d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        public static V4d TransposedMultiply(V4d v, M44d m)
        {
            return new V4d(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20 + v.W * m.M30, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21 + v.W * m.M31, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22 + v.W * m.M32, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23 + v.W * m.M33);
        }

        #endregion

        #region Bool Operators

        public static bool operator <(M44d a, M44d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23 && 
                a.M30 < b.M30 && 
                a.M31 < b.M31 && 
                a.M32 < b.M32 && 
                a.M33 < b.M33;
        }

        public static bool operator <(M44d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s && 
                a.M30 < s && 
                a.M31 < s && 
                a.M32 < s && 
                a.M33 < s;
        }

        public static bool operator <(double s, M44d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23  && 
                s < a.M30  && 
                s < a.M31  && 
                s < a.M32  && 
                s < a.M33 ;
        }

        public static bool operator >(M44d a, M44d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23 && 
                a.M30 > b.M30 && 
                a.M31 > b.M31 && 
                a.M32 > b.M32 && 
                a.M33 > b.M33;
        }

        public static bool operator >(M44d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s && 
                a.M30 > s && 
                a.M31 > s && 
                a.M32 > s && 
                a.M33 > s;
        }

        public static bool operator >(double s, M44d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23  && 
                s > a.M30  && 
                s > a.M31  && 
                s > a.M32  && 
                s > a.M33 ;
        }

        public static bool operator ==(M44d a, M44d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23 && 
                a.M30 == b.M30 && 
                a.M31 == b.M31 && 
                a.M32 == b.M32 && 
                a.M33 == b.M33;
        }

        public static bool operator ==(M44d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s && 
                a.M30 == s && 
                a.M31 == s && 
                a.M32 == s && 
                a.M33 == s;
        }

        public static bool operator ==(double s, M44d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23  && 
                s == a.M30  && 
                s == a.M31  && 
                s == a.M32  && 
                s == a.M33 ;
        }

        public static bool operator <=(M44d a, M44d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23 && 
                a.M30 <= b.M30 && 
                a.M31 <= b.M31 && 
                a.M32 <= b.M32 && 
                a.M33 <= b.M33;
        }

        public static bool operator <=(M44d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s && 
                a.M30 <= s && 
                a.M31 <= s && 
                a.M32 <= s && 
                a.M33 <= s;
        }

        public static bool operator <=(double s, M44d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23  && 
                s <= a.M30  && 
                s <= a.M31  && 
                s <= a.M32  && 
                s <= a.M33 ;
        }

        public static bool operator >=(M44d a, M44d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23 && 
                a.M30 >= b.M30 && 
                a.M31 >= b.M31 && 
                a.M32 >= b.M32 && 
                a.M33 >= b.M33;
        }

        public static bool operator >=(M44d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s && 
                a.M30 >= s && 
                a.M31 >= s && 
                a.M32 >= s && 
                a.M33 >= s;
        }

        public static bool operator >=(double s, M44d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23  && 
                s >= a.M30  && 
                s >= a.M31  && 
                s >= a.M32  && 
                s >= a.M33 ;
        }

        public static bool operator !=(M44d a, M44d b)
        {
            return !(a == b);
        }
        
        public static bool operator !=(M44d m, double s)
        {
            return !(m == s);
        }
        
        public static bool operator !=(double s, M44d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.Combine(
                M00.GetHashCode(), M01.GetHashCode(), M02.GetHashCode(), M03.GetHashCode(), 
                M10.GetHashCode(), M11.GetHashCode(), M12.GetHashCode(), M13.GetHashCode(), 
                M20.GetHashCode(), M21.GetHashCode(), M22.GetHashCode(), M23.GetHashCode(), 
                M30.GetHashCode(), M31.GetHashCode(), M32.GetHashCode(), M33.GetHashCode()); 
        }

        public override bool Equals(object other)
        {
            return (other is M44d) ? (this == (M44d)other) : false;
        }

        public override string ToString()
        {
            return ToString(null, Localization.FormatEnUS);
        }

        public string ToString(string format)
        {
            return ToString(format, Localization.FormatEnUS);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = Localization.FormatEnUS;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R3.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }
        
        public static M44d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M44d.FromRows(
                V4d.Parse(x[0]), 
                V4d.Parse(x[1]), 
                V4d.Parse(x[2]), 
                V4d.Parse(x[3])
            );
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by matrix m.
        /// </summary>
        public static V3d TransformDir(M44d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3d TransformPos(M44d m, V3d p)
        {
            return new V3d(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by this matrix.
        /// </summary>
        public V3d TransformDir(V3d v)
        {
            return new V3d(
                M00 * v.X + M01 * v.Y + M02 * v.Z, 
                M10 * v.X + M11 * v.Y + M12 * v.Z, 
                M20 * v.X + M21 * v.Y + M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V3d TransformPos(V3d p)
        {
            return new V3d(
                M00 * p.X + M01 * p.Y + M02 * p.Z + M03, 
                M10 * p.X + M11 * p.Y + M12 * p.Z + M13, 
                M20 * p.X + M21 * p.Y + M22 * p.Z + M23
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V3d TransposedTransformDir(M44d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M10 * v.Y + m.M20 * v.Z, 
                m.M01 * v.X + m.M11 * v.Y + m.M21 * v.Z, 
                m.M02 * v.X + m.M12 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.w is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3d TransposedTransformPos(M44d m, V3d p)
        {
            return new V3d(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.w is presumed 0.0) by transposed version of this matrix.
        /// </summary>
        public V3d TransposedTransformDir(V3d v)
        {
            return new V3d(
                M00 * v.X + M10 * v.Y + M20 * v.Z, 
                M01 * v.X + M11 * v.Y + M21 * v.Z, 
                M02 * v.X + M12 * v.Y + M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by transposed version of this matrix.
        /// No projective transform is performed.
        /// </summary>
        public V3d TransposedTransformPos(V3d p)
        {
            return new V3d(
                M00 * p.X + M10 * p.Y + M20 * p.Z + M30, 
                M01 * p.X + M11 * p.Y + M21 * p.Z + M31, 
                M02 * p.X + M12 * p.Y + M22 * p.Z + M32
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3d TransformPosProj(M44d m, V3d p)
        {
            double s = (m.M30 * p.X  + m.M31 * p.Y  + m.M32 * p.Z + m.M33);
            s = 1 / s;
            return (TransformPos(m, p)) * s;
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V4d TransformPosProjFull(M44d m, V3d p)
        {
            return new V4d(
                (m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z+ m.M03), 
                (m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z+ m.M13), 
                (m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z+ m.M23), 
                (m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z+ m.M33)
                );
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public V3d TransformPosProj(V3d p)
        {
            return TransformPosProj(this, p);
        }

        /// <summary>
        /// Transforms point p (p.w is presumed 1.0) by this matrix.
        /// Projective transform is performed.
        /// </summary>
        public V4d TransformPosProjFull(V3d p)
        {
            return TransformPosProjFull(this, p);
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns index-th row of this matrix.
        /// </summary>
        public V4d Row(int index)
        {
            switch (index)
            {
                case 0: return R0;
                case 1: return R1;
                case 2: return R2;
                case 3: return R3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns index-th column of this matrix.
        /// </summary>
        public V4d Column(int index)
        {
            switch (index)
            {
                case 0: return C0;
                case 1: return C1;
                case 2: return C2;
                case 3: return C3;
                default: throw new IndexOutOfRangeException();
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public double Trace
        {
            get { return M00 + M11 + M22 + M33 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public double Det
        {
            get
            {
                // using bottom row because elements M30, M31, and M32
                // are zero most of the time.
                double d = 0;
                if (M30 != 0.0f) d -= M30 * (
                M01 * M12 * M23 + M02 * M13 * M21 + M03 * M11 * M22
                - M21 * M12 * M03 - M22 * M13 * M01 - M23 * M11 * M02
                );
                if (M31 != 0.0f) d += M31 * (
                M00 * M12 * M23 + M02 * M13 * M20 + M03 * M10 * M22
                - M20 * M12 * M03 - M22 * M13 * M00 - M23 * M10 * M02
                );
                if (M32 != 0.0f) d -= M32 * (
                M00 * M11 * M23 + M01 * M13 * M20 + M03 * M10 * M21
                - M20 * M11 * M03 - M21 * M13 * M00 - M23 * M10 * M01
                );
                if (M33 != 0.0f) d += M33 * (
                M00 * M11 * M22 + M01 * M12 * M20 + M02 * M10 * M21
                - M20 * M11 * M02 - M21 * M12 * M00 - M22 * M10 * M01
                );
                return d;
            }
        }
        
        /// <summary>
        /// Returns the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public double Determinant()
        {
            return Det;
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible { get { return Det != 0; } }
        
        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular { get { return Det == 0; } }

        /// <summary>
        /// Transposes this matrix (and returns this).
        /// </summary>
        public void Transpose()
        {
            Fun.Swap(ref M10, ref M01);
            Fun.Swap(ref M20, ref M02);
            Fun.Swap(ref M21, ref M12);
            Fun.Swap(ref M30, ref M03);
            Fun.Swap(ref M31, ref M13);
            Fun.Swap(ref M32, ref M23);
        }
        
        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M44d Transposed
        {
            get
            {
                return new M44d {
                    M00 = M00, M01 = M10, M02 = M20, M03 = M30, 
                    M10 = M01, M11 = M11, M12 = M21, M13 = M31, 
                    M20 = M02, M21 = M12, M22 = M22, M23 = M32, 
                    M30 = M03, M31 = M13, M32 = M23, M33 = M33
                };
            }
        }

        private static V2l s_luSize = new V2l(4, 4);
        private static V2l s_luDelta = new V2l(1, 4);

        /// <summary>
        /// Inverts the matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return false;
            this = (M44d)(lu.LuInverse(p).Data);
            return true;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M44d.Zero is returned.
        /// </summary>
        public M44d LuInverse()
        {
            var lu = new Matrix<double>((double[])this, 0, s_luSize, s_luDelta);
            var p = lu.LuFactorize();
            if (p == null) return M44d.Zero;
            return (M44d)(lu.LuInverse(p).Data);
        }

        /// <summary>
        /// Inverts the matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        public bool Invert() { return LuInvert();  }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M44d.Zero is returned.
        /// </summary>
        public M44d Inverse { get { return LuInverse(); } }

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        public static bool ApproximatelyEquals(M44d a, M44d b, double epsilon)
        {
            return DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        /// <summary>
        /// Returns if the matrix is the identity matrix I.
        /// </summary>
        public bool IsIdentity(double epsilon)
        {
            return ApproximatelyEquals(this, Identity, epsilon);
        }

        /// <summary>
        /// Returns if the matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        public bool IsOrthonormal(double epsilon)
        {
            var i = this * this.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        public bool IsOrthogonal(double epsilon)
        {
            var i = this * this.Transposed;
            for (int j = 0; j < 4; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }
        #endregion

        #region Matrix Multiplication

        public static M44d operator *(M44d a, M44d b)
        {
            return new M44d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        public static M44d Multiply(M44d a, M44d b)
        {
            return new M44d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M44dEqualityComparer : IEqualityComparer<M44d>
    {
        public static readonly M44dEqualityComparer Default
            = new M44dEqualityComparer();

        #region IEqualityComparer<M44d> Members

        public bool Equals(M44d v0, M44d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M44d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    #endregion

}
