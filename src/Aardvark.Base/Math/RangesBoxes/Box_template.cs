using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    //# Action comma = () => Out(", ");
    //# Action add = () => Out(" + ");
    //# Action andand = () => Out(" && ");
    //# foreach (var t in Meta.RangeAndBoxTypes) {
    //#     var lt = t.LimitType; var vt = lt as Meta.VecType;
    //#     int dim = vt != null ? vt.Len : 1;
    //#     var ft = dim > 1 ? vt.FieldType : lt;
    //#     var fun = dim > 1 ? "VecFun" : "Fun";
    //#     var ch = ft.Char;
    //#     int dplus1 = dim + 1;
    //#     var fields = dim > 1 ? vt.Fields : null;
    //#     var args = dim > 1 ? fields.ToLower() : null;
    //#     var ltype = lt.Name;
    //#     var lcast = dim > 1 ? "" : ft == Meta.IntType || ft == Meta.DoubleType ? "" : "(" + ltype + ")";
    //#     var ftype = ft.Name;
    //#     var fcast = dim > 1 ? "" : ft == Meta.IntType || ft == Meta.DoubleType ? "" : "(" + ftype + ")";
    //#     var bname = dim > 1 ? "box" : "range";
    //#     var type = t.Name;
    //#     var minvalue = dim > 1 ? ltype + ".MinValue"
    //#                            : lt.IsReal ? "Constant<" + ltype + ">.ParseableMinValue" : ltype + ".MinValue";
    //#     var maxvalue = dim > 1 ? ltype + ".MaxValue"
    //#                            : lt.IsReal ? "Constant<" + ltype + ">.ParseableMaxValue" : ltype + ".MaxValue";
    #region __type__

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct __type__
        : IRange<__ltype__, __type__>, /*# if (dim > 1) {
                */IBoundingBox__dim__d, ISize__dim__d,/*# } */ IFormattable
    {
        [DataMember]
        public __ltype__ Min;
        [DataMember]
        public __ltype__ Max;

        #region Constructors

        /// <summary>
        /// Creates a __bname__ from minimum and maximum limits.
        /// </summary>
        public __type__(__ltype__ min, __ltype__ max)
        {
            Min = min;
            Max = max;
        }

        //#if(dim > 1) {
        //#var xyz = vt.Fields;
        /// <summary>
        /// Creates a __bname__ from minimum and maximum limits.
        /// </summary>
        public __type__(/*# xyz.ForEach(X => { */__ftype__ min__X__, /*# }); xyz.ForEach(X => { */__ftype__ max__X__/*# }, comma); */)
        {
            //# xyz.ForEach(X => {
            Min.__X__ = min__X__;
            //# });
            //# xyz.ForEach(X => {
            Max.__X__ = max__X__;
            //# });
        }

        //# }
        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public __type__(__ltype__ pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        //# for (int k = 3; k < 5; k++) {
        /// <summary>
        /// Creates a __bname__ from __k__ points.
        /// </summary>
        public __type__(/*# k.ForEach(i => {*/__ltype__ p__i__/*#}, comma);*/)
        {
            Min = __fun__.Min(/*# k.ForEach(i => {*/p__i__/*#}, comma);*/);
            Max = __fun__.Max(/*# k.ForEach(i => {*/p__i__/*#}, comma);*/);
        }

        //# }
        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public __type__(__type__ range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        //# for (int k = 2; k < 5; k++) {
        /// <summary>
        /// Create a box containing all supplied __bname__s.
        /// </summary>
        public __type__(/*# k.ForEach(i => {*/__type__ b__i__/*#}, comma);*/)
        {
            Min = __fun__.Min(/*# k.ForEach(i => {*/b__i__.Min/*#}, comma);*/);
            Max = __fun__.Max(/*# k.ForEach(i => {*/b__i__.Max/*#}, comma);*/);
        }

        //# }
        //# if (dim > 1) {
        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public __type__(__ltype__[] points)
        {
            Min = Max = points[0];
            long count = points.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        public __type__(__ltype__[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public __type__(IEnumerable<__ltype__> points)
        {
            Min = __maxvalue__;
            Max = __minvalue__;
            if (points == null) return;
            foreach (__ltype__ p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public __type__(IEnumerable<__type__> boxes)
        {
            Min = __maxvalue__;
            Max = __minvalue__;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates __bname__ from a Range1 in each direction.
        /// </summary>
        public __type__(/*# fields.ForEach(f => {*/Range1__ch__ range__f__/*# }, comma);*/)
        {
            //# fields.ForEach(f => {
            Min.__f__ = range__f__.Min;
            Max.__f__ = range__f__.Max;
            //# });
        }

        //# } // dim > 1
        //# if (dim == 1) {
        /// <summary>
        /// Creates __bname__ as the bounding range of given points.
        /// </summary>
        public __type__(__ftype__[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates __bname__ as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        public __type__(__ftype__[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates __bname__ as the bounding range of given values.
        /// </summary>
        public __type__(IEnumerable<__ftype__> values)
        {
            Min = __maxvalue__;
            Max = __minvalue__;
            foreach (__ftype__ v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        public static __type__ FromMinAndSize(__ftype__ min, __ftype__ size)
        {
            return new __type__(min, __fcast__(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        public static __type__ FromCenterAndSize(__ftype__ center, __ftype__ size)
        {
            return new __type__(__fcast__(center - size / 2), __fcast__(center + size / 2));
        }

        //# }
        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly __type__ Invalid
                = new __type__(__maxvalue__, __minvalue__);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly __type__ Infinite
                = new __type__(__minvalue__, __maxvalue__);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        //# if (dim == 1) {
        public static readonly __type__ Unit = new __type__(0, 1);
        //# } else {
        public static readonly __type__ Unit = new __type__(__ltype__.Zero, __ltype__.One);
        //# }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return /*# if (dim == 1) { */Min >= Max;/*# } else { */Min.AnyGreaterOrEqual(Max);/*# } */ }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return /*# if (dim == 1) { */Min <= Max;/*# } else { */Min.AllSmallerOrEqual(Max);/*# } */ }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return /*# if (dim == 1) { */Min > Max;/*# } else { */Min.AnyGreater(Max) || Min.IsNaN || Max.IsNaN;/*# } */ }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the __bname__.
        /// </summary>
        public __ltype__ Size
        {
            get { return __lcast__(Max - Min); }
            set { Max = __lcast__(Min + value); }
        }

        public __ltype__ Center
        {
            get { return __lcast__((Min + Max) / 2); }
        }

        //# if (dim == 1) {
        public IEnumerable<__ltype__> Elements
        {
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        //# } // dim == 1
        //# if (dim > 1) {
        //# fields.ForEach(f => {
        public __ftype__ Size__f__
        {
            get { return Max.__f__ - Min.__f__; }
            set { Max.__f__ = Min.__f__ + value; }
        }

        public Range1__ch__ Range__f__
        {
            get { return new Range1__ch__(Min.__f__, Max.__f__); }
        }

        //# });
        //# if (dim == 2) {
        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            get { return SizeY > SizeX ? 1 : 0; }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            get { return SizeY < SizeX ? 1 : 0; }
        }

        public __ftype__ Area
        {
            get { return SizeX * SizeY; }
        }

        //# } // dim == 2
        //# if (dim == 3) {
        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            get
            {
                int major = 0;
                var s = Size;
                if (s.Y > s.X) major = 1;
                if (s.Z > s[major]) major = 2;
                return major;
            }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            get
            {
                int minor = 0;
                var s = Size;
                if (s.Y < s.X) minor = 1;
                if (s.Z < s[minor]) minor = 2;
                return minor;
            }
        }

        public __ftype__ SurfaceArea
        {
            get
            {
                var s = Size;
                return (s.X * s.Y + s.X * s.Z + s.Y * s.Z) * 2;
            }
        }

        public __ftype__ Volume
        {
            get
            {
                if (IsInvalid) return 0;
                return SizeX * SizeY * SizeZ;
            }
        }

        //# } // dim == 3
        //# for (int di = 0; di < (1 << dim); di++) {
        //#     var pnt = dim.Range().Select(i => (di & (1 << i)) == 0 ? "O" : "I").Join();
        //#     var arg = dim.Range().Select(i => ((di & (1 << i)) == 0 ? "Min" : "Max") + "." + fields[i]).Join(", ");
        public __ltype__ __pnt__ { get { return /*# if (di == 0) {*/Min;/*#}
                                                    else if (di == (1 << dim) - 1) {*/Max;/*#}
                                                    else {*/new __ltype__(__arg__);/*#}*/ } }
        //# }

        //# } // dim > 1
        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return __bname__ enlarged by the supplied value in all directions.
        /// </summary>
        public __type__ EnlargedBy(__ltype__ increment)
        {
            return new __type__(__lcast__(Min - increment), __lcast__(Max + increment));
        }

        /// <summary>
        /// Return __bname__ enlarged by the supplied values.
        /// </summary>
        public __type__ EnlargedBy(__ltype__ deltaMin, __ltype__ deltaMax)
        {
            return new __type__(__lcast__(Min - deltaMin), __lcast__(Max + deltaMax));
        }

        /// <summary>
        /// Return __bname__ shrunk by the supplied value in all directions.
        /// </summary>
        public __type__ ShrunkBy(__ltype__ delta)
        {
            return new __type__(__lcast__(Min + delta), __lcast__(Max - delta));
        }

        /// <summary>
        /// Return __bname__ shrunk by the supplied values.
        /// </summary>
        public __type__ ShrunkBy(__ltype__ deltaMin, __ltype__ deltaMax)
        {
            return new __type__(__lcast__(Min + deltaMin), __lcast__(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges __bname__ by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(__ltype__ delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges __bname__ by the supplied values.
        /// </summary>
        public void EnlargeBy(__ltype__ deltaMin, __ltype__ deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks __bname__ by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(__ltype__ delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks __bname__ by the supplied values.
        /// </summary>
        public void ShrinkBy(__ltype__ deltaMin, __ltype__ deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        //# if (dim > 1) {
        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        public __type__ EnlargedBy(__ftype__ delta)
        {
            return new __type__(
                    new __ltype__(/*# fields.ForEach(f => { */Min.__f__ - delta/*# }, comma);*/),
                    new __ltype__(/*# fields.ForEach(f => { */Max.__f__ + delta/*# }, comma);*/));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        public __type__ ShrunkBy(__ftype__ delta)
        {
            return new __type__(
                    new __ltype__(/*# fields.ForEach(f => { */Min.__f__ + delta/*# }, comma);*/),
                    new __ltype__(/*# fields.ForEach(f => { */Max.__f__ - delta/*# }, comma);*/));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        public __type__ EnlargedBy(/*# fields.ForEach(f => { */
                __ftype__ deltaMin__f__, __ftype__ deltaMax__f__/*# }, comma);*/)
        {
            return new __type__(
                    new __ltype__(/*# fields.ForEach(f => { */Min.__f__ - deltaMin__f__/*# }, comma);*/),
                    new __ltype__(/*# fields.ForEach(f => { */Max.__f__ + deltaMax__f__/*# }, comma);*/));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        public __type__ ShrunkBy(/*# fields.ForEach(f => { */
                __ftype__ deltaMin__f__, __ftype__ deltaMax__f__/*# }, comma);*/)
        {
            return new __type__(
                    new __ltype__(/*# fields.ForEach(f => { */Min.__f__ + deltaMin__f__/*# }, comma);*/),
                    new __ltype__(/*# fields.ForEach(f => { */Max.__f__ - deltaMax__f__/*# }, comma);*/));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        public void EnlargeBy(__ftype__ delta)
        {
            //# fields.ForEach(f => {
            Min.__f__ -= delta; Max.__f__ += delta;
            //# });
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        public void ShrinkBy(__ftype__ delta)
        {
            //# fields.ForEach(f => {
            Min.__f__ += delta; Max.__f__ -= delta;
            //# });
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        public void EnlargeBy(/*# fields.ForEach(f => { */
                __ftype__ deltaMin__f__, __ftype__ deltaMax__f__/*# }, comma);*/)
        {
            //# fields.ForEach(f => {
            Min.__f__ -= deltaMin__f__; Max.__f__ += deltaMax__f__;
            //# });
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        public void ShrinkBy(/*# fields.ForEach(f => { */
                __ftype__ deltaMin__f__, __ftype__ deltaMax__f__/*# }, comma);*/)
        {
            //# fields.ForEach(f => {
            Min.__f__ += deltaMin__f__; Max.__f__ -= deltaMax__f__;
            //# });
        }

        //# if (ft.IsReal) {
        /// <summary>
        /// Return __bname__ scaled by the supplied factor around its center.
        /// </summary>
        public __type__ ScaledFromCenterBy(__ftype__ factor)
        {
            var size = Size;
            var increment = (size * factor - size) / 2;
            return new __type__(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return __bname__ scaled by the supplied factor around its center.
        /// </summary>
        public __type__ ScaledFromCenterBy(__ltype__ vectorFactor)
        {
            var size = Size;
            var increment = (size * vectorFactor - size) / 2;
            return new __type__(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return a box enlarged in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        public __type__ EnlargedByRelativeEps(__ftype__ eps)
        {
            return EnlargedBy(eps * Size.Length);
        }

        /// <summary>
        /// Enlarge the box in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        public void EnlargeByRelativeEps(__ftype__ eps)
        {
            EnlargeBy(eps * Size.Length);
        }

        //# }
        //# }
        #endregion

        #region Box Arithmetics

        //# if (dim == 1) {
        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        public __ltype__ Clamped(__ltype__ x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }

        //# } else { // dim > 1
        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        public __ltype__ Clamped(__ltype__ p)
        {
            return new __ltype__(/*# fields.ForEach(f => { */
                        p.__f__ < Min.__f__ ? Min.__f__ : (p.__f__ > Max.__f__ ? Max.__f__ : p.__f__)/*# }, comma); */);
        }

        //# if (ft.IsReal) {
        public double DistanceSquared(__ltype__ p)
        {
            return /*# fields.ForEach(f => { */
                p.__f__ < Min.__f__ ? (Min.__f__ - p.__f__) * (Min.__f__ - p.__f__) : (p.__f__ > Max.__f__ ? (p.__f__ - Max.__f__) * (p.__f__ - Max.__f__) : 0.0)/*# }, add); */;
        }

        public double Distance(__ltype__ p)
        {
            return Fun.Sqrt(/*# fields.ForEach(f => { */
                p.__f__ < Min.__f__ ? (Min.__f__ - p.__f__) * (Min.__f__ - p.__f__) : (p.__f__ > Max.__f__ ? (p.__f__ - Max.__f__) * (p.__f__ - Max.__f__) : 0.0)/*# }, add); */);
        }

        //# } // ft.IsReal
        //# } // dim > 1
        //# if (ft.IsReal) {
        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        /// <param name="x">Position between min and max [0,1].</param>
        public __ltype__ Lerp(double x)
        {
            return __fun__.Lerp(x, Min, Max);
        }

        //# if (dim == 1) {
        /// <summary>
        /// Performs the inverse of Lerp.
        /// </summary>
        public __ltype__ InvLerp(__ltype__ x)
        {
            return __fun__.InvLerp(x, Min, Max);
        }

        //# } else { // dim > 1
        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        public __ltype__ Lerp(__ltype__ p)
        {
            return new __ltype__(/*# fields.ForEach(f => { */
                        Min.__f__ + p.__f__ * (Max.__f__ - Min.__f__)/*# }, comma); */);
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        public __ltype__ Lerp(/*# args.ForEach(a => { */__ftype__ __a__/*# }, comma); */)
        {
            return new __ltype__(/*# fields.ForEach(args, (f, a) => { */
                        Min.__f__ + __a__ * (Max.__f__ - Min.__f__)/*# }, comma); */);
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        public __ltype__ InvLerp(__ltype__ p)
        {
            return new __ltype__(/*# fields.ForEach(f => { */
                        (p.__f__ - Min.__f__) / (Max.__f__ - Min.__f__)/*# }, comma); */);
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        public __ltype__ InvLerp(/*# args.ForEach(a => { */__ftype__ __a__/*# }, comma); */)
        {
            return new __ltype__(/*# fields.ForEach(args, (f, a) => { */
                        (__a__ - Min.__f__) / (Max.__f__ - Min.__f__)/*# }, comma); */);
        }

        //# } // dim > 1
        //# } // ftype == "float" || ftype == "double"

        //# if (dim > 1) {
        /// <summary>
        /// Returns the __bname__ with Min value clamped to splitValue.
        /// </summary>
        public __type__ SplitRight(__ltype__ splitValue)
        {
            var result = new __type__(Min, Max);
            //# fields.ForEach(f => {
            if (splitValue.__f__ > result.Min.__f__) result.Min.__f__ = splitValue.__f__;
            //# });
            return result;
        }

        /// <summary>
        /// Returns the __bname__ with Max value clamped to splitValue.
        /// </summary>
        public __type__ SplitLeft(__ltype__ splitValue)
        {
            var result = new __type__(Min, Max);
            //# fields.ForEach(f => {
            if (splitValue.__f__ < result.Max.__f__) result.Max.__f__ = splitValue.__f__;
            //# });
            return result;
        }

        //# }
        //# if (dim == 1) {
        /// <summary>
        /// Returns the __bname__ with Min value clamped to splitValue.
        /// </summary>
        public __type__ SplitRight(__ftype__ splitValue)
        {
            if (splitValue > Max) return __type__.Invalid;
            if (splitValue <= Min) return this;
            return new __type__(splitValue, Max);
        }

        /// <summary>
        /// Returns the __bname__ with Max value clamped to splitValue.
        /// </summary>
        public __type__ SplitLeft(__ftype__ splitValue)
        {
            if (splitValue < Min) return __type__.Invalid;
            if (splitValue >= Max) return this;
            return new __type__(Min, splitValue);
        }

        //# }
        //# if (dim == 2) {
        /// <summary>
        /// Returns the __bname__ with Min.X clamped to splitValue.
        /// </summary>
        public __type__ SplitRight(__ftype__ splitAtX)
        {
            if (splitAtX > Max.X) return __type__.Invalid;
            if (splitAtX <= Min.X) return this;
            return new __type__(new __ltype__(splitAtX, Min.Y), Max);
        }

        /// <summary>
        /// Returns a __bname__ with Max.X clamped to splitValue.
        /// </summary>
        public __type__ SplitLeft(__ftype__ splitAtX)
        {
            if (splitAtX < Min.X) return __type__.Invalid;
            if (splitAtX >= Max.X) return this;
            return new __type__(Min, new __ltype__(splitAtX, Max.Y));
        }

        /// <summary>
        /// Returns the __bname__ with Min.Y clamped to splitValue.
        /// </summary>
        public __type__ SplitTop(__ftype__ splitAtY)
        {
            if (splitAtY > Max.Y) return __type__.Invalid;
            if (splitAtY <= Min.Y) return this;
            return new __type__(new __ltype__(Min.X, splitAtY), Max);
        }

        /// <summary>
        /// Returns the __bname__ with Max.Y clamped to splitValue.
        /// </summary>
        public __type__ SplitBottom(__ftype__ splitAtY)
        {
            if (splitAtY < Min.Y) return __type__.Invalid;
            if (splitAtY >= Max.Y) return this;
            return new __type__(Min, new __ltype__(Max.X, splitAtY));
        }

        public __type__ SplitLeftBottom(__ltype__ splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y < Min.Y) return __type__.Invalid;
            return new __type__(Min, splitAt);
        }

        public __type__ SplitRightBottom(__ltype__ splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y < Min.Y) return __type__.Invalid;
            return new __type__(new __ltype__(splitAt.X, Min.Y), new __ltype__(Max.X, splitAt.Y));
        }

        public __type__ SplitLeftTop(__ltype__ splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y > Max.Y) return __type__.Invalid;
            return new __type__(new __ltype__(Min.X, splitAt.Y), new __ltype__(splitAt.X, Max.Y));
        }

        public __type__ SplitRightTop(__ltype__ splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y > Max.Y) return __type__.Invalid;
            return new __type__(splitAt, Max);
        }

        //# }
        //# if ( dim == 1) {
        /// <summary>
        /// Returns the __bname__ extended to contain the supplied __bname__.
        /// </summary>
        public __type__ ExtendedBy(__type__ range)
        {
            return new __type__(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the __bname__ extended to contain the supplied value.
        /// </summary>
        public __type__ ExtendedBy(__ftype__ value)
        {
            return new __type__(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the __bname__ to contain the supplied __bname__.
        /// </summary>
        public void ExtendBy(__type__ range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the __bname__ to contain the supplied value.
        /// </summary>
        public void ExtendBy(__ftype__ value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        //# }
        //# if ( dim > 1) {
        /// <summary>
        /// Returns the __bname__ extended to contain the supplied __bname__.
        /// </summary>
        public __type__ ExtendedBy(__type__ b)
        {
            return new __type__(
                    new __ltype__(/*# fields.ForEach(f => {*/
                        b.Min.__f__ < Min.__f__ ? b.Min.__f__ : Min.__f__/*# }, comma); */),
                    new __ltype__(/*# fields.ForEach(f => {*/
                        b.Max.__f__ > Max.__f__ ? b.Max.__f__ : Max.__f__/*# }, comma); */));
        }

        /// <summary>
        /// Returns the __bname__ extended to contain the supplied value.
        /// </summary>
        public __type__ ExtendedBy(__ltype__ v)
        {
            return new __type__(
                    new __ltype__(/*# fields.ForEach(f => {*/
                        v.__f__ < Min.__f__ ? v.__f__ : Min.__f__/*# }, comma); */),
                    new __ltype__(/*# fields.ForEach(f => { */
                        v.__f__ > Max.__f__ ? v.__f__ : Max.__f__/*# }, comma); */));
        }

        /// <summary>
        /// Extends the __bname__ to contain the supplied __bname__.
        /// </summary>
        public void ExtendBy(__type__ box)
        {
            //# fields.ForEach(f => {
            if (box.Min.__f__ < Min.__f__) Min.__f__ = box.Min.__f__;
            if (box.Max.__f__ > Max.__f__) Max.__f__ = box.Max.__f__;
            //# });
        }

        /// <summary>
        /// Extends the __bname__ to contain the supplied value.
        /// </summary>
        public void ExtendBy(__ltype__ point)
        {
            //# fields.ForEach(f => {
            if (point.__f__ < Min.__f__) Min.__f__ = point.__f__;
            if (point.__f__ > Max.__f__) Max.__f__ = point.__f__;
            //# });
        }

        //# }
        //# if (dim == 1) {
        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        public bool Contains(__ftype__ value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        public bool Contains(__type__ b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        public bool Intersects(__type__ range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(__type__ range, __ftype__ eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        public __type__ Repair()
        {
            if (this.Equals(__type__.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        //# }
        //# if (dim > 1) {
        //# fields.ForEach(args, (f, a) => {
        public __type__ Extend__f__By(__ftype__ __a__)
        {
            if (__a__ < Min.__f__) Min.__f__ = __a__;
            if (__a__ > Max.__f__) Max.__f__ = __a__;
            return this;
        }

        //# });
        public __type__ ExtendDimBy(int dim, __ftype__ x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        public bool Contains(__ltype__ p)
        {
            return/*# fields.ForEach(f => {*/
                p.__f__ >= Min.__f__ && p.__f__ <= Max.__f__/*# }, andand);*/;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        public bool Contains(__type__ b)
        {
            return/*# fields.ForEach(f => {*/
                b.Min.__f__ >= Min.__f__ && b.Max.__f__ <= Max.__f__/*# }, andand);*/;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        public __type__ Repair()
        {
            if (Equals(__type__.Invalid)) return this;
            //# fields.ForEach(f => {
            if (Min.__f__ > Max.__f__) Fun.Swap(ref Min.__f__, ref Max.__f__);
            //# });
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        public bool Intersects(__type__ box)
        {
            //# fields.ForEach(f => {
            if (Min.__f__ >= box.Max.__f__) return false;
            if (Max.__f__ <= box.Min.__f__) return false;
            //# });
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(__type__ box, __ltype__ eps)
        {
            //# fields.ForEach(f => {
            if (Min.__f__ - eps.__f__ >= box.Max.__f__) return false;
            if (Max.__f__ + eps.__f__ <= box.Min.__f__) return false;
            //# });
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(__type__ box, __ftype__ eps)
        {
            //# fields.ForEach(f => {
            if (Min.__f__ - eps >= box.Max.__f__) return false;
            if (Max.__f__ + eps <= box.Min.__f__) return false;
            //# });
            return true;
        }

        public __type__ Invalidate()
        {
            Min = __maxvalue__;
            Max = __minvalue__;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        public Box.Flags OutsideFlags(__ltype__ p0)
        {
            Box.Flags bf = Box.Flags.None;
            //# fields.ForEach(f => {
            if (p0.__f__ < Min.__f__) bf |= Box.Flags.Min__f__;
            else if (p0.__f__ > Max.__f__) bf |= Box.Flags.Max__f__;
            //# });
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        public Box.Flags OutsideFlags(__type__ b)
        {
            Box.Flags bf = Box.Flags.None;
            //# fields.ForEach(f => {
            if (b.Min.__f__ < Min.__f__) bf |= Box.Flags.Min__f__;
            if (b.Max.__f__ > Max.__f__) bf |= Box.Flags.Max__f__;
            //# });
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        public void GetMinMaxInDirection(__ltype__ v, out __ltype__ vMin, out __ltype__ vMax)
        {
            vMin = __minvalue__;
            vMax = __maxvalue__;
            //# fields.ForEach(f => {
            if (v.__f__ >= 0)
            {
                vMin.__f__ = Min.__f__;
                vMax.__f__ = Max.__f__;
            }
            else
            {
                vMin.__f__ = Max.__f__;
                vMax.__f__ = Min.__f__;
            }
            //# });
        }

        //# }
        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(__type__ a, __type__ b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(__type__ a, __type__ b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a __bname__ shifted by the supplied value.
        /// </summary>
        public static __type__ operator +(__type__ box, __ltype__ v)
        {
            return new __type__(__lcast__(box.Min + v), __lcast__(box.Max + v));
        }

        /// <summary>
        /// Returns a __bname__ shifted by the negative supplied value.
        /// </summary>
        public static __type__ operator -(__type__ box, __ltype__ v)
        {
            return new __type__(__lcast__(box.Min - v), __lcast__(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is __type__) ? this == (__type__)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<__type__, int, __ltype__> Setter =
            (ref __type__ box, int i, __ltype__ value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static __type__ Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            //# if (dim > 1) {
            return new __type__(__ltype__.Parse(x[0].ToString()),
                                __ltype__.Parse(x[1].ToString()));
            //# } else {
            return new __type__(__ftype__.Parse(x[0], CultureInfo.InvariantCulture),
                                __ftype__.Parse(x[1], CultureInfo.InvariantCulture));
            //# }
        }

        public static __type__ Parse(Text t)
        {
            //# if (dim > 1) {
            return t.NestedBracketSplit(1, __ltype__.Parse, __type__.Setter);
            //# } else {
            return t.NestedBracketSplit(1, Text<__ltype__>.Parse, __type__.Setter);
            //# }
        }

        #endregion

        #region Various

        public static __type__ Union(__type__ a, __type__ b)
        {
            return new __type__(__fun__.Min(a.Min, b.Min), __fun__.Max(a.Max, b.Max));
        }

        public static __type__ Intersection(__type__ a, __type__ b)
        {
            return new __type__(__fun__.Max(a.Min, b.Min), __fun__.Min(a.Max, b.Max));
        }

        public __type__ Union(__type__ b)
        {
            return Union(this, b);
        }

        public __type__ Intersection(__type__ b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            //# var format = "format, fp" + (dim > 1 ? ", beginV, betweenV, endV" : "");
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(__format__) + betweenB
                          + Max.ToString(__format__) + endB;
        }

        #endregion

        //# if (dim > 1) {
        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        public static __type__ FromSize(__ltype__ size)
        {
            return new __type__(__ltype__.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        public static __type__ FromMinAndSize(__ltype__ min, __ltype__ size)
        {
            return new __type__(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        public static __type__ FromCenterAndSize(__ltype__ center, __ltype__ size)
        {
            return new __type__(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        public static __type__ FromSize(ISize__dim__d iSize)
        {
            return new __type__(
                __ltype__.Zero, /*# if (ft != Meta.DoubleType) { */(__ltype__)/*# } */iSize.Size__dim__d);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        public static __type__ FromMinAndSize(__ltype__ min, ISize__dim__d iSize)
        {
            return new __type__(
                min, min + /*# if (ft != Meta.DoubleType) { */(__ltype__)/*# } */iSize.Size__dim__d);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        public static __type__ FromCenterAndSize(__ltype__ center, ISize__dim__d iSize)
        {
            var size = /*# if (ft != Meta.DoubleType) { */(__ltype__)/*# } */iSize.Size__dim__d;
            return new __type__(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        public static __type__ FromPoints(__ltype__ p0, __ltype__ p1)
        {
            return new __type__(__fun__.Min(p0, p1), __fun__.Max(p0, p1));
        }

        //# if (dim == 2) {
        public static __type__ FromSize(__ftype__ width, __ftype__ height)
        {
            return __type__.FromSize(new __ltype__(width, height));
        }

        public static __type__ FromMinAndSize(__ltype__ min, __ftype__ width, __ftype__ height)
        {
            return new __type__(min, min + new __ltype__(width, height));
        }

        public static __type__ FromMinAndSize(
            __ftype__ minX, __ftype__ minY, __ftype__ width, __ftype__ height
            )
        {
            return __type__.FromMinAndSize(new __ltype__(minX, minY), new __ltype__(width, height));
        }

        public static __type__ FromCenterAndSize(__ltype__ center, __ftype__ width, __ftype__ height)
        {
            return FromCenterAndSize(center, new __ltype__(width, height));
        }

        public static __type__ FromCenterAndSize(
            __ftype__ centerX, __ftype__ centerY, __ftype__ width, __ftype__ height
            )
        {
            return FromCenterAndSize(new __ltype__(centerX, centerY), new __ltype__(width, height));
        }

        //# }
        #endregion

        #region Transforms

        public __type__ Translated(__ltype__ shift)
        {
            return IsInvalid ? __type__.Invalid
                             : new __type__(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        public __type__ Scaled(__ltype__ factor)
        {
            return IsInvalid ? __type__.Invalid
                             : new __type__(Min * factor, Max * factor);
        }

        public Box__dim__d Transformed(M__dplus1____dplus1__d trafo)
        {
            return IsInvalid ? Box__dim__d.Invalid
                             : new Box__dim__d(ComputeCorners().Map(
                                            p => trafo.TransformPos((V__dim__d)p)));
        }

        public Box__dim__d Transformed(Trafo__dim__d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        public __ltype__ Corner(int index)
        {
            return
                new __ltype__(/*# fields.ForEach((f, i) => { var bit = 1 << i; */
                        (index & __bit__) == 0 ? Min.__f__ : Max.__f__/*#}, comma);*/);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        public __ltype__[] ComputeCorners()
        {
            return new __ltype__[] {
                Min,
                //# for (int i = 1; i < (1 << dim) - 1; i++) {
                new __ltype__(/*#
                fields.ForEach((f, b) => { var bf = ((i & (1<<b)) == 0) ? "Min" : "Max";
                                          */__bf__.__f__/*# }, comma); */),
                //# }
                Max
            };
        }

        #endregion

        #region Enumerators

        //# if (dim > 0 && !ft.IsReal) {
        /// <summary>
        /// Returns all points from [Min,Max[ with X-Variable in the outer loop.
        /// </summary>
        public IEnumerable<__ltype__> EnumerateInsidePoints()
        {
            var p = new __ltype__();
            //# fields.ForEach(f => {
            for (p.__f__ = Min.__f__; p.__f__ < Max.__f__; p.__f__++)
            //# });
                yield return p;
        }

        //# }
        #endregion

        #region IBoundingBox__dim__d Members

        public Box__dim__d BoundingBox__dim__d
        {
            get { return new Box__dim__d(/*# if (ft != Meta.DoubleType) { */(V__dim__d)/*# } */Min, /*# if (ft != Meta.DoubleType) { */(V__dim__d)/*# } */Max); }
        }

        #endregion

        #region ISize__dim__d Members

        public V__dim__d Size__dim__d
        {
            get { return /*# if (ft != Meta.DoubleType) { */(V__dim__d)/*# } */Size; }
        }

        #endregion

        //# }
    }

    public static partial class BoxFun
    {
        #region Collection GetBounding__type__ Extensions

        public static __type__ GetBounding__type__(
                this __ltype__[] pointArray)
        {
            return pointArray.GetBounding__type__(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the Bounding__type__ of the first count elements
        /// of the array.
        /// </summary>
        public static __type__ GetBounding__type__(
                this __ltype__[] pointArray, long count)
        {
            if (count <= 0) return __type__.Invalid;
            var box = new __type__(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the Bounding__type__ of count elements
        /// of the array starting at start
        /// </summary>
        public static __type__ GetBounding__type__(
                this __ltype__[] pointArray, long start, long count)
        {
            if (count <= 0) return __type__.Invalid;
            var box = new __type__(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the Bounding__type__ of count elements
        /// of the array starting at start
        /// </summary>
        public static __type__ GetBounding__type__<T>(
                this T[] array, long start, long count, Func<T, __ltype__> pointSelector)
        {
            if (count <= 0) return __type__.Invalid;
            var box = new __type__(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static __type__ GetBounding__type__(
                this List<__ltype__> pointList)
        {
            return pointList.GetBounding__type__(pointList.Count);
        }

        /// <summary>
        /// Returns the Bounding__type__ of the first count elements
        /// of the list.
        /// </summary>
        public static __type__ GetBounding__type__(
                this List<__ltype__> pointList, int count)
        {
            if (count <= 0) return __type__.Invalid;
            var box = new __type__(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        //# foreach (var itype in new[] { "int", "long" }) {
        //#     var getlength = itype == "int" ? "Length" : "LongLength";
        public static __type__ GetBounding__type__(
                this __itype__[] indexArray, __ltype__[] pointArray)
        {
            return indexArray.GetBounding__type__(indexArray.__getlength__, pointArray);
        }

        public static __type__ GetBounding__type__(
                this __itype__[] indexArray, __itype__ count,
                __ltype__[] pointArray)
        {
            if (count <= 0) return __type__.Invalid;
            var box = new __type__(pointArray[indexArray[0]]);
            for (__itype__ i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static __type__ GetBounding__type__(
                this __itype__[] indexArray, __itype__ start, __itype__ count,
                __ltype__[] pointArray)
        {
            if (count <= 0) return __type__.Invalid;
            var box = new __type__(pointArray[indexArray[start]]);
            for (__itype__ i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static __type__ GetBounding__type__<T>(
                this __itype__[] indexArray, __itype__ start, __itype__ count,
                T[] array, Func<T, __ltype__> pointSelector)
        {
            if (count <= 0) return __type__.Invalid;
            var box = new __type__(pointSelector(array[indexArray[start]]));
            for (__itype__ i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        //# }
        public static __type__ GetBounding__type__(
                this IEnumerable<__ltype__> points)
        {
            var box = __type__.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    //# }
}
