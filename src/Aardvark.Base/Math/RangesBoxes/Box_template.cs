using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;
using System.Xml.Serialization;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    #region Flags

    public static partial class Box
    {
        [Flags]
        public enum Flags
        {
            None = 0x00000000,

            /* ---------------------------------------------------------------
                flags that mark the faces of a box
            --------------------------------------------------------------- */
            MinX0 = 0x00000001,
            MinY0 = 0x00000002,
            MinZ0 = 0x00000004,

            MaxX0 = 0x00000008,
            MaxY0 = 0x00000010,
            MaxZ0 = 0x00000020,

            Min0 = MinX0 | MinY0 | MinZ0,
            Max0 = MaxX0 | MaxY0 | MaxZ0,

            X0 = MinX0 | MaxX0,
            Y0 = MinY0 | MaxY0,
            Z0 = MinZ0 | MaxZ0,

            All0 = Min0 | Max0,

            /* ---------------------------------------------------------------
                flags that mark the faces of a second, independent box
            --------------------------------------------------------------- */
            MinX1 = MinX0 << 6,
            MinY1 = MinY0 << 6,
            MinZ1 = MinZ0 << 6,
            MaxX1 = MaxX0 << 6,
            MaxY1 = MaxY0 << 6,
            MaxZ1 = MaxZ0 << 6,
            Min1 = Min0 << 6,
            Max1 = Max0 << 6,
            X1 = X0 << 6,
            Y1 = Y0 << 6,
            Z1 = Z0 << 6,
            All1 = All0 << 6,

            /* ---------------------------------------------------------------
                flags that operate on both face bits together
            --------------------------------------------------------------- */
            MinX = MinX0 | MinX1,
            MinY = MinY0 | MinY1,
            MinZ = MinZ0 | MinZ1,
            MaxX = MaxX0 | MaxX1,
            MaxY = MaxY0 | MaxY1,
            MaxZ = MaxZ0 | MaxZ1,
            Min = Min0 | Min1,
            Max = Max0 | Max1,
            MinXMinY = MinX | MinY,
            MinXMaxY = MinX | MaxY,
            MaxXMinY = MaxX | MinY,
            MaxXMaxY = MaxX | MaxY,
            X = X0 | X1,
            Y = Y0 | Y1,
            Z = Z0 | Z1,
            All = All0 | All1,

            /* ---------------------------------------------------------------
                flags that mark the edges of the box
            --------------------------------------------------------------- */
            Edge01 = 0x00001000,
            Edge23 = 0x00002000,
            Edge45 = 0x00004000,
            Edge67 = 0x00008000,
            Edge02 = 0x00010000,
            Edge13 = 0x00020000,
            Edge46 = 0x00040000,
            Edge57 = 0x00080000,
            Edge04 = 0x00100000,
            Edge15 = 0x00200000,
            Edge26 = 0x00400000,
            Edge37 = 0x00800000,

            /* ---------------------------------------------------------------
                flags that mark the corners of the box
            --------------------------------------------------------------- */
            Corner0 = 0x01000000,
            Corner1 = 0x02000000,
            Corner2 = 0x04000000,
            Corner3 = 0x08000000,
            Corner4 = 0x10000000,
            Corner5 = 0x20000000,
            Corner6 = 0x40000000,
            Corner7 = (int)-0x80000000,
        }
    }

    #endregion

    //# Action comma = () => Out(", ");
    //# Action add = () => Out(" + ");
    //# Action andand = () => Out(" && ");
    //# Action oror = () => Out(" || ");
    //# var fdtypes = new[] { Meta.FloatType, Meta.DoubleType };
    //# foreach (var t in Meta.RangeAndBoxTypes) {
    //#     var lt = t.LimitType; var vt = lt as Meta.VecType;
    //#     int dim = vt != null ? vt.Len : 1;
    //#     var dlt = dim > 1 ? Meta.VecTypeOf(dim, Meta.DoubleType) : Meta.DoubleType;
    //#     var ft = dim > 1 ? vt.FieldType : lt;
    //#     var vtrep = dim == 1 ? Meta.TryGetVecTypeOf(2, ft) : null;
    //#     var vtype = vtrep?.Name;
    //#     var ch = ft.Char;
    //#     int dplus1 = dim + 1;
    //#     var fields = dim > 1 ? vt.Fields : null;
    //#     var args = dim > 1 ? fields.ToLower() : null;
    //#     var ltype = lt.Name;
    //#     var dltype = dlt.Name;
    //#     var lcast = dim > 1 ? "" : ft == Meta.IntType || ft == Meta.DoubleType ? "" : "(" + ltype + ")";
    //#     var ftype = ft.Name;
    //#     var fcast = dim > 1 ? "" : ft == Meta.IntType || ft == Meta.DoubleType ? "" : "(" + ftype + ")";
    //#     var bname = dim > 1 ? "box" : "range";
    //#     var bnamecaps = dim > 1 ? "Box" : "Range";
    //#     var type = t.Name;
    //#     var ct = (ft == Meta.FloatType || ft == Meta.DoubleType) ? ft : Meta.ComputationTypeOf(ft);
    //#     var ctype = ct.Name;
    //#     var cch = ct.Char;
    //#     var iboundingbox = "IBoundingBox" + dim + ch;
    //#     var iboundingcircle = "IBoundingCircle" + dim + cch;
    //#     var iboundingsphere = "IBoundingSphere" + dim + cch;
    //#     var isize = "ISize" + dim + ch;
    //#     var minvalue = dim > 1 ? ltype + ".MinValue"
    //#                            : lt.IsReal ? "Constant<" + ltype + ">.ParseableMinValue" : ltype + ".MinValue";
    //#     var maxvalue = dim > 1 ? ltype + ".MaxValue"
    //#                            : lt.IsReal ? "Constant<" + ltype + ">.ParseableMaxValue" : ltype + ".MaxValue";
    //#     var half = (ct == Meta.DoubleType) ? "0.5" : "0.5f";
    #region __type__

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct __type__
        : IEquatable<__type__>, IRange<__ltype__, __type__>, /*# if (dim > 1) {
                */__iboundingbox__, __isize__, /*# } if (dim == 2) {
                */__iboundingcircle__, /*# } if (dim == 3) {
                */__iboundingsphere__, /*# }*/IFormattable
    {
        [DataMember]
        public __ltype__ Min;
        [DataMember]
        public __ltype__ Max;

        #region Constructors

        //# foreach (var t1 in  Meta.RangeAndBoxTypes) {
        //#     var type1 = t1.Name;
        //#     var lt1 = t1.LimitType; var vt1 = lt1 as Meta.VecType;
        //#     int dim1 = vt1 != null ? vt1.Len : 1;
        //#     if (t != t1 && dim == dim1) {
        /// <summary>
        /// Construct a __type__ from a __type1__.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(__type1__ b)
        {
            Min = (__ltype__) b.Min;
            Max = (__ltype__) b.Max;
        }

        //#     }
        //# }
        //# if (vtype != null) {
        /// <summary>
        /// Construct a __type__ from a __vtype__.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(__vtype__ v)
        {
            Min = v.X;
            Max = v.Y;
        }

        //# }
        /// <summary>
        /// Creates a __bname__ from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(__ltype__ min, __ltype__ max)
        {
            Min = min;
            Max = max;
        }

        //#if(dim > 1) {
        //#var xyz = vt.Fields;
        /// <summary>
        /// Creates a __bname__ from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(/*# xyz.ForEach(X => { */__ftype__ min__X__, /*# }); xyz.ForEach(X => { */__ftype__ max__X__/*# }, comma); */)
        {
            //# xyz.ForEach(X => {
            Min.__X__ = min__X__;
            //# });
            //# xyz.ForEach(X => {
            Max.__X__ = max__X__;
            //# });
        }

        //# }
        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(__ltype__ pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        //# for (int k = 3; k < 5; k++) {
        /// <summary>
        /// Creates a __bname__ from __k__ points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(/*# k.ForEach(i => {*/__ltype__ p__i__/*#}, comma);*/)
        {
            Min = Fun.Min(/*# k.ForEach(i => {*/p__i__/*#}, comma);*/);
            Max = Fun.Max(/*# k.ForEach(i => {*/p__i__/*#}, comma);*/);
        }

        //# }
        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(__type__ range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        //# for (int k = 2; k < 5; k++) {
        /// <summary>
        /// Create a box containing all supplied __bname__s.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(/*# k.ForEach(i => {*/__type__ b__i__/*#}, comma);*/)
        {
            Min = Fun.Min(/*# k.ForEach(i => {*/b__i__.Min/*#}, comma);*/);
            Max = Fun.Max(/*# k.ForEach(i => {*/b__i__.Max/*#}, comma);*/);
        }

        //# }
        //# if (dim > 1) {
        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(__ltype__[] points) : this((ReadOnlySpan<__ltype__>)points) { }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(ReadOnlySpan<__ltype__> points)
        {
            Min = __maxvalue__;
            Max = __minvalue__;
            if (points == null) return;
            var count = points.Length;
            for (var i = 0; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(__ltype__[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(IEnumerable<__ltype__> points)
        {
            Min = __maxvalue__;
            Max = __minvalue__;
            if (points == null) return;
            foreach (__ltype__ p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public __type__(IEnumerable<__type__> boxes)
        {
            Min = __maxvalue__;
            Max = __minvalue__;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates __bname__ from a Range1 in each direction.
        /// </summary>
        public __type__(/*# fields.ForEach(f => {*/Range1__ch__ range__f__/*# }, comma);*/)
        {
            //# fields.ForEach(f => {
            Min.__f__ = range__f__.Min;
            Max.__f__ = range__f__.Max;
            //# });
        }

        //# } // dim > 1
        //# if (dim == 1) {
        /// <summary>
        /// Creates __bname__ as the bounding range of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(__ftype__[] values)
        {
            Min = __maxvalue__;
            Max = __minvalue__;
            if (values == null) return;
            long count = values.LongLength;
            for (long i = 0; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates __bname__ as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(__ftype__[] values, long start, long count)
        {
            if (count <= 0)
            {
                Min = __maxvalue__;
                Max = __minvalue__;
            }
            else
            {
                Min = Max = values[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
            }
        }

        /// <summary>
        /// Creates __bname__ as the bounding range of given values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(IEnumerable<__ftype__> values)
        {
            Min = __maxvalue__;
            Max = __minvalue__;
            if (values == null) return;
            foreach (__ftype__ v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ FromMinAndSize(__ftype__ min, __ftype__ size)
        {
            return new __type__(min, __fcast__(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ FromCenterAndSize(__ftype__ center, __ftype__ size)
        {
            return new __type__(__fcast__(center - size / 2), __fcast__(center + size / 2));
        }

        //# }
        #endregion

        #region Conversions

        //# foreach (var t1 in  Meta.RangeAndBoxTypes) {
        //#     var type1 = t1.Name;
        //#     var lt1 = t1.LimitType; var vt1 = lt1 as Meta.VecType;
        //#     int dim1 = vt1 != null ? vt1.Len : 1;
        //#     if (t != t1 && dim == dim1) {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator __type__(__type1__ b) => new(b);

        //#     }
        //# }
        //# if (vtype != null) {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator __type__(__vtype__ v) => new(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator __vtype__(__type__ r) => new(r.Min, r.Max);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __vtype__ To__vtype__() => (__vtype__)this;

        //# }
        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static __type__ Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new(__maxvalue__, __minvalue__); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static __type__ Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new(__minvalue__, __maxvalue__); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        //# if (dim == 1) {
        public static __type__ Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new(0, 1); }
        //# } else {
        public static __type__ Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new(__ltype__.Zero, __ltype__.One); }
        //# }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public readonly bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return /*# if (dim == 1) { */Min >= Max;/*# } else { */Min.AnyGreaterOrEqual(Max);/*# } */ }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public readonly bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public readonly bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return /*# if (dim == 1) { */Min <= Max;/*# } else { */Min.AllSmallerOrEqual(Max);/*# } */ }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public readonly bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return /*# if (dim == 1) { */Min > Max;/*# } else { */Min.AnyGreater(Max)/*# if (ft.IsReal) {*/ || Min.IsNaN || Max.IsNaN/*# }*/;/*# } */ }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public readonly bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }

        //# if (dim == 2) {
        /// <summary>
        /// Same as Min.X.
        /// </summary>
        [XmlIgnore]
        public __ftype__ Left
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            readonly get { return Min.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Min.X = value; }
        }

        /// <summary>
        /// Same as Max.X.
        /// </summary>
        [XmlIgnore]
        public __ftype__ Right
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            readonly get { return Max.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.X = value; }
        }

        /// <summary>
        /// Same as Min.Y.
        /// </summary>
        [XmlIgnore]
        public __ftype__ Top
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            readonly get { return Min.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Min.Y = value; }
        }

        /// <summary>
        /// Same as Max.Y.
        /// </summary>
        [XmlIgnore]
        public __ftype__ Bottom
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            readonly get { return Max.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Y = value; }
        }
        //# } // dim = 2

        /// <summary>
        /// Calculates size of the __bname__.
        /// </summary>
        [XmlIgnore]
        public __ltype__ Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            readonly get { return __lcast__(Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = __lcast__(Min + value); }
        }

        public readonly __ltype__ Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return __lcast__((Min + Max) / 2); }
        }

        //# if (dim == 1) {
        public readonly IEnumerable<__ltype__> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        //# } // dim == 1
        //# if (dim > 1) {
        //# fields.ForEach(f => {
        [XmlIgnore]
        public __ftype__ Size__f__
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            readonly get { return Max.__f__ - Min.__f__; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.__f__ = Min.__f__ + value; }
        }

        public readonly Range1__ch__ Range__f__
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1__ch__(Min.__f__, Max.__f__); }
        }

        //# });
        //# if (dim == 2) {
        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public readonly int MajorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeY > SizeX ? 1 : 0; }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public readonly int MinorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeY < SizeX ? 1 : 0; }
        }

        public readonly __ftype__ Area
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeX * SizeY; }
        }

        //# } // dim == 2
        //# if (dim == 3) {
        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public readonly int MajorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                int major = 0;
                var s = Size;
                if (s.Y > s.X) major = 1;
                if (s.Z > s[major]) major = 2;
                return major;
            }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public readonly int MinorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                int minor = 0;
                var s = Size;
                if (s.Y < s.X) minor = 1;
                if (s.Z < s[minor]) minor = 2;
                return minor;
            }
        }

        public readonly __ftype__ SurfaceArea
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var s = Size;
                return (s.X * s.Y + s.X * s.Z + s.Y * s.Z) * 2;
            }
        }

        public readonly __ftype__ Volume
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) return 0;
                return SizeX * SizeY * SizeZ;
            }
        }

        //# } // dim == 3
        //# for (int di = 0; di < (1 << dim); di++) {
        //#     var pnt = dim.Range().Select(i => (di & (1 << i)) == 0 ? "O" : "I").Join();
        //#     var arg = dim.Range().Select(i => ((di & (1 << i)) == 0 ? "Min" : "Max") + "." + fields[i]).Join(", ");
        public readonly __ltype__ __pnt__ { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return /*# if (di == 0) {*/Min;/*#}
                                                    else if (di == (1 << dim) - 1) {*/Max;/*#}
                                                    else {*/new __ltype__(__arg__);/*#}*/ } }
        //# }

        //# } // dim > 1
        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return __bname__ enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ EnlargedBy(__ltype__ increment)
        {
            return new __type__(__lcast__(Min - increment), __lcast__(Max + increment));
        }

        /// <summary>
        /// Return __bname__ enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ EnlargedBy(__ltype__ deltaMin, __ltype__ deltaMax)
        {
            return new __type__(__lcast__(Min - deltaMin), __lcast__(Max + deltaMax));
        }

        /// <summary>
        /// Return __bname__ shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ ShrunkBy(__ltype__ delta)
        {
            return new __type__(__lcast__(Min + delta), __lcast__(Max - delta));
        }

        /// <summary>
        /// Return __bname__ shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ ShrunkBy(__ltype__ deltaMin, __ltype__ deltaMax)
        {
            return new __type__(__lcast__(Min + deltaMin), __lcast__(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges __bname__ by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(__ltype__ delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges __bname__ by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(__ltype__ deltaMin, __ltype__ deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks __bname__ by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(__ltype__ delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks __bname__ by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(__ltype__ deltaMin, __ltype__ deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        //# if (dim > 1) {
        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ EnlargedBy(__ftype__ delta)
        {
            return new __type__(
                    new __ltype__(/*# fields.ForEach(f => { */Min.__f__ - delta/*# }, comma);*/),
                    new __ltype__(/*# fields.ForEach(f => { */Max.__f__ + delta/*# }, comma);*/));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ ShrunkBy(__ftype__ delta)
        {
            return new __type__(
                    new __ltype__(/*# fields.ForEach(f => { */Min.__f__ + delta/*# }, comma);*/),
                    new __ltype__(/*# fields.ForEach(f => { */Max.__f__ - delta/*# }, comma);*/));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ EnlargedBy(/*# fields.ForEach(f => { */
                __ftype__ deltaMin__f__, __ftype__ deltaMax__f__/*# }, comma);*/)
        {
            return new __type__(
                    new __ltype__(/*# fields.ForEach(f => { */Min.__f__ - deltaMin__f__/*# }, comma);*/),
                    new __ltype__(/*# fields.ForEach(f => { */Max.__f__ + deltaMax__f__/*# }, comma);*/));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ ShrunkBy(/*# fields.ForEach(f => { */
                __ftype__ deltaMin__f__, __ftype__ deltaMax__f__/*# }, comma);*/)
        {
            return new __type__(
                    new __ltype__(/*# fields.ForEach(f => { */Min.__f__ + deltaMin__f__/*# }, comma);*/),
                    new __ltype__(/*# fields.ForEach(f => { */Max.__f__ - deltaMax__f__/*# }, comma);*/));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(__ftype__ delta)
        {
            //# fields.ForEach(f => {
            Min.__f__ -= delta; Max.__f__ += delta;
            //# });
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(__ftype__ delta)
        {
            //# fields.ForEach(f => {
            Min.__f__ += delta; Max.__f__ -= delta;
            //# });
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(/*# fields.ForEach(f => { */
                __ftype__ deltaMin__f__, __ftype__ deltaMax__f__/*# }, comma);*/)
        {
            //# fields.ForEach(f => {
            Min.__f__ -= deltaMin__f__; Max.__f__ += deltaMax__f__;
            //# });
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(/*# fields.ForEach(f => { */
                __ftype__ deltaMin__f__, __ftype__ deltaMax__f__/*# }, comma);*/)
        {
            //# fields.ForEach(f => {
            Min.__f__ += deltaMin__f__; Max.__f__ -= deltaMax__f__;
            //# });
        }

        //# if (ft.IsReal) {
        /// <summary>
        /// Return __bname__ scaled by the supplied factor around its center.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ ScaledFromCenterBy(__ftype__ factor)
        {
            var size = Size;
            var increment = (size * factor - size) / 2;
            return new __type__(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return __bname__ scaled by the supplied factor around its center.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ ScaledFromCenterBy(__ltype__ vectorFactor)
        {
            var size = Size;
            var increment = (size * vectorFactor - size) / 2;
            return new __type__(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return a box enlarged in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ EnlargedByRelativeEps(__ftype__ eps)
        {
            return EnlargedBy(eps * Size.Length);
        }

        /// <summary>
        /// Enlarge the box in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeByRelativeEps(__ftype__ eps)
        {
            EnlargeBy(eps * Size.Length);
        }

        //# }
        //# }
        #endregion

        #region Box Arithmetics

        //# if (dim == 1) {
        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __ltype__ Clamped(__ltype__ x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }

        //# } else { // dim > 1
        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __ltype__ Clamped(__ltype__ p)
        {
            return new __ltype__(/*# fields.ForEach(f => { */
                        p.__f__ < Min.__f__ ? Min.__f__ : (p.__f__ > Max.__f__ ? Max.__f__ : p.__f__)/*# }, comma); */);
        }

        //# if (ft.IsReal) {
        /// <summary>
        /// Returns the squared distance to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly double DistanceSquared(__ltype__ p)
        {
            return /*# fields.ForEach(f => { */
                (p.__f__ < Min.__f__ ? (Min.__f__ - p.__f__) * (Min.__f__ - p.__f__) : (p.__f__ > Max.__f__ ? (p.__f__ - Max.__f__) * (p.__f__ - Max.__f__) : 0.0))/*# }, add); */;
        }

        /// <summary>
        /// Returns the distance to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly double Distance(__ltype__ p)
        {
            return Fun.Sqrt(/*# fields.ForEach(f => { */
                (p.__f__ < Min.__f__ ? (Min.__f__ - p.__f__) * (Min.__f__ - p.__f__) : (p.__f__ > Max.__f__ ? (p.__f__ - Max.__f__) * (p.__f__ - Max.__f__) : 0.0))/*# }, add); */);
        }

        //# } // ft.IsReal
        //# } // dim > 1
        //# if (ft.IsReal) {
        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __ltype__ Lerp(__ftype__ x)
            => Fun.Lerp(x, Min, Max);

        //# if (dim == 1) {
        /// <summary>
        /// Performs the inverse of Lerp.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __ltype__ InvLerp(__ltype__ x)
            => Fun.InvLerp(x, Min, Max);

        //# } else { // dim > 1
        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __ltype__ Lerp(__ltype__ p)
            => Fun.Lerp(p, Min, Max);

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __ltype__ Lerp(/*# args.ForEach(a => { */__ftype__ __a__/*# }, comma); */)
            => Fun.Lerp(new __ltype__(/*# args.ForEach(a => { */__a__/*# }, comma); */), Min, Max);

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __ltype__ InvLerp(__ltype__ p)
            => Fun.InvLerp(p, Min, Max);

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __ltype__ InvLerp(/*# args.ForEach(a => { */__ftype__ __a__/*# }, comma); */)
            => Fun.InvLerp(new __ltype__(/*# args.ForEach(a => { */__a__/*# }, comma); */), Min, Max);

        //# } // dim > 1
        //# } // ftype == "float" || ftype == "double"
        //# else {
        //# fdtypes.ForEach(tt => {
        //# var ttype = tt.Name;
        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __ltype__ Lerp(__ttype__ t)
            => Fun.Lerp(t, Min, Max);

        //# if (dim > 1) {
        //# var vtt = Meta.VecTypeOf(dim, tt);
        //# var vttype = vtt.Name;
        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __ltype__ Lerp(__vttype__ t)
            => Fun.Lerp(t, Min, Max);

        //# } // dim > 1
        //# });
        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __dltype__ InvLerp(__ltype__ y)
            => Fun.InvLerp(y, Min, Max);

        //# } // not real

        //# if (dim > 1) {
        /// <summary>
        /// Returns the __bname__ with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ SplitRight(__ltype__ splitValue)
        {
            var result = new __type__(Min, Max);
            //# fields.ForEach(f => {
            if (splitValue.__f__ > result.Min.__f__) result.Min.__f__ = splitValue.__f__;
            //# });
            return result;
        }

        /// <summary>
        /// Returns the __bname__ with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ SplitLeft(__ltype__ splitValue)
        {
            var result = new __type__(Min, Max);
            //# fields.ForEach(f => {
            if (splitValue.__f__ < result.Max.__f__) result.Max.__f__ = splitValue.__f__;
            //# });
            return result;
        }

        //# }
        //# if (dim == 1) {
        /// <summary>
        /// Returns the __bname__ with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ SplitRight(__ftype__ splitValue)
        {
            if (splitValue > Max) return __type__.Invalid;
            if (splitValue <= Min) return this;
            return new __type__(splitValue, Max);
        }

        /// <summary>
        /// Returns the __bname__ with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ SplitLeft(__ftype__ splitValue)
        {
            if (splitValue < Min) return __type__.Invalid;
            if (splitValue >= Max) return this;
            return new __type__(Min, splitValue);
        }

        //# }
        //# if (dim == 2) {
        /// <summary>
        /// Returns the __bname__ with Min.X clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ SplitRight(__ftype__ splitAtX)
        {
            if (splitAtX > Max.X) return __type__.Invalid;
            if (splitAtX <= Min.X) return this;
            return new __type__(new __ltype__(splitAtX, Min.Y), Max);
        }

        /// <summary>
        /// Returns a __bname__ with Max.X clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ SplitLeft(__ftype__ splitAtX)
        {
            if (splitAtX < Min.X) return __type__.Invalid;
            if (splitAtX >= Max.X) return this;
            return new __type__(Min, new __ltype__(splitAtX, Max.Y));
        }

        /// <summary>
        /// Returns the __bname__ with Min.Y clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ SplitTop(__ftype__ splitAtY)
        {
            if (splitAtY > Max.Y) return __type__.Invalid;
            if (splitAtY <= Min.Y) return this;
            return new __type__(new __ltype__(Min.X, splitAtY), Max);
        }

        /// <summary>
        /// Returns the __bname__ with Max.Y clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ SplitBottom(__ftype__ splitAtY)
        {
            if (splitAtY < Min.Y) return __type__.Invalid;
            if (splitAtY >= Max.Y) return this;
            return new __type__(Min, new __ltype__(Max.X, splitAtY));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ SplitLeftBottom(__ltype__ splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y < Min.Y) return __type__.Invalid;
            return new __type__(Min, splitAt);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ SplitRightBottom(__ltype__ splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y < Min.Y) return __type__.Invalid;
            return new __type__(new __ltype__(splitAt.X, Min.Y), new __ltype__(Max.X, splitAt.Y));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ SplitLeftTop(__ltype__ splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y > Max.Y) return __type__.Invalid;
            return new __type__(new __ltype__(Min.X, splitAt.Y), new __ltype__(splitAt.X, Max.Y));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ SplitRightTop(__ltype__ splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y > Max.Y) return __type__.Invalid;
            return new __type__(splitAt, Max);
        }

        //# }
        //# if ( dim == 1) {
        /// <summary>
        /// Returns the __bname__ extended to contain the supplied __bname__.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ ExtendedBy(__type__ range)
        {
            return new __type__(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the __bname__ extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ ExtendedBy(__ftype__ value)
        {
            return new __type__(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the __bname__ to contain the supplied __bname__.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(__type__ range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the __bname__ to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(__ftype__ value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        //# }
        //# if ( dim > 1) {
        /// <summary>
        /// Returns the __bname__ extended to contain the supplied __bname__.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ ExtendedBy(__type__ b)
        {
            return new __type__(
                    new __ltype__(/*# fields.ForEach(f => {*/
                        b.Min.__f__ < Min.__f__ ? b.Min.__f__ : Min.__f__/*# }, comma); */),
                    new __ltype__(/*# fields.ForEach(f => {*/
                        b.Max.__f__ > Max.__f__ ? b.Max.__f__ : Max.__f__/*# }, comma); */));
        }

        /// <summary>
        /// Returns the __bname__ extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ ExtendedBy(__ltype__ v)
        {
            return new __type__(
                    new __ltype__(/*# fields.ForEach(f => {*/
                        v.__f__ < Min.__f__ ? v.__f__ : Min.__f__/*# }, comma); */),
                    new __ltype__(/*# fields.ForEach(f => { */
                        v.__f__ > Max.__f__ ? v.__f__ : Max.__f__/*# }, comma); */));
        }

        /// <summary>
        /// Extends the __bname__ to contain the supplied __bname__.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(__type__ box)
        {
            //# fields.ForEach(f => {
            if (box.Min.__f__ < Min.__f__) Min.__f__ = box.Min.__f__;
            if (box.Max.__f__ > Max.__f__) Max.__f__ = box.Max.__f__;
            //# });
        }

        /// <summary>
        /// Extends the __bname__ to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(__ltype__ point)
        {
            //# fields.ForEach(f => {
            if (point.__f__ < Min.__f__) Min.__f__ = point.__f__;
            if (point.__f__ > Max.__f__) Max.__f__ = point.__f__;
            //# });
        }

        //# }
        //# if (dim == 1) {
        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(__ftype__ value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(__type__ b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Intersects(__type__ range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Intersects(__type__ range, __ftype__ eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__ Repair()
        {
            if (this.Equals(__type__.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        //# }
        //# if (dim > 1) {
        //# fields.ForEach(args, (f, a) => {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__ Extend__f__By(__ftype__ __a__)
        {
            if (__a__ < Min.__f__) Min.__f__ = __a__;
            if (__a__ > Max.__f__) Max.__f__ = __a__;
            return this;
        }

        //# });
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__ ExtendDimBy(int dim, __ftype__ x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(__ltype__ p)
        {
            return/*# fields.ForEach(f => {*/
                p.__f__ >= Min.__f__ && p.__f__ <= Max.__f__/*# }, andand);*/;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Contains(__type__ b)
        {
            return/*# fields.ForEach(f => {*/
                b.Min.__f__ >= Min.__f__ && b.Max.__f__ <= Max.__f__/*# }, andand);*/;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__ Repair()
        {
            if (Equals(__type__.Invalid)) return this;
            //# fields.ForEach(f => {
            if (Min.__f__ > Max.__f__) Fun.Swap(ref Min.__f__, ref Max.__f__);
            //# });
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Intersects(__type__ box)
        {
            //# fields.ForEach(f => {
            if (Min.__f__ >= box.Max.__f__) return false;
            if (Max.__f__ <= box.Min.__f__) return false;
            //# });
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Intersects(__type__ box, __ltype__ eps)
        {
            //# fields.ForEach(f => {
            if (Min.__f__ - eps.__f__ >= box.Max.__f__) return false;
            if (Max.__f__ + eps.__f__ <= box.Min.__f__) return false;
            //# });
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Intersects(__type__ box, __ftype__ eps)
        {
            //# fields.ForEach(f => {
            if (Min.__f__ - eps >= box.Max.__f__) return false;
            if (Max.__f__ + eps <= box.Min.__f__) return false;
            //# });
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__ Invalidate()
        {
            Min = __maxvalue__;
            Max = __minvalue__;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly Box.Flags OutsideFlags(__ltype__ p0)
        {
            Box.Flags bf = Box.Flags.None;
            //# fields.ForEach(f => {
            if (p0.__f__ < Min.__f__) bf |= Box.Flags.Min__f__;
            else if (p0.__f__ > Max.__f__) bf |= Box.Flags.Max__f__;
            //# });
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly Box.Flags OutsideFlags(__type__ b)
        {
            Box.Flags bf = Box.Flags.None;
            //# fields.ForEach(f => {
            if (b.Min.__f__ < Min.__f__) bf |= Box.Flags.Min__f__;
            if (b.Max.__f__ > Max.__f__) bf |= Box.Flags.Max__f__;
            //# });
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly void GetMinMaxInDirection(__ltype__ v, out __ltype__ vMin, out __ltype__ vMax)
        {
            vMin = __minvalue__;
            vMax = __maxvalue__;
            //# fields.ForEach(f => {
            if (v.__f__ >= 0)
            {
                vMin.__f__ = Min.__f__;
                vMax.__f__ = Max.__f__;
            }
            else
            {
                vMin.__f__ = Max.__f__;
                vMax.__f__ = Min.__f__;
            }
            //# });
        }

        //# }
        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(__type__ a, __type__ b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(__type__ a, __type__ b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a __bname__ shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ operator +(__type__ box, __ltype__ v)
        {
            return new __type__(__lcast__(box.Min + v), __lcast__(box.Max + v));
        }

        /// <summary>
        /// Returns a __bname__ shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ operator -(__type__ box, __ltype__ v)
        {
            return new __type__(__lcast__(box.Min - v), __lcast__(box.Max - v));
        }

        #endregion

        #region Overrides

        public override readonly int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool Equals(__type__ other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override readonly bool Equals(object obj) =>
            (obj is Range1sb o) && Equals(o);

        public override readonly string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public readonly string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<__type__, int, __ltype__> Setter =
            (ref __type__ box, int i, __ltype__ value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static __type__ Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            //# if (dim > 1) {
            return new __type__(__ltype__.Parse(x[0].ToString()),
                                __ltype__.Parse(x[1].ToString()));
            //# } else {
            return new __type__(__ftype__.Parse(x[0], CultureInfo.InvariantCulture),
                                __ftype__.Parse(x[1], CultureInfo.InvariantCulture));
            //# }
        }

        public static __type__ Parse(Text t)
        {
            //# if (dim > 1) {
            return t.NestedBracketSplit(1, __ltype__.Parse, __type__.Setter);
            //# } else {
            return t.NestedBracketSplit(1, Text<__ltype__>.Parse, __type__.Setter);
            //# }
        }

        #endregion

        #region IFormattable Members

        public readonly string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]"/*# if (dim > 1) {*/, "[", ", ", "]"/*# }*/);
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        //# var begin = "begin" + ((dim > 1) ? "B" : "");
        //# var between = "between" + ((dim > 1) ? "B" : "");
        //# var end = "end" + ((dim > 1) ? "B" : "");
        public readonly string ToString(string format, IFormatProvider fp, string __begin__, string __between__, string __end__/*# if (dim > 1) {*/, string beginV, string betweenV, string endV/*# }*/)
        {
            //# var format = "format, fp" + (dim > 1 ? ", beginV, betweenV, endV" : "");
            fp ??= CultureInfo.InvariantCulture;
            return __begin__ + Min.ToString(__format__) + __between__ + Max.ToString(__format__) + __end__;
        }

        #endregion
        //# if (dim > 1) {

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ FromSize(__ltype__ size)
        {
            return new __type__(__ltype__.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ FromMinAndSize(__ltype__ min, __ltype__ size)
        {
            return new __type__(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ FromCenterAndSize(__ltype__ center, __ltype__ size)
        {
            return new __type__(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ FromSize(ISize__dim____ch__ iSize)
        {
            return new __type__(
                __ltype__.Zero, iSize.Size__dim____ch__);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ FromMinAndSize(__ltype__ min, ISize__dim____ch__ iSize)
        {
            return new __type__(
                min, min + iSize.Size__dim____ch__);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ FromCenterAndSize(__ltype__ center, ISize__dim____ch__ iSize)
        {
            var size = iSize.Size__dim____ch__;
            return new __type__(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ FromPoints(__ltype__ p0, __ltype__ p1)
        {
            return new __type__(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        //# if (dim == 2) {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ FromSize(__ftype__ width, __ftype__ height)
        {
            return __type__.FromSize(new __ltype__(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ FromMinAndSize(__ltype__ min, __ftype__ width, __ftype__ height)
        {
            return new __type__(min, min + new __ltype__(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ FromMinAndSize(
            __ftype__ minX, __ftype__ minY, __ftype__ width, __ftype__ height
            )
        {
            return __type__.FromMinAndSize(new __ltype__(minX, minY), new __ltype__(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ FromCenterAndSize(__ltype__ center, __ftype__ width, __ftype__ height)
        {
            return FromCenterAndSize(center, new __ltype__(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ FromCenterAndSize(
            __ftype__ centerX, __ftype__ centerY, __ftype__ width, __ftype__ height
            )
        {
            return FromCenterAndSize(new __ltype__(centerX, centerY), new __ltype__(width, height));
        }

        //# }
        #endregion

        #region Transforms

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ Translated(__ltype__ shift)
        {
            return IsInvalid ? __type__.Invalid
                             : new __type__(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __type__ Scaled(__ltype__ factor)
        {
            return IsInvalid ? __type__.Invalid
                             : new __type__(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        //# {
        //# var tc = (ft == Meta.FloatType) ? "f" : "d";
        //# var tftype = (ft == Meta.FloatType) ? "float" : "double";
        public readonly Box__dim____tc__ Transformed(M__dplus1____dplus1____tc__ trafo)
        {
            if (/*# fields.ForEach((f, i) => {*/Min.__f__ > Max.__f__/*#}, oror);*/) return Box__dim____tc__.Invalid;
            var t = new V__dim____tc__(/*# fields.ForEach((f, i) => {*/trafo.M__i____dim__/*#}, comma);*/);
            var res = new Box__dim____tc__(t, t);
            __tftype__ av, bv;
            //# for (int i = 0; i < dim; i++) { var fi = vt.Fields[i];
            //# for (int j = 0; j < dim; j++) { var fj = vt.Fields[j];
            av = trafo.M__i____j__ * Min.__fj__;
            bv = trafo.M__i____j__ * Max.__fj__;
            if (av < bv) { res.Min.__fi__ += av; res.Max.__fi__ += bv; }
            else { res.Min.__fi__ += bv; res.Max.__fi__ += av; }
            //# }
            //# }
            return res;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly Box__dim____tc__ Transformed(Trafo__dim____tc__ trafo)
        {
            return Transformed(trafo.Forward);
        }
        //# }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __ltype__ Corner(int index)
        {
            return
                new __ltype__(/*# fields.ForEach((f, i) => { var bit = 1 << i; */
                        (index & __bit__) == 0 ? Min.__f__ : Max.__f__/*#}, comma);*/);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __ltype__[] ComputeCorners()
        {
            return [
                Min,
                //# for (int i = 1; i < (1 << dim) - 1; i++) {
                new(/*#
                fields.ForEach((f, b) => { var bf = ((i & (1<<b)) == 0) ? "Min" : "Max";
                                          */__bf__.__f__/*# }, comma); */),
                //# }
                Max
            ];
        }

        //# if (dim == 2) {
        // TODO: Comment and implement for dimensions other than 2.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly __ltype__[] ComputeCornersCCW()
        {
            return [
                Min,
                new(Max.X, Min.Y),
                Max,
                new(Min.X, Max.Y),
            ];
        }
        //# }

        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public readonly IEnumerable<__ltype__> Corners
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return Min;
                //# for (int i = 1; i < (1 << dim) - 1; i++) {
                yield return new __ltype__(/*#
                fields.ForEach((f, b) => { var bf = ((i & (1<<b)) == 0) ? "Min" : "Max";
                                          */__bf__.__f__/*# }, comma); */);
                //# }
                yield return Max;
            }
        }

        #endregion

        #region Swizzle methods

        //# if (dim == 3) {
        // TODO: Implement for other dimensions
        public readonly Range1__ch__ X { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1__ch__(Min.X, Max.X); } }
        public readonly Range1__ch__ Y { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1__ch__(Min.Y, Max.Y); } }
        public readonly Range1__ch__ Z { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1__ch__(Min.Z, Max.Z); } }
        public readonly Box2__ch__ XY { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2__ch__(Min.XY, Max.XY); } }
        public readonly Box2__ch__ XZ { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2__ch__(Min.XZ, Max.XZ); } }
        public readonly Box2__ch__ YX { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2__ch__(Min.YX, Max.YX); } }
        public readonly Box2__ch__ YZ { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2__ch__(Min.YZ, Max.YZ); } }
        public readonly Box2__ch__ ZX { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2__ch__(Min.ZX, Max.ZX); } }
        public readonly Box2__ch__ ZY { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2__ch__(Min.ZY, Max.ZY); } }
        //# }

        #endregion

        #region Enumerators

        //# if (dim > 0 && !ft.IsReal) {
        /// <summary>
        /// Returns all points from [Min,Max[ with X-Variable in the outer loop.
        /// </summary>
        public readonly IEnumerable<__ltype__> EnumerateInsidePoints()
        {
            var p = new __ltype__();
            //# fields.ForEach(f => {
            for (p.__f__ = Min.__f__; p.__f__ < Max.__f__; p.__f__++)
            //# });
                yield return p;
        }

        //# }
        #endregion

        #region IBoundingBox__dim____ch__ Members

        public readonly Box__dim____ch__ BoundingBox__dim____ch__
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this; }
        }

        #endregion
        //# if (dim == 2) {

        #region IBoundingCircle__dim____cch__ Members

        public readonly Circle__dim____cch__ BoundingCircle__dim____cch__
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => IsInvalid ? Circle__dim____cch__.Invalid : new Circle__dim____cch__(/*# if (ft != ct) {*/(V__dim____cch__)/*# }*/Center, __half__ * Size.Length);
        }

        #endregion
        //# }
        //# if (dim == 3) {

        #region IBoundingSphere__dim____cch__ Members

        public readonly Sphere__dim____cch__ BoundingSphere__dim____cch__
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => IsInvalid ? Sphere__dim____cch__.Invalid : new Sphere__dim____cch__(/*# if (ft != ct) {*/(V__dim____cch__)/*# }*/Center, __half__ * Size.Length);
        }

        #endregion
        //# }

        #region ISize__dim____ch__ Members

        public readonly V__dim____ch__ Size__dim____ch__
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Size; }
        }

        #endregion
        //# }
    }

    public static partial class __bnamecaps__
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ Union(this __type__ a, __type__ b)
        {
            return new __type__(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ Intersection(this __type__ a, __type__ b)
        {
            return new __type__(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }
        //# if (dim == 1) {

        /// <summary>
        /// Checks if two __bname__s intersect each other with a tolerance parameter.
        /// </summary>
        // TODO: Implement for d > 2
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Intersects(this __type__ a, __type__ b, __ftype__ eps, out __type__ result)
        {
            result = __type__.Invalid;
            if (a.Min - eps > b.Max) return false;
            else if (a.Max + eps < b.Min) return false;
            else
            {
                result = new __type__(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
                if (result.Size < eps)
                {
                    __ftype__ center = result.Center;
                    result.Min = __lcast__(center - eps);
                    result.Max = __lcast__(center + eps);
                }
                return true;
            }
        }
        //# }

        #endregion

        #region Bounding __bname__ for arrays

        /// <summary>
        /// Returns the bounding __bname__ of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ GetBounding__bnamecaps__(this __ltype__[] pointArray)
        {
            return pointArray.GetBounding__bnamecaps__(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding __bname__ of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ GetBounding__bnamecaps__(this __ltype__[] pointArray, long count)
        {
            return pointArray.GetBounding__bnamecaps__(0, count);
        }

        /// <summary>
        /// Returns the bounding __bname__ of count elements of the array starting at start.
        /// </summary>
        public static __type__ GetBounding__bnamecaps__(
                this __ltype__[] pointArray, long start, long count)
        {
            if (count <= 0) return __type__.Invalid;
            var box = new __type__(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding __bname__ of count elements of the array starting at start.
        /// </summary>
        public static __type__ GetBounding__bnamecaps__<T>(this T[] array, long start, long count, Func<T, __ltype__> pointSelector)
        {
            if (count <= 0) return __type__.Invalid;
            var box = new __type__(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding __bname__ for lists

        /// <summary>
        /// Returns the bounding __bname__ of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ GetBounding__bnamecaps__(this List<__ltype__> pointList)
        {
            return pointList.GetBounding__bnamecaps__(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding __bname__ of the first count elements of the list.
        /// </summary>
        public static __type__ GetBounding__bnamecaps__(this List<__ltype__> pointList, int count)
        {
            if (count <= 0) return __type__.Invalid;
            var box = new __type__(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding __bname__ for indexed arrays

        //# foreach (var itype in new[] { "int", "long" }) {
        //#     var getlength = itype == "int" ? "Length" : "LongLength";
        /// <summary>
        /// Returns the bounding __bname__ of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ GetBounding__bnamecaps__(this __itype__[] indexArray, __ltype__[] pointArray)
        {
            return indexArray.GetBounding__bnamecaps__(0, indexArray.__getlength__, pointArray);
        }

        /// <summary>
        /// Returns the bounding __bname__ of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ GetBounding__bnamecaps__(this __itype__[] indexArray, __itype__ count, __ltype__[] pointArray)
        {
            return indexArray.GetBounding__bnamecaps__(0, count, pointArray);
        }

        /// <summary>
        /// Returns the bounding __bname__ of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static __type__ GetBounding__bnamecaps__(this __itype__[] indexArray, __itype__ start, __itype__ count, __ltype__[] pointArray)
        {
            if (count <= 0) return __type__.Invalid;
            var box = new __type__(pointArray[indexArray[start]]);
            for (__itype__ i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding __bname__ of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static __type__ GetBounding__bnamecaps__<T>(this __itype__[] indexArray, __itype__ start, __itype__ count, T[] array, Func<T, __ltype__> pointSelector)
        {
            if (count <= 0) return __type__.Invalid;
            var box = new __type__(pointSelector(array[indexArray[start]]));
            for (__itype__ i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        //# }
        #endregion

        #region Bounding __bname__ for IEnumerable

        /// <summary>
        /// Returns the bounding __bname__ of the elements of the collection.
        /// </summary>
        public static __type__ GetBounding__bnamecaps__(this IEnumerable<__ltype__> points)
        {
            var box = __type__.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
        //# if (dim == 3) {

        #region Get octant

        /// <summary>
        /// Octant 0-7.
        /// 0th, 1st and 2nd bit encodes x-, y-, z-axis, respectively.
        /// E.g. 0 is octant [box.Min, box.Center], 7 is octant [box.Center, box.Max].
        /// </summary>
        public static __type__ GetOctant(this __type__ box, int i)
        {
            if (i < 0 || i > 7) throw new IndexOutOfRangeException();

            __ftype__ x0, x1, y0, y1, z0, z1;
            var c = box.Center;
            if ((i & 1) == 0) { x0 = box.Min.X; x1 = c.X; } else { x0 = c.X; x1 = box.Max.X; }
            if ((i & 2) == 0) { y0 = box.Min.Y; y1 = c.Y; } else { y0 = c.Y; y1 = box.Max.Y; }
            if (i < 4) { z0 = box.Min.Z; z1 = c.Z; } else { z0 = c.Z; z1 = box.Max.Z; }
            return new __type__(new __ltype__(x0, y0, z0), new __ltype__(x1, y1, z1));
        }

        #endregion

        #region Outline corners

        /// <summary>
        /// Gets outline corner indices of a box as seen from given position (in counter-clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static int[] GetOutlineCornerIndicesCCW(this __type__ box, __ltype__ fromPosition)
        {
            if (fromPosition.X < box.Min.X)
            { //-X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X -Y -Z
                        return [1, 5, 4, 6, 2, 3];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X -Y +Z
                        return [0, 1, 5, 7, 6, 2];
                    }
                    else
                    { // -X -Y  Z
                        return [1, 5, 6, 2];
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X +Y -Z
                        return [0, 4, 6, 7, 3, 1];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X +Y +Z
                        return [0, 4, 5, 7, 3, 2];
                    }
                    else
                    { // -X +Y  Z
                        return [0, 4, 7, 3];
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X  Y -Z
                        return [1, 4, 6, 3];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X  Y +Z
                        return [0, 5, 7, 2];
                    }
                    else
                    { // -X  Y  Z
                        return [0, 4, 6, 2];
                    }
                }
            }
            else if (fromPosition.X > box.Max.X)
            { // +X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X -Y -Z
                        return [0, 2, 3, 7, 5, 4];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X -Y +Z
                        return [0, 1, 3, 7, 6, 4];
                }
                    else
                    { // +X -Y  Z
                        return [0, 3, 7, 4];
            }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X +Y -Z
                        return [0, 2, 6, 7, 5, 1];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X +Y +Z
                        return [1, 3, 2, 6, 4, 5];
}
                    else
                    { // +X +Y  Z
                        return [1, 2, 6, 5];
}
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X  Y -Z
                        return [0, 2, 7, 5];
    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X  Y +Z
                        return [1, 3, 6, 4];
}
                    else
                    { // +X  Y  Z
                        return [1, 3, 7, 5];
}
                }
            }
            else
            { // X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X -Y -Z
                        return [2, 3, 5, 4];
        }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X -Y +Z
                        return [0, 1, 7, 6];
    }
                    else
                    { //  X -Y  Z
                        return [0, 1, 5, 4];
}
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X +Y -Z
                        return [0, 6, 7, 1];
    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X +Y +Z
                        return [2, 4, 5, 3];
}
                    else
                    { //  X +Y  Z
                        return [2, 6, 7, 3];
}
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X  Y -Z
                        return [0, 2, 3, 1];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X  Y +Z
                        return [4, 5, 7, 6];
                    }
                    else
                    { //  X  Y  Z
                        return null;
                    }
                }
            }
        }

        /// <summary>
        /// Gets outline corner indices of a box as seen from given position (in clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static int[] GetOutlineCornerIndicesCW(this __type__ box, __ltype__ fromPosition)
        {
            if (fromPosition.X < box.Min.X)
            { //-X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X -Y -Z
                        return [1, 3, 2, 6, 4, 5];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X -Y +Z
                        return [0, 2, 6, 7, 5, 1];
                    }
                    else
                    { // -X -Y  Z
                        return [1, 2, 6, 5];
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X +Y -Z
                        return [0, 1, 3, 7, 6, 4];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X +Y +Z
                        return [0, 2, 3, 7, 5, 4];
                    }
                    else
                    { // -X +Y  Z
                        return [0, 3, 7, 4];
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X  Y -Z
                        return [1, 3, 6, 4];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X  Y +Z
                        return [0, 2, 7, 5];
                    }
                    else
                    { // -X  Y  Z
                        return [0, 2, 6, 4];
                    }
                }
            }
            else if (fromPosition.X > box.Max.X)
            { // +X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X -Y -Z
                        return [0, 4, 5, 7, 3, 2];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X -Y +Z
                        return [0, 4, 6, 7, 3, 1];
                    }
                    else
                    { // +X -Y  Z
                        return [0, 4, 7, 3];
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X +Y -Z
                        return [0, 1, 5, 7, 6, 2];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X +Y +Z
                        return [1, 5, 4, 6, 2, 3];
                    }
                    else
                    { // +X +Y  Z
                        return [1, 5, 6, 2];
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X  Y -Z
                        return [0, 5, 7, 2];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X  Y +Z
                        return [1, 4, 6, 3];
                    }
                    else
                    { // +X  Y  Z
                        return [1, 5, 7, 3];
                    }
                }
            }
            else
            { // X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X -Y -Z
                        return [2, 4, 5, 3];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X -Y +Z
                        return [0, 6, 7, 1];
                    }
                    else
                    { //  X -Y  Z
                        return [0, 4, 5, 1];
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X +Y -Z
                        return [0, 1, 7, 6];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X +Y +Z
                        return [2, 3, 5, 4];
                    }
                    else
                    { //  X +Y  Z
                        return [2, 3, 7, 6];
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X  Y -Z
                        return [0, 1, 3, 2];
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X  Y +Z
                        return [4, 6, 7, 5];
                    }
                    else
                    { //  X  Y  Z
                        return null;
                    }
                }
            }
        }

        /// <summary>
        /// Gets outline corners of a box as seen from given position (in counter-clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static __ltype__[] GetOutlineCornersCCW(this __type__ box, __ltype__ fromPosition)
        {
            var cs = box.ComputeCorners();
            return GetOutlineCornerIndicesCCW(box, fromPosition)?.Map(i => cs[i]);
        }

        /// <summary>
        /// Gets outline corners of a box as seen from given position (in clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static __ltype__[] GetOutlineCornersCW(this __type__ box, __ltype__ fromPosition)
        {
            var cs = box.ComputeCorners();
            return GetOutlineCornerIndicesCW(box, fromPosition)?.Map(i => cs[i]);
        }

        #endregion
        //# }
    }
    //# if (dim == 1) {

    #region Range extensions

    //# if (ft.IsReal) {
    public static partial class Conversion
    {
        #region Angles (Radians, Degrees, Gons)

        //# var units = new[] { "Radians", "Degrees", "Gons" };
        //# units.ForEach(u1 => {
        //# units.ForEach(u2 => { if (u1 == u2) return;
        //# var n1 = u1.ToLower();
        //# var n2 = u2.ToLower();
        /// <summary>
        /// Converts the angles given in __n2__ to __n1__.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ __u1__From__u2__(this __type__ __n2__)
            => new(__n2__.Min.__u1__From__u2__(), __n2__.Max.__u1__From__u2__());

        //# }); });
        #endregion
    }

    //# }
    public static partial class __bnamecaps__Extensions
    {
        /// <summary>
        /// Returns the int sequence 0 ... count-1.
        /// </summary>
        public static IEnumerable<__ltype__> Range(this __ltype__ count)
        {
            for (__ltype__ i = 0; i < count; i++) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<__ltype__> UpTo(this __ltype__ self, __ltype__ upToInclusive)
        {
            return self.UpTo(upToInclusive, 1);
        }

        public static IEnumerable<__ltype__> UpTo(this __ltype__ self, __ltype__ upToInclusive, __ltype__ step)
        {
            for (__ltype__ i = self; i <= upToInclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<__ltype__> UpToExclusive(this __ltype__ self, __ltype__ upToExclusive)
        {
            return self.UpToExclusive(upToExclusive, 1);
        }

        public static IEnumerable<__ltype__> UpToExclusive(this __ltype__ self, __ltype__ upToExclusive, __ltype__ step)
        {
            for (__ltype__ i = self; i < upToExclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<__ltype__> DownTo(this __ltype__ self, __ltype__ downToInclusive)
        {
            return self.DownTo(downToInclusive, 1);
        }

        public static IEnumerable<__ltype__> DownTo(this __ltype__ self, __ltype__ downToInclusive, __ltype__ step)
        {
            for (__ltype__ i = self; i >= downToInclusive; i -= step) yield return i;
        }
    }

    #endregion
    //# }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this __type__ a, __type__ b)
        {
            return ApproximateEquals(a, b, Constant<__ftype__>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this __type__ a, __type__ b, __ftype__ tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    //# if (dim == 3) {
    #region __type__AndFlags

    [DataContract]
    public struct __type__AndFlags
    {
        [DataMember]
        public Box.Flags BFlags;
        [DataMember]
        public __type__ BBox;

        public __type__AndFlags(__type__ union, __type__ box0, __type__ box1)
        {
            BFlags = 0;
            BBox = union;
            if (box0.Min.X > union.Min.X) { BBox.Min.X = box0.Min.X; BFlags |= Box.Flags.MinX0; }
            if (box0.Min.Y > union.Min.Y) { BBox.Min.Y = box0.Min.Y; BFlags |= Box.Flags.MinY0; }
            if (box0.Min.Z > union.Min.Z) { BBox.Min.Z = box0.Min.Z; BFlags |= Box.Flags.MinZ0; }
            if (box0.Max.X < union.Max.X) { BBox.Max.X = box0.Max.X; BFlags |= Box.Flags.MaxX0; }
            if (box0.Max.Y < union.Max.Y) { BBox.Max.Y = box0.Max.Y; BFlags |= Box.Flags.MaxY0; }
            if (box0.Max.Z < union.Max.Z) { BBox.Max.Z = box0.Max.Z; BFlags |= Box.Flags.MaxZ0; }
            if (box1.Min.X > union.Min.X) { BBox.Min.X = box1.Min.X; BFlags |= Box.Flags.MinX1; }
            if (box1.Min.Y > union.Min.Y) { BBox.Min.Y = box1.Min.Y; BFlags |= Box.Flags.MinY1; }
            if (box1.Min.Z > union.Min.Z) { BBox.Min.Z = box1.Min.Z; BFlags |= Box.Flags.MinZ1; }
            if (box1.Max.X < union.Max.X) { BBox.Max.X = box1.Max.X; BFlags |= Box.Flags.MaxX1; }
            if (box1.Max.Y < union.Max.Y) { BBox.Max.Y = box1.Max.Y; BFlags |= Box.Flags.MaxY1; }
            if (box1.Max.Z < union.Max.Z) { BBox.Max.Z = box1.Max.Z; BFlags |= Box.Flags.MaxZ1; }
        }
    }

    #endregion

    //# }
    //# }
}
