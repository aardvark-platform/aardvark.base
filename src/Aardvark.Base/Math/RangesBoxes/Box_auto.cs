using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    #region Range1b

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1b
        : IRange<byte, Range1b>,  IFormattable
    {
        [DataMember]
        public byte Min;
        [DataMember]
        public byte Max;

        #region Constructors

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        public Range1b(byte min, byte max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Range1b(byte pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        public Range1b(byte p0, byte p1, byte p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        public Range1b(byte p0, byte p1, byte p2, byte p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Range1b(Range1b range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1b(Range1b b0, Range1b b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1b(Range1b b0, Range1b b1, Range1b b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1b(Range1b b0, Range1b b1, Range1b b2, Range1b b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        public Range1b(byte[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        public Range1b(byte[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        public Range1b(IEnumerable<byte> values)
        {
            Min = byte.MaxValue;
            Max = byte.MinValue;
            foreach (byte v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        public static Range1b FromMinAndSize(byte min, byte size)
        {
            return new Range1b(min, (byte)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        public static Range1b FromCenterAndSize(byte center, byte size)
        {
            return new Range1b((byte)(center - size / 2), (byte)(center + size / 2));
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Range1b Invalid
                = new Range1b(byte.MaxValue, byte.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Range1b Infinite
                = new Range1b(byte.MinValue, byte.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Range1b Unit = new Range1b(0, 1);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        public byte Size
        {
            get { return (byte)(Max - Min); }
            set { Max = (byte)(Min + value); }
        }

        public byte Center
        {
            get { return (byte)((Min + Max) / 2); }
        }

        public IEnumerable<byte> Elements
        {
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        public Range1b EnlargedBy(byte increment)
        {
            return new Range1b((byte)(Min - increment), (byte)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        public Range1b EnlargedBy(byte deltaMin, byte deltaMax)
        {
            return new Range1b((byte)(Min - deltaMin), (byte)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        public Range1b ShrunkBy(byte delta)
        {
            return new Range1b((byte)(Min + delta), (byte)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        public Range1b ShrunkBy(byte deltaMin, byte deltaMax)
        {
            return new Range1b((byte)(Min + deltaMin), (byte)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(byte delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        public void EnlargeBy(byte deltaMin, byte deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(byte delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        public void ShrinkBy(byte deltaMin, byte deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        public byte Clamped(byte x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        public Range1b SplitRight(byte splitValue)
        {
            if (splitValue > Max) return Range1b.Invalid;
            if (splitValue <= Min) return this;
            return new Range1b(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        public Range1b SplitLeft(byte splitValue)
        {
            if (splitValue < Min) return Range1b.Invalid;
            if (splitValue >= Max) return this;
            return new Range1b(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        public Range1b ExtendedBy(Range1b range)
        {
            return new Range1b(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        public Range1b ExtendedBy(byte value)
        {
            return new Range1b(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        public void ExtendBy(Range1b range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        public void ExtendBy(byte value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        public bool Contains(byte value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        public bool Contains(Range1b b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        public bool Intersects(Range1b range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Range1b range, byte eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        public Range1b Repair()
        {
            if (this.Equals(Range1b.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Range1b a, Range1b b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Range1b a, Range1b b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        public static Range1b operator +(Range1b box, byte v)
        {
            return new Range1b((byte)(box.Min + v), (byte)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        public static Range1b operator -(Range1b box, byte v)
        {
            return new Range1b((byte)(box.Min - v), (byte)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Range1b) ? this == (Range1b)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1b, int, byte> Setter =
            (ref Range1b box, int i, byte value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1b Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1b(byte.Parse(x[0], CultureInfo.InvariantCulture),
                                byte.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1b Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<byte>.Parse, Range1b.Setter);
        }

        #endregion

        #region Various

        public static Range1b Union(Range1b a, Range1b b)
        {
            return new Range1b(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Range1b Intersection(Range1b a, Range1b b)
        {
            return new Range1b(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Range1b Union(Range1b b)
        {
            return Union(this, b);
        }

        public Range1b Intersection(Range1b b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingRange1b Extensions

        public static Range1b GetBoundingRange1b(
                this byte[] pointArray)
        {
            return pointArray.GetBoundingRange1b(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingRange1b of the first count elements
        /// of the array.
        /// </summary>
        public static Range1b GetBoundingRange1b(
                this byte[] pointArray, long count)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1b of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1b GetBoundingRange1b(
                this byte[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1b of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1b GetBoundingRange1b<T>(
                this T[] array, long start, long count, Func<T, byte> pointSelector)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Range1b GetBoundingRange1b(
                this List<byte> pointList)
        {
            return pointList.GetBoundingRange1b(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingRange1b of the first count elements
        /// of the list.
        /// </summary>
        public static Range1b GetBoundingRange1b(
                this List<byte> pointList, int count)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Range1b GetBoundingRange1b(
                this int[] indexArray, byte[] pointArray)
        {
            return indexArray.GetBoundingRange1b(indexArray.Length, pointArray);
        }

        public static Range1b GetBoundingRange1b(
                this int[] indexArray, int count,
                byte[] pointArray)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1b GetBoundingRange1b(
                this int[] indexArray, int start, int count,
                byte[] pointArray)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1b GetBoundingRange1b<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, byte> pointSelector)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1b GetBoundingRange1b(
                this long[] indexArray, byte[] pointArray)
        {
            return indexArray.GetBoundingRange1b(indexArray.LongLength, pointArray);
        }

        public static Range1b GetBoundingRange1b(
                this long[] indexArray, long count,
                byte[] pointArray)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1b GetBoundingRange1b(
                this long[] indexArray, long start, long count,
                byte[] pointArray)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1b GetBoundingRange1b<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, byte> pointSelector)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1b GetBoundingRange1b(
                this IEnumerable<byte> points)
        {
            var box = Range1b.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Range1sb

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1sb
        : IRange<sbyte, Range1sb>,  IFormattable
    {
        [DataMember]
        public sbyte Min;
        [DataMember]
        public sbyte Max;

        #region Constructors

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        public Range1sb(sbyte min, sbyte max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Range1sb(sbyte pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        public Range1sb(sbyte p0, sbyte p1, sbyte p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        public Range1sb(sbyte p0, sbyte p1, sbyte p2, sbyte p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Range1sb(Range1sb range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1sb(Range1sb b0, Range1sb b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1sb(Range1sb b0, Range1sb b1, Range1sb b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1sb(Range1sb b0, Range1sb b1, Range1sb b2, Range1sb b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        public Range1sb(sbyte[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        public Range1sb(sbyte[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        public Range1sb(IEnumerable<sbyte> values)
        {
            Min = sbyte.MaxValue;
            Max = sbyte.MinValue;
            foreach (sbyte v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        public static Range1sb FromMinAndSize(sbyte min, sbyte size)
        {
            return new Range1sb(min, (sbyte)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        public static Range1sb FromCenterAndSize(sbyte center, sbyte size)
        {
            return new Range1sb((sbyte)(center - size / 2), (sbyte)(center + size / 2));
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Range1sb Invalid
                = new Range1sb(sbyte.MaxValue, sbyte.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Range1sb Infinite
                = new Range1sb(sbyte.MinValue, sbyte.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Range1sb Unit = new Range1sb(0, 1);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        public sbyte Size
        {
            get { return (sbyte)(Max - Min); }
            set { Max = (sbyte)(Min + value); }
        }

        public sbyte Center
        {
            get { return (sbyte)((Min + Max) / 2); }
        }

        public IEnumerable<sbyte> Elements
        {
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        public Range1sb EnlargedBy(sbyte increment)
        {
            return new Range1sb((sbyte)(Min - increment), (sbyte)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        public Range1sb EnlargedBy(sbyte deltaMin, sbyte deltaMax)
        {
            return new Range1sb((sbyte)(Min - deltaMin), (sbyte)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        public Range1sb ShrunkBy(sbyte delta)
        {
            return new Range1sb((sbyte)(Min + delta), (sbyte)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        public Range1sb ShrunkBy(sbyte deltaMin, sbyte deltaMax)
        {
            return new Range1sb((sbyte)(Min + deltaMin), (sbyte)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(sbyte delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        public void EnlargeBy(sbyte deltaMin, sbyte deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(sbyte delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        public void ShrinkBy(sbyte deltaMin, sbyte deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        public sbyte Clamped(sbyte x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        public Range1sb SplitRight(sbyte splitValue)
        {
            if (splitValue > Max) return Range1sb.Invalid;
            if (splitValue <= Min) return this;
            return new Range1sb(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        public Range1sb SplitLeft(sbyte splitValue)
        {
            if (splitValue < Min) return Range1sb.Invalid;
            if (splitValue >= Max) return this;
            return new Range1sb(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        public Range1sb ExtendedBy(Range1sb range)
        {
            return new Range1sb(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        public Range1sb ExtendedBy(sbyte value)
        {
            return new Range1sb(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        public void ExtendBy(Range1sb range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        public void ExtendBy(sbyte value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        public bool Contains(sbyte value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        public bool Contains(Range1sb b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        public bool Intersects(Range1sb range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Range1sb range, sbyte eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        public Range1sb Repair()
        {
            if (this.Equals(Range1sb.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Range1sb a, Range1sb b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Range1sb a, Range1sb b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        public static Range1sb operator +(Range1sb box, sbyte v)
        {
            return new Range1sb((sbyte)(box.Min + v), (sbyte)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        public static Range1sb operator -(Range1sb box, sbyte v)
        {
            return new Range1sb((sbyte)(box.Min - v), (sbyte)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Range1sb) ? this == (Range1sb)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1sb, int, sbyte> Setter =
            (ref Range1sb box, int i, sbyte value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1sb Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1sb(sbyte.Parse(x[0], CultureInfo.InvariantCulture),
                                sbyte.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1sb Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<sbyte>.Parse, Range1sb.Setter);
        }

        #endregion

        #region Various

        public static Range1sb Union(Range1sb a, Range1sb b)
        {
            return new Range1sb(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Range1sb Intersection(Range1sb a, Range1sb b)
        {
            return new Range1sb(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Range1sb Union(Range1sb b)
        {
            return Union(this, b);
        }

        public Range1sb Intersection(Range1sb b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingRange1sb Extensions

        public static Range1sb GetBoundingRange1sb(
                this sbyte[] pointArray)
        {
            return pointArray.GetBoundingRange1sb(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingRange1sb of the first count elements
        /// of the array.
        /// </summary>
        public static Range1sb GetBoundingRange1sb(
                this sbyte[] pointArray, long count)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1sb of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1sb GetBoundingRange1sb(
                this sbyte[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1sb of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1sb GetBoundingRange1sb<T>(
                this T[] array, long start, long count, Func<T, sbyte> pointSelector)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Range1sb GetBoundingRange1sb(
                this List<sbyte> pointList)
        {
            return pointList.GetBoundingRange1sb(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingRange1sb of the first count elements
        /// of the list.
        /// </summary>
        public static Range1sb GetBoundingRange1sb(
                this List<sbyte> pointList, int count)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Range1sb GetBoundingRange1sb(
                this int[] indexArray, sbyte[] pointArray)
        {
            return indexArray.GetBoundingRange1sb(indexArray.Length, pointArray);
        }

        public static Range1sb GetBoundingRange1sb(
                this int[] indexArray, int count,
                sbyte[] pointArray)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1sb GetBoundingRange1sb(
                this int[] indexArray, int start, int count,
                sbyte[] pointArray)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1sb GetBoundingRange1sb<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, sbyte> pointSelector)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1sb GetBoundingRange1sb(
                this long[] indexArray, sbyte[] pointArray)
        {
            return indexArray.GetBoundingRange1sb(indexArray.LongLength, pointArray);
        }

        public static Range1sb GetBoundingRange1sb(
                this long[] indexArray, long count,
                sbyte[] pointArray)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1sb GetBoundingRange1sb(
                this long[] indexArray, long start, long count,
                sbyte[] pointArray)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1sb GetBoundingRange1sb<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, sbyte> pointSelector)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1sb GetBoundingRange1sb(
                this IEnumerable<sbyte> points)
        {
            var box = Range1sb.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Range1s

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1s
        : IRange<short, Range1s>,  IFormattable
    {
        [DataMember]
        public short Min;
        [DataMember]
        public short Max;

        #region Constructors

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        public Range1s(short min, short max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Range1s(short pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        public Range1s(short p0, short p1, short p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        public Range1s(short p0, short p1, short p2, short p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Range1s(Range1s range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1s(Range1s b0, Range1s b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1s(Range1s b0, Range1s b1, Range1s b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1s(Range1s b0, Range1s b1, Range1s b2, Range1s b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        public Range1s(short[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        public Range1s(short[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        public Range1s(IEnumerable<short> values)
        {
            Min = short.MaxValue;
            Max = short.MinValue;
            foreach (short v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        public static Range1s FromMinAndSize(short min, short size)
        {
            return new Range1s(min, (short)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        public static Range1s FromCenterAndSize(short center, short size)
        {
            return new Range1s((short)(center - size / 2), (short)(center + size / 2));
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Range1s Invalid
                = new Range1s(short.MaxValue, short.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Range1s Infinite
                = new Range1s(short.MinValue, short.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Range1s Unit = new Range1s(0, 1);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        public short Size
        {
            get { return (short)(Max - Min); }
            set { Max = (short)(Min + value); }
        }

        public short Center
        {
            get { return (short)((Min + Max) / 2); }
        }

        public IEnumerable<short> Elements
        {
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        public Range1s EnlargedBy(short increment)
        {
            return new Range1s((short)(Min - increment), (short)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        public Range1s EnlargedBy(short deltaMin, short deltaMax)
        {
            return new Range1s((short)(Min - deltaMin), (short)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        public Range1s ShrunkBy(short delta)
        {
            return new Range1s((short)(Min + delta), (short)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        public Range1s ShrunkBy(short deltaMin, short deltaMax)
        {
            return new Range1s((short)(Min + deltaMin), (short)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(short delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        public void EnlargeBy(short deltaMin, short deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(short delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        public void ShrinkBy(short deltaMin, short deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        public short Clamped(short x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        public Range1s SplitRight(short splitValue)
        {
            if (splitValue > Max) return Range1s.Invalid;
            if (splitValue <= Min) return this;
            return new Range1s(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        public Range1s SplitLeft(short splitValue)
        {
            if (splitValue < Min) return Range1s.Invalid;
            if (splitValue >= Max) return this;
            return new Range1s(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        public Range1s ExtendedBy(Range1s range)
        {
            return new Range1s(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        public Range1s ExtendedBy(short value)
        {
            return new Range1s(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        public void ExtendBy(Range1s range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        public void ExtendBy(short value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        public bool Contains(short value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        public bool Contains(Range1s b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        public bool Intersects(Range1s range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Range1s range, short eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        public Range1s Repair()
        {
            if (this.Equals(Range1s.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Range1s a, Range1s b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Range1s a, Range1s b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        public static Range1s operator +(Range1s box, short v)
        {
            return new Range1s((short)(box.Min + v), (short)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        public static Range1s operator -(Range1s box, short v)
        {
            return new Range1s((short)(box.Min - v), (short)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Range1s) ? this == (Range1s)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1s, int, short> Setter =
            (ref Range1s box, int i, short value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1s Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1s(short.Parse(x[0], CultureInfo.InvariantCulture),
                                short.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1s Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<short>.Parse, Range1s.Setter);
        }

        #endregion

        #region Various

        public static Range1s Union(Range1s a, Range1s b)
        {
            return new Range1s(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Range1s Intersection(Range1s a, Range1s b)
        {
            return new Range1s(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Range1s Union(Range1s b)
        {
            return Union(this, b);
        }

        public Range1s Intersection(Range1s b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingRange1s Extensions

        public static Range1s GetBoundingRange1s(
                this short[] pointArray)
        {
            return pointArray.GetBoundingRange1s(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingRange1s of the first count elements
        /// of the array.
        /// </summary>
        public static Range1s GetBoundingRange1s(
                this short[] pointArray, long count)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1s of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1s GetBoundingRange1s(
                this short[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1s of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1s GetBoundingRange1s<T>(
                this T[] array, long start, long count, Func<T, short> pointSelector)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Range1s GetBoundingRange1s(
                this List<short> pointList)
        {
            return pointList.GetBoundingRange1s(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingRange1s of the first count elements
        /// of the list.
        /// </summary>
        public static Range1s GetBoundingRange1s(
                this List<short> pointList, int count)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Range1s GetBoundingRange1s(
                this int[] indexArray, short[] pointArray)
        {
            return indexArray.GetBoundingRange1s(indexArray.Length, pointArray);
        }

        public static Range1s GetBoundingRange1s(
                this int[] indexArray, int count,
                short[] pointArray)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1s GetBoundingRange1s(
                this int[] indexArray, int start, int count,
                short[] pointArray)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1s GetBoundingRange1s<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, short> pointSelector)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1s GetBoundingRange1s(
                this long[] indexArray, short[] pointArray)
        {
            return indexArray.GetBoundingRange1s(indexArray.LongLength, pointArray);
        }

        public static Range1s GetBoundingRange1s(
                this long[] indexArray, long count,
                short[] pointArray)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1s GetBoundingRange1s(
                this long[] indexArray, long start, long count,
                short[] pointArray)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1s GetBoundingRange1s<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, short> pointSelector)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1s GetBoundingRange1s(
                this IEnumerable<short> points)
        {
            var box = Range1s.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Range1us

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1us
        : IRange<ushort, Range1us>,  IFormattable
    {
        [DataMember]
        public ushort Min;
        [DataMember]
        public ushort Max;

        #region Constructors

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        public Range1us(ushort min, ushort max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Range1us(ushort pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        public Range1us(ushort p0, ushort p1, ushort p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        public Range1us(ushort p0, ushort p1, ushort p2, ushort p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Range1us(Range1us range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1us(Range1us b0, Range1us b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1us(Range1us b0, Range1us b1, Range1us b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1us(Range1us b0, Range1us b1, Range1us b2, Range1us b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        public Range1us(ushort[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        public Range1us(ushort[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        public Range1us(IEnumerable<ushort> values)
        {
            Min = ushort.MaxValue;
            Max = ushort.MinValue;
            foreach (ushort v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        public static Range1us FromMinAndSize(ushort min, ushort size)
        {
            return new Range1us(min, (ushort)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        public static Range1us FromCenterAndSize(ushort center, ushort size)
        {
            return new Range1us((ushort)(center - size / 2), (ushort)(center + size / 2));
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Range1us Invalid
                = new Range1us(ushort.MaxValue, ushort.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Range1us Infinite
                = new Range1us(ushort.MinValue, ushort.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Range1us Unit = new Range1us(0, 1);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        public ushort Size
        {
            get { return (ushort)(Max - Min); }
            set { Max = (ushort)(Min + value); }
        }

        public ushort Center
        {
            get { return (ushort)((Min + Max) / 2); }
        }

        public IEnumerable<ushort> Elements
        {
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        public Range1us EnlargedBy(ushort increment)
        {
            return new Range1us((ushort)(Min - increment), (ushort)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        public Range1us EnlargedBy(ushort deltaMin, ushort deltaMax)
        {
            return new Range1us((ushort)(Min - deltaMin), (ushort)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        public Range1us ShrunkBy(ushort delta)
        {
            return new Range1us((ushort)(Min + delta), (ushort)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        public Range1us ShrunkBy(ushort deltaMin, ushort deltaMax)
        {
            return new Range1us((ushort)(Min + deltaMin), (ushort)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(ushort delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        public void EnlargeBy(ushort deltaMin, ushort deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(ushort delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        public void ShrinkBy(ushort deltaMin, ushort deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        public ushort Clamped(ushort x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        public Range1us SplitRight(ushort splitValue)
        {
            if (splitValue > Max) return Range1us.Invalid;
            if (splitValue <= Min) return this;
            return new Range1us(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        public Range1us SplitLeft(ushort splitValue)
        {
            if (splitValue < Min) return Range1us.Invalid;
            if (splitValue >= Max) return this;
            return new Range1us(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        public Range1us ExtendedBy(Range1us range)
        {
            return new Range1us(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        public Range1us ExtendedBy(ushort value)
        {
            return new Range1us(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        public void ExtendBy(Range1us range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        public void ExtendBy(ushort value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        public bool Contains(ushort value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        public bool Contains(Range1us b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        public bool Intersects(Range1us range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Range1us range, ushort eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        public Range1us Repair()
        {
            if (this.Equals(Range1us.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Range1us a, Range1us b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Range1us a, Range1us b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        public static Range1us operator +(Range1us box, ushort v)
        {
            return new Range1us((ushort)(box.Min + v), (ushort)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        public static Range1us operator -(Range1us box, ushort v)
        {
            return new Range1us((ushort)(box.Min - v), (ushort)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Range1us) ? this == (Range1us)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1us, int, ushort> Setter =
            (ref Range1us box, int i, ushort value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1us Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1us(ushort.Parse(x[0], CultureInfo.InvariantCulture),
                                ushort.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1us Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<ushort>.Parse, Range1us.Setter);
        }

        #endregion

        #region Various

        public static Range1us Union(Range1us a, Range1us b)
        {
            return new Range1us(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Range1us Intersection(Range1us a, Range1us b)
        {
            return new Range1us(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Range1us Union(Range1us b)
        {
            return Union(this, b);
        }

        public Range1us Intersection(Range1us b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingRange1us Extensions

        public static Range1us GetBoundingRange1us(
                this ushort[] pointArray)
        {
            return pointArray.GetBoundingRange1us(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingRange1us of the first count elements
        /// of the array.
        /// </summary>
        public static Range1us GetBoundingRange1us(
                this ushort[] pointArray, long count)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1us of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1us GetBoundingRange1us(
                this ushort[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1us of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1us GetBoundingRange1us<T>(
                this T[] array, long start, long count, Func<T, ushort> pointSelector)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Range1us GetBoundingRange1us(
                this List<ushort> pointList)
        {
            return pointList.GetBoundingRange1us(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingRange1us of the first count elements
        /// of the list.
        /// </summary>
        public static Range1us GetBoundingRange1us(
                this List<ushort> pointList, int count)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Range1us GetBoundingRange1us(
                this int[] indexArray, ushort[] pointArray)
        {
            return indexArray.GetBoundingRange1us(indexArray.Length, pointArray);
        }

        public static Range1us GetBoundingRange1us(
                this int[] indexArray, int count,
                ushort[] pointArray)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1us GetBoundingRange1us(
                this int[] indexArray, int start, int count,
                ushort[] pointArray)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1us GetBoundingRange1us<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, ushort> pointSelector)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1us GetBoundingRange1us(
                this long[] indexArray, ushort[] pointArray)
        {
            return indexArray.GetBoundingRange1us(indexArray.LongLength, pointArray);
        }

        public static Range1us GetBoundingRange1us(
                this long[] indexArray, long count,
                ushort[] pointArray)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1us GetBoundingRange1us(
                this long[] indexArray, long start, long count,
                ushort[] pointArray)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1us GetBoundingRange1us<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, ushort> pointSelector)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1us GetBoundingRange1us(
                this IEnumerable<ushort> points)
        {
            var box = Range1us.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Range1i

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1i
        : IRange<int, Range1i>,  IFormattable
    {
        [DataMember]
        public int Min;
        [DataMember]
        public int Max;

        #region Constructors

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        public Range1i(int min, int max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Range1i(int pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        public Range1i(int p0, int p1, int p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        public Range1i(int p0, int p1, int p2, int p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Range1i(Range1i range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1i(Range1i b0, Range1i b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1i(Range1i b0, Range1i b1, Range1i b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1i(Range1i b0, Range1i b1, Range1i b2, Range1i b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        public Range1i(int[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        public Range1i(int[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        public Range1i(IEnumerable<int> values)
        {
            Min = int.MaxValue;
            Max = int.MinValue;
            foreach (int v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        public static Range1i FromMinAndSize(int min, int size)
        {
            return new Range1i(min, (min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        public static Range1i FromCenterAndSize(int center, int size)
        {
            return new Range1i((center - size / 2), (center + size / 2));
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Range1i Invalid
                = new Range1i(int.MaxValue, int.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Range1i Infinite
                = new Range1i(int.MinValue, int.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Range1i Unit = new Range1i(0, 1);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        public int Size
        {
            get { return (Max - Min); }
            set { Max = (Min + value); }
        }

        public int Center
        {
            get { return ((Min + Max) / 2); }
        }

        public IEnumerable<int> Elements
        {
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        public Range1i EnlargedBy(int increment)
        {
            return new Range1i((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        public Range1i EnlargedBy(int deltaMin, int deltaMax)
        {
            return new Range1i((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        public Range1i ShrunkBy(int delta)
        {
            return new Range1i((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        public Range1i ShrunkBy(int deltaMin, int deltaMax)
        {
            return new Range1i((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(int delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        public void EnlargeBy(int deltaMin, int deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(int delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        public void ShrinkBy(int deltaMin, int deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        public int Clamped(int x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        public Range1i SplitRight(int splitValue)
        {
            if (splitValue > Max) return Range1i.Invalid;
            if (splitValue <= Min) return this;
            return new Range1i(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        public Range1i SplitLeft(int splitValue)
        {
            if (splitValue < Min) return Range1i.Invalid;
            if (splitValue >= Max) return this;
            return new Range1i(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        public Range1i ExtendedBy(Range1i range)
        {
            return new Range1i(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        public Range1i ExtendedBy(int value)
        {
            return new Range1i(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        public void ExtendBy(Range1i range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        public void ExtendBy(int value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        public bool Contains(int value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        public bool Contains(Range1i b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        public bool Intersects(Range1i range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Range1i range, int eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        public Range1i Repair()
        {
            if (this.Equals(Range1i.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Range1i a, Range1i b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Range1i a, Range1i b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        public static Range1i operator +(Range1i box, int v)
        {
            return new Range1i((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        public static Range1i operator -(Range1i box, int v)
        {
            return new Range1i((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Range1i) ? this == (Range1i)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1i, int, int> Setter =
            (ref Range1i box, int i, int value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1i(int.Parse(x[0], CultureInfo.InvariantCulture),
                                int.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1i Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<int>.Parse, Range1i.Setter);
        }

        #endregion

        #region Various

        public static Range1i Union(Range1i a, Range1i b)
        {
            return new Range1i(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Range1i Intersection(Range1i a, Range1i b)
        {
            return new Range1i(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Range1i Union(Range1i b)
        {
            return Union(this, b);
        }

        public Range1i Intersection(Range1i b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingRange1i Extensions

        public static Range1i GetBoundingRange1i(
                this int[] pointArray)
        {
            return pointArray.GetBoundingRange1i(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingRange1i of the first count elements
        /// of the array.
        /// </summary>
        public static Range1i GetBoundingRange1i(
                this int[] pointArray, long count)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1i of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1i GetBoundingRange1i(
                this int[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1i of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1i GetBoundingRange1i<T>(
                this T[] array, long start, long count, Func<T, int> pointSelector)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Range1i GetBoundingRange1i(
                this List<int> pointList)
        {
            return pointList.GetBoundingRange1i(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingRange1i of the first count elements
        /// of the list.
        /// </summary>
        public static Range1i GetBoundingRange1i(
                this List<int> pointList, int count)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Range1i GetBoundingRange1i(
                this int[] indexArray, int[] pointArray)
        {
            return indexArray.GetBoundingRange1i(indexArray.Length, pointArray);
        }

        public static Range1i GetBoundingRange1i(
                this int[] indexArray, int count,
                int[] pointArray)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1i GetBoundingRange1i(
                this int[] indexArray, int start, int count,
                int[] pointArray)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1i GetBoundingRange1i<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, int> pointSelector)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1i GetBoundingRange1i(
                this long[] indexArray, int[] pointArray)
        {
            return indexArray.GetBoundingRange1i(indexArray.LongLength, pointArray);
        }

        public static Range1i GetBoundingRange1i(
                this long[] indexArray, long count,
                int[] pointArray)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1i GetBoundingRange1i(
                this long[] indexArray, long start, long count,
                int[] pointArray)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1i GetBoundingRange1i<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, int> pointSelector)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1i GetBoundingRange1i(
                this IEnumerable<int> points)
        {
            var box = Range1i.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Range1ui

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1ui
        : IRange<uint, Range1ui>,  IFormattable
    {
        [DataMember]
        public uint Min;
        [DataMember]
        public uint Max;

        #region Constructors

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        public Range1ui(uint min, uint max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Range1ui(uint pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        public Range1ui(uint p0, uint p1, uint p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        public Range1ui(uint p0, uint p1, uint p2, uint p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Range1ui(Range1ui range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1ui(Range1ui b0, Range1ui b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1ui(Range1ui b0, Range1ui b1, Range1ui b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1ui(Range1ui b0, Range1ui b1, Range1ui b2, Range1ui b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        public Range1ui(uint[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        public Range1ui(uint[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        public Range1ui(IEnumerable<uint> values)
        {
            Min = uint.MaxValue;
            Max = uint.MinValue;
            foreach (uint v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        public static Range1ui FromMinAndSize(uint min, uint size)
        {
            return new Range1ui(min, (uint)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        public static Range1ui FromCenterAndSize(uint center, uint size)
        {
            return new Range1ui((uint)(center - size / 2), (uint)(center + size / 2));
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Range1ui Invalid
                = new Range1ui(uint.MaxValue, uint.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Range1ui Infinite
                = new Range1ui(uint.MinValue, uint.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Range1ui Unit = new Range1ui(0, 1);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        public uint Size
        {
            get { return (uint)(Max - Min); }
            set { Max = (uint)(Min + value); }
        }

        public uint Center
        {
            get { return (uint)((Min + Max) / 2); }
        }

        public IEnumerable<uint> Elements
        {
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        public Range1ui EnlargedBy(uint increment)
        {
            return new Range1ui((uint)(Min - increment), (uint)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        public Range1ui EnlargedBy(uint deltaMin, uint deltaMax)
        {
            return new Range1ui((uint)(Min - deltaMin), (uint)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        public Range1ui ShrunkBy(uint delta)
        {
            return new Range1ui((uint)(Min + delta), (uint)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        public Range1ui ShrunkBy(uint deltaMin, uint deltaMax)
        {
            return new Range1ui((uint)(Min + deltaMin), (uint)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(uint delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        public void EnlargeBy(uint deltaMin, uint deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(uint delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        public void ShrinkBy(uint deltaMin, uint deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        public uint Clamped(uint x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        public Range1ui SplitRight(uint splitValue)
        {
            if (splitValue > Max) return Range1ui.Invalid;
            if (splitValue <= Min) return this;
            return new Range1ui(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        public Range1ui SplitLeft(uint splitValue)
        {
            if (splitValue < Min) return Range1ui.Invalid;
            if (splitValue >= Max) return this;
            return new Range1ui(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        public Range1ui ExtendedBy(Range1ui range)
        {
            return new Range1ui(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        public Range1ui ExtendedBy(uint value)
        {
            return new Range1ui(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        public void ExtendBy(Range1ui range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        public void ExtendBy(uint value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        public bool Contains(uint value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        public bool Contains(Range1ui b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        public bool Intersects(Range1ui range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Range1ui range, uint eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        public Range1ui Repair()
        {
            if (this.Equals(Range1ui.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Range1ui a, Range1ui b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Range1ui a, Range1ui b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        public static Range1ui operator +(Range1ui box, uint v)
        {
            return new Range1ui((uint)(box.Min + v), (uint)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        public static Range1ui operator -(Range1ui box, uint v)
        {
            return new Range1ui((uint)(box.Min - v), (uint)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Range1ui) ? this == (Range1ui)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1ui, int, uint> Setter =
            (ref Range1ui box, int i, uint value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1ui Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1ui(uint.Parse(x[0], CultureInfo.InvariantCulture),
                                uint.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1ui Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<uint>.Parse, Range1ui.Setter);
        }

        #endregion

        #region Various

        public static Range1ui Union(Range1ui a, Range1ui b)
        {
            return new Range1ui(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Range1ui Intersection(Range1ui a, Range1ui b)
        {
            return new Range1ui(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Range1ui Union(Range1ui b)
        {
            return Union(this, b);
        }

        public Range1ui Intersection(Range1ui b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingRange1ui Extensions

        public static Range1ui GetBoundingRange1ui(
                this uint[] pointArray)
        {
            return pointArray.GetBoundingRange1ui(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingRange1ui of the first count elements
        /// of the array.
        /// </summary>
        public static Range1ui GetBoundingRange1ui(
                this uint[] pointArray, long count)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1ui of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1ui GetBoundingRange1ui(
                this uint[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1ui of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1ui GetBoundingRange1ui<T>(
                this T[] array, long start, long count, Func<T, uint> pointSelector)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Range1ui GetBoundingRange1ui(
                this List<uint> pointList)
        {
            return pointList.GetBoundingRange1ui(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingRange1ui of the first count elements
        /// of the list.
        /// </summary>
        public static Range1ui GetBoundingRange1ui(
                this List<uint> pointList, int count)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Range1ui GetBoundingRange1ui(
                this int[] indexArray, uint[] pointArray)
        {
            return indexArray.GetBoundingRange1ui(indexArray.Length, pointArray);
        }

        public static Range1ui GetBoundingRange1ui(
                this int[] indexArray, int count,
                uint[] pointArray)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1ui GetBoundingRange1ui(
                this int[] indexArray, int start, int count,
                uint[] pointArray)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1ui GetBoundingRange1ui<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, uint> pointSelector)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1ui GetBoundingRange1ui(
                this long[] indexArray, uint[] pointArray)
        {
            return indexArray.GetBoundingRange1ui(indexArray.LongLength, pointArray);
        }

        public static Range1ui GetBoundingRange1ui(
                this long[] indexArray, long count,
                uint[] pointArray)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1ui GetBoundingRange1ui(
                this long[] indexArray, long start, long count,
                uint[] pointArray)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1ui GetBoundingRange1ui<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, uint> pointSelector)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1ui GetBoundingRange1ui(
                this IEnumerable<uint> points)
        {
            var box = Range1ui.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Range1l

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1l
        : IRange<long, Range1l>,  IFormattable
    {
        [DataMember]
        public long Min;
        [DataMember]
        public long Max;

        #region Constructors

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        public Range1l(long min, long max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Range1l(long pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        public Range1l(long p0, long p1, long p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        public Range1l(long p0, long p1, long p2, long p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Range1l(Range1l range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1l(Range1l b0, Range1l b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1l(Range1l b0, Range1l b1, Range1l b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1l(Range1l b0, Range1l b1, Range1l b2, Range1l b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        public Range1l(long[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        public Range1l(long[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        public Range1l(IEnumerable<long> values)
        {
            Min = long.MaxValue;
            Max = long.MinValue;
            foreach (long v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        public static Range1l FromMinAndSize(long min, long size)
        {
            return new Range1l(min, (long)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        public static Range1l FromCenterAndSize(long center, long size)
        {
            return new Range1l((long)(center - size / 2), (long)(center + size / 2));
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Range1l Invalid
                = new Range1l(long.MaxValue, long.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Range1l Infinite
                = new Range1l(long.MinValue, long.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Range1l Unit = new Range1l(0, 1);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        public long Size
        {
            get { return (long)(Max - Min); }
            set { Max = (long)(Min + value); }
        }

        public long Center
        {
            get { return (long)((Min + Max) / 2); }
        }

        public IEnumerable<long> Elements
        {
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        public Range1l EnlargedBy(long increment)
        {
            return new Range1l((long)(Min - increment), (long)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        public Range1l EnlargedBy(long deltaMin, long deltaMax)
        {
            return new Range1l((long)(Min - deltaMin), (long)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        public Range1l ShrunkBy(long delta)
        {
            return new Range1l((long)(Min + delta), (long)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        public Range1l ShrunkBy(long deltaMin, long deltaMax)
        {
            return new Range1l((long)(Min + deltaMin), (long)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(long delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        public void EnlargeBy(long deltaMin, long deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(long delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        public void ShrinkBy(long deltaMin, long deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        public long Clamped(long x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        public Range1l SplitRight(long splitValue)
        {
            if (splitValue > Max) return Range1l.Invalid;
            if (splitValue <= Min) return this;
            return new Range1l(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        public Range1l SplitLeft(long splitValue)
        {
            if (splitValue < Min) return Range1l.Invalid;
            if (splitValue >= Max) return this;
            return new Range1l(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        public Range1l ExtendedBy(Range1l range)
        {
            return new Range1l(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        public Range1l ExtendedBy(long value)
        {
            return new Range1l(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        public void ExtendBy(Range1l range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        public void ExtendBy(long value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        public bool Contains(long value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        public bool Contains(Range1l b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        public bool Intersects(Range1l range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Range1l range, long eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        public Range1l Repair()
        {
            if (this.Equals(Range1l.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Range1l a, Range1l b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Range1l a, Range1l b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        public static Range1l operator +(Range1l box, long v)
        {
            return new Range1l((long)(box.Min + v), (long)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        public static Range1l operator -(Range1l box, long v)
        {
            return new Range1l((long)(box.Min - v), (long)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Range1l) ? this == (Range1l)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1l, int, long> Setter =
            (ref Range1l box, int i, long value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1l(long.Parse(x[0], CultureInfo.InvariantCulture),
                                long.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1l Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<long>.Parse, Range1l.Setter);
        }

        #endregion

        #region Various

        public static Range1l Union(Range1l a, Range1l b)
        {
            return new Range1l(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Range1l Intersection(Range1l a, Range1l b)
        {
            return new Range1l(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Range1l Union(Range1l b)
        {
            return Union(this, b);
        }

        public Range1l Intersection(Range1l b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingRange1l Extensions

        public static Range1l GetBoundingRange1l(
                this long[] pointArray)
        {
            return pointArray.GetBoundingRange1l(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingRange1l of the first count elements
        /// of the array.
        /// </summary>
        public static Range1l GetBoundingRange1l(
                this long[] pointArray, long count)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1l of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1l GetBoundingRange1l(
                this long[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1l of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1l GetBoundingRange1l<T>(
                this T[] array, long start, long count, Func<T, long> pointSelector)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Range1l GetBoundingRange1l(
                this List<long> pointList)
        {
            return pointList.GetBoundingRange1l(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingRange1l of the first count elements
        /// of the list.
        /// </summary>
        public static Range1l GetBoundingRange1l(
                this List<long> pointList, int count)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Range1l GetBoundingRange1l(
                this int[] indexArray, long[] pointArray)
        {
            return indexArray.GetBoundingRange1l(indexArray.Length, pointArray);
        }

        public static Range1l GetBoundingRange1l(
                this int[] indexArray, int count,
                long[] pointArray)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1l GetBoundingRange1l(
                this int[] indexArray, int start, int count,
                long[] pointArray)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1l GetBoundingRange1l<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, long> pointSelector)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1l GetBoundingRange1l(
                this long[] indexArray, long[] pointArray)
        {
            return indexArray.GetBoundingRange1l(indexArray.LongLength, pointArray);
        }

        public static Range1l GetBoundingRange1l(
                this long[] indexArray, long count,
                long[] pointArray)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1l GetBoundingRange1l(
                this long[] indexArray, long start, long count,
                long[] pointArray)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1l GetBoundingRange1l<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, long> pointSelector)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1l GetBoundingRange1l(
                this IEnumerable<long> points)
        {
            var box = Range1l.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Range1ul

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1ul
        : IRange<ulong, Range1ul>,  IFormattable
    {
        [DataMember]
        public ulong Min;
        [DataMember]
        public ulong Max;

        #region Constructors

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        public Range1ul(ulong min, ulong max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Range1ul(ulong pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        public Range1ul(ulong p0, ulong p1, ulong p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        public Range1ul(ulong p0, ulong p1, ulong p2, ulong p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Range1ul(Range1ul range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1ul(Range1ul b0, Range1ul b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1ul(Range1ul b0, Range1ul b1, Range1ul b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1ul(Range1ul b0, Range1ul b1, Range1ul b2, Range1ul b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        public Range1ul(ulong[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        public Range1ul(ulong[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        public Range1ul(IEnumerable<ulong> values)
        {
            Min = ulong.MaxValue;
            Max = ulong.MinValue;
            foreach (ulong v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        public static Range1ul FromMinAndSize(ulong min, ulong size)
        {
            return new Range1ul(min, (ulong)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        public static Range1ul FromCenterAndSize(ulong center, ulong size)
        {
            return new Range1ul((ulong)(center - size / 2), (ulong)(center + size / 2));
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Range1ul Invalid
                = new Range1ul(ulong.MaxValue, ulong.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Range1ul Infinite
                = new Range1ul(ulong.MinValue, ulong.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Range1ul Unit = new Range1ul(0, 1);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        public ulong Size
        {
            get { return (ulong)(Max - Min); }
            set { Max = (ulong)(Min + value); }
        }

        public ulong Center
        {
            get { return (ulong)((Min + Max) / 2); }
        }

        public IEnumerable<ulong> Elements
        {
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        public Range1ul EnlargedBy(ulong increment)
        {
            return new Range1ul((ulong)(Min - increment), (ulong)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        public Range1ul EnlargedBy(ulong deltaMin, ulong deltaMax)
        {
            return new Range1ul((ulong)(Min - deltaMin), (ulong)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        public Range1ul ShrunkBy(ulong delta)
        {
            return new Range1ul((ulong)(Min + delta), (ulong)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        public Range1ul ShrunkBy(ulong deltaMin, ulong deltaMax)
        {
            return new Range1ul((ulong)(Min + deltaMin), (ulong)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(ulong delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        public void EnlargeBy(ulong deltaMin, ulong deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(ulong delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        public void ShrinkBy(ulong deltaMin, ulong deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        public ulong Clamped(ulong x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        public Range1ul SplitRight(ulong splitValue)
        {
            if (splitValue > Max) return Range1ul.Invalid;
            if (splitValue <= Min) return this;
            return new Range1ul(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        public Range1ul SplitLeft(ulong splitValue)
        {
            if (splitValue < Min) return Range1ul.Invalid;
            if (splitValue >= Max) return this;
            return new Range1ul(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        public Range1ul ExtendedBy(Range1ul range)
        {
            return new Range1ul(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        public Range1ul ExtendedBy(ulong value)
        {
            return new Range1ul(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        public void ExtendBy(Range1ul range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        public void ExtendBy(ulong value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        public bool Contains(ulong value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        public bool Contains(Range1ul b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        public bool Intersects(Range1ul range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Range1ul range, ulong eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        public Range1ul Repair()
        {
            if (this.Equals(Range1ul.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Range1ul a, Range1ul b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Range1ul a, Range1ul b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        public static Range1ul operator +(Range1ul box, ulong v)
        {
            return new Range1ul((ulong)(box.Min + v), (ulong)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        public static Range1ul operator -(Range1ul box, ulong v)
        {
            return new Range1ul((ulong)(box.Min - v), (ulong)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Range1ul) ? this == (Range1ul)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1ul, int, ulong> Setter =
            (ref Range1ul box, int i, ulong value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1ul Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1ul(ulong.Parse(x[0], CultureInfo.InvariantCulture),
                                ulong.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1ul Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<ulong>.Parse, Range1ul.Setter);
        }

        #endregion

        #region Various

        public static Range1ul Union(Range1ul a, Range1ul b)
        {
            return new Range1ul(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Range1ul Intersection(Range1ul a, Range1ul b)
        {
            return new Range1ul(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Range1ul Union(Range1ul b)
        {
            return Union(this, b);
        }

        public Range1ul Intersection(Range1ul b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingRange1ul Extensions

        public static Range1ul GetBoundingRange1ul(
                this ulong[] pointArray)
        {
            return pointArray.GetBoundingRange1ul(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingRange1ul of the first count elements
        /// of the array.
        /// </summary>
        public static Range1ul GetBoundingRange1ul(
                this ulong[] pointArray, long count)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1ul of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1ul GetBoundingRange1ul(
                this ulong[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1ul of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1ul GetBoundingRange1ul<T>(
                this T[] array, long start, long count, Func<T, ulong> pointSelector)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Range1ul GetBoundingRange1ul(
                this List<ulong> pointList)
        {
            return pointList.GetBoundingRange1ul(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingRange1ul of the first count elements
        /// of the list.
        /// </summary>
        public static Range1ul GetBoundingRange1ul(
                this List<ulong> pointList, int count)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Range1ul GetBoundingRange1ul(
                this int[] indexArray, ulong[] pointArray)
        {
            return indexArray.GetBoundingRange1ul(indexArray.Length, pointArray);
        }

        public static Range1ul GetBoundingRange1ul(
                this int[] indexArray, int count,
                ulong[] pointArray)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1ul GetBoundingRange1ul(
                this int[] indexArray, int start, int count,
                ulong[] pointArray)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1ul GetBoundingRange1ul<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, ulong> pointSelector)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1ul GetBoundingRange1ul(
                this long[] indexArray, ulong[] pointArray)
        {
            return indexArray.GetBoundingRange1ul(indexArray.LongLength, pointArray);
        }

        public static Range1ul GetBoundingRange1ul(
                this long[] indexArray, long count,
                ulong[] pointArray)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1ul GetBoundingRange1ul(
                this long[] indexArray, long start, long count,
                ulong[] pointArray)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1ul GetBoundingRange1ul<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, ulong> pointSelector)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1ul GetBoundingRange1ul(
                this IEnumerable<ulong> points)
        {
            var box = Range1ul.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Range1f

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1f
        : IRange<float, Range1f>,  IFormattable
    {
        [DataMember]
        public float Min;
        [DataMember]
        public float Max;

        #region Constructors

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        public Range1f(float min, float max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Range1f(float pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        public Range1f(float p0, float p1, float p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        public Range1f(float p0, float p1, float p2, float p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Range1f(Range1f range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1f(Range1f b0, Range1f b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1f(Range1f b0, Range1f b1, Range1f b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1f(Range1f b0, Range1f b1, Range1f b2, Range1f b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        public Range1f(float[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        public Range1f(float[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        public Range1f(IEnumerable<float> values)
        {
            Min = Constant<float>.ParseableMaxValue;
            Max = Constant<float>.ParseableMinValue;
            foreach (float v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        public static Range1f FromMinAndSize(float min, float size)
        {
            return new Range1f(min, (float)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        public static Range1f FromCenterAndSize(float center, float size)
        {
            return new Range1f((float)(center - size / 2), (float)(center + size / 2));
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Range1f Invalid
                = new Range1f(Constant<float>.ParseableMaxValue, Constant<float>.ParseableMinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Range1f Infinite
                = new Range1f(Constant<float>.ParseableMinValue, Constant<float>.ParseableMaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Range1f Unit = new Range1f(0, 1);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        public float Size
        {
            get { return (float)(Max - Min); }
            set { Max = (float)(Min + value); }
        }

        public float Center
        {
            get { return (float)((Min + Max) / 2); }
        }

        public IEnumerable<float> Elements
        {
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        public Range1f EnlargedBy(float increment)
        {
            return new Range1f((float)(Min - increment), (float)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        public Range1f EnlargedBy(float deltaMin, float deltaMax)
        {
            return new Range1f((float)(Min - deltaMin), (float)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        public Range1f ShrunkBy(float delta)
        {
            return new Range1f((float)(Min + delta), (float)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        public Range1f ShrunkBy(float deltaMin, float deltaMax)
        {
            return new Range1f((float)(Min + deltaMin), (float)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(float delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        public void EnlargeBy(float deltaMin, float deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(float delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        public void ShrinkBy(float deltaMin, float deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        public float Clamped(float x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }

        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        /// <param name="x">Position between min and max [0,1].</param>
        public float Lerp(float x)
        {
            return Fun.Lerp(x, Min, Max);
        }

        /// <summary>
        /// Performs the inverse of Lerp.
        /// </summary>
        public float InvLerp(float x)
        {
            return Fun.InvLerp(x, Min, Max);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        public Range1f SplitRight(float splitValue)
        {
            if (splitValue > Max) return Range1f.Invalid;
            if (splitValue <= Min) return this;
            return new Range1f(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        public Range1f SplitLeft(float splitValue)
        {
            if (splitValue < Min) return Range1f.Invalid;
            if (splitValue >= Max) return this;
            return new Range1f(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        public Range1f ExtendedBy(Range1f range)
        {
            return new Range1f(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        public Range1f ExtendedBy(float value)
        {
            return new Range1f(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        public void ExtendBy(Range1f range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        public void ExtendBy(float value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        public bool Contains(float value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        public bool Contains(Range1f b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        public bool Intersects(Range1f range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Range1f range, float eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        public Range1f Repair()
        {
            if (this.Equals(Range1f.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Range1f a, Range1f b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Range1f a, Range1f b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        public static Range1f operator +(Range1f box, float v)
        {
            return new Range1f((float)(box.Min + v), (float)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        public static Range1f operator -(Range1f box, float v)
        {
            return new Range1f((float)(box.Min - v), (float)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Range1f) ? this == (Range1f)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1f, int, float> Setter =
            (ref Range1f box, int i, float value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1f(float.Parse(x[0], CultureInfo.InvariantCulture),
                                float.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1f Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<float>.Parse, Range1f.Setter);
        }

        #endregion

        #region Various

        public static Range1f Union(Range1f a, Range1f b)
        {
            return new Range1f(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Range1f Intersection(Range1f a, Range1f b)
        {
            return new Range1f(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Range1f Union(Range1f b)
        {
            return Union(this, b);
        }

        public Range1f Intersection(Range1f b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingRange1f Extensions

        public static Range1f GetBoundingRange1f(
                this float[] pointArray)
        {
            return pointArray.GetBoundingRange1f(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingRange1f of the first count elements
        /// of the array.
        /// </summary>
        public static Range1f GetBoundingRange1f(
                this float[] pointArray, long count)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1f of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1f GetBoundingRange1f(
                this float[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1f of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1f GetBoundingRange1f<T>(
                this T[] array, long start, long count, Func<T, float> pointSelector)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Range1f GetBoundingRange1f(
                this List<float> pointList)
        {
            return pointList.GetBoundingRange1f(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingRange1f of the first count elements
        /// of the list.
        /// </summary>
        public static Range1f GetBoundingRange1f(
                this List<float> pointList, int count)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Range1f GetBoundingRange1f(
                this int[] indexArray, float[] pointArray)
        {
            return indexArray.GetBoundingRange1f(indexArray.Length, pointArray);
        }

        public static Range1f GetBoundingRange1f(
                this int[] indexArray, int count,
                float[] pointArray)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1f GetBoundingRange1f(
                this int[] indexArray, int start, int count,
                float[] pointArray)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1f GetBoundingRange1f<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, float> pointSelector)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1f GetBoundingRange1f(
                this long[] indexArray, float[] pointArray)
        {
            return indexArray.GetBoundingRange1f(indexArray.LongLength, pointArray);
        }

        public static Range1f GetBoundingRange1f(
                this long[] indexArray, long count,
                float[] pointArray)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1f GetBoundingRange1f(
                this long[] indexArray, long start, long count,
                float[] pointArray)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1f GetBoundingRange1f<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, float> pointSelector)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1f GetBoundingRange1f(
                this IEnumerable<float> points)
        {
            var box = Range1f.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Range1d

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1d
        : IRange<double, Range1d>,  IFormattable
    {
        [DataMember]
        public double Min;
        [DataMember]
        public double Max;

        #region Constructors

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        public Range1d(double min, double max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Range1d(double pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        public Range1d(double p0, double p1, double p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        public Range1d(double p0, double p1, double p2, double p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Range1d(Range1d range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1d(Range1d b0, Range1d b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1d(Range1d b0, Range1d b1, Range1d b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        public Range1d(Range1d b0, Range1d b1, Range1d b2, Range1d b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        public Range1d(double[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        public Range1d(double[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        public Range1d(IEnumerable<double> values)
        {
            Min = Constant<double>.ParseableMaxValue;
            Max = Constant<double>.ParseableMinValue;
            foreach (double v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        public static Range1d FromMinAndSize(double min, double size)
        {
            return new Range1d(min, (min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        public static Range1d FromCenterAndSize(double center, double size)
        {
            return new Range1d((center - size / 2), (center + size / 2));
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Range1d Invalid
                = new Range1d(Constant<double>.ParseableMaxValue, Constant<double>.ParseableMinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Range1d Infinite
                = new Range1d(Constant<double>.ParseableMinValue, Constant<double>.ParseableMaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Range1d Unit = new Range1d(0, 1);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        public double Size
        {
            get { return (Max - Min); }
            set { Max = (Min + value); }
        }

        public double Center
        {
            get { return ((Min + Max) / 2); }
        }

        public IEnumerable<double> Elements
        {
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        public Range1d EnlargedBy(double increment)
        {
            return new Range1d((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        public Range1d EnlargedBy(double deltaMin, double deltaMax)
        {
            return new Range1d((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        public Range1d ShrunkBy(double delta)
        {
            return new Range1d((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        public Range1d ShrunkBy(double deltaMin, double deltaMax)
        {
            return new Range1d((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(double delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        public void EnlargeBy(double deltaMin, double deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(double delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        public void ShrinkBy(double deltaMin, double deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        public double Clamped(double x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }

        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        /// <param name="x">Position between min and max [0,1].</param>
        public double Lerp(double x)
        {
            return Fun.Lerp(x, Min, Max);
        }

        /// <summary>
        /// Performs the inverse of Lerp.
        /// </summary>
        public double InvLerp(double x)
        {
            return Fun.InvLerp(x, Min, Max);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        public Range1d SplitRight(double splitValue)
        {
            if (splitValue > Max) return Range1d.Invalid;
            if (splitValue <= Min) return this;
            return new Range1d(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        public Range1d SplitLeft(double splitValue)
        {
            if (splitValue < Min) return Range1d.Invalid;
            if (splitValue >= Max) return this;
            return new Range1d(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        public Range1d ExtendedBy(Range1d range)
        {
            return new Range1d(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        public Range1d ExtendedBy(double value)
        {
            return new Range1d(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        public void ExtendBy(Range1d range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        public void ExtendBy(double value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        public bool Contains(double value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        public bool Contains(Range1d b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        public bool Intersects(Range1d range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Range1d range, double eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        public Range1d Repair()
        {
            if (this.Equals(Range1d.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Range1d a, Range1d b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Range1d a, Range1d b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        public static Range1d operator +(Range1d box, double v)
        {
            return new Range1d((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        public static Range1d operator -(Range1d box, double v)
        {
            return new Range1d((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Range1d) ? this == (Range1d)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1d, int, double> Setter =
            (ref Range1d box, int i, double value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1d(double.Parse(x[0], CultureInfo.InvariantCulture),
                                double.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1d Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<double>.Parse, Range1d.Setter);
        }

        #endregion

        #region Various

        public static Range1d Union(Range1d a, Range1d b)
        {
            return new Range1d(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Range1d Intersection(Range1d a, Range1d b)
        {
            return new Range1d(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Range1d Union(Range1d b)
        {
            return Union(this, b);
        }

        public Range1d Intersection(Range1d b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingRange1d Extensions

        public static Range1d GetBoundingRange1d(
                this double[] pointArray)
        {
            return pointArray.GetBoundingRange1d(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingRange1d of the first count elements
        /// of the array.
        /// </summary>
        public static Range1d GetBoundingRange1d(
                this double[] pointArray, long count)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1d of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1d GetBoundingRange1d(
                this double[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingRange1d of count elements
        /// of the array starting at start
        /// </summary>
        public static Range1d GetBoundingRange1d<T>(
                this T[] array, long start, long count, Func<T, double> pointSelector)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Range1d GetBoundingRange1d(
                this List<double> pointList)
        {
            return pointList.GetBoundingRange1d(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingRange1d of the first count elements
        /// of the list.
        /// </summary>
        public static Range1d GetBoundingRange1d(
                this List<double> pointList, int count)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Range1d GetBoundingRange1d(
                this int[] indexArray, double[] pointArray)
        {
            return indexArray.GetBoundingRange1d(indexArray.Length, pointArray);
        }

        public static Range1d GetBoundingRange1d(
                this int[] indexArray, int count,
                double[] pointArray)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1d GetBoundingRange1d(
                this int[] indexArray, int start, int count,
                double[] pointArray)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1d GetBoundingRange1d<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, double> pointSelector)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1d GetBoundingRange1d(
                this long[] indexArray, double[] pointArray)
        {
            return indexArray.GetBoundingRange1d(indexArray.LongLength, pointArray);
        }

        public static Range1d GetBoundingRange1d(
                this long[] indexArray, long count,
                double[] pointArray)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1d GetBoundingRange1d(
                this long[] indexArray, long start, long count,
                double[] pointArray)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Range1d GetBoundingRange1d<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, double> pointSelector)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Range1d GetBoundingRange1d(
                this IEnumerable<double> points)
        {
            var box = Range1d.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Box2i

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box2i
        : IRange<V2i, Box2i>, IBoundingBox2d, ISize2d, IFormattable
    {
        [DataMember]
        public V2i Min;
        [DataMember]
        public V2i Max;

        #region Constructors

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box2i(V2i min, V2i max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box2i(int minX, int minY, int maxX, int maxY)
        {
            Min.X = minX;
            Min.Y = minY;
            Max.X = maxX;
            Max.Y = maxY;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Box2i(V2i pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        public Box2i(V2i p0, V2i p1, V2i p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        public Box2i(V2i p0, V2i p1, V2i p2, V2i p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Box2i(Box2i range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box2i(Box2i b0, Box2i b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box2i(Box2i b0, Box2i b1, Box2i b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box2i(Box2i b0, Box2i b1, Box2i b2, Box2i b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box2i(V2i[] points)
        {
            Min = Max = points[0];
            long count = points.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        public Box2i(V2i[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box2i(IEnumerable<V2i> points)
        {
            Min = V2i.MaxValue;
            Max = V2i.MinValue;
            if (points == null) return;
            foreach (V2i p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box2i(IEnumerable<Box2i> boxes)
        {
            Min = V2i.MaxValue;
            Max = V2i.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box2i(Range1i rangeX, Range1i rangeY)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Box2i Invalid
                = new Box2i(V2i.MaxValue, V2i.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Box2i Infinite
                = new Box2i(V2i.MinValue, V2i.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Box2i Unit = new Box2i(V2i.Zero, V2i.One);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min.AnyGreater(Max) || Min.IsNaN || Max.IsNaN; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        public V2i Size
        {
            get { return (Max - Min); }
            set { Max = (Min + value); }
        }

        public V2i Center
        {
            get { return ((Min + Max) / 2); }
        }

        public int SizeX
        {
            get { return Max.X - Min.X; }
            set { Max.X = Min.X + value; }
        }

        public Range1i RangeX
        {
            get { return new Range1i(Min.X, Max.X); }
        }

        public int SizeY
        {
            get { return Max.Y - Min.Y; }
            set { Max.Y = Min.Y + value; }
        }

        public Range1i RangeY
        {
            get { return new Range1i(Min.Y, Max.Y); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            get { return SizeY > SizeX ? 1 : 0; }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            get { return SizeY < SizeX ? 1 : 0; }
        }

        public int Area
        {
            get { return SizeX * SizeY; }
        }

        public V2i OO { get { return Min; } }
        public V2i IO { get { return new V2i(Max.X, Min.Y); } }
        public V2i OI { get { return new V2i(Min.X, Max.Y); } }
        public V2i II { get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        public Box2i EnlargedBy(V2i increment)
        {
            return new Box2i((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        public Box2i EnlargedBy(V2i deltaMin, V2i deltaMax)
        {
            return new Box2i((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        public Box2i ShrunkBy(V2i delta)
        {
            return new Box2i((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        public Box2i ShrunkBy(V2i deltaMin, V2i deltaMax)
        {
            return new Box2i((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(V2i delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        public void EnlargeBy(V2i deltaMin, V2i deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(V2i delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        public void ShrinkBy(V2i deltaMin, V2i deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        public Box2i EnlargedBy(int delta)
        {
            return new Box2i(
                    new V2i(Min.X - delta, Min.Y - delta),
                    new V2i(Max.X + delta, Max.Y + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        public Box2i ShrunkBy(int delta)
        {
            return new Box2i(
                    new V2i(Min.X + delta, Min.Y + delta),
                    new V2i(Max.X - delta, Max.Y - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        public Box2i EnlargedBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY)
        {
            return new Box2i(
                    new V2i(Min.X - deltaMinX, Min.Y - deltaMinY),
                    new V2i(Max.X + deltaMaxX, Max.Y + deltaMaxY));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        public Box2i ShrunkBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY)
        {
            return new Box2i(
                    new V2i(Min.X + deltaMinX, Min.Y + deltaMinY),
                    new V2i(Max.X - deltaMaxX, Max.Y - deltaMaxY));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        public void EnlargeBy(int delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        public void ShrinkBy(int delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        public void EnlargeBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        public void ShrinkBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        public V2i Clamped(V2i p)
        {
            return new V2i(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y));
        }


        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        public Box2i SplitRight(V2i splitValue)
        {
            var result = new Box2i(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        public Box2i SplitLeft(V2i splitValue)
        {
            var result = new Box2i(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Min.X clamped to splitValue.
        /// </summary>
        public Box2i SplitRight(int splitAtX)
        {
            if (splitAtX > Max.X) return Box2i.Invalid;
            if (splitAtX <= Min.X) return this;
            return new Box2i(new V2i(splitAtX, Min.Y), Max);
        }

        /// <summary>
        /// Returns a box with Max.X clamped to splitValue.
        /// </summary>
        public Box2i SplitLeft(int splitAtX)
        {
            if (splitAtX < Min.X) return Box2i.Invalid;
            if (splitAtX >= Max.X) return this;
            return new Box2i(Min, new V2i(splitAtX, Max.Y));
        }

        /// <summary>
        /// Returns the box with Min.Y clamped to splitValue.
        /// </summary>
        public Box2i SplitTop(int splitAtY)
        {
            if (splitAtY > Max.Y) return Box2i.Invalid;
            if (splitAtY <= Min.Y) return this;
            return new Box2i(new V2i(Min.X, splitAtY), Max);
        }

        /// <summary>
        /// Returns the box with Max.Y clamped to splitValue.
        /// </summary>
        public Box2i SplitBottom(int splitAtY)
        {
            if (splitAtY < Min.Y) return Box2i.Invalid;
            if (splitAtY >= Max.Y) return this;
            return new Box2i(Min, new V2i(Max.X, splitAtY));
        }

        public Box2i SplitLeftBottom(V2i splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y < Min.Y) return Box2i.Invalid;
            return new Box2i(Min, splitAt);
        }

        public Box2i SplitRightBottom(V2i splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y < Min.Y) return Box2i.Invalid;
            return new Box2i(new V2i(splitAt.X, Min.Y), new V2i(Max.X, splitAt.Y));
        }

        public Box2i SplitLeftTop(V2i splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y > Max.Y) return Box2i.Invalid;
            return new Box2i(new V2i(Min.X, splitAt.Y), new V2i(splitAt.X, Max.Y));
        }

        public Box2i SplitRightTop(V2i splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y > Max.Y) return Box2i.Invalid;
            return new Box2i(splitAt, Max);
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        public Box2i ExtendedBy(Box2i b)
        {
            return new Box2i(
                    new V2i(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y),
                    new V2i(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        public Box2i ExtendedBy(V2i v)
        {
            return new Box2i(
                    new V2i(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y),
                    new V2i(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        public void ExtendBy(Box2i box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        public void ExtendBy(V2i point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
        }

        public Box2i ExtendXBy(int x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        public Box2i ExtendYBy(int y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        public Box2i ExtendDimBy(int dim, int x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        public bool Contains(V2i p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        public bool Contains(Box2i b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        public Box2i Repair()
        {
            if (Equals(Box2i.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        public bool Intersects(Box2i box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box2i box, V2i eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box2i box, int eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            return true;
        }

        public Box2i Invalidate()
        {
            Min = V2i.MaxValue;
            Max = V2i.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        public Box.Flags OutsideFlags(V2i p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        public Box.Flags OutsideFlags(Box2i b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        public void GetMinMaxInDirection(V2i v, out V2i vMin, out V2i vMax)
        {
            vMin = V2i.MinValue;
            vMax = V2i.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Box2i a, Box2i b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Box2i a, Box2i b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        public static Box2i operator +(Box2i box, V2i v)
        {
            return new Box2i((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        public static Box2i operator -(Box2i box, V2i v)
        {
            return new Box2i((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Box2i) ? this == (Box2i)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box2i, int, V2i> Setter =
            (ref Box2i box, int i, V2i value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box2i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box2i(V2i.Parse(x[0].ToString()),
                                V2i.Parse(x[1].ToString()));
        }

        public static Box2i Parse(Text t)
        {
            return t.NestedBracketSplit(1, V2i.Parse, Box2i.Setter);
        }

        #endregion

        #region Various

        public static Box2i Union(Box2i a, Box2i b)
        {
            return new Box2i(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Box2i Intersection(Box2i a, Box2i b)
        {
            return new Box2i(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Box2i Union(Box2i b)
        {
            return Union(this, b);
        }

        public Box2i Intersection(Box2i b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        public static Box2i FromSize(V2i size)
        {
            return new Box2i(V2i.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        public static Box2i FromMinAndSize(V2i min, V2i size)
        {
            return new Box2i(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        public static Box2i FromCenterAndSize(V2i center, V2i size)
        {
            return new Box2i(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        public static Box2i FromSize(ISize2d iSize)
        {
            return new Box2i(
                V2i.Zero, (V2i)iSize.Size2d);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        public static Box2i FromMinAndSize(V2i min, ISize2d iSize)
        {
            return new Box2i(
                min, min + (V2i)iSize.Size2d);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        public static Box2i FromCenterAndSize(V2i center, ISize2d iSize)
        {
            var size = (V2i)iSize.Size2d;
            return new Box2i(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        public static Box2i FromPoints(V2i p0, V2i p1)
        {
            return new Box2i(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        public static Box2i FromSize(int width, int height)
        {
            return Box2i.FromSize(new V2i(width, height));
        }

        public static Box2i FromMinAndSize(V2i min, int width, int height)
        {
            return new Box2i(min, min + new V2i(width, height));
        }

        public static Box2i FromMinAndSize(
            int minX, int minY, int width, int height
            )
        {
            return Box2i.FromMinAndSize(new V2i(minX, minY), new V2i(width, height));
        }

        public static Box2i FromCenterAndSize(V2i center, int width, int height)
        {
            return FromCenterAndSize(center, new V2i(width, height));
        }

        public static Box2i FromCenterAndSize(
            int centerX, int centerY, int width, int height
            )
        {
            return FromCenterAndSize(new V2i(centerX, centerY), new V2i(width, height));
        }

        #endregion

        #region Transforms

        public Box2i Translated(V2i shift)
        {
            return IsInvalid ? Box2i.Invalid
                             : new Box2i(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        public Box2i Scaled(V2i factor)
        {
            return IsInvalid ? Box2i.Invalid
                             : new Box2i(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box2d Transformed(M33d trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y) return Box2d.Invalid; 
            var t = new V2d(trafo.M02, trafo.M12);
            var res = new Box2d(t, t);
            double av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            return res;
        }

        public Box2d Transformed(Trafo2d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        public V2i Corner(int index)
        {
            return
                new V2i(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        public V2i[] ComputeCorners()
        {
            return new V2i[] {
                Min,
                new V2i(Max.X, Min.Y),
                new V2i(Min.X, Max.Y),
                Max
            };
        }

        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V2i> Corners
        {
            get
            {
                yield return Min;
                yield return new V2i(Max.X, Min.Y);
                yield return new V2i(Min.X, Max.Y);
                yield return Max;
            }
        }

        #endregion

        #region Enumerators

        /// <summary>
        /// Returns all points from [Min,Max[ with X-Variable in the outer loop.
        /// </summary>
        public IEnumerable<V2i> EnumerateInsidePoints()
        {
            var p = new V2i();
            for (p.X = Min.X; p.X < Max.X; p.X++)
            for (p.Y = Min.Y; p.Y < Max.Y; p.Y++)
                yield return p;
        }

        #endregion

        #region IBoundingBox2d Members

        public Box2d BoundingBox2d
        {
            get { return new Box2d((V2d)Min, (V2d)Max); }
        }

        #endregion

        #region ISize2d Members

        public V2d Size2d
        {
            get { return (V2d)Size; }
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingBox2i Extensions

        public static Box2i GetBoundingBox2i(
                this V2i[] pointArray)
        {
            return pointArray.GetBoundingBox2i(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingBox2i of the first count elements
        /// of the array.
        /// </summary>
        public static Box2i GetBoundingBox2i(
                this V2i[] pointArray, long count)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox2i of count elements
        /// of the array starting at start
        /// </summary>
        public static Box2i GetBoundingBox2i(
                this V2i[] pointArray, long start, long count)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox2i of count elements
        /// of the array starting at start
        /// </summary>
        public static Box2i GetBoundingBox2i<T>(
                this T[] array, long start, long count, Func<T, V2i> pointSelector)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Box2i GetBoundingBox2i(
                this List<V2i> pointList)
        {
            return pointList.GetBoundingBox2i(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingBox2i of the first count elements
        /// of the list.
        /// </summary>
        public static Box2i GetBoundingBox2i(
                this List<V2i> pointList, int count)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Box2i GetBoundingBox2i(
                this int[] indexArray, V2i[] pointArray)
        {
            return indexArray.GetBoundingBox2i(indexArray.Length, pointArray);
        }

        public static Box2i GetBoundingBox2i(
                this int[] indexArray, int count,
                V2i[] pointArray)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2i GetBoundingBox2i(
                this int[] indexArray, int start, int count,
                V2i[] pointArray)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2i GetBoundingBox2i<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, V2i> pointSelector)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box2i GetBoundingBox2i(
                this long[] indexArray, V2i[] pointArray)
        {
            return indexArray.GetBoundingBox2i(indexArray.LongLength, pointArray);
        }

        public static Box2i GetBoundingBox2i(
                this long[] indexArray, long count,
                V2i[] pointArray)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2i GetBoundingBox2i(
                this long[] indexArray, long start, long count,
                V2i[] pointArray)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2i GetBoundingBox2i<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, V2i> pointSelector)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box2i GetBoundingBox2i(
                this IEnumerable<V2i> points)
        {
            var box = Box2i.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Box2l

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box2l
        : IRange<V2l, Box2l>, IBoundingBox2d, ISize2d, IFormattable
    {
        [DataMember]
        public V2l Min;
        [DataMember]
        public V2l Max;

        #region Constructors

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box2l(V2l min, V2l max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box2l(long minX, long minY, long maxX, long maxY)
        {
            Min.X = minX;
            Min.Y = minY;
            Max.X = maxX;
            Max.Y = maxY;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Box2l(V2l pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        public Box2l(V2l p0, V2l p1, V2l p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        public Box2l(V2l p0, V2l p1, V2l p2, V2l p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Box2l(Box2l range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box2l(Box2l b0, Box2l b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box2l(Box2l b0, Box2l b1, Box2l b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box2l(Box2l b0, Box2l b1, Box2l b2, Box2l b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box2l(V2l[] points)
        {
            Min = Max = points[0];
            long count = points.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        public Box2l(V2l[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box2l(IEnumerable<V2l> points)
        {
            Min = V2l.MaxValue;
            Max = V2l.MinValue;
            if (points == null) return;
            foreach (V2l p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box2l(IEnumerable<Box2l> boxes)
        {
            Min = V2l.MaxValue;
            Max = V2l.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box2l(Range1l rangeX, Range1l rangeY)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Box2l Invalid
                = new Box2l(V2l.MaxValue, V2l.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Box2l Infinite
                = new Box2l(V2l.MinValue, V2l.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Box2l Unit = new Box2l(V2l.Zero, V2l.One);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min.AnyGreater(Max) || Min.IsNaN || Max.IsNaN; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        public V2l Size
        {
            get { return (Max - Min); }
            set { Max = (Min + value); }
        }

        public V2l Center
        {
            get { return ((Min + Max) / 2); }
        }

        public long SizeX
        {
            get { return Max.X - Min.X; }
            set { Max.X = Min.X + value; }
        }

        public Range1l RangeX
        {
            get { return new Range1l(Min.X, Max.X); }
        }

        public long SizeY
        {
            get { return Max.Y - Min.Y; }
            set { Max.Y = Min.Y + value; }
        }

        public Range1l RangeY
        {
            get { return new Range1l(Min.Y, Max.Y); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            get { return SizeY > SizeX ? 1 : 0; }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            get { return SizeY < SizeX ? 1 : 0; }
        }

        public long Area
        {
            get { return SizeX * SizeY; }
        }

        public V2l OO { get { return Min; } }
        public V2l IO { get { return new V2l(Max.X, Min.Y); } }
        public V2l OI { get { return new V2l(Min.X, Max.Y); } }
        public V2l II { get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        public Box2l EnlargedBy(V2l increment)
        {
            return new Box2l((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        public Box2l EnlargedBy(V2l deltaMin, V2l deltaMax)
        {
            return new Box2l((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        public Box2l ShrunkBy(V2l delta)
        {
            return new Box2l((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        public Box2l ShrunkBy(V2l deltaMin, V2l deltaMax)
        {
            return new Box2l((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(V2l delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        public void EnlargeBy(V2l deltaMin, V2l deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(V2l delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        public void ShrinkBy(V2l deltaMin, V2l deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        public Box2l EnlargedBy(long delta)
        {
            return new Box2l(
                    new V2l(Min.X - delta, Min.Y - delta),
                    new V2l(Max.X + delta, Max.Y + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        public Box2l ShrunkBy(long delta)
        {
            return new Box2l(
                    new V2l(Min.X + delta, Min.Y + delta),
                    new V2l(Max.X - delta, Max.Y - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        public Box2l EnlargedBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY)
        {
            return new Box2l(
                    new V2l(Min.X - deltaMinX, Min.Y - deltaMinY),
                    new V2l(Max.X + deltaMaxX, Max.Y + deltaMaxY));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        public Box2l ShrunkBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY)
        {
            return new Box2l(
                    new V2l(Min.X + deltaMinX, Min.Y + deltaMinY),
                    new V2l(Max.X - deltaMaxX, Max.Y - deltaMaxY));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        public void EnlargeBy(long delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        public void ShrinkBy(long delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        public void EnlargeBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        public void ShrinkBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        public V2l Clamped(V2l p)
        {
            return new V2l(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y));
        }


        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        public Box2l SplitRight(V2l splitValue)
        {
            var result = new Box2l(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        public Box2l SplitLeft(V2l splitValue)
        {
            var result = new Box2l(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Min.X clamped to splitValue.
        /// </summary>
        public Box2l SplitRight(long splitAtX)
        {
            if (splitAtX > Max.X) return Box2l.Invalid;
            if (splitAtX <= Min.X) return this;
            return new Box2l(new V2l(splitAtX, Min.Y), Max);
        }

        /// <summary>
        /// Returns a box with Max.X clamped to splitValue.
        /// </summary>
        public Box2l SplitLeft(long splitAtX)
        {
            if (splitAtX < Min.X) return Box2l.Invalid;
            if (splitAtX >= Max.X) return this;
            return new Box2l(Min, new V2l(splitAtX, Max.Y));
        }

        /// <summary>
        /// Returns the box with Min.Y clamped to splitValue.
        /// </summary>
        public Box2l SplitTop(long splitAtY)
        {
            if (splitAtY > Max.Y) return Box2l.Invalid;
            if (splitAtY <= Min.Y) return this;
            return new Box2l(new V2l(Min.X, splitAtY), Max);
        }

        /// <summary>
        /// Returns the box with Max.Y clamped to splitValue.
        /// </summary>
        public Box2l SplitBottom(long splitAtY)
        {
            if (splitAtY < Min.Y) return Box2l.Invalid;
            if (splitAtY >= Max.Y) return this;
            return new Box2l(Min, new V2l(Max.X, splitAtY));
        }

        public Box2l SplitLeftBottom(V2l splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y < Min.Y) return Box2l.Invalid;
            return new Box2l(Min, splitAt);
        }

        public Box2l SplitRightBottom(V2l splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y < Min.Y) return Box2l.Invalid;
            return new Box2l(new V2l(splitAt.X, Min.Y), new V2l(Max.X, splitAt.Y));
        }

        public Box2l SplitLeftTop(V2l splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y > Max.Y) return Box2l.Invalid;
            return new Box2l(new V2l(Min.X, splitAt.Y), new V2l(splitAt.X, Max.Y));
        }

        public Box2l SplitRightTop(V2l splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y > Max.Y) return Box2l.Invalid;
            return new Box2l(splitAt, Max);
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        public Box2l ExtendedBy(Box2l b)
        {
            return new Box2l(
                    new V2l(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y),
                    new V2l(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        public Box2l ExtendedBy(V2l v)
        {
            return new Box2l(
                    new V2l(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y),
                    new V2l(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        public void ExtendBy(Box2l box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        public void ExtendBy(V2l point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
        }

        public Box2l ExtendXBy(long x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        public Box2l ExtendYBy(long y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        public Box2l ExtendDimBy(int dim, long x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        public bool Contains(V2l p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        public bool Contains(Box2l b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        public Box2l Repair()
        {
            if (Equals(Box2l.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        public bool Intersects(Box2l box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box2l box, V2l eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box2l box, long eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            return true;
        }

        public Box2l Invalidate()
        {
            Min = V2l.MaxValue;
            Max = V2l.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        public Box.Flags OutsideFlags(V2l p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        public Box.Flags OutsideFlags(Box2l b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        public void GetMinMaxInDirection(V2l v, out V2l vMin, out V2l vMax)
        {
            vMin = V2l.MinValue;
            vMax = V2l.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Box2l a, Box2l b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Box2l a, Box2l b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        public static Box2l operator +(Box2l box, V2l v)
        {
            return new Box2l((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        public static Box2l operator -(Box2l box, V2l v)
        {
            return new Box2l((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Box2l) ? this == (Box2l)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box2l, int, V2l> Setter =
            (ref Box2l box, int i, V2l value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box2l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box2l(V2l.Parse(x[0].ToString()),
                                V2l.Parse(x[1].ToString()));
        }

        public static Box2l Parse(Text t)
        {
            return t.NestedBracketSplit(1, V2l.Parse, Box2l.Setter);
        }

        #endregion

        #region Various

        public static Box2l Union(Box2l a, Box2l b)
        {
            return new Box2l(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Box2l Intersection(Box2l a, Box2l b)
        {
            return new Box2l(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Box2l Union(Box2l b)
        {
            return Union(this, b);
        }

        public Box2l Intersection(Box2l b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        public static Box2l FromSize(V2l size)
        {
            return new Box2l(V2l.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        public static Box2l FromMinAndSize(V2l min, V2l size)
        {
            return new Box2l(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        public static Box2l FromCenterAndSize(V2l center, V2l size)
        {
            return new Box2l(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        public static Box2l FromSize(ISize2d iSize)
        {
            return new Box2l(
                V2l.Zero, (V2l)iSize.Size2d);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        public static Box2l FromMinAndSize(V2l min, ISize2d iSize)
        {
            return new Box2l(
                min, min + (V2l)iSize.Size2d);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        public static Box2l FromCenterAndSize(V2l center, ISize2d iSize)
        {
            var size = (V2l)iSize.Size2d;
            return new Box2l(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        public static Box2l FromPoints(V2l p0, V2l p1)
        {
            return new Box2l(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        public static Box2l FromSize(long width, long height)
        {
            return Box2l.FromSize(new V2l(width, height));
        }

        public static Box2l FromMinAndSize(V2l min, long width, long height)
        {
            return new Box2l(min, min + new V2l(width, height));
        }

        public static Box2l FromMinAndSize(
            long minX, long minY, long width, long height
            )
        {
            return Box2l.FromMinAndSize(new V2l(minX, minY), new V2l(width, height));
        }

        public static Box2l FromCenterAndSize(V2l center, long width, long height)
        {
            return FromCenterAndSize(center, new V2l(width, height));
        }

        public static Box2l FromCenterAndSize(
            long centerX, long centerY, long width, long height
            )
        {
            return FromCenterAndSize(new V2l(centerX, centerY), new V2l(width, height));
        }

        #endregion

        #region Transforms

        public Box2l Translated(V2l shift)
        {
            return IsInvalid ? Box2l.Invalid
                             : new Box2l(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        public Box2l Scaled(V2l factor)
        {
            return IsInvalid ? Box2l.Invalid
                             : new Box2l(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box2d Transformed(M33d trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y) return Box2d.Invalid; 
            var t = new V2d(trafo.M02, trafo.M12);
            var res = new Box2d(t, t);
            double av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            return res;
        }

        public Box2d Transformed(Trafo2d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        public V2l Corner(int index)
        {
            return
                new V2l(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        public V2l[] ComputeCorners()
        {
            return new V2l[] {
                Min,
                new V2l(Max.X, Min.Y),
                new V2l(Min.X, Max.Y),
                Max
            };
        }

        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V2l> Corners
        {
            get
            {
                yield return Min;
                yield return new V2l(Max.X, Min.Y);
                yield return new V2l(Min.X, Max.Y);
                yield return Max;
            }
        }

        #endregion

        #region Enumerators

        /// <summary>
        /// Returns all points from [Min,Max[ with X-Variable in the outer loop.
        /// </summary>
        public IEnumerable<V2l> EnumerateInsidePoints()
        {
            var p = new V2l();
            for (p.X = Min.X; p.X < Max.X; p.X++)
            for (p.Y = Min.Y; p.Y < Max.Y; p.Y++)
                yield return p;
        }

        #endregion

        #region IBoundingBox2d Members

        public Box2d BoundingBox2d
        {
            get { return new Box2d((V2d)Min, (V2d)Max); }
        }

        #endregion

        #region ISize2d Members

        public V2d Size2d
        {
            get { return (V2d)Size; }
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingBox2l Extensions

        public static Box2l GetBoundingBox2l(
                this V2l[] pointArray)
        {
            return pointArray.GetBoundingBox2l(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingBox2l of the first count elements
        /// of the array.
        /// </summary>
        public static Box2l GetBoundingBox2l(
                this V2l[] pointArray, long count)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox2l of count elements
        /// of the array starting at start
        /// </summary>
        public static Box2l GetBoundingBox2l(
                this V2l[] pointArray, long start, long count)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox2l of count elements
        /// of the array starting at start
        /// </summary>
        public static Box2l GetBoundingBox2l<T>(
                this T[] array, long start, long count, Func<T, V2l> pointSelector)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Box2l GetBoundingBox2l(
                this List<V2l> pointList)
        {
            return pointList.GetBoundingBox2l(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingBox2l of the first count elements
        /// of the list.
        /// </summary>
        public static Box2l GetBoundingBox2l(
                this List<V2l> pointList, int count)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Box2l GetBoundingBox2l(
                this int[] indexArray, V2l[] pointArray)
        {
            return indexArray.GetBoundingBox2l(indexArray.Length, pointArray);
        }

        public static Box2l GetBoundingBox2l(
                this int[] indexArray, int count,
                V2l[] pointArray)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2l GetBoundingBox2l(
                this int[] indexArray, int start, int count,
                V2l[] pointArray)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2l GetBoundingBox2l<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, V2l> pointSelector)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box2l GetBoundingBox2l(
                this long[] indexArray, V2l[] pointArray)
        {
            return indexArray.GetBoundingBox2l(indexArray.LongLength, pointArray);
        }

        public static Box2l GetBoundingBox2l(
                this long[] indexArray, long count,
                V2l[] pointArray)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2l GetBoundingBox2l(
                this long[] indexArray, long start, long count,
                V2l[] pointArray)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2l GetBoundingBox2l<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, V2l> pointSelector)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box2l GetBoundingBox2l(
                this IEnumerable<V2l> points)
        {
            var box = Box2l.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Box2f

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box2f
        : IRange<V2f, Box2f>, IBoundingBox2d, ISize2d, IFormattable
    {
        [DataMember]
        public V2f Min;
        [DataMember]
        public V2f Max;

        #region Constructors

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box2f(V2f min, V2f max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box2f(float minX, float minY, float maxX, float maxY)
        {
            Min.X = minX;
            Min.Y = minY;
            Max.X = maxX;
            Max.Y = maxY;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Box2f(V2f pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        public Box2f(V2f p0, V2f p1, V2f p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        public Box2f(V2f p0, V2f p1, V2f p2, V2f p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Box2f(Box2f range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box2f(Box2f b0, Box2f b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box2f(Box2f b0, Box2f b1, Box2f b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box2f(Box2f b0, Box2f b1, Box2f b2, Box2f b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box2f(V2f[] points)
        {
            Min = Max = points[0];
            long count = points.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        public Box2f(V2f[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box2f(IEnumerable<V2f> points)
        {
            Min = V2f.MaxValue;
            Max = V2f.MinValue;
            if (points == null) return;
            foreach (V2f p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box2f(IEnumerable<Box2f> boxes)
        {
            Min = V2f.MaxValue;
            Max = V2f.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box2f(Range1f rangeX, Range1f rangeY)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Box2f Invalid
                = new Box2f(V2f.MaxValue, V2f.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Box2f Infinite
                = new Box2f(V2f.MinValue, V2f.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Box2f Unit = new Box2f(V2f.Zero, V2f.One);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min.AnyGreater(Max) || Min.IsNaN || Max.IsNaN; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        public V2f Size
        {
            get { return (Max - Min); }
            set { Max = (Min + value); }
        }

        public V2f Center
        {
            get { return ((Min + Max) / 2); }
        }

        public float SizeX
        {
            get { return Max.X - Min.X; }
            set { Max.X = Min.X + value; }
        }

        public Range1f RangeX
        {
            get { return new Range1f(Min.X, Max.X); }
        }

        public float SizeY
        {
            get { return Max.Y - Min.Y; }
            set { Max.Y = Min.Y + value; }
        }

        public Range1f RangeY
        {
            get { return new Range1f(Min.Y, Max.Y); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            get { return SizeY > SizeX ? 1 : 0; }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            get { return SizeY < SizeX ? 1 : 0; }
        }

        public float Area
        {
            get { return SizeX * SizeY; }
        }

        public V2f OO { get { return Min; } }
        public V2f IO { get { return new V2f(Max.X, Min.Y); } }
        public V2f OI { get { return new V2f(Min.X, Max.Y); } }
        public V2f II { get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        public Box2f EnlargedBy(V2f increment)
        {
            return new Box2f((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        public Box2f EnlargedBy(V2f deltaMin, V2f deltaMax)
        {
            return new Box2f((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        public Box2f ShrunkBy(V2f delta)
        {
            return new Box2f((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        public Box2f ShrunkBy(V2f deltaMin, V2f deltaMax)
        {
            return new Box2f((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(V2f delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        public void EnlargeBy(V2f deltaMin, V2f deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(V2f delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        public void ShrinkBy(V2f deltaMin, V2f deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        public Box2f EnlargedBy(float delta)
        {
            return new Box2f(
                    new V2f(Min.X - delta, Min.Y - delta),
                    new V2f(Max.X + delta, Max.Y + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        public Box2f ShrunkBy(float delta)
        {
            return new Box2f(
                    new V2f(Min.X + delta, Min.Y + delta),
                    new V2f(Max.X - delta, Max.Y - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        public Box2f EnlargedBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY)
        {
            return new Box2f(
                    new V2f(Min.X - deltaMinX, Min.Y - deltaMinY),
                    new V2f(Max.X + deltaMaxX, Max.Y + deltaMaxY));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        public Box2f ShrunkBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY)
        {
            return new Box2f(
                    new V2f(Min.X + deltaMinX, Min.Y + deltaMinY),
                    new V2f(Max.X - deltaMaxX, Max.Y - deltaMaxY));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        public void EnlargeBy(float delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        public void ShrinkBy(float delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        public void EnlargeBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        public void ShrinkBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        public Box2f ScaledFromCenterBy(float factor)
        {
            var size = Size;
            var increment = (size * factor - size) / 2;
            return new Box2f(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        public Box2f ScaledFromCenterBy(V2f vectorFactor)
        {
            var size = Size;
            var increment = (size * vectorFactor - size) / 2;
            return new Box2f(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return a box enlarged in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        public Box2f EnlargedByRelativeEps(float eps)
        {
            return EnlargedBy(eps * Size.Length);
        }

        /// <summary>
        /// Enlarge the box in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        public void EnlargeByRelativeEps(float eps)
        {
            EnlargeBy(eps * Size.Length);
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        public V2f Clamped(V2f p)
        {
            return new V2f(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y));
        }

        /// <summary>
        /// Returns the squared distance to the supplied point.
        /// </summary>
        public double DistanceSquared(V2f p)
        {
            return 
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0));
        }

        /// <summary>
        /// Returns the distance to the supplied point.
        /// </summary>
        public double Distance(V2f p)
        {
            return Fun.Sqrt(
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0)));
        }

        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        /// <param name="x">Position between min and max [0,1].</param>
        public V2f Lerp(float x)
        {
            return Fun.Lerp(x, Min, Max);
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        public V2f Lerp(V2f p)
        {
            return new V2f(
                        Fun.Lerp(p.X, Min.X, Max.X), 
                        Fun.Lerp(p.Y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        public V2f Lerp(float x, float y)
        {
            return new V2f(
                         Fun.Lerp(x, Min.X, Max.X), 
                         Fun.Lerp(y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        public V2f InvLerp(V2f p)
        {
            return new V2f(
                        Fun.InvLerp(p.X, Min.X, Max.X), 
                        Fun.InvLerp(p.Y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        public V2f InvLerp(float x, float y)
        {
            return new V2f(
                        Fun.InvLerp(x, Min.X, Max.X), 
                        Fun.InvLerp(y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        public Box2f SplitRight(V2f splitValue)
        {
            var result = new Box2f(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        public Box2f SplitLeft(V2f splitValue)
        {
            var result = new Box2f(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Min.X clamped to splitValue.
        /// </summary>
        public Box2f SplitRight(float splitAtX)
        {
            if (splitAtX > Max.X) return Box2f.Invalid;
            if (splitAtX <= Min.X) return this;
            return new Box2f(new V2f(splitAtX, Min.Y), Max);
        }

        /// <summary>
        /// Returns a box with Max.X clamped to splitValue.
        /// </summary>
        public Box2f SplitLeft(float splitAtX)
        {
            if (splitAtX < Min.X) return Box2f.Invalid;
            if (splitAtX >= Max.X) return this;
            return new Box2f(Min, new V2f(splitAtX, Max.Y));
        }

        /// <summary>
        /// Returns the box with Min.Y clamped to splitValue.
        /// </summary>
        public Box2f SplitTop(float splitAtY)
        {
            if (splitAtY > Max.Y) return Box2f.Invalid;
            if (splitAtY <= Min.Y) return this;
            return new Box2f(new V2f(Min.X, splitAtY), Max);
        }

        /// <summary>
        /// Returns the box with Max.Y clamped to splitValue.
        /// </summary>
        public Box2f SplitBottom(float splitAtY)
        {
            if (splitAtY < Min.Y) return Box2f.Invalid;
            if (splitAtY >= Max.Y) return this;
            return new Box2f(Min, new V2f(Max.X, splitAtY));
        }

        public Box2f SplitLeftBottom(V2f splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y < Min.Y) return Box2f.Invalid;
            return new Box2f(Min, splitAt);
        }

        public Box2f SplitRightBottom(V2f splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y < Min.Y) return Box2f.Invalid;
            return new Box2f(new V2f(splitAt.X, Min.Y), new V2f(Max.X, splitAt.Y));
        }

        public Box2f SplitLeftTop(V2f splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y > Max.Y) return Box2f.Invalid;
            return new Box2f(new V2f(Min.X, splitAt.Y), new V2f(splitAt.X, Max.Y));
        }

        public Box2f SplitRightTop(V2f splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y > Max.Y) return Box2f.Invalid;
            return new Box2f(splitAt, Max);
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        public Box2f ExtendedBy(Box2f b)
        {
            return new Box2f(
                    new V2f(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y),
                    new V2f(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        public Box2f ExtendedBy(V2f v)
        {
            return new Box2f(
                    new V2f(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y),
                    new V2f(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        public void ExtendBy(Box2f box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        public void ExtendBy(V2f point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
        }

        public Box2f ExtendXBy(float x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        public Box2f ExtendYBy(float y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        public Box2f ExtendDimBy(int dim, float x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        public bool Contains(V2f p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        public bool Contains(Box2f b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        public Box2f Repair()
        {
            if (Equals(Box2f.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        public bool Intersects(Box2f box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box2f box, V2f eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box2f box, float eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            return true;
        }

        public Box2f Invalidate()
        {
            Min = V2f.MaxValue;
            Max = V2f.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        public Box.Flags OutsideFlags(V2f p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        public Box.Flags OutsideFlags(Box2f b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        public void GetMinMaxInDirection(V2f v, out V2f vMin, out V2f vMax)
        {
            vMin = V2f.MinValue;
            vMax = V2f.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Box2f a, Box2f b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Box2f a, Box2f b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        public static Box2f operator +(Box2f box, V2f v)
        {
            return new Box2f((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        public static Box2f operator -(Box2f box, V2f v)
        {
            return new Box2f((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Box2f) ? this == (Box2f)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box2f, int, V2f> Setter =
            (ref Box2f box, int i, V2f value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box2f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box2f(V2f.Parse(x[0].ToString()),
                                V2f.Parse(x[1].ToString()));
        }

        public static Box2f Parse(Text t)
        {
            return t.NestedBracketSplit(1, V2f.Parse, Box2f.Setter);
        }

        #endregion

        #region Various

        public static Box2f Union(Box2f a, Box2f b)
        {
            return new Box2f(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Box2f Intersection(Box2f a, Box2f b)
        {
            return new Box2f(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Box2f Union(Box2f b)
        {
            return Union(this, b);
        }

        public Box2f Intersection(Box2f b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        public static Box2f FromSize(V2f size)
        {
            return new Box2f(V2f.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        public static Box2f FromMinAndSize(V2f min, V2f size)
        {
            return new Box2f(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        public static Box2f FromCenterAndSize(V2f center, V2f size)
        {
            return new Box2f(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        public static Box2f FromSize(ISize2d iSize)
        {
            return new Box2f(
                V2f.Zero, (V2f)iSize.Size2d);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        public static Box2f FromMinAndSize(V2f min, ISize2d iSize)
        {
            return new Box2f(
                min, min + (V2f)iSize.Size2d);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        public static Box2f FromCenterAndSize(V2f center, ISize2d iSize)
        {
            var size = (V2f)iSize.Size2d;
            return new Box2f(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        public static Box2f FromPoints(V2f p0, V2f p1)
        {
            return new Box2f(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        public static Box2f FromSize(float width, float height)
        {
            return Box2f.FromSize(new V2f(width, height));
        }

        public static Box2f FromMinAndSize(V2f min, float width, float height)
        {
            return new Box2f(min, min + new V2f(width, height));
        }

        public static Box2f FromMinAndSize(
            float minX, float minY, float width, float height
            )
        {
            return Box2f.FromMinAndSize(new V2f(minX, minY), new V2f(width, height));
        }

        public static Box2f FromCenterAndSize(V2f center, float width, float height)
        {
            return FromCenterAndSize(center, new V2f(width, height));
        }

        public static Box2f FromCenterAndSize(
            float centerX, float centerY, float width, float height
            )
        {
            return FromCenterAndSize(new V2f(centerX, centerY), new V2f(width, height));
        }

        #endregion

        #region Transforms

        public Box2f Translated(V2f shift)
        {
            return IsInvalid ? Box2f.Invalid
                             : new Box2f(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        public Box2f Scaled(V2f factor)
        {
            return IsInvalid ? Box2f.Invalid
                             : new Box2f(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box2d Transformed(M33d trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y) return Box2d.Invalid; 
            var t = new V2d(trafo.M02, trafo.M12);
            var res = new Box2d(t, t);
            double av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            return res;
        }

        public Box2d Transformed(Trafo2d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        public V2f Corner(int index)
        {
            return
                new V2f(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        public V2f[] ComputeCorners()
        {
            return new V2f[] {
                Min,
                new V2f(Max.X, Min.Y),
                new V2f(Min.X, Max.Y),
                Max
            };
        }

        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V2f> Corners
        {
            get
            {
                yield return Min;
                yield return new V2f(Max.X, Min.Y);
                yield return new V2f(Min.X, Max.Y);
                yield return Max;
            }
        }

        #endregion

        #region Enumerators

        #endregion

        #region IBoundingBox2d Members

        public Box2d BoundingBox2d
        {
            get { return new Box2d((V2d)Min, (V2d)Max); }
        }

        #endregion

        #region ISize2d Members

        public V2d Size2d
        {
            get { return (V2d)Size; }
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingBox2f Extensions

        public static Box2f GetBoundingBox2f(
                this V2f[] pointArray)
        {
            return pointArray.GetBoundingBox2f(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingBox2f of the first count elements
        /// of the array.
        /// </summary>
        public static Box2f GetBoundingBox2f(
                this V2f[] pointArray, long count)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox2f of count elements
        /// of the array starting at start
        /// </summary>
        public static Box2f GetBoundingBox2f(
                this V2f[] pointArray, long start, long count)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox2f of count elements
        /// of the array starting at start
        /// </summary>
        public static Box2f GetBoundingBox2f<T>(
                this T[] array, long start, long count, Func<T, V2f> pointSelector)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Box2f GetBoundingBox2f(
                this List<V2f> pointList)
        {
            return pointList.GetBoundingBox2f(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingBox2f of the first count elements
        /// of the list.
        /// </summary>
        public static Box2f GetBoundingBox2f(
                this List<V2f> pointList, int count)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Box2f GetBoundingBox2f(
                this int[] indexArray, V2f[] pointArray)
        {
            return indexArray.GetBoundingBox2f(indexArray.Length, pointArray);
        }

        public static Box2f GetBoundingBox2f(
                this int[] indexArray, int count,
                V2f[] pointArray)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2f GetBoundingBox2f(
                this int[] indexArray, int start, int count,
                V2f[] pointArray)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2f GetBoundingBox2f<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, V2f> pointSelector)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box2f GetBoundingBox2f(
                this long[] indexArray, V2f[] pointArray)
        {
            return indexArray.GetBoundingBox2f(indexArray.LongLength, pointArray);
        }

        public static Box2f GetBoundingBox2f(
                this long[] indexArray, long count,
                V2f[] pointArray)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2f GetBoundingBox2f(
                this long[] indexArray, long start, long count,
                V2f[] pointArray)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2f GetBoundingBox2f<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, V2f> pointSelector)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box2f GetBoundingBox2f(
                this IEnumerable<V2f> points)
        {
            var box = Box2f.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Box2d

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box2d
        : IRange<V2d, Box2d>, IBoundingBox2d, ISize2d, IFormattable
    {
        [DataMember]
        public V2d Min;
        [DataMember]
        public V2d Max;

        #region Constructors

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box2d(V2d min, V2d max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box2d(double minX, double minY, double maxX, double maxY)
        {
            Min.X = minX;
            Min.Y = minY;
            Max.X = maxX;
            Max.Y = maxY;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Box2d(V2d pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        public Box2d(V2d p0, V2d p1, V2d p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        public Box2d(V2d p0, V2d p1, V2d p2, V2d p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Box2d(Box2d range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box2d(Box2d b0, Box2d b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box2d(Box2d b0, Box2d b1, Box2d b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box2d(Box2d b0, Box2d b1, Box2d b2, Box2d b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box2d(V2d[] points)
        {
            Min = Max = points[0];
            long count = points.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        public Box2d(V2d[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box2d(IEnumerable<V2d> points)
        {
            Min = V2d.MaxValue;
            Max = V2d.MinValue;
            if (points == null) return;
            foreach (V2d p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box2d(IEnumerable<Box2d> boxes)
        {
            Min = V2d.MaxValue;
            Max = V2d.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box2d(Range1d rangeX, Range1d rangeY)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Box2d Invalid
                = new Box2d(V2d.MaxValue, V2d.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Box2d Infinite
                = new Box2d(V2d.MinValue, V2d.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Box2d Unit = new Box2d(V2d.Zero, V2d.One);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min.AnyGreater(Max) || Min.IsNaN || Max.IsNaN; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        public V2d Size
        {
            get { return (Max - Min); }
            set { Max = (Min + value); }
        }

        public V2d Center
        {
            get { return ((Min + Max) / 2); }
        }

        public double SizeX
        {
            get { return Max.X - Min.X; }
            set { Max.X = Min.X + value; }
        }

        public Range1d RangeX
        {
            get { return new Range1d(Min.X, Max.X); }
        }

        public double SizeY
        {
            get { return Max.Y - Min.Y; }
            set { Max.Y = Min.Y + value; }
        }

        public Range1d RangeY
        {
            get { return new Range1d(Min.Y, Max.Y); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            get { return SizeY > SizeX ? 1 : 0; }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            get { return SizeY < SizeX ? 1 : 0; }
        }

        public double Area
        {
            get { return SizeX * SizeY; }
        }

        public V2d OO { get { return Min; } }
        public V2d IO { get { return new V2d(Max.X, Min.Y); } }
        public V2d OI { get { return new V2d(Min.X, Max.Y); } }
        public V2d II { get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        public Box2d EnlargedBy(V2d increment)
        {
            return new Box2d((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        public Box2d EnlargedBy(V2d deltaMin, V2d deltaMax)
        {
            return new Box2d((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        public Box2d ShrunkBy(V2d delta)
        {
            return new Box2d((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        public Box2d ShrunkBy(V2d deltaMin, V2d deltaMax)
        {
            return new Box2d((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(V2d delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        public void EnlargeBy(V2d deltaMin, V2d deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(V2d delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        public void ShrinkBy(V2d deltaMin, V2d deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        public Box2d EnlargedBy(double delta)
        {
            return new Box2d(
                    new V2d(Min.X - delta, Min.Y - delta),
                    new V2d(Max.X + delta, Max.Y + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        public Box2d ShrunkBy(double delta)
        {
            return new Box2d(
                    new V2d(Min.X + delta, Min.Y + delta),
                    new V2d(Max.X - delta, Max.Y - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        public Box2d EnlargedBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY)
        {
            return new Box2d(
                    new V2d(Min.X - deltaMinX, Min.Y - deltaMinY),
                    new V2d(Max.X + deltaMaxX, Max.Y + deltaMaxY));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        public Box2d ShrunkBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY)
        {
            return new Box2d(
                    new V2d(Min.X + deltaMinX, Min.Y + deltaMinY),
                    new V2d(Max.X - deltaMaxX, Max.Y - deltaMaxY));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        public void EnlargeBy(double delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        public void ShrinkBy(double delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        public void EnlargeBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        public void ShrinkBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        public Box2d ScaledFromCenterBy(double factor)
        {
            var size = Size;
            var increment = (size * factor - size) / 2;
            return new Box2d(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        public Box2d ScaledFromCenterBy(V2d vectorFactor)
        {
            var size = Size;
            var increment = (size * vectorFactor - size) / 2;
            return new Box2d(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return a box enlarged in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        public Box2d EnlargedByRelativeEps(double eps)
        {
            return EnlargedBy(eps * Size.Length);
        }

        /// <summary>
        /// Enlarge the box in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        public void EnlargeByRelativeEps(double eps)
        {
            EnlargeBy(eps * Size.Length);
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        public V2d Clamped(V2d p)
        {
            return new V2d(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y));
        }

        /// <summary>
        /// Returns the squared distance to the supplied point.
        /// </summary>
        public double DistanceSquared(V2d p)
        {
            return 
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0));
        }

        /// <summary>
        /// Returns the distance to the supplied point.
        /// </summary>
        public double Distance(V2d p)
        {
            return Fun.Sqrt(
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0)));
        }

        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        /// <param name="x">Position between min and max [0,1].</param>
        public V2d Lerp(double x)
        {
            return Fun.Lerp(x, Min, Max);
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        public V2d Lerp(V2d p)
        {
            return new V2d(
                        Fun.Lerp(p.X, Min.X, Max.X), 
                        Fun.Lerp(p.Y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        public V2d Lerp(double x, double y)
        {
            return new V2d(
                         Fun.Lerp(x, Min.X, Max.X), 
                         Fun.Lerp(y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        public V2d InvLerp(V2d p)
        {
            return new V2d(
                        Fun.InvLerp(p.X, Min.X, Max.X), 
                        Fun.InvLerp(p.Y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        public V2d InvLerp(double x, double y)
        {
            return new V2d(
                        Fun.InvLerp(x, Min.X, Max.X), 
                        Fun.InvLerp(y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        public Box2d SplitRight(V2d splitValue)
        {
            var result = new Box2d(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        public Box2d SplitLeft(V2d splitValue)
        {
            var result = new Box2d(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Min.X clamped to splitValue.
        /// </summary>
        public Box2d SplitRight(double splitAtX)
        {
            if (splitAtX > Max.X) return Box2d.Invalid;
            if (splitAtX <= Min.X) return this;
            return new Box2d(new V2d(splitAtX, Min.Y), Max);
        }

        /// <summary>
        /// Returns a box with Max.X clamped to splitValue.
        /// </summary>
        public Box2d SplitLeft(double splitAtX)
        {
            if (splitAtX < Min.X) return Box2d.Invalid;
            if (splitAtX >= Max.X) return this;
            return new Box2d(Min, new V2d(splitAtX, Max.Y));
        }

        /// <summary>
        /// Returns the box with Min.Y clamped to splitValue.
        /// </summary>
        public Box2d SplitTop(double splitAtY)
        {
            if (splitAtY > Max.Y) return Box2d.Invalid;
            if (splitAtY <= Min.Y) return this;
            return new Box2d(new V2d(Min.X, splitAtY), Max);
        }

        /// <summary>
        /// Returns the box with Max.Y clamped to splitValue.
        /// </summary>
        public Box2d SplitBottom(double splitAtY)
        {
            if (splitAtY < Min.Y) return Box2d.Invalid;
            if (splitAtY >= Max.Y) return this;
            return new Box2d(Min, new V2d(Max.X, splitAtY));
        }

        public Box2d SplitLeftBottom(V2d splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y < Min.Y) return Box2d.Invalid;
            return new Box2d(Min, splitAt);
        }

        public Box2d SplitRightBottom(V2d splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y < Min.Y) return Box2d.Invalid;
            return new Box2d(new V2d(splitAt.X, Min.Y), new V2d(Max.X, splitAt.Y));
        }

        public Box2d SplitLeftTop(V2d splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y > Max.Y) return Box2d.Invalid;
            return new Box2d(new V2d(Min.X, splitAt.Y), new V2d(splitAt.X, Max.Y));
        }

        public Box2d SplitRightTop(V2d splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y > Max.Y) return Box2d.Invalid;
            return new Box2d(splitAt, Max);
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        public Box2d ExtendedBy(Box2d b)
        {
            return new Box2d(
                    new V2d(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y),
                    new V2d(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        public Box2d ExtendedBy(V2d v)
        {
            return new Box2d(
                    new V2d(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y),
                    new V2d(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        public void ExtendBy(Box2d box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        public void ExtendBy(V2d point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
        }

        public Box2d ExtendXBy(double x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        public Box2d ExtendYBy(double y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        public Box2d ExtendDimBy(int dim, double x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        public bool Contains(V2d p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        public bool Contains(Box2d b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        public Box2d Repair()
        {
            if (Equals(Box2d.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        public bool Intersects(Box2d box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box2d box, V2d eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box2d box, double eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            return true;
        }

        public Box2d Invalidate()
        {
            Min = V2d.MaxValue;
            Max = V2d.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        public Box.Flags OutsideFlags(V2d p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        public Box.Flags OutsideFlags(Box2d b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        public void GetMinMaxInDirection(V2d v, out V2d vMin, out V2d vMax)
        {
            vMin = V2d.MinValue;
            vMax = V2d.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Box2d a, Box2d b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Box2d a, Box2d b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        public static Box2d operator +(Box2d box, V2d v)
        {
            return new Box2d((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        public static Box2d operator -(Box2d box, V2d v)
        {
            return new Box2d((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Box2d) ? this == (Box2d)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box2d, int, V2d> Setter =
            (ref Box2d box, int i, V2d value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box2d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box2d(V2d.Parse(x[0].ToString()),
                                V2d.Parse(x[1].ToString()));
        }

        public static Box2d Parse(Text t)
        {
            return t.NestedBracketSplit(1, V2d.Parse, Box2d.Setter);
        }

        #endregion

        #region Various

        public static Box2d Union(Box2d a, Box2d b)
        {
            return new Box2d(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Box2d Intersection(Box2d a, Box2d b)
        {
            return new Box2d(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Box2d Union(Box2d b)
        {
            return Union(this, b);
        }

        public Box2d Intersection(Box2d b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        public static Box2d FromSize(V2d size)
        {
            return new Box2d(V2d.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        public static Box2d FromMinAndSize(V2d min, V2d size)
        {
            return new Box2d(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        public static Box2d FromCenterAndSize(V2d center, V2d size)
        {
            return new Box2d(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        public static Box2d FromSize(ISize2d iSize)
        {
            return new Box2d(
                V2d.Zero, iSize.Size2d);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        public static Box2d FromMinAndSize(V2d min, ISize2d iSize)
        {
            return new Box2d(
                min, min + iSize.Size2d);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        public static Box2d FromCenterAndSize(V2d center, ISize2d iSize)
        {
            var size = iSize.Size2d;
            return new Box2d(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        public static Box2d FromPoints(V2d p0, V2d p1)
        {
            return new Box2d(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        public static Box2d FromSize(double width, double height)
        {
            return Box2d.FromSize(new V2d(width, height));
        }

        public static Box2d FromMinAndSize(V2d min, double width, double height)
        {
            return new Box2d(min, min + new V2d(width, height));
        }

        public static Box2d FromMinAndSize(
            double minX, double minY, double width, double height
            )
        {
            return Box2d.FromMinAndSize(new V2d(minX, minY), new V2d(width, height));
        }

        public static Box2d FromCenterAndSize(V2d center, double width, double height)
        {
            return FromCenterAndSize(center, new V2d(width, height));
        }

        public static Box2d FromCenterAndSize(
            double centerX, double centerY, double width, double height
            )
        {
            return FromCenterAndSize(new V2d(centerX, centerY), new V2d(width, height));
        }

        #endregion

        #region Transforms

        public Box2d Translated(V2d shift)
        {
            return IsInvalid ? Box2d.Invalid
                             : new Box2d(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        public Box2d Scaled(V2d factor)
        {
            return IsInvalid ? Box2d.Invalid
                             : new Box2d(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box2d Transformed(M33d trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y) return Box2d.Invalid; 
            var t = new V2d(trafo.M02, trafo.M12);
            var res = new Box2d(t, t);
            double av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            return res;
        }

        public Box2d Transformed(Trafo2d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        public V2d Corner(int index)
        {
            return
                new V2d(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        public V2d[] ComputeCorners()
        {
            return new V2d[] {
                Min,
                new V2d(Max.X, Min.Y),
                new V2d(Min.X, Max.Y),
                Max
            };
        }

        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V2d> Corners
        {
            get
            {
                yield return Min;
                yield return new V2d(Max.X, Min.Y);
                yield return new V2d(Min.X, Max.Y);
                yield return Max;
            }
        }

        #endregion

        #region Enumerators

        #endregion

        #region IBoundingBox2d Members

        public Box2d BoundingBox2d
        {
            get { return new Box2d(Min, Max); }
        }

        #endregion

        #region ISize2d Members

        public V2d Size2d
        {
            get { return Size; }
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingBox2d Extensions

        public static Box2d GetBoundingBox2d(
                this V2d[] pointArray)
        {
            return pointArray.GetBoundingBox2d(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingBox2d of the first count elements
        /// of the array.
        /// </summary>
        public static Box2d GetBoundingBox2d(
                this V2d[] pointArray, long count)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox2d of count elements
        /// of the array starting at start
        /// </summary>
        public static Box2d GetBoundingBox2d(
                this V2d[] pointArray, long start, long count)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox2d of count elements
        /// of the array starting at start
        /// </summary>
        public static Box2d GetBoundingBox2d<T>(
                this T[] array, long start, long count, Func<T, V2d> pointSelector)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Box2d GetBoundingBox2d(
                this List<V2d> pointList)
        {
            return pointList.GetBoundingBox2d(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingBox2d of the first count elements
        /// of the list.
        /// </summary>
        public static Box2d GetBoundingBox2d(
                this List<V2d> pointList, int count)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Box2d GetBoundingBox2d(
                this int[] indexArray, V2d[] pointArray)
        {
            return indexArray.GetBoundingBox2d(indexArray.Length, pointArray);
        }

        public static Box2d GetBoundingBox2d(
                this int[] indexArray, int count,
                V2d[] pointArray)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2d GetBoundingBox2d(
                this int[] indexArray, int start, int count,
                V2d[] pointArray)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2d GetBoundingBox2d<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, V2d> pointSelector)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box2d GetBoundingBox2d(
                this long[] indexArray, V2d[] pointArray)
        {
            return indexArray.GetBoundingBox2d(indexArray.LongLength, pointArray);
        }

        public static Box2d GetBoundingBox2d(
                this long[] indexArray, long count,
                V2d[] pointArray)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2d GetBoundingBox2d(
                this long[] indexArray, long start, long count,
                V2d[] pointArray)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box2d GetBoundingBox2d<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, V2d> pointSelector)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box2d GetBoundingBox2d(
                this IEnumerable<V2d> points)
        {
            var box = Box2d.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Box3i

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box3i
        : IRange<V3i, Box3i>, IBoundingBox3d, ISize3d, IFormattable
    {
        [DataMember]
        public V3i Min;
        [DataMember]
        public V3i Max;

        #region Constructors

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box3i(V3i min, V3i max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box3i(int minX, int minY, int minZ, int maxX, int maxY, int maxZ)
        {
            Min.X = minX;
            Min.Y = minY;
            Min.Z = minZ;
            Max.X = maxX;
            Max.Y = maxY;
            Max.Z = maxZ;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Box3i(V3i pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        public Box3i(V3i p0, V3i p1, V3i p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        public Box3i(V3i p0, V3i p1, V3i p2, V3i p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Box3i(Box3i range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box3i(Box3i b0, Box3i b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box3i(Box3i b0, Box3i b1, Box3i b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box3i(Box3i b0, Box3i b1, Box3i b2, Box3i b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box3i(V3i[] points)
        {
            Min = Max = points[0];
            long count = points.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        public Box3i(V3i[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box3i(IEnumerable<V3i> points)
        {
            Min = V3i.MaxValue;
            Max = V3i.MinValue;
            if (points == null) return;
            foreach (V3i p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box3i(IEnumerable<Box3i> boxes)
        {
            Min = V3i.MaxValue;
            Max = V3i.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box3i(Range1i rangeX, Range1i rangeY, Range1i rangeZ)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
            Min.Z = rangeZ.Min;
            Max.Z = rangeZ.Max;
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Box3i Invalid
                = new Box3i(V3i.MaxValue, V3i.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Box3i Infinite
                = new Box3i(V3i.MinValue, V3i.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Box3i Unit = new Box3i(V3i.Zero, V3i.One);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min.AnyGreater(Max) || Min.IsNaN || Max.IsNaN; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        public V3i Size
        {
            get { return (Max - Min); }
            set { Max = (Min + value); }
        }

        public V3i Center
        {
            get { return ((Min + Max) / 2); }
        }

        public int SizeX
        {
            get { return Max.X - Min.X; }
            set { Max.X = Min.X + value; }
        }

        public Range1i RangeX
        {
            get { return new Range1i(Min.X, Max.X); }
        }

        public int SizeY
        {
            get { return Max.Y - Min.Y; }
            set { Max.Y = Min.Y + value; }
        }

        public Range1i RangeY
        {
            get { return new Range1i(Min.Y, Max.Y); }
        }

        public int SizeZ
        {
            get { return Max.Z - Min.Z; }
            set { Max.Z = Min.Z + value; }
        }

        public Range1i RangeZ
        {
            get { return new Range1i(Min.Z, Max.Z); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            get
            {
                int major = 0;
                var s = Size;
                if (s.Y > s.X) major = 1;
                if (s.Z > s[major]) major = 2;
                return major;
            }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            get
            {
                int minor = 0;
                var s = Size;
                if (s.Y < s.X) minor = 1;
                if (s.Z < s[minor]) minor = 2;
                return minor;
            }
        }

        public int SurfaceArea
        {
            get
            {
                var s = Size;
                return (s.X * s.Y + s.X * s.Z + s.Y * s.Z) * 2;
            }
        }

        public int Volume
        {
            get
            {
                if (IsInvalid) return 0;
                return SizeX * SizeY * SizeZ;
            }
        }

        public V3i OOO { get { return Min; } }
        public V3i IOO { get { return new V3i(Max.X, Min.Y, Min.Z); } }
        public V3i OIO { get { return new V3i(Min.X, Max.Y, Min.Z); } }
        public V3i IIO { get { return new V3i(Max.X, Max.Y, Min.Z); } }
        public V3i OOI { get { return new V3i(Min.X, Min.Y, Max.Z); } }
        public V3i IOI { get { return new V3i(Max.X, Min.Y, Max.Z); } }
        public V3i OII { get { return new V3i(Min.X, Max.Y, Max.Z); } }
        public V3i III { get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        public Box3i EnlargedBy(V3i increment)
        {
            return new Box3i((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        public Box3i EnlargedBy(V3i deltaMin, V3i deltaMax)
        {
            return new Box3i((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        public Box3i ShrunkBy(V3i delta)
        {
            return new Box3i((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        public Box3i ShrunkBy(V3i deltaMin, V3i deltaMax)
        {
            return new Box3i((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(V3i delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        public void EnlargeBy(V3i deltaMin, V3i deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(V3i delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        public void ShrinkBy(V3i deltaMin, V3i deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        public Box3i EnlargedBy(int delta)
        {
            return new Box3i(
                    new V3i(Min.X - delta, Min.Y - delta, Min.Z - delta),
                    new V3i(Max.X + delta, Max.Y + delta, Max.Z + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        public Box3i ShrunkBy(int delta)
        {
            return new Box3i(
                    new V3i(Min.X + delta, Min.Y + delta, Min.Z + delta),
                    new V3i(Max.X - delta, Max.Y - delta, Max.Z - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        public Box3i EnlargedBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY, 
                int deltaMinZ, int deltaMaxZ)
        {
            return new Box3i(
                    new V3i(Min.X - deltaMinX, Min.Y - deltaMinY, Min.Z - deltaMinZ),
                    new V3i(Max.X + deltaMaxX, Max.Y + deltaMaxY, Max.Z + deltaMaxZ));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        public Box3i ShrunkBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY, 
                int deltaMinZ, int deltaMaxZ)
        {
            return new Box3i(
                    new V3i(Min.X + deltaMinX, Min.Y + deltaMinY, Min.Z + deltaMinZ),
                    new V3i(Max.X - deltaMaxX, Max.Y - deltaMaxY, Max.Z - deltaMaxZ));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        public void EnlargeBy(int delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
            Min.Z -= delta; Max.Z += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        public void ShrinkBy(int delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
            Min.Z += delta; Max.Z -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        public void EnlargeBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY, 
                int deltaMinZ, int deltaMaxZ)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
            Min.Z -= deltaMinZ; Max.Z += deltaMaxZ;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        public void ShrinkBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY, 
                int deltaMinZ, int deltaMaxZ)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
            Min.Z += deltaMinZ; Max.Z -= deltaMaxZ;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        public V3i Clamped(V3i p)
        {
            return new V3i(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y), 
                        p.Z < Min.Z ? Min.Z : (p.Z > Max.Z ? Max.Z : p.Z));
        }


        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        public Box3i SplitRight(V3i splitValue)
        {
            var result = new Box3i(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            if (splitValue.Z > result.Min.Z) result.Min.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        public Box3i SplitLeft(V3i splitValue)
        {
            var result = new Box3i(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            if (splitValue.Z < result.Max.Z) result.Max.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        public Box3i ExtendedBy(Box3i b)
        {
            return new Box3i(
                    new V3i(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y, 
                        b.Min.Z < Min.Z ? b.Min.Z : Min.Z),
                    new V3i(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y, 
                        b.Max.Z > Max.Z ? b.Max.Z : Max.Z));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        public Box3i ExtendedBy(V3i v)
        {
            return new Box3i(
                    new V3i(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y, 
                        v.Z < Min.Z ? v.Z : Min.Z),
                    new V3i(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y, 
                        v.Z > Max.Z ? v.Z : Max.Z));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        public void ExtendBy(Box3i box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
            if (box.Min.Z < Min.Z) Min.Z = box.Min.Z;
            if (box.Max.Z > Max.Z) Max.Z = box.Max.Z;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        public void ExtendBy(V3i point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
            if (point.Z < Min.Z) Min.Z = point.Z;
            if (point.Z > Max.Z) Max.Z = point.Z;
        }

        public Box3i ExtendXBy(int x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        public Box3i ExtendYBy(int y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        public Box3i ExtendZBy(int z)
        {
            if (z < Min.Z) Min.Z = z;
            if (z > Max.Z) Max.Z = z;
            return this;
        }

        public Box3i ExtendDimBy(int dim, int x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        public bool Contains(V3i p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y && 
                p.Z >= Min.Z && p.Z <= Max.Z;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        public bool Contains(Box3i b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y && 
                b.Min.Z >= Min.Z && b.Max.Z <= Max.Z;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        public Box3i Repair()
        {
            if (Equals(Box3i.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            if (Min.Z > Max.Z) Fun.Swap(ref Min.Z, ref Max.Z);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        public bool Intersects(Box3i box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            if (Min.Z >= box.Max.Z) return false;
            if (Max.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box3i box, V3i eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            if (Min.Z - eps.Z >= box.Max.Z) return false;
            if (Max.Z + eps.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box3i box, int eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            if (Min.Z - eps >= box.Max.Z) return false;
            if (Max.Z + eps <= box.Min.Z) return false;
            return true;
        }

        public Box3i Invalidate()
        {
            Min = V3i.MaxValue;
            Max = V3i.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        public Box.Flags OutsideFlags(V3i p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (p0.Z < Min.Z) bf |= Box.Flags.MinZ;
            else if (p0.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        public Box.Flags OutsideFlags(Box3i b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (b.Min.Z < Min.Z) bf |= Box.Flags.MinZ;
            if (b.Max.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        public void GetMinMaxInDirection(V3i v, out V3i vMin, out V3i vMax)
        {
            vMin = V3i.MinValue;
            vMax = V3i.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
            if (v.Z >= 0)
            {
                vMin.Z = Min.Z;
                vMax.Z = Max.Z;
            }
            else
            {
                vMin.Z = Max.Z;
                vMax.Z = Min.Z;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Box3i a, Box3i b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Box3i a, Box3i b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        public static Box3i operator +(Box3i box, V3i v)
        {
            return new Box3i((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        public static Box3i operator -(Box3i box, V3i v)
        {
            return new Box3i((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Box3i) ? this == (Box3i)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box3i, int, V3i> Setter =
            (ref Box3i box, int i, V3i value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box3i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box3i(V3i.Parse(x[0].ToString()),
                                V3i.Parse(x[1].ToString()));
        }

        public static Box3i Parse(Text t)
        {
            return t.NestedBracketSplit(1, V3i.Parse, Box3i.Setter);
        }

        #endregion

        #region Various

        public static Box3i Union(Box3i a, Box3i b)
        {
            return new Box3i(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Box3i Intersection(Box3i a, Box3i b)
        {
            return new Box3i(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Box3i Union(Box3i b)
        {
            return Union(this, b);
        }

        public Box3i Intersection(Box3i b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        public static Box3i FromSize(V3i size)
        {
            return new Box3i(V3i.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        public static Box3i FromMinAndSize(V3i min, V3i size)
        {
            return new Box3i(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        public static Box3i FromCenterAndSize(V3i center, V3i size)
        {
            return new Box3i(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        public static Box3i FromSize(ISize3d iSize)
        {
            return new Box3i(
                V3i.Zero, (V3i)iSize.Size3d);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        public static Box3i FromMinAndSize(V3i min, ISize3d iSize)
        {
            return new Box3i(
                min, min + (V3i)iSize.Size3d);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        public static Box3i FromCenterAndSize(V3i center, ISize3d iSize)
        {
            var size = (V3i)iSize.Size3d;
            return new Box3i(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        public static Box3i FromPoints(V3i p0, V3i p1)
        {
            return new Box3i(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        #endregion

        #region Transforms

        public Box3i Translated(V3i shift)
        {
            return IsInvalid ? Box3i.Invalid
                             : new Box3i(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        public Box3i Scaled(V3i factor)
        {
            return IsInvalid ? Box3i.Invalid
                             : new Box3i(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box3d Transformed(M44d trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y || Min.Z > Max.Z) return Box3d.Invalid; 
            var t = new V3d(trafo.M03, trafo.M13, trafo.M23);
            var res = new Box3d(t, t);
            double av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M02 * Min.Z;
            bv = trafo.M02 * Max.Z;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M12 * Min.Z;
            bv = trafo.M12 * Max.Z;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M20 * Min.X;
            bv = trafo.M20 * Max.X;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M21 * Min.Y;
            bv = trafo.M21 * Max.Y;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M22 * Min.Z;
            bv = trafo.M22 * Max.Z;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            return res;
        }

        public Box3d Transformed(Trafo3d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        public V3i Corner(int index)
        {
            return
                new V3i(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y, 
                        (index & 4) == 0 ? Min.Z : Max.Z);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        public V3i[] ComputeCorners()
        {
            return new V3i[] {
                Min,
                new V3i(Max.X, Min.Y, Min.Z),
                new V3i(Min.X, Max.Y, Min.Z),
                new V3i(Max.X, Max.Y, Min.Z),
                new V3i(Min.X, Min.Y, Max.Z),
                new V3i(Max.X, Min.Y, Max.Z),
                new V3i(Min.X, Max.Y, Max.Z),
                Max
            };
        }

        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V3i> Corners
        {
            get
            {
                yield return Min;
                yield return new V3i(Max.X, Min.Y, Min.Z);
                yield return new V3i(Min.X, Max.Y, Min.Z);
                yield return new V3i(Max.X, Max.Y, Min.Z);
                yield return new V3i(Min.X, Min.Y, Max.Z);
                yield return new V3i(Max.X, Min.Y, Max.Z);
                yield return new V3i(Min.X, Max.Y, Max.Z);
                yield return Max;
            }
        }

        #endregion

        #region Enumerators

        /// <summary>
        /// Returns all points from [Min,Max[ with X-Variable in the outer loop.
        /// </summary>
        public IEnumerable<V3i> EnumerateInsidePoints()
        {
            var p = new V3i();
            for (p.X = Min.X; p.X < Max.X; p.X++)
            for (p.Y = Min.Y; p.Y < Max.Y; p.Y++)
            for (p.Z = Min.Z; p.Z < Max.Z; p.Z++)
                yield return p;
        }

        #endregion

        #region IBoundingBox3d Members

        public Box3d BoundingBox3d
        {
            get { return new Box3d((V3d)Min, (V3d)Max); }
        }

        #endregion

        #region ISize3d Members

        public V3d Size3d
        {
            get { return (V3d)Size; }
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingBox3i Extensions

        public static Box3i GetBoundingBox3i(
                this V3i[] pointArray)
        {
            return pointArray.GetBoundingBox3i(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingBox3i of the first count elements
        /// of the array.
        /// </summary>
        public static Box3i GetBoundingBox3i(
                this V3i[] pointArray, long count)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox3i of count elements
        /// of the array starting at start
        /// </summary>
        public static Box3i GetBoundingBox3i(
                this V3i[] pointArray, long start, long count)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox3i of count elements
        /// of the array starting at start
        /// </summary>
        public static Box3i GetBoundingBox3i<T>(
                this T[] array, long start, long count, Func<T, V3i> pointSelector)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Box3i GetBoundingBox3i(
                this List<V3i> pointList)
        {
            return pointList.GetBoundingBox3i(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingBox3i of the first count elements
        /// of the list.
        /// </summary>
        public static Box3i GetBoundingBox3i(
                this List<V3i> pointList, int count)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Box3i GetBoundingBox3i(
                this int[] indexArray, V3i[] pointArray)
        {
            return indexArray.GetBoundingBox3i(indexArray.Length, pointArray);
        }

        public static Box3i GetBoundingBox3i(
                this int[] indexArray, int count,
                V3i[] pointArray)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3i GetBoundingBox3i(
                this int[] indexArray, int start, int count,
                V3i[] pointArray)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3i GetBoundingBox3i<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, V3i> pointSelector)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box3i GetBoundingBox3i(
                this long[] indexArray, V3i[] pointArray)
        {
            return indexArray.GetBoundingBox3i(indexArray.LongLength, pointArray);
        }

        public static Box3i GetBoundingBox3i(
                this long[] indexArray, long count,
                V3i[] pointArray)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3i GetBoundingBox3i(
                this long[] indexArray, long start, long count,
                V3i[] pointArray)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3i GetBoundingBox3i<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, V3i> pointSelector)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box3i GetBoundingBox3i(
                this IEnumerable<V3i> points)
        {
            var box = Box3i.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Box3l

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box3l
        : IRange<V3l, Box3l>, IBoundingBox3d, ISize3d, IFormattable
    {
        [DataMember]
        public V3l Min;
        [DataMember]
        public V3l Max;

        #region Constructors

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box3l(V3l min, V3l max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box3l(long minX, long minY, long minZ, long maxX, long maxY, long maxZ)
        {
            Min.X = minX;
            Min.Y = minY;
            Min.Z = minZ;
            Max.X = maxX;
            Max.Y = maxY;
            Max.Z = maxZ;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Box3l(V3l pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        public Box3l(V3l p0, V3l p1, V3l p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        public Box3l(V3l p0, V3l p1, V3l p2, V3l p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Box3l(Box3l range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box3l(Box3l b0, Box3l b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box3l(Box3l b0, Box3l b1, Box3l b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box3l(Box3l b0, Box3l b1, Box3l b2, Box3l b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box3l(V3l[] points)
        {
            Min = Max = points[0];
            long count = points.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        public Box3l(V3l[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box3l(IEnumerable<V3l> points)
        {
            Min = V3l.MaxValue;
            Max = V3l.MinValue;
            if (points == null) return;
            foreach (V3l p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box3l(IEnumerable<Box3l> boxes)
        {
            Min = V3l.MaxValue;
            Max = V3l.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box3l(Range1l rangeX, Range1l rangeY, Range1l rangeZ)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
            Min.Z = rangeZ.Min;
            Max.Z = rangeZ.Max;
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Box3l Invalid
                = new Box3l(V3l.MaxValue, V3l.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Box3l Infinite
                = new Box3l(V3l.MinValue, V3l.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Box3l Unit = new Box3l(V3l.Zero, V3l.One);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min.AnyGreater(Max) || Min.IsNaN || Max.IsNaN; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        public V3l Size
        {
            get { return (Max - Min); }
            set { Max = (Min + value); }
        }

        public V3l Center
        {
            get { return ((Min + Max) / 2); }
        }

        public long SizeX
        {
            get { return Max.X - Min.X; }
            set { Max.X = Min.X + value; }
        }

        public Range1l RangeX
        {
            get { return new Range1l(Min.X, Max.X); }
        }

        public long SizeY
        {
            get { return Max.Y - Min.Y; }
            set { Max.Y = Min.Y + value; }
        }

        public Range1l RangeY
        {
            get { return new Range1l(Min.Y, Max.Y); }
        }

        public long SizeZ
        {
            get { return Max.Z - Min.Z; }
            set { Max.Z = Min.Z + value; }
        }

        public Range1l RangeZ
        {
            get { return new Range1l(Min.Z, Max.Z); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            get
            {
                int major = 0;
                var s = Size;
                if (s.Y > s.X) major = 1;
                if (s.Z > s[major]) major = 2;
                return major;
            }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            get
            {
                int minor = 0;
                var s = Size;
                if (s.Y < s.X) minor = 1;
                if (s.Z < s[minor]) minor = 2;
                return minor;
            }
        }

        public long SurfaceArea
        {
            get
            {
                var s = Size;
                return (s.X * s.Y + s.X * s.Z + s.Y * s.Z) * 2;
            }
        }

        public long Volume
        {
            get
            {
                if (IsInvalid) return 0;
                return SizeX * SizeY * SizeZ;
            }
        }

        public V3l OOO { get { return Min; } }
        public V3l IOO { get { return new V3l(Max.X, Min.Y, Min.Z); } }
        public V3l OIO { get { return new V3l(Min.X, Max.Y, Min.Z); } }
        public V3l IIO { get { return new V3l(Max.X, Max.Y, Min.Z); } }
        public V3l OOI { get { return new V3l(Min.X, Min.Y, Max.Z); } }
        public V3l IOI { get { return new V3l(Max.X, Min.Y, Max.Z); } }
        public V3l OII { get { return new V3l(Min.X, Max.Y, Max.Z); } }
        public V3l III { get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        public Box3l EnlargedBy(V3l increment)
        {
            return new Box3l((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        public Box3l EnlargedBy(V3l deltaMin, V3l deltaMax)
        {
            return new Box3l((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        public Box3l ShrunkBy(V3l delta)
        {
            return new Box3l((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        public Box3l ShrunkBy(V3l deltaMin, V3l deltaMax)
        {
            return new Box3l((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(V3l delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        public void EnlargeBy(V3l deltaMin, V3l deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(V3l delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        public void ShrinkBy(V3l deltaMin, V3l deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        public Box3l EnlargedBy(long delta)
        {
            return new Box3l(
                    new V3l(Min.X - delta, Min.Y - delta, Min.Z - delta),
                    new V3l(Max.X + delta, Max.Y + delta, Max.Z + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        public Box3l ShrunkBy(long delta)
        {
            return new Box3l(
                    new V3l(Min.X + delta, Min.Y + delta, Min.Z + delta),
                    new V3l(Max.X - delta, Max.Y - delta, Max.Z - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        public Box3l EnlargedBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY, 
                long deltaMinZ, long deltaMaxZ)
        {
            return new Box3l(
                    new V3l(Min.X - deltaMinX, Min.Y - deltaMinY, Min.Z - deltaMinZ),
                    new V3l(Max.X + deltaMaxX, Max.Y + deltaMaxY, Max.Z + deltaMaxZ));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        public Box3l ShrunkBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY, 
                long deltaMinZ, long deltaMaxZ)
        {
            return new Box3l(
                    new V3l(Min.X + deltaMinX, Min.Y + deltaMinY, Min.Z + deltaMinZ),
                    new V3l(Max.X - deltaMaxX, Max.Y - deltaMaxY, Max.Z - deltaMaxZ));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        public void EnlargeBy(long delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
            Min.Z -= delta; Max.Z += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        public void ShrinkBy(long delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
            Min.Z += delta; Max.Z -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        public void EnlargeBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY, 
                long deltaMinZ, long deltaMaxZ)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
            Min.Z -= deltaMinZ; Max.Z += deltaMaxZ;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        public void ShrinkBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY, 
                long deltaMinZ, long deltaMaxZ)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
            Min.Z += deltaMinZ; Max.Z -= deltaMaxZ;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        public V3l Clamped(V3l p)
        {
            return new V3l(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y), 
                        p.Z < Min.Z ? Min.Z : (p.Z > Max.Z ? Max.Z : p.Z));
        }


        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        public Box3l SplitRight(V3l splitValue)
        {
            var result = new Box3l(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            if (splitValue.Z > result.Min.Z) result.Min.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        public Box3l SplitLeft(V3l splitValue)
        {
            var result = new Box3l(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            if (splitValue.Z < result.Max.Z) result.Max.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        public Box3l ExtendedBy(Box3l b)
        {
            return new Box3l(
                    new V3l(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y, 
                        b.Min.Z < Min.Z ? b.Min.Z : Min.Z),
                    new V3l(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y, 
                        b.Max.Z > Max.Z ? b.Max.Z : Max.Z));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        public Box3l ExtendedBy(V3l v)
        {
            return new Box3l(
                    new V3l(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y, 
                        v.Z < Min.Z ? v.Z : Min.Z),
                    new V3l(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y, 
                        v.Z > Max.Z ? v.Z : Max.Z));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        public void ExtendBy(Box3l box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
            if (box.Min.Z < Min.Z) Min.Z = box.Min.Z;
            if (box.Max.Z > Max.Z) Max.Z = box.Max.Z;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        public void ExtendBy(V3l point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
            if (point.Z < Min.Z) Min.Z = point.Z;
            if (point.Z > Max.Z) Max.Z = point.Z;
        }

        public Box3l ExtendXBy(long x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        public Box3l ExtendYBy(long y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        public Box3l ExtendZBy(long z)
        {
            if (z < Min.Z) Min.Z = z;
            if (z > Max.Z) Max.Z = z;
            return this;
        }

        public Box3l ExtendDimBy(int dim, long x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        public bool Contains(V3l p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y && 
                p.Z >= Min.Z && p.Z <= Max.Z;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        public bool Contains(Box3l b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y && 
                b.Min.Z >= Min.Z && b.Max.Z <= Max.Z;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        public Box3l Repair()
        {
            if (Equals(Box3l.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            if (Min.Z > Max.Z) Fun.Swap(ref Min.Z, ref Max.Z);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        public bool Intersects(Box3l box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            if (Min.Z >= box.Max.Z) return false;
            if (Max.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box3l box, V3l eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            if (Min.Z - eps.Z >= box.Max.Z) return false;
            if (Max.Z + eps.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box3l box, long eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            if (Min.Z - eps >= box.Max.Z) return false;
            if (Max.Z + eps <= box.Min.Z) return false;
            return true;
        }

        public Box3l Invalidate()
        {
            Min = V3l.MaxValue;
            Max = V3l.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        public Box.Flags OutsideFlags(V3l p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (p0.Z < Min.Z) bf |= Box.Flags.MinZ;
            else if (p0.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        public Box.Flags OutsideFlags(Box3l b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (b.Min.Z < Min.Z) bf |= Box.Flags.MinZ;
            if (b.Max.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        public void GetMinMaxInDirection(V3l v, out V3l vMin, out V3l vMax)
        {
            vMin = V3l.MinValue;
            vMax = V3l.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
            if (v.Z >= 0)
            {
                vMin.Z = Min.Z;
                vMax.Z = Max.Z;
            }
            else
            {
                vMin.Z = Max.Z;
                vMax.Z = Min.Z;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Box3l a, Box3l b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Box3l a, Box3l b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        public static Box3l operator +(Box3l box, V3l v)
        {
            return new Box3l((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        public static Box3l operator -(Box3l box, V3l v)
        {
            return new Box3l((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Box3l) ? this == (Box3l)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box3l, int, V3l> Setter =
            (ref Box3l box, int i, V3l value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box3l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box3l(V3l.Parse(x[0].ToString()),
                                V3l.Parse(x[1].ToString()));
        }

        public static Box3l Parse(Text t)
        {
            return t.NestedBracketSplit(1, V3l.Parse, Box3l.Setter);
        }

        #endregion

        #region Various

        public static Box3l Union(Box3l a, Box3l b)
        {
            return new Box3l(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Box3l Intersection(Box3l a, Box3l b)
        {
            return new Box3l(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Box3l Union(Box3l b)
        {
            return Union(this, b);
        }

        public Box3l Intersection(Box3l b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        public static Box3l FromSize(V3l size)
        {
            return new Box3l(V3l.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        public static Box3l FromMinAndSize(V3l min, V3l size)
        {
            return new Box3l(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        public static Box3l FromCenterAndSize(V3l center, V3l size)
        {
            return new Box3l(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        public static Box3l FromSize(ISize3d iSize)
        {
            return new Box3l(
                V3l.Zero, (V3l)iSize.Size3d);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        public static Box3l FromMinAndSize(V3l min, ISize3d iSize)
        {
            return new Box3l(
                min, min + (V3l)iSize.Size3d);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        public static Box3l FromCenterAndSize(V3l center, ISize3d iSize)
        {
            var size = (V3l)iSize.Size3d;
            return new Box3l(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        public static Box3l FromPoints(V3l p0, V3l p1)
        {
            return new Box3l(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        #endregion

        #region Transforms

        public Box3l Translated(V3l shift)
        {
            return IsInvalid ? Box3l.Invalid
                             : new Box3l(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        public Box3l Scaled(V3l factor)
        {
            return IsInvalid ? Box3l.Invalid
                             : new Box3l(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box3d Transformed(M44d trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y || Min.Z > Max.Z) return Box3d.Invalid; 
            var t = new V3d(trafo.M03, trafo.M13, trafo.M23);
            var res = new Box3d(t, t);
            double av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M02 * Min.Z;
            bv = trafo.M02 * Max.Z;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M12 * Min.Z;
            bv = trafo.M12 * Max.Z;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M20 * Min.X;
            bv = trafo.M20 * Max.X;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M21 * Min.Y;
            bv = trafo.M21 * Max.Y;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M22 * Min.Z;
            bv = trafo.M22 * Max.Z;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            return res;
        }

        public Box3d Transformed(Trafo3d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        public V3l Corner(int index)
        {
            return
                new V3l(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y, 
                        (index & 4) == 0 ? Min.Z : Max.Z);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        public V3l[] ComputeCorners()
        {
            return new V3l[] {
                Min,
                new V3l(Max.X, Min.Y, Min.Z),
                new V3l(Min.X, Max.Y, Min.Z),
                new V3l(Max.X, Max.Y, Min.Z),
                new V3l(Min.X, Min.Y, Max.Z),
                new V3l(Max.X, Min.Y, Max.Z),
                new V3l(Min.X, Max.Y, Max.Z),
                Max
            };
        }

        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V3l> Corners
        {
            get
            {
                yield return Min;
                yield return new V3l(Max.X, Min.Y, Min.Z);
                yield return new V3l(Min.X, Max.Y, Min.Z);
                yield return new V3l(Max.X, Max.Y, Min.Z);
                yield return new V3l(Min.X, Min.Y, Max.Z);
                yield return new V3l(Max.X, Min.Y, Max.Z);
                yield return new V3l(Min.X, Max.Y, Max.Z);
                yield return Max;
            }
        }

        #endregion

        #region Enumerators

        /// <summary>
        /// Returns all points from [Min,Max[ with X-Variable in the outer loop.
        /// </summary>
        public IEnumerable<V3l> EnumerateInsidePoints()
        {
            var p = new V3l();
            for (p.X = Min.X; p.X < Max.X; p.X++)
            for (p.Y = Min.Y; p.Y < Max.Y; p.Y++)
            for (p.Z = Min.Z; p.Z < Max.Z; p.Z++)
                yield return p;
        }

        #endregion

        #region IBoundingBox3d Members

        public Box3d BoundingBox3d
        {
            get { return new Box3d((V3d)Min, (V3d)Max); }
        }

        #endregion

        #region ISize3d Members

        public V3d Size3d
        {
            get { return (V3d)Size; }
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingBox3l Extensions

        public static Box3l GetBoundingBox3l(
                this V3l[] pointArray)
        {
            return pointArray.GetBoundingBox3l(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingBox3l of the first count elements
        /// of the array.
        /// </summary>
        public static Box3l GetBoundingBox3l(
                this V3l[] pointArray, long count)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox3l of count elements
        /// of the array starting at start
        /// </summary>
        public static Box3l GetBoundingBox3l(
                this V3l[] pointArray, long start, long count)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox3l of count elements
        /// of the array starting at start
        /// </summary>
        public static Box3l GetBoundingBox3l<T>(
                this T[] array, long start, long count, Func<T, V3l> pointSelector)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Box3l GetBoundingBox3l(
                this List<V3l> pointList)
        {
            return pointList.GetBoundingBox3l(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingBox3l of the first count elements
        /// of the list.
        /// </summary>
        public static Box3l GetBoundingBox3l(
                this List<V3l> pointList, int count)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Box3l GetBoundingBox3l(
                this int[] indexArray, V3l[] pointArray)
        {
            return indexArray.GetBoundingBox3l(indexArray.Length, pointArray);
        }

        public static Box3l GetBoundingBox3l(
                this int[] indexArray, int count,
                V3l[] pointArray)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3l GetBoundingBox3l(
                this int[] indexArray, int start, int count,
                V3l[] pointArray)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3l GetBoundingBox3l<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, V3l> pointSelector)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box3l GetBoundingBox3l(
                this long[] indexArray, V3l[] pointArray)
        {
            return indexArray.GetBoundingBox3l(indexArray.LongLength, pointArray);
        }

        public static Box3l GetBoundingBox3l(
                this long[] indexArray, long count,
                V3l[] pointArray)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3l GetBoundingBox3l(
                this long[] indexArray, long start, long count,
                V3l[] pointArray)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3l GetBoundingBox3l<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, V3l> pointSelector)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box3l GetBoundingBox3l(
                this IEnumerable<V3l> points)
        {
            var box = Box3l.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Box3f

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box3f
        : IRange<V3f, Box3f>, IBoundingBox3d, ISize3d, IFormattable
    {
        [DataMember]
        public V3f Min;
        [DataMember]
        public V3f Max;

        #region Constructors

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box3f(V3f min, V3f max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box3f(float minX, float minY, float minZ, float maxX, float maxY, float maxZ)
        {
            Min.X = minX;
            Min.Y = minY;
            Min.Z = minZ;
            Max.X = maxX;
            Max.Y = maxY;
            Max.Z = maxZ;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Box3f(V3f pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        public Box3f(V3f p0, V3f p1, V3f p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        public Box3f(V3f p0, V3f p1, V3f p2, V3f p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Box3f(Box3f range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box3f(Box3f b0, Box3f b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box3f(Box3f b0, Box3f b1, Box3f b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box3f(Box3f b0, Box3f b1, Box3f b2, Box3f b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box3f(V3f[] points)
        {
            Min = Max = points[0];
            long count = points.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        public Box3f(V3f[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box3f(IEnumerable<V3f> points)
        {
            Min = V3f.MaxValue;
            Max = V3f.MinValue;
            if (points == null) return;
            foreach (V3f p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box3f(IEnumerable<Box3f> boxes)
        {
            Min = V3f.MaxValue;
            Max = V3f.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box3f(Range1f rangeX, Range1f rangeY, Range1f rangeZ)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
            Min.Z = rangeZ.Min;
            Max.Z = rangeZ.Max;
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Box3f Invalid
                = new Box3f(V3f.MaxValue, V3f.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Box3f Infinite
                = new Box3f(V3f.MinValue, V3f.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Box3f Unit = new Box3f(V3f.Zero, V3f.One);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min.AnyGreater(Max) || Min.IsNaN || Max.IsNaN; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        public V3f Size
        {
            get { return (Max - Min); }
            set { Max = (Min + value); }
        }

        public V3f Center
        {
            get { return ((Min + Max) / 2); }
        }

        public float SizeX
        {
            get { return Max.X - Min.X; }
            set { Max.X = Min.X + value; }
        }

        public Range1f RangeX
        {
            get { return new Range1f(Min.X, Max.X); }
        }

        public float SizeY
        {
            get { return Max.Y - Min.Y; }
            set { Max.Y = Min.Y + value; }
        }

        public Range1f RangeY
        {
            get { return new Range1f(Min.Y, Max.Y); }
        }

        public float SizeZ
        {
            get { return Max.Z - Min.Z; }
            set { Max.Z = Min.Z + value; }
        }

        public Range1f RangeZ
        {
            get { return new Range1f(Min.Z, Max.Z); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            get
            {
                int major = 0;
                var s = Size;
                if (s.Y > s.X) major = 1;
                if (s.Z > s[major]) major = 2;
                return major;
            }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            get
            {
                int minor = 0;
                var s = Size;
                if (s.Y < s.X) minor = 1;
                if (s.Z < s[minor]) minor = 2;
                return minor;
            }
        }

        public float SurfaceArea
        {
            get
            {
                var s = Size;
                return (s.X * s.Y + s.X * s.Z + s.Y * s.Z) * 2;
            }
        }

        public float Volume
        {
            get
            {
                if (IsInvalid) return 0;
                return SizeX * SizeY * SizeZ;
            }
        }

        public V3f OOO { get { return Min; } }
        public V3f IOO { get { return new V3f(Max.X, Min.Y, Min.Z); } }
        public V3f OIO { get { return new V3f(Min.X, Max.Y, Min.Z); } }
        public V3f IIO { get { return new V3f(Max.X, Max.Y, Min.Z); } }
        public V3f OOI { get { return new V3f(Min.X, Min.Y, Max.Z); } }
        public V3f IOI { get { return new V3f(Max.X, Min.Y, Max.Z); } }
        public V3f OII { get { return new V3f(Min.X, Max.Y, Max.Z); } }
        public V3f III { get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        public Box3f EnlargedBy(V3f increment)
        {
            return new Box3f((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        public Box3f EnlargedBy(V3f deltaMin, V3f deltaMax)
        {
            return new Box3f((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        public Box3f ShrunkBy(V3f delta)
        {
            return new Box3f((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        public Box3f ShrunkBy(V3f deltaMin, V3f deltaMax)
        {
            return new Box3f((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(V3f delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        public void EnlargeBy(V3f deltaMin, V3f deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(V3f delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        public void ShrinkBy(V3f deltaMin, V3f deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        public Box3f EnlargedBy(float delta)
        {
            return new Box3f(
                    new V3f(Min.X - delta, Min.Y - delta, Min.Z - delta),
                    new V3f(Max.X + delta, Max.Y + delta, Max.Z + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        public Box3f ShrunkBy(float delta)
        {
            return new Box3f(
                    new V3f(Min.X + delta, Min.Y + delta, Min.Z + delta),
                    new V3f(Max.X - delta, Max.Y - delta, Max.Z - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        public Box3f EnlargedBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY, 
                float deltaMinZ, float deltaMaxZ)
        {
            return new Box3f(
                    new V3f(Min.X - deltaMinX, Min.Y - deltaMinY, Min.Z - deltaMinZ),
                    new V3f(Max.X + deltaMaxX, Max.Y + deltaMaxY, Max.Z + deltaMaxZ));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        public Box3f ShrunkBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY, 
                float deltaMinZ, float deltaMaxZ)
        {
            return new Box3f(
                    new V3f(Min.X + deltaMinX, Min.Y + deltaMinY, Min.Z + deltaMinZ),
                    new V3f(Max.X - deltaMaxX, Max.Y - deltaMaxY, Max.Z - deltaMaxZ));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        public void EnlargeBy(float delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
            Min.Z -= delta; Max.Z += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        public void ShrinkBy(float delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
            Min.Z += delta; Max.Z -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        public void EnlargeBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY, 
                float deltaMinZ, float deltaMaxZ)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
            Min.Z -= deltaMinZ; Max.Z += deltaMaxZ;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        public void ShrinkBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY, 
                float deltaMinZ, float deltaMaxZ)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
            Min.Z += deltaMinZ; Max.Z -= deltaMaxZ;
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        public Box3f ScaledFromCenterBy(float factor)
        {
            var size = Size;
            var increment = (size * factor - size) / 2;
            return new Box3f(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        public Box3f ScaledFromCenterBy(V3f vectorFactor)
        {
            var size = Size;
            var increment = (size * vectorFactor - size) / 2;
            return new Box3f(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return a box enlarged in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        public Box3f EnlargedByRelativeEps(float eps)
        {
            return EnlargedBy(eps * Size.Length);
        }

        /// <summary>
        /// Enlarge the box in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        public void EnlargeByRelativeEps(float eps)
        {
            EnlargeBy(eps * Size.Length);
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        public V3f Clamped(V3f p)
        {
            return new V3f(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y), 
                        p.Z < Min.Z ? Min.Z : (p.Z > Max.Z ? Max.Z : p.Z));
        }

        /// <summary>
        /// Returns the squared distance to the supplied point.
        /// </summary>
        public double DistanceSquared(V3f p)
        {
            return 
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0)) + 
                (p.Z < Min.Z ? (Min.Z - p.Z) * (Min.Z - p.Z) : (p.Z > Max.Z ? (p.Z - Max.Z) * (p.Z - Max.Z) : 0.0));
        }

        /// <summary>
        /// Returns the distance to the supplied point.
        /// </summary>
        public double Distance(V3f p)
        {
            return Fun.Sqrt(
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0)) + 
                (p.Z < Min.Z ? (Min.Z - p.Z) * (Min.Z - p.Z) : (p.Z > Max.Z ? (p.Z - Max.Z) * (p.Z - Max.Z) : 0.0)));
        }

        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        /// <param name="x">Position between min and max [0,1].</param>
        public V3f Lerp(float x)
        {
            return Fun.Lerp(x, Min, Max);
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        public V3f Lerp(V3f p)
        {
            return new V3f(
                        Fun.Lerp(p.X, Min.X, Max.X), 
                        Fun.Lerp(p.Y, Min.Y, Max.Y), 
                        Fun.Lerp(p.Z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        public V3f Lerp(float x, float y, float z)
        {
            return new V3f(
                         Fun.Lerp(x, Min.X, Max.X), 
                         Fun.Lerp(y, Min.Y, Max.Y), 
                         Fun.Lerp(z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        public V3f InvLerp(V3f p)
        {
            return new V3f(
                        Fun.InvLerp(p.X, Min.X, Max.X), 
                        Fun.InvLerp(p.Y, Min.Y, Max.Y), 
                        Fun.InvLerp(p.Z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        public V3f InvLerp(float x, float y, float z)
        {
            return new V3f(
                        Fun.InvLerp(x, Min.X, Max.X), 
                        Fun.InvLerp(y, Min.Y, Max.Y), 
                        Fun.InvLerp(z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        public Box3f SplitRight(V3f splitValue)
        {
            var result = new Box3f(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            if (splitValue.Z > result.Min.Z) result.Min.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        public Box3f SplitLeft(V3f splitValue)
        {
            var result = new Box3f(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            if (splitValue.Z < result.Max.Z) result.Max.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        public Box3f ExtendedBy(Box3f b)
        {
            return new Box3f(
                    new V3f(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y, 
                        b.Min.Z < Min.Z ? b.Min.Z : Min.Z),
                    new V3f(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y, 
                        b.Max.Z > Max.Z ? b.Max.Z : Max.Z));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        public Box3f ExtendedBy(V3f v)
        {
            return new Box3f(
                    new V3f(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y, 
                        v.Z < Min.Z ? v.Z : Min.Z),
                    new V3f(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y, 
                        v.Z > Max.Z ? v.Z : Max.Z));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        public void ExtendBy(Box3f box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
            if (box.Min.Z < Min.Z) Min.Z = box.Min.Z;
            if (box.Max.Z > Max.Z) Max.Z = box.Max.Z;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        public void ExtendBy(V3f point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
            if (point.Z < Min.Z) Min.Z = point.Z;
            if (point.Z > Max.Z) Max.Z = point.Z;
        }

        public Box3f ExtendXBy(float x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        public Box3f ExtendYBy(float y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        public Box3f ExtendZBy(float z)
        {
            if (z < Min.Z) Min.Z = z;
            if (z > Max.Z) Max.Z = z;
            return this;
        }

        public Box3f ExtendDimBy(int dim, float x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        public bool Contains(V3f p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y && 
                p.Z >= Min.Z && p.Z <= Max.Z;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        public bool Contains(Box3f b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y && 
                b.Min.Z >= Min.Z && b.Max.Z <= Max.Z;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        public Box3f Repair()
        {
            if (Equals(Box3f.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            if (Min.Z > Max.Z) Fun.Swap(ref Min.Z, ref Max.Z);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        public bool Intersects(Box3f box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            if (Min.Z >= box.Max.Z) return false;
            if (Max.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box3f box, V3f eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            if (Min.Z - eps.Z >= box.Max.Z) return false;
            if (Max.Z + eps.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box3f box, float eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            if (Min.Z - eps >= box.Max.Z) return false;
            if (Max.Z + eps <= box.Min.Z) return false;
            return true;
        }

        public Box3f Invalidate()
        {
            Min = V3f.MaxValue;
            Max = V3f.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        public Box.Flags OutsideFlags(V3f p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (p0.Z < Min.Z) bf |= Box.Flags.MinZ;
            else if (p0.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        public Box.Flags OutsideFlags(Box3f b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (b.Min.Z < Min.Z) bf |= Box.Flags.MinZ;
            if (b.Max.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        public void GetMinMaxInDirection(V3f v, out V3f vMin, out V3f vMax)
        {
            vMin = V3f.MinValue;
            vMax = V3f.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
            if (v.Z >= 0)
            {
                vMin.Z = Min.Z;
                vMax.Z = Max.Z;
            }
            else
            {
                vMin.Z = Max.Z;
                vMax.Z = Min.Z;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Box3f a, Box3f b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Box3f a, Box3f b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        public static Box3f operator +(Box3f box, V3f v)
        {
            return new Box3f((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        public static Box3f operator -(Box3f box, V3f v)
        {
            return new Box3f((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Box3f) ? this == (Box3f)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box3f, int, V3f> Setter =
            (ref Box3f box, int i, V3f value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box3f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box3f(V3f.Parse(x[0].ToString()),
                                V3f.Parse(x[1].ToString()));
        }

        public static Box3f Parse(Text t)
        {
            return t.NestedBracketSplit(1, V3f.Parse, Box3f.Setter);
        }

        #endregion

        #region Various

        public static Box3f Union(Box3f a, Box3f b)
        {
            return new Box3f(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Box3f Intersection(Box3f a, Box3f b)
        {
            return new Box3f(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Box3f Union(Box3f b)
        {
            return Union(this, b);
        }

        public Box3f Intersection(Box3f b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        public static Box3f FromSize(V3f size)
        {
            return new Box3f(V3f.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        public static Box3f FromMinAndSize(V3f min, V3f size)
        {
            return new Box3f(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        public static Box3f FromCenterAndSize(V3f center, V3f size)
        {
            return new Box3f(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        public static Box3f FromSize(ISize3d iSize)
        {
            return new Box3f(
                V3f.Zero, (V3f)iSize.Size3d);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        public static Box3f FromMinAndSize(V3f min, ISize3d iSize)
        {
            return new Box3f(
                min, min + (V3f)iSize.Size3d);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        public static Box3f FromCenterAndSize(V3f center, ISize3d iSize)
        {
            var size = (V3f)iSize.Size3d;
            return new Box3f(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        public static Box3f FromPoints(V3f p0, V3f p1)
        {
            return new Box3f(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        #endregion

        #region Transforms

        public Box3f Translated(V3f shift)
        {
            return IsInvalid ? Box3f.Invalid
                             : new Box3f(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        public Box3f Scaled(V3f factor)
        {
            return IsInvalid ? Box3f.Invalid
                             : new Box3f(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box3d Transformed(M44d trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y || Min.Z > Max.Z) return Box3d.Invalid; 
            var t = new V3d(trafo.M03, trafo.M13, trafo.M23);
            var res = new Box3d(t, t);
            double av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M02 * Min.Z;
            bv = trafo.M02 * Max.Z;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M12 * Min.Z;
            bv = trafo.M12 * Max.Z;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M20 * Min.X;
            bv = trafo.M20 * Max.X;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M21 * Min.Y;
            bv = trafo.M21 * Max.Y;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M22 * Min.Z;
            bv = trafo.M22 * Max.Z;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            return res;
        }

        public Box3d Transformed(Trafo3d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        public V3f Corner(int index)
        {
            return
                new V3f(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y, 
                        (index & 4) == 0 ? Min.Z : Max.Z);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        public V3f[] ComputeCorners()
        {
            return new V3f[] {
                Min,
                new V3f(Max.X, Min.Y, Min.Z),
                new V3f(Min.X, Max.Y, Min.Z),
                new V3f(Max.X, Max.Y, Min.Z),
                new V3f(Min.X, Min.Y, Max.Z),
                new V3f(Max.X, Min.Y, Max.Z),
                new V3f(Min.X, Max.Y, Max.Z),
                Max
            };
        }

        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V3f> Corners
        {
            get
            {
                yield return Min;
                yield return new V3f(Max.X, Min.Y, Min.Z);
                yield return new V3f(Min.X, Max.Y, Min.Z);
                yield return new V3f(Max.X, Max.Y, Min.Z);
                yield return new V3f(Min.X, Min.Y, Max.Z);
                yield return new V3f(Max.X, Min.Y, Max.Z);
                yield return new V3f(Min.X, Max.Y, Max.Z);
                yield return Max;
            }
        }

        #endregion

        #region Enumerators

        #endregion

        #region IBoundingBox3d Members

        public Box3d BoundingBox3d
        {
            get { return new Box3d((V3d)Min, (V3d)Max); }
        }

        #endregion

        #region ISize3d Members

        public V3d Size3d
        {
            get { return (V3d)Size; }
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingBox3f Extensions

        public static Box3f GetBoundingBox3f(
                this V3f[] pointArray)
        {
            return pointArray.GetBoundingBox3f(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingBox3f of the first count elements
        /// of the array.
        /// </summary>
        public static Box3f GetBoundingBox3f(
                this V3f[] pointArray, long count)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox3f of count elements
        /// of the array starting at start
        /// </summary>
        public static Box3f GetBoundingBox3f(
                this V3f[] pointArray, long start, long count)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox3f of count elements
        /// of the array starting at start
        /// </summary>
        public static Box3f GetBoundingBox3f<T>(
                this T[] array, long start, long count, Func<T, V3f> pointSelector)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Box3f GetBoundingBox3f(
                this List<V3f> pointList)
        {
            return pointList.GetBoundingBox3f(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingBox3f of the first count elements
        /// of the list.
        /// </summary>
        public static Box3f GetBoundingBox3f(
                this List<V3f> pointList, int count)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Box3f GetBoundingBox3f(
                this int[] indexArray, V3f[] pointArray)
        {
            return indexArray.GetBoundingBox3f(indexArray.Length, pointArray);
        }

        public static Box3f GetBoundingBox3f(
                this int[] indexArray, int count,
                V3f[] pointArray)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3f GetBoundingBox3f(
                this int[] indexArray, int start, int count,
                V3f[] pointArray)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3f GetBoundingBox3f<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, V3f> pointSelector)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box3f GetBoundingBox3f(
                this long[] indexArray, V3f[] pointArray)
        {
            return indexArray.GetBoundingBox3f(indexArray.LongLength, pointArray);
        }

        public static Box3f GetBoundingBox3f(
                this long[] indexArray, long count,
                V3f[] pointArray)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3f GetBoundingBox3f(
                this long[] indexArray, long start, long count,
                V3f[] pointArray)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3f GetBoundingBox3f<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, V3f> pointSelector)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box3f GetBoundingBox3f(
                this IEnumerable<V3f> points)
        {
            var box = Box3f.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

    #region Box3d

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box3d
        : IRange<V3d, Box3d>, IBoundingBox3d, ISize3d, IFormattable
    {
        [DataMember]
        public V3d Min;
        [DataMember]
        public V3d Max;

        #region Constructors

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box3d(V3d min, V3d max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        public Box3d(double minX, double minY, double minZ, double maxX, double maxY, double maxZ)
        {
            Min.X = minX;
            Min.Y = minY;
            Min.Z = minZ;
            Max.X = maxX;
            Max.Y = maxY;
            Max.Z = maxZ;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        public Box3d(V3d pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        public Box3d(V3d p0, V3d p1, V3d p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        public Box3d(V3d p0, V3d p1, V3d p2, V3d p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        public Box3d(Box3d range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box3d(Box3d b0, Box3d b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box3d(Box3d b0, Box3d b1, Box3d b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        public Box3d(Box3d b0, Box3d b1, Box3d b2, Box3d b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box3d(V3d[] points)
        {
            Min = Max = points[0];
            long count = points.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        public Box3d(V3d[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        public Box3d(IEnumerable<V3d> points)
        {
            Min = V3d.MaxValue;
            Max = V3d.MinValue;
            if (points == null) return;
            foreach (V3d p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box3d(IEnumerable<Box3d> boxes)
        {
            Min = V3d.MaxValue;
            Max = V3d.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box3d(Range1d rangeX, Range1d rangeY, Range1d rangeZ)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
            Min.Z = rangeZ.Min;
            Max.Z = rangeZ.Max;
        }

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static readonly Box3d Invalid
                = new Box3d(V3d.MaxValue, V3d.MinValue);

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static readonly Box3d Infinite
                = new Box3d(V3d.MinValue, V3d.MaxValue);

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static readonly Box3d Unit = new Box3d(V3d.Zero, V3d.One);
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            get { return Min.AnyGreater(Max) || Min.IsNaN || Max.IsNaN; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            get { return this == Infinite; }
        }

        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        public V3d Size
        {
            get { return (Max - Min); }
            set { Max = (Min + value); }
        }

        public V3d Center
        {
            get { return ((Min + Max) / 2); }
        }

        public double SizeX
        {
            get { return Max.X - Min.X; }
            set { Max.X = Min.X + value; }
        }

        public Range1d RangeX
        {
            get { return new Range1d(Min.X, Max.X); }
        }

        public double SizeY
        {
            get { return Max.Y - Min.Y; }
            set { Max.Y = Min.Y + value; }
        }

        public Range1d RangeY
        {
            get { return new Range1d(Min.Y, Max.Y); }
        }

        public double SizeZ
        {
            get { return Max.Z - Min.Z; }
            set { Max.Z = Min.Z + value; }
        }

        public Range1d RangeZ
        {
            get { return new Range1d(Min.Z, Max.Z); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            get
            {
                int major = 0;
                var s = Size;
                if (s.Y > s.X) major = 1;
                if (s.Z > s[major]) major = 2;
                return major;
            }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            get
            {
                int minor = 0;
                var s = Size;
                if (s.Y < s.X) minor = 1;
                if (s.Z < s[minor]) minor = 2;
                return minor;
            }
        }

        public double SurfaceArea
        {
            get
            {
                var s = Size;
                return (s.X * s.Y + s.X * s.Z + s.Y * s.Z) * 2;
            }
        }

        public double Volume
        {
            get
            {
                if (IsInvalid) return 0;
                return SizeX * SizeY * SizeZ;
            }
        }

        public V3d OOO { get { return Min; } }
        public V3d IOO { get { return new V3d(Max.X, Min.Y, Min.Z); } }
        public V3d OIO { get { return new V3d(Min.X, Max.Y, Min.Z); } }
        public V3d IIO { get { return new V3d(Max.X, Max.Y, Min.Z); } }
        public V3d OOI { get { return new V3d(Min.X, Min.Y, Max.Z); } }
        public V3d IOI { get { return new V3d(Max.X, Min.Y, Max.Z); } }
        public V3d OII { get { return new V3d(Min.X, Max.Y, Max.Z); } }
        public V3d III { get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        public Box3d EnlargedBy(V3d increment)
        {
            return new Box3d((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        public Box3d EnlargedBy(V3d deltaMin, V3d deltaMax)
        {
            return new Box3d((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        public Box3d ShrunkBy(V3d delta)
        {
            return new Box3d((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        public Box3d ShrunkBy(V3d deltaMin, V3d deltaMax)
        {
            return new Box3d((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        public void EnlargeBy(V3d delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        public void EnlargeBy(V3d deltaMin, V3d deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        public void ShrinkBy(V3d delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        public void ShrinkBy(V3d deltaMin, V3d deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        public Box3d EnlargedBy(double delta)
        {
            return new Box3d(
                    new V3d(Min.X - delta, Min.Y - delta, Min.Z - delta),
                    new V3d(Max.X + delta, Max.Y + delta, Max.Z + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        public Box3d ShrunkBy(double delta)
        {
            return new Box3d(
                    new V3d(Min.X + delta, Min.Y + delta, Min.Z + delta),
                    new V3d(Max.X - delta, Max.Y - delta, Max.Z - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        public Box3d EnlargedBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY, 
                double deltaMinZ, double deltaMaxZ)
        {
            return new Box3d(
                    new V3d(Min.X - deltaMinX, Min.Y - deltaMinY, Min.Z - deltaMinZ),
                    new V3d(Max.X + deltaMaxX, Max.Y + deltaMaxY, Max.Z + deltaMaxZ));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        public Box3d ShrunkBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY, 
                double deltaMinZ, double deltaMaxZ)
        {
            return new Box3d(
                    new V3d(Min.X + deltaMinX, Min.Y + deltaMinY, Min.Z + deltaMinZ),
                    new V3d(Max.X - deltaMaxX, Max.Y - deltaMaxY, Max.Z - deltaMaxZ));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        public void EnlargeBy(double delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
            Min.Z -= delta; Max.Z += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        public void ShrinkBy(double delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
            Min.Z += delta; Max.Z -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        public void EnlargeBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY, 
                double deltaMinZ, double deltaMaxZ)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
            Min.Z -= deltaMinZ; Max.Z += deltaMaxZ;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        public void ShrinkBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY, 
                double deltaMinZ, double deltaMaxZ)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
            Min.Z += deltaMinZ; Max.Z -= deltaMaxZ;
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        public Box3d ScaledFromCenterBy(double factor)
        {
            var size = Size;
            var increment = (size * factor - size) / 2;
            return new Box3d(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        public Box3d ScaledFromCenterBy(V3d vectorFactor)
        {
            var size = Size;
            var increment = (size * vectorFactor - size) / 2;
            return new Box3d(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return a box enlarged in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        public Box3d EnlargedByRelativeEps(double eps)
        {
            return EnlargedBy(eps * Size.Length);
        }

        /// <summary>
        /// Enlarge the box in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        public void EnlargeByRelativeEps(double eps)
        {
            EnlargeBy(eps * Size.Length);
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        public V3d Clamped(V3d p)
        {
            return new V3d(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y), 
                        p.Z < Min.Z ? Min.Z : (p.Z > Max.Z ? Max.Z : p.Z));
        }

        /// <summary>
        /// Returns the squared distance to the supplied point.
        /// </summary>
        public double DistanceSquared(V3d p)
        {
            return 
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0)) + 
                (p.Z < Min.Z ? (Min.Z - p.Z) * (Min.Z - p.Z) : (p.Z > Max.Z ? (p.Z - Max.Z) * (p.Z - Max.Z) : 0.0));
        }

        /// <summary>
        /// Returns the distance to the supplied point.
        /// </summary>
        public double Distance(V3d p)
        {
            return Fun.Sqrt(
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0)) + 
                (p.Z < Min.Z ? (Min.Z - p.Z) * (Min.Z - p.Z) : (p.Z > Max.Z ? (p.Z - Max.Z) * (p.Z - Max.Z) : 0.0)));
        }

        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        /// <param name="x">Position between min and max [0,1].</param>
        public V3d Lerp(double x)
        {
            return Fun.Lerp(x, Min, Max);
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        public V3d Lerp(V3d p)
        {
            return new V3d(
                        Fun.Lerp(p.X, Min.X, Max.X), 
                        Fun.Lerp(p.Y, Min.Y, Max.Y), 
                        Fun.Lerp(p.Z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        public V3d Lerp(double x, double y, double z)
        {
            return new V3d(
                         Fun.Lerp(x, Min.X, Max.X), 
                         Fun.Lerp(y, Min.Y, Max.Y), 
                         Fun.Lerp(z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        public V3d InvLerp(V3d p)
        {
            return new V3d(
                        Fun.InvLerp(p.X, Min.X, Max.X), 
                        Fun.InvLerp(p.Y, Min.Y, Max.Y), 
                        Fun.InvLerp(p.Z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        public V3d InvLerp(double x, double y, double z)
        {
            return new V3d(
                        Fun.InvLerp(x, Min.X, Max.X), 
                        Fun.InvLerp(y, Min.Y, Max.Y), 
                        Fun.InvLerp(z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        public Box3d SplitRight(V3d splitValue)
        {
            var result = new Box3d(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            if (splitValue.Z > result.Min.Z) result.Min.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        public Box3d SplitLeft(V3d splitValue)
        {
            var result = new Box3d(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            if (splitValue.Z < result.Max.Z) result.Max.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        public Box3d ExtendedBy(Box3d b)
        {
            return new Box3d(
                    new V3d(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y, 
                        b.Min.Z < Min.Z ? b.Min.Z : Min.Z),
                    new V3d(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y, 
                        b.Max.Z > Max.Z ? b.Max.Z : Max.Z));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        public Box3d ExtendedBy(V3d v)
        {
            return new Box3d(
                    new V3d(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y, 
                        v.Z < Min.Z ? v.Z : Min.Z),
                    new V3d(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y, 
                        v.Z > Max.Z ? v.Z : Max.Z));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        public void ExtendBy(Box3d box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
            if (box.Min.Z < Min.Z) Min.Z = box.Min.Z;
            if (box.Max.Z > Max.Z) Max.Z = box.Max.Z;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        public void ExtendBy(V3d point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
            if (point.Z < Min.Z) Min.Z = point.Z;
            if (point.Z > Max.Z) Max.Z = point.Z;
        }

        public Box3d ExtendXBy(double x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        public Box3d ExtendYBy(double y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        public Box3d ExtendZBy(double z)
        {
            if (z < Min.Z) Min.Z = z;
            if (z > Max.Z) Max.Z = z;
            return this;
        }

        public Box3d ExtendDimBy(int dim, double x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        public bool Contains(V3d p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y && 
                p.Z >= Min.Z && p.Z <= Max.Z;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        public bool Contains(Box3d b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y && 
                b.Min.Z >= Min.Z && b.Max.Z <= Max.Z;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        public Box3d Repair()
        {
            if (Equals(Box3d.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            if (Min.Z > Max.Z) Fun.Swap(ref Min.Z, ref Max.Z);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        public bool Intersects(Box3d box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            if (Min.Z >= box.Max.Z) return false;
            if (Max.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box3d box, V3d eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            if (Min.Z - eps.Z >= box.Max.Z) return false;
            if (Max.Z + eps.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        public bool Intersects(Box3d box, double eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            if (Min.Z - eps >= box.Max.Z) return false;
            if (Max.Z + eps <= box.Min.Z) return false;
            return true;
        }

        public Box3d Invalidate()
        {
            Min = V3d.MaxValue;
            Max = V3d.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        public Box.Flags OutsideFlags(V3d p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (p0.Z < Min.Z) bf |= Box.Flags.MinZ;
            else if (p0.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        public Box.Flags OutsideFlags(Box3d b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (b.Min.Z < Min.Z) bf |= Box.Flags.MinZ;
            if (b.Max.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        public void GetMinMaxInDirection(V3d v, out V3d vMin, out V3d vMax)
        {
            vMin = V3d.MinValue;
            vMax = V3d.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
            if (v.Z >= 0)
            {
                vMin.Z = Min.Z;
                vMax.Z = Max.Z;
            }
            else
            {
                vMin.Z = Max.Z;
                vMax.Z = Min.Z;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator ==(Box3d a, Box3d b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        public static bool operator !=(Box3d a, Box3d b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        public static Box3d operator +(Box3d box, V3d v)
        {
            return new Box3d((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        public static Box3d operator -(Box3d box, V3d v)
        {
            return new Box3d((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        public override bool Equals(object obj)
        {
            return (obj is Box3d) ? this == (Box3d)obj : false;
        }

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box3d, int, V3d> Setter =
            (ref Box3d box, int i, V3d value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box3d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box3d(V3d.Parse(x[0].ToString()),
                                V3d.Parse(x[1].ToString()));
        }

        public static Box3d Parse(Text t)
        {
            return t.NestedBracketSplit(1, V3d.Parse, Box3d.Setter);
        }

        #endregion

        #region Various

        public static Box3d Union(Box3d a, Box3d b)
        {
            return new Box3d(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        public static Box3d Intersection(Box3d a, Box3d b)
        {
            return new Box3d(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        public Box3d Union(Box3d b)
        {
            return Union(this, b);
        }

        public Box3d Intersection(Box3d b)
        {
            return Intersection(this, b);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        public static Box3d FromSize(V3d size)
        {
            return new Box3d(V3d.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        public static Box3d FromMinAndSize(V3d min, V3d size)
        {
            return new Box3d(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        public static Box3d FromCenterAndSize(V3d center, V3d size)
        {
            return new Box3d(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        public static Box3d FromSize(ISize3d iSize)
        {
            return new Box3d(
                V3d.Zero, iSize.Size3d);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        public static Box3d FromMinAndSize(V3d min, ISize3d iSize)
        {
            return new Box3d(
                min, min + iSize.Size3d);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        public static Box3d FromCenterAndSize(V3d center, ISize3d iSize)
        {
            var size = iSize.Size3d;
            return new Box3d(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        public static Box3d FromPoints(V3d p0, V3d p1)
        {
            return new Box3d(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        #endregion

        #region Transforms

        public Box3d Translated(V3d shift)
        {
            return IsInvalid ? Box3d.Invalid
                             : new Box3d(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        public Box3d Scaled(V3d factor)
        {
            return IsInvalid ? Box3d.Invalid
                             : new Box3d(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box3d Transformed(M44d trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y || Min.Z > Max.Z) return Box3d.Invalid; 
            var t = new V3d(trafo.M03, trafo.M13, trafo.M23);
            var res = new Box3d(t, t);
            double av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M02 * Min.Z;
            bv = trafo.M02 * Max.Z;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M12 * Min.Z;
            bv = trafo.M12 * Max.Z;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M20 * Min.X;
            bv = trafo.M20 * Max.X;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M21 * Min.Y;
            bv = trafo.M21 * Max.Y;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M22 * Min.Z;
            bv = trafo.M22 * Max.Z;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            return res;
        }

        public Box3d Transformed(Trafo3d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        public V3d Corner(int index)
        {
            return
                new V3d(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y, 
                        (index & 4) == 0 ? Min.Z : Max.Z);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        public V3d[] ComputeCorners()
        {
            return new V3d[] {
                Min,
                new V3d(Max.X, Min.Y, Min.Z),
                new V3d(Min.X, Max.Y, Min.Z),
                new V3d(Max.X, Max.Y, Min.Z),
                new V3d(Min.X, Min.Y, Max.Z),
                new V3d(Max.X, Min.Y, Max.Z),
                new V3d(Min.X, Max.Y, Max.Z),
                Max
            };
        }

        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V3d> Corners
        {
            get
            {
                yield return Min;
                yield return new V3d(Max.X, Min.Y, Min.Z);
                yield return new V3d(Min.X, Max.Y, Min.Z);
                yield return new V3d(Max.X, Max.Y, Min.Z);
                yield return new V3d(Min.X, Min.Y, Max.Z);
                yield return new V3d(Max.X, Min.Y, Max.Z);
                yield return new V3d(Min.X, Max.Y, Max.Z);
                yield return Max;
            }
        }

        #endregion

        #region Enumerators

        #endregion

        #region IBoundingBox3d Members

        public Box3d BoundingBox3d
        {
            get { return new Box3d(Min, Max); }
        }

        #endregion

        #region ISize3d Members

        public V3d Size3d
        {
            get { return Size; }
        }

        #endregion

    }

    public static partial class BoxFun
    {
        #region Collection GetBoundingBox3d Extensions

        public static Box3d GetBoundingBox3d(
                this V3d[] pointArray)
        {
            return pointArray.GetBoundingBox3d(pointArray.LongLength);
        }

        /// <summary>
        /// Returns the BoundingBox3d of the first count elements
        /// of the array.
        /// </summary>
        public static Box3d GetBoundingBox3d(
                this V3d[] pointArray, long count)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointArray[0]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox3d of count elements
        /// of the array starting at start
        /// </summary>
        public static Box3d GetBoundingBox3d(
                this V3d[] pointArray, long start, long count)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the BoundingBox3d of count elements
        /// of the array starting at start
        /// </summary>
        public static Box3d GetBoundingBox3d<T>(
                this T[] array, long start, long count, Func<T, V3d> pointSelector)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        public static Box3d GetBoundingBox3d(
                this List<V3d> pointList)
        {
            return pointList.GetBoundingBox3d(pointList.Count);
        }

        /// <summary>
        /// Returns the BoundingBox3d of the first count elements
        /// of the list.
        /// </summary>
        public static Box3d GetBoundingBox3d(
                this List<V3d> pointList, int count)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        public static Box3d GetBoundingBox3d(
                this int[] indexArray, V3d[] pointArray)
        {
            return indexArray.GetBoundingBox3d(indexArray.Length, pointArray);
        }

        public static Box3d GetBoundingBox3d(
                this int[] indexArray, int count,
                V3d[] pointArray)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointArray[indexArray[0]]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3d GetBoundingBox3d(
                this int[] indexArray, int start, int count,
                V3d[] pointArray)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3d GetBoundingBox3d<T>(
                this int[] indexArray, int start, int count,
                T[] array, Func<T, V3d> pointSelector)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box3d GetBoundingBox3d(
                this long[] indexArray, V3d[] pointArray)
        {
            return indexArray.GetBoundingBox3d(indexArray.LongLength, pointArray);
        }

        public static Box3d GetBoundingBox3d(
                this long[] indexArray, long count,
                V3d[] pointArray)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointArray[indexArray[0]]);
            for (long i = 1; i < count; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3d GetBoundingBox3d(
                this long[] indexArray, long start, long count,
                V3d[] pointArray)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        public static Box3d GetBoundingBox3d<T>(
                this long[] indexArray, long start, long count,
                T[] array, Func<T, V3d> pointSelector)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        public static Box3d GetBoundingBox3d(
                this IEnumerable<V3d> points)
        {
            var box = Box3d.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #endregion

}
