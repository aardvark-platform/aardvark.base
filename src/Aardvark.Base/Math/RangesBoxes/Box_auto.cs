using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;
using System.Xml.Serialization;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    #region Flags

    public static partial class Box
    {
        [Flags]
        public enum Flags
        {
            None = 0x00000000,

            /* ---------------------------------------------------------------
                flags that mark the faces of a box
            --------------------------------------------------------------- */
            MinX0 = 0x00000001,
            MinY0 = 0x00000002,
            MinZ0 = 0x00000004,

            MaxX0 = 0x00000008,
            MaxY0 = 0x00000010,
            MaxZ0 = 0x00000020,

            Min0 = MinX0 | MinY0 | MinZ0,
            Max0 = MaxX0 | MaxY0 | MaxZ0,

            X0 = MinX0 | MaxX0,
            Y0 = MinY0 | MaxY0,
            Z0 = MinZ0 | MaxZ0,

            All0 = Min0 | Max0,

            /* ---------------------------------------------------------------
                flags that mark the faces of a second, independent box
            --------------------------------------------------------------- */
            MinX1 = MinX0 << 6,
            MinY1 = MinY0 << 6,
            MinZ1 = MinZ0 << 6,
            MaxX1 = MaxX0 << 6,
            MaxY1 = MaxY0 << 6,
            MaxZ1 = MaxZ0 << 6,
            Min1 = Min0 << 6,
            Max1 = Max0 << 6,
            X1 = X0 << 6,
            Y1 = Y0 << 6,
            Z1 = Z0 << 6,
            All1 = All0 << 6,

            /* ---------------------------------------------------------------
                flags that operate on both face bits together
            --------------------------------------------------------------- */
            MinX = MinX0 | MinX1,
            MinY = MinY0 | MinY1,
            MinZ = MinZ0 | MinZ1,
            MaxX = MaxX0 | MaxX1,
            MaxY = MaxY0 | MaxY1,
            MaxZ = MaxZ0 | MaxZ1,
            Min = Min0 | Min1,
            Max = Max0 | Max1,
            MinXMinY = MinX | MinY,
            MinXMaxY = MinX | MaxY,
            MaxXMinY = MaxX | MinY,
            MaxXMaxY = MaxX | MaxY,
            X = X0 | X1,
            Y = Y0 | Y1,
            Z = Z0 | Z1,
            All = All0 | All1,

            /* ---------------------------------------------------------------
                flags that mark the edges of the box
            --------------------------------------------------------------- */
            Edge01 = 0x00001000,
            Edge23 = 0x00002000,
            Edge45 = 0x00004000,
            Edge67 = 0x00008000,
            Edge02 = 0x00010000,
            Edge13 = 0x00020000,
            Edge46 = 0x00040000,
            Edge57 = 0x00080000,
            Edge04 = 0x00100000,
            Edge15 = 0x00200000,
            Edge26 = 0x00400000,
            Edge37 = 0x00800000,

            /* ---------------------------------------------------------------
                flags that mark the corners of the box
            --------------------------------------------------------------- */
            Corner0 = 0x01000000,
            Corner1 = 0x02000000,
            Corner2 = 0x04000000,
            Corner3 = 0x08000000,
            Corner4 = 0x10000000,
            Corner5 = 0x20000000,
            Corner6 = 0x40000000,
            Corner7 = (int)-0x80000000,
        }
    }

    #endregion

    #region Range1b

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1b
        : IEquatable<Range1b>, IRange<byte, Range1b>,  IFormattable
    {
        [DataMember]
        public byte Min;
        [DataMember]
        public byte Max;

        #region Constructors

        /// <summary>
        /// Construct a Range1b from a Range1sb.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(Range1sb b)
        {
            Min = (byte) b.Min;
            Max = (byte) b.Max;
        }

        /// <summary>
        /// Construct a Range1b from a Range1s.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(Range1s b)
        {
            Min = (byte) b.Min;
            Max = (byte) b.Max;
        }

        /// <summary>
        /// Construct a Range1b from a Range1us.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(Range1us b)
        {
            Min = (byte) b.Min;
            Max = (byte) b.Max;
        }

        /// <summary>
        /// Construct a Range1b from a Range1i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(Range1i b)
        {
            Min = (byte) b.Min;
            Max = (byte) b.Max;
        }

        /// <summary>
        /// Construct a Range1b from a Range1ui.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(Range1ui b)
        {
            Min = (byte) b.Min;
            Max = (byte) b.Max;
        }

        /// <summary>
        /// Construct a Range1b from a Range1l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(Range1l b)
        {
            Min = (byte) b.Min;
            Max = (byte) b.Max;
        }

        /// <summary>
        /// Construct a Range1b from a Range1ul.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(Range1ul b)
        {
            Min = (byte) b.Min;
            Max = (byte) b.Max;
        }

        /// <summary>
        /// Construct a Range1b from a Range1f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(Range1f b)
        {
            Min = (byte) b.Min;
            Max = (byte) b.Max;
        }

        /// <summary>
        /// Construct a Range1b from a Range1d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(Range1d b)
        {
            Min = (byte) b.Min;
            Max = (byte) b.Max;
        }

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(byte min, byte max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(byte pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(byte p0, byte p1, byte p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(byte p0, byte p1, byte p2, byte p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(Range1b range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(Range1b b0, Range1b b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(Range1b b0, Range1b b1, Range1b b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(Range1b b0, Range1b b1, Range1b b2, Range1b b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(byte[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(byte[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b(IEnumerable<byte> values)
        {
            Min = byte.MaxValue;
            Max = byte.MinValue;
            foreach (byte v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1b FromMinAndSize(byte min, byte size)
        {
            return new Range1b(min, (byte)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1b FromCenterAndSize(byte center, byte size)
        {
            return new Range1b((byte)(center - size / 2), (byte)(center + size / 2));
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1b(Range1sb b)
            => new Range1b(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1b(Range1s b)
            => new Range1b(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1b(Range1us b)
            => new Range1b(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1b(Range1i b)
            => new Range1b(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1b(Range1ui b)
            => new Range1b(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1b(Range1l b)
            => new Range1b(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1b(Range1ul b)
            => new Range1b(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1b(Range1f b)
            => new Range1b(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1b(Range1d b)
            => new Range1b(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Range1b Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1b(byte.MaxValue, byte.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Range1b Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1b(byte.MinValue, byte.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Range1b Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1b(0, 1); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }


        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        [XmlIgnore]
        public byte Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (byte)(Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (byte)(Min + value); }
        }

        public byte Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (byte)((Min + Max) / 2); }
        }

        public IEnumerable<byte> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b EnlargedBy(byte increment)
        {
            return new Range1b((byte)(Min - increment), (byte)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b EnlargedBy(byte deltaMin, byte deltaMax)
        {
            return new Range1b((byte)(Min - deltaMin), (byte)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b ShrunkBy(byte delta)
        {
            return new Range1b((byte)(Min + delta), (byte)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b ShrunkBy(byte deltaMin, byte deltaMax)
        {
            return new Range1b((byte)(Min + deltaMin), (byte)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(byte delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(byte deltaMin, byte deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(byte delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(byte deltaMin, byte deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public byte Clamped(byte x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b SplitRight(byte splitValue)
        {
            if (splitValue > Max) return Range1b.Invalid;
            if (splitValue <= Min) return this;
            return new Range1b(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b SplitLeft(byte splitValue)
        {
            if (splitValue < Min) return Range1b.Invalid;
            if (splitValue >= Max) return this;
            return new Range1b(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b ExtendedBy(Range1b range)
        {
            return new Range1b(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b ExtendedBy(byte value)
        {
            return new Range1b(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Range1b range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(byte value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(byte value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Range1b b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1b range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1b range, byte eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1b Repair()
        {
            if (this.Equals(Range1b.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Range1b a, Range1b b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Range1b a, Range1b b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1b operator +(Range1b box, byte v)
        {
            return new Range1b((byte)(box.Min + v), (byte)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1b operator -(Range1b box, byte v)
        {
            return new Range1b((byte)(box.Min - v), (byte)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Range1b other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Range1b o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1b, int, byte> Setter =
            (ref Range1b box, int i, byte value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1b Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1b(byte.Parse(x[0], CultureInfo.InvariantCulture),
                                byte.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1b Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<byte>.Parse, Range1b.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion
    }

    public static partial class Range
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1b Union(this Range1b a, Range1b b)
        {
            return new Range1b(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1b Intersection(this Range1b a, Range1b b)
        {
            return new Range1b(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        /// <summary>
        /// Checks if two ranges intersect each other with a tolerance parameter.
        /// </summary>
        // TODO: Implement for d > 2
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Intersects(this Range1b a, Range1b b, byte eps, out Range1b result)
        {
            result = Range1b.Invalid;
            if (a.Min - eps > b.Max) return false;
            else if (a.Max + eps < b.Min) return false;
            else
            {
                result = new Range1b(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
                if (result.Size < eps)
                {
                    byte center = result.Center;
                    result.Min = (byte)(center - eps);
                    result.Max = (byte)(center + eps);
                }
                return true;
            }
        }

        #endregion

        #region Bounding range for arrays

        /// <summary>
        /// Returns the bounding range of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1b GetBoundingRange(this byte[] pointArray)
        {
            return pointArray.GetBoundingRange(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1b GetBoundingRange(this byte[] pointArray, long count)
        {
            return pointArray.GetBoundingRange(0, count);
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1b GetBoundingRange(
                this byte[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1b GetBoundingRange<T>(this T[] array, long start, long count, Func<T, byte> pointSelector)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding range for lists

        /// <summary>
        /// Returns the bounding range of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1b GetBoundingRange(this List<byte> pointList)
        {
            return pointList.GetBoundingRange(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the list.
        /// </summary>
        public static Range1b GetBoundingRange(this List<byte> pointList, int count)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding range for indexed arrays

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1b GetBoundingRange(this int[] indexArray, byte[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1b GetBoundingRange(this int[] indexArray, int count, byte[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1b GetBoundingRange(this int[] indexArray, int start, int count, byte[] pointArray)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1b GetBoundingRange<T>(this int[] indexArray, int start, int count, T[] array, Func<T, byte> pointSelector)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1b GetBoundingRange(this long[] indexArray, byte[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1b GetBoundingRange(this long[] indexArray, long count, byte[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1b GetBoundingRange(this long[] indexArray, long start, long count, byte[] pointArray)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1b GetBoundingRange<T>(this long[] indexArray, long start, long count, T[] array, Func<T, byte> pointSelector)
        {
            if (count <= 0) return Range1b.Invalid;
            var box = new Range1b(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding range for IEnumerable

        /// <summary>
        /// Returns the bounding range of the elements of the collection.
        /// </summary>
        public static Range1b GetBoundingRange(this IEnumerable<byte> points)
        {
            var box = Range1b.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #region Range extensions

    public static partial class RangeExtensions
    {
        /// <summary>
        /// Returns the int sequence 0 ... count-1.
        /// </summary>
        public static IEnumerable<byte> Range(this byte count)
        {
            for (byte i = 0; i < count; i++) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<byte> UpTo(this byte self, byte upToInclusive)
        {
            return self.UpTo(upToInclusive, 1);
        }

        public static IEnumerable<byte> UpTo(this byte self, byte upToInclusive, byte step)
        {
            for (byte i = self; i <= upToInclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<byte> UpToExclusive(this byte self, byte upToExclusive)
        {
            return self.UpToExclusive(upToExclusive, 1);
        }

        public static IEnumerable<byte> UpToExclusive(this byte self, byte upToExclusive, byte step)
        {
            for (byte i = self; i < upToExclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<byte> DownTo(this byte self, byte downToInclusive)
        {
            return self.DownTo(downToInclusive, 1);
        }

        public static IEnumerable<byte> DownTo(this byte self, byte downToInclusive, byte step)
        {
            for (byte i = self; i >= downToInclusive; i -= step) yield return i;
        }
    }

    #endregion

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1b a, Range1b b)
        {
            return ApproximateEquals(a, b, Constant<byte>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1b a, Range1b b, byte tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Range1sb

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1sb
        : IEquatable<Range1sb>, IRange<sbyte, Range1sb>,  IFormattable
    {
        [DataMember]
        public sbyte Min;
        [DataMember]
        public sbyte Max;

        #region Constructors

        /// <summary>
        /// Construct a Range1sb from a Range1b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(Range1b b)
        {
            Min = (sbyte) b.Min;
            Max = (sbyte) b.Max;
        }

        /// <summary>
        /// Construct a Range1sb from a Range1s.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(Range1s b)
        {
            Min = (sbyte) b.Min;
            Max = (sbyte) b.Max;
        }

        /// <summary>
        /// Construct a Range1sb from a Range1us.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(Range1us b)
        {
            Min = (sbyte) b.Min;
            Max = (sbyte) b.Max;
        }

        /// <summary>
        /// Construct a Range1sb from a Range1i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(Range1i b)
        {
            Min = (sbyte) b.Min;
            Max = (sbyte) b.Max;
        }

        /// <summary>
        /// Construct a Range1sb from a Range1ui.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(Range1ui b)
        {
            Min = (sbyte) b.Min;
            Max = (sbyte) b.Max;
        }

        /// <summary>
        /// Construct a Range1sb from a Range1l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(Range1l b)
        {
            Min = (sbyte) b.Min;
            Max = (sbyte) b.Max;
        }

        /// <summary>
        /// Construct a Range1sb from a Range1ul.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(Range1ul b)
        {
            Min = (sbyte) b.Min;
            Max = (sbyte) b.Max;
        }

        /// <summary>
        /// Construct a Range1sb from a Range1f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(Range1f b)
        {
            Min = (sbyte) b.Min;
            Max = (sbyte) b.Max;
        }

        /// <summary>
        /// Construct a Range1sb from a Range1d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(Range1d b)
        {
            Min = (sbyte) b.Min;
            Max = (sbyte) b.Max;
        }

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(sbyte min, sbyte max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(sbyte pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(sbyte p0, sbyte p1, sbyte p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(sbyte p0, sbyte p1, sbyte p2, sbyte p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(Range1sb range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(Range1sb b0, Range1sb b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(Range1sb b0, Range1sb b1, Range1sb b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(Range1sb b0, Range1sb b1, Range1sb b2, Range1sb b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(sbyte[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(sbyte[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb(IEnumerable<sbyte> values)
        {
            Min = sbyte.MaxValue;
            Max = sbyte.MinValue;
            foreach (sbyte v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1sb FromMinAndSize(sbyte min, sbyte size)
        {
            return new Range1sb(min, (sbyte)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1sb FromCenterAndSize(sbyte center, sbyte size)
        {
            return new Range1sb((sbyte)(center - size / 2), (sbyte)(center + size / 2));
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1sb(Range1b b)
            => new Range1sb(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1sb(Range1s b)
            => new Range1sb(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1sb(Range1us b)
            => new Range1sb(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1sb(Range1i b)
            => new Range1sb(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1sb(Range1ui b)
            => new Range1sb(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1sb(Range1l b)
            => new Range1sb(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1sb(Range1ul b)
            => new Range1sb(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1sb(Range1f b)
            => new Range1sb(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1sb(Range1d b)
            => new Range1sb(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Range1sb Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1sb(sbyte.MaxValue, sbyte.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Range1sb Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1sb(sbyte.MinValue, sbyte.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Range1sb Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1sb(0, 1); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }


        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        [XmlIgnore]
        public sbyte Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (sbyte)(Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (sbyte)(Min + value); }
        }

        public sbyte Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (sbyte)((Min + Max) / 2); }
        }

        public IEnumerable<sbyte> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb EnlargedBy(sbyte increment)
        {
            return new Range1sb((sbyte)(Min - increment), (sbyte)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb EnlargedBy(sbyte deltaMin, sbyte deltaMax)
        {
            return new Range1sb((sbyte)(Min - deltaMin), (sbyte)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb ShrunkBy(sbyte delta)
        {
            return new Range1sb((sbyte)(Min + delta), (sbyte)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb ShrunkBy(sbyte deltaMin, sbyte deltaMax)
        {
            return new Range1sb((sbyte)(Min + deltaMin), (sbyte)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(sbyte delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(sbyte deltaMin, sbyte deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(sbyte delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(sbyte deltaMin, sbyte deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public sbyte Clamped(sbyte x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb SplitRight(sbyte splitValue)
        {
            if (splitValue > Max) return Range1sb.Invalid;
            if (splitValue <= Min) return this;
            return new Range1sb(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb SplitLeft(sbyte splitValue)
        {
            if (splitValue < Min) return Range1sb.Invalid;
            if (splitValue >= Max) return this;
            return new Range1sb(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb ExtendedBy(Range1sb range)
        {
            return new Range1sb(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb ExtendedBy(sbyte value)
        {
            return new Range1sb(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Range1sb range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(sbyte value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(sbyte value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Range1sb b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1sb range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1sb range, sbyte eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1sb Repair()
        {
            if (this.Equals(Range1sb.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Range1sb a, Range1sb b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Range1sb a, Range1sb b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1sb operator +(Range1sb box, sbyte v)
        {
            return new Range1sb((sbyte)(box.Min + v), (sbyte)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1sb operator -(Range1sb box, sbyte v)
        {
            return new Range1sb((sbyte)(box.Min - v), (sbyte)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Range1sb other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Range1sb o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1sb, int, sbyte> Setter =
            (ref Range1sb box, int i, sbyte value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1sb Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1sb(sbyte.Parse(x[0], CultureInfo.InvariantCulture),
                                sbyte.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1sb Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<sbyte>.Parse, Range1sb.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion
    }

    public static partial class Range
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1sb Union(this Range1sb a, Range1sb b)
        {
            return new Range1sb(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1sb Intersection(this Range1sb a, Range1sb b)
        {
            return new Range1sb(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        /// <summary>
        /// Checks if two ranges intersect each other with a tolerance parameter.
        /// </summary>
        // TODO: Implement for d > 2
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Intersects(this Range1sb a, Range1sb b, sbyte eps, out Range1sb result)
        {
            result = Range1sb.Invalid;
            if (a.Min - eps > b.Max) return false;
            else if (a.Max + eps < b.Min) return false;
            else
            {
                result = new Range1sb(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
                if (result.Size < eps)
                {
                    sbyte center = result.Center;
                    result.Min = (sbyte)(center - eps);
                    result.Max = (sbyte)(center + eps);
                }
                return true;
            }
        }

        #endregion

        #region Bounding range for arrays

        /// <summary>
        /// Returns the bounding range of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1sb GetBoundingRange(this sbyte[] pointArray)
        {
            return pointArray.GetBoundingRange(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1sb GetBoundingRange(this sbyte[] pointArray, long count)
        {
            return pointArray.GetBoundingRange(0, count);
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1sb GetBoundingRange(
                this sbyte[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1sb GetBoundingRange<T>(this T[] array, long start, long count, Func<T, sbyte> pointSelector)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding range for lists

        /// <summary>
        /// Returns the bounding range of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1sb GetBoundingRange(this List<sbyte> pointList)
        {
            return pointList.GetBoundingRange(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the list.
        /// </summary>
        public static Range1sb GetBoundingRange(this List<sbyte> pointList, int count)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding range for indexed arrays

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1sb GetBoundingRange(this int[] indexArray, sbyte[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1sb GetBoundingRange(this int[] indexArray, int count, sbyte[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1sb GetBoundingRange(this int[] indexArray, int start, int count, sbyte[] pointArray)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1sb GetBoundingRange<T>(this int[] indexArray, int start, int count, T[] array, Func<T, sbyte> pointSelector)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1sb GetBoundingRange(this long[] indexArray, sbyte[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1sb GetBoundingRange(this long[] indexArray, long count, sbyte[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1sb GetBoundingRange(this long[] indexArray, long start, long count, sbyte[] pointArray)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1sb GetBoundingRange<T>(this long[] indexArray, long start, long count, T[] array, Func<T, sbyte> pointSelector)
        {
            if (count <= 0) return Range1sb.Invalid;
            var box = new Range1sb(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding range for IEnumerable

        /// <summary>
        /// Returns the bounding range of the elements of the collection.
        /// </summary>
        public static Range1sb GetBoundingRange(this IEnumerable<sbyte> points)
        {
            var box = Range1sb.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #region Range extensions

    public static partial class RangeExtensions
    {
        /// <summary>
        /// Returns the int sequence 0 ... count-1.
        /// </summary>
        public static IEnumerable<sbyte> Range(this sbyte count)
        {
            for (sbyte i = 0; i < count; i++) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<sbyte> UpTo(this sbyte self, sbyte upToInclusive)
        {
            return self.UpTo(upToInclusive, 1);
        }

        public static IEnumerable<sbyte> UpTo(this sbyte self, sbyte upToInclusive, sbyte step)
        {
            for (sbyte i = self; i <= upToInclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<sbyte> UpToExclusive(this sbyte self, sbyte upToExclusive)
        {
            return self.UpToExclusive(upToExclusive, 1);
        }

        public static IEnumerable<sbyte> UpToExclusive(this sbyte self, sbyte upToExclusive, sbyte step)
        {
            for (sbyte i = self; i < upToExclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<sbyte> DownTo(this sbyte self, sbyte downToInclusive)
        {
            return self.DownTo(downToInclusive, 1);
        }

        public static IEnumerable<sbyte> DownTo(this sbyte self, sbyte downToInclusive, sbyte step)
        {
            for (sbyte i = self; i >= downToInclusive; i -= step) yield return i;
        }
    }

    #endregion

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1sb a, Range1sb b)
        {
            return ApproximateEquals(a, b, Constant<sbyte>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1sb a, Range1sb b, sbyte tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Range1s

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1s
        : IEquatable<Range1s>, IRange<short, Range1s>,  IFormattable
    {
        [DataMember]
        public short Min;
        [DataMember]
        public short Max;

        #region Constructors

        /// <summary>
        /// Construct a Range1s from a Range1b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(Range1b b)
        {
            Min = (short) b.Min;
            Max = (short) b.Max;
        }

        /// <summary>
        /// Construct a Range1s from a Range1sb.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(Range1sb b)
        {
            Min = (short) b.Min;
            Max = (short) b.Max;
        }

        /// <summary>
        /// Construct a Range1s from a Range1us.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(Range1us b)
        {
            Min = (short) b.Min;
            Max = (short) b.Max;
        }

        /// <summary>
        /// Construct a Range1s from a Range1i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(Range1i b)
        {
            Min = (short) b.Min;
            Max = (short) b.Max;
        }

        /// <summary>
        /// Construct a Range1s from a Range1ui.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(Range1ui b)
        {
            Min = (short) b.Min;
            Max = (short) b.Max;
        }

        /// <summary>
        /// Construct a Range1s from a Range1l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(Range1l b)
        {
            Min = (short) b.Min;
            Max = (short) b.Max;
        }

        /// <summary>
        /// Construct a Range1s from a Range1ul.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(Range1ul b)
        {
            Min = (short) b.Min;
            Max = (short) b.Max;
        }

        /// <summary>
        /// Construct a Range1s from a Range1f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(Range1f b)
        {
            Min = (short) b.Min;
            Max = (short) b.Max;
        }

        /// <summary>
        /// Construct a Range1s from a Range1d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(Range1d b)
        {
            Min = (short) b.Min;
            Max = (short) b.Max;
        }

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(short min, short max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(short pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(short p0, short p1, short p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(short p0, short p1, short p2, short p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(Range1s range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(Range1s b0, Range1s b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(Range1s b0, Range1s b1, Range1s b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(Range1s b0, Range1s b1, Range1s b2, Range1s b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(short[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(short[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s(IEnumerable<short> values)
        {
            Min = short.MaxValue;
            Max = short.MinValue;
            foreach (short v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1s FromMinAndSize(short min, short size)
        {
            return new Range1s(min, (short)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1s FromCenterAndSize(short center, short size)
        {
            return new Range1s((short)(center - size / 2), (short)(center + size / 2));
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1s(Range1b b)
            => new Range1s(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1s(Range1sb b)
            => new Range1s(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1s(Range1us b)
            => new Range1s(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1s(Range1i b)
            => new Range1s(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1s(Range1ui b)
            => new Range1s(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1s(Range1l b)
            => new Range1s(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1s(Range1ul b)
            => new Range1s(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1s(Range1f b)
            => new Range1s(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1s(Range1d b)
            => new Range1s(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Range1s Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1s(short.MaxValue, short.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Range1s Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1s(short.MinValue, short.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Range1s Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1s(0, 1); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }


        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        [XmlIgnore]
        public short Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (short)(Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (short)(Min + value); }
        }

        public short Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (short)((Min + Max) / 2); }
        }

        public IEnumerable<short> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s EnlargedBy(short increment)
        {
            return new Range1s((short)(Min - increment), (short)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s EnlargedBy(short deltaMin, short deltaMax)
        {
            return new Range1s((short)(Min - deltaMin), (short)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s ShrunkBy(short delta)
        {
            return new Range1s((short)(Min + delta), (short)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s ShrunkBy(short deltaMin, short deltaMax)
        {
            return new Range1s((short)(Min + deltaMin), (short)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(short delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(short deltaMin, short deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(short delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(short deltaMin, short deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public short Clamped(short x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s SplitRight(short splitValue)
        {
            if (splitValue > Max) return Range1s.Invalid;
            if (splitValue <= Min) return this;
            return new Range1s(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s SplitLeft(short splitValue)
        {
            if (splitValue < Min) return Range1s.Invalid;
            if (splitValue >= Max) return this;
            return new Range1s(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s ExtendedBy(Range1s range)
        {
            return new Range1s(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s ExtendedBy(short value)
        {
            return new Range1s(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Range1s range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(short value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(short value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Range1s b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1s range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1s range, short eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1s Repair()
        {
            if (this.Equals(Range1s.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Range1s a, Range1s b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Range1s a, Range1s b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1s operator +(Range1s box, short v)
        {
            return new Range1s((short)(box.Min + v), (short)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1s operator -(Range1s box, short v)
        {
            return new Range1s((short)(box.Min - v), (short)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Range1s other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Range1s o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1s, int, short> Setter =
            (ref Range1s box, int i, short value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1s Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1s(short.Parse(x[0], CultureInfo.InvariantCulture),
                                short.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1s Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<short>.Parse, Range1s.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion
    }

    public static partial class Range
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1s Union(this Range1s a, Range1s b)
        {
            return new Range1s(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1s Intersection(this Range1s a, Range1s b)
        {
            return new Range1s(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        /// <summary>
        /// Checks if two ranges intersect each other with a tolerance parameter.
        /// </summary>
        // TODO: Implement for d > 2
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Intersects(this Range1s a, Range1s b, short eps, out Range1s result)
        {
            result = Range1s.Invalid;
            if (a.Min - eps > b.Max) return false;
            else if (a.Max + eps < b.Min) return false;
            else
            {
                result = new Range1s(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
                if (result.Size < eps)
                {
                    short center = result.Center;
                    result.Min = (short)(center - eps);
                    result.Max = (short)(center + eps);
                }
                return true;
            }
        }

        #endregion

        #region Bounding range for arrays

        /// <summary>
        /// Returns the bounding range of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1s GetBoundingRange(this short[] pointArray)
        {
            return pointArray.GetBoundingRange(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1s GetBoundingRange(this short[] pointArray, long count)
        {
            return pointArray.GetBoundingRange(0, count);
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1s GetBoundingRange(
                this short[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1s GetBoundingRange<T>(this T[] array, long start, long count, Func<T, short> pointSelector)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding range for lists

        /// <summary>
        /// Returns the bounding range of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1s GetBoundingRange(this List<short> pointList)
        {
            return pointList.GetBoundingRange(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the list.
        /// </summary>
        public static Range1s GetBoundingRange(this List<short> pointList, int count)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding range for indexed arrays

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1s GetBoundingRange(this int[] indexArray, short[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1s GetBoundingRange(this int[] indexArray, int count, short[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1s GetBoundingRange(this int[] indexArray, int start, int count, short[] pointArray)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1s GetBoundingRange<T>(this int[] indexArray, int start, int count, T[] array, Func<T, short> pointSelector)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1s GetBoundingRange(this long[] indexArray, short[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1s GetBoundingRange(this long[] indexArray, long count, short[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1s GetBoundingRange(this long[] indexArray, long start, long count, short[] pointArray)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1s GetBoundingRange<T>(this long[] indexArray, long start, long count, T[] array, Func<T, short> pointSelector)
        {
            if (count <= 0) return Range1s.Invalid;
            var box = new Range1s(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding range for IEnumerable

        /// <summary>
        /// Returns the bounding range of the elements of the collection.
        /// </summary>
        public static Range1s GetBoundingRange(this IEnumerable<short> points)
        {
            var box = Range1s.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #region Range extensions

    public static partial class RangeExtensions
    {
        /// <summary>
        /// Returns the int sequence 0 ... count-1.
        /// </summary>
        public static IEnumerable<short> Range(this short count)
        {
            for (short i = 0; i < count; i++) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<short> UpTo(this short self, short upToInclusive)
        {
            return self.UpTo(upToInclusive, 1);
        }

        public static IEnumerable<short> UpTo(this short self, short upToInclusive, short step)
        {
            for (short i = self; i <= upToInclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<short> UpToExclusive(this short self, short upToExclusive)
        {
            return self.UpToExclusive(upToExclusive, 1);
        }

        public static IEnumerable<short> UpToExclusive(this short self, short upToExclusive, short step)
        {
            for (short i = self; i < upToExclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<short> DownTo(this short self, short downToInclusive)
        {
            return self.DownTo(downToInclusive, 1);
        }

        public static IEnumerable<short> DownTo(this short self, short downToInclusive, short step)
        {
            for (short i = self; i >= downToInclusive; i -= step) yield return i;
        }
    }

    #endregion

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1s a, Range1s b)
        {
            return ApproximateEquals(a, b, Constant<short>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1s a, Range1s b, short tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Range1us

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1us
        : IEquatable<Range1us>, IRange<ushort, Range1us>,  IFormattable
    {
        [DataMember]
        public ushort Min;
        [DataMember]
        public ushort Max;

        #region Constructors

        /// <summary>
        /// Construct a Range1us from a Range1b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(Range1b b)
        {
            Min = (ushort) b.Min;
            Max = (ushort) b.Max;
        }

        /// <summary>
        /// Construct a Range1us from a Range1sb.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(Range1sb b)
        {
            Min = (ushort) b.Min;
            Max = (ushort) b.Max;
        }

        /// <summary>
        /// Construct a Range1us from a Range1s.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(Range1s b)
        {
            Min = (ushort) b.Min;
            Max = (ushort) b.Max;
        }

        /// <summary>
        /// Construct a Range1us from a Range1i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(Range1i b)
        {
            Min = (ushort) b.Min;
            Max = (ushort) b.Max;
        }

        /// <summary>
        /// Construct a Range1us from a Range1ui.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(Range1ui b)
        {
            Min = (ushort) b.Min;
            Max = (ushort) b.Max;
        }

        /// <summary>
        /// Construct a Range1us from a Range1l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(Range1l b)
        {
            Min = (ushort) b.Min;
            Max = (ushort) b.Max;
        }

        /// <summary>
        /// Construct a Range1us from a Range1ul.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(Range1ul b)
        {
            Min = (ushort) b.Min;
            Max = (ushort) b.Max;
        }

        /// <summary>
        /// Construct a Range1us from a Range1f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(Range1f b)
        {
            Min = (ushort) b.Min;
            Max = (ushort) b.Max;
        }

        /// <summary>
        /// Construct a Range1us from a Range1d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(Range1d b)
        {
            Min = (ushort) b.Min;
            Max = (ushort) b.Max;
        }

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(ushort min, ushort max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(ushort pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(ushort p0, ushort p1, ushort p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(ushort p0, ushort p1, ushort p2, ushort p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(Range1us range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(Range1us b0, Range1us b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(Range1us b0, Range1us b1, Range1us b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(Range1us b0, Range1us b1, Range1us b2, Range1us b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(ushort[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(ushort[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us(IEnumerable<ushort> values)
        {
            Min = ushort.MaxValue;
            Max = ushort.MinValue;
            foreach (ushort v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1us FromMinAndSize(ushort min, ushort size)
        {
            return new Range1us(min, (ushort)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1us FromCenterAndSize(ushort center, ushort size)
        {
            return new Range1us((ushort)(center - size / 2), (ushort)(center + size / 2));
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1us(Range1b b)
            => new Range1us(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1us(Range1sb b)
            => new Range1us(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1us(Range1s b)
            => new Range1us(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1us(Range1i b)
            => new Range1us(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1us(Range1ui b)
            => new Range1us(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1us(Range1l b)
            => new Range1us(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1us(Range1ul b)
            => new Range1us(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1us(Range1f b)
            => new Range1us(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1us(Range1d b)
            => new Range1us(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Range1us Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1us(ushort.MaxValue, ushort.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Range1us Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1us(ushort.MinValue, ushort.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Range1us Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1us(0, 1); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }


        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        [XmlIgnore]
        public ushort Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (ushort)(Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (ushort)(Min + value); }
        }

        public ushort Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (ushort)((Min + Max) / 2); }
        }

        public IEnumerable<ushort> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us EnlargedBy(ushort increment)
        {
            return new Range1us((ushort)(Min - increment), (ushort)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us EnlargedBy(ushort deltaMin, ushort deltaMax)
        {
            return new Range1us((ushort)(Min - deltaMin), (ushort)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us ShrunkBy(ushort delta)
        {
            return new Range1us((ushort)(Min + delta), (ushort)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us ShrunkBy(ushort deltaMin, ushort deltaMax)
        {
            return new Range1us((ushort)(Min + deltaMin), (ushort)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(ushort delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(ushort deltaMin, ushort deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(ushort delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(ushort deltaMin, ushort deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ushort Clamped(ushort x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us SplitRight(ushort splitValue)
        {
            if (splitValue > Max) return Range1us.Invalid;
            if (splitValue <= Min) return this;
            return new Range1us(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us SplitLeft(ushort splitValue)
        {
            if (splitValue < Min) return Range1us.Invalid;
            if (splitValue >= Max) return this;
            return new Range1us(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us ExtendedBy(Range1us range)
        {
            return new Range1us(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us ExtendedBy(ushort value)
        {
            return new Range1us(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Range1us range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(ushort value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(ushort value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Range1us b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1us range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1us range, ushort eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1us Repair()
        {
            if (this.Equals(Range1us.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Range1us a, Range1us b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Range1us a, Range1us b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1us operator +(Range1us box, ushort v)
        {
            return new Range1us((ushort)(box.Min + v), (ushort)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1us operator -(Range1us box, ushort v)
        {
            return new Range1us((ushort)(box.Min - v), (ushort)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Range1us other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Range1us o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1us, int, ushort> Setter =
            (ref Range1us box, int i, ushort value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1us Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1us(ushort.Parse(x[0], CultureInfo.InvariantCulture),
                                ushort.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1us Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<ushort>.Parse, Range1us.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion
    }

    public static partial class Range
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1us Union(this Range1us a, Range1us b)
        {
            return new Range1us(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1us Intersection(this Range1us a, Range1us b)
        {
            return new Range1us(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        /// <summary>
        /// Checks if two ranges intersect each other with a tolerance parameter.
        /// </summary>
        // TODO: Implement for d > 2
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Intersects(this Range1us a, Range1us b, ushort eps, out Range1us result)
        {
            result = Range1us.Invalid;
            if (a.Min - eps > b.Max) return false;
            else if (a.Max + eps < b.Min) return false;
            else
            {
                result = new Range1us(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
                if (result.Size < eps)
                {
                    ushort center = result.Center;
                    result.Min = (ushort)(center - eps);
                    result.Max = (ushort)(center + eps);
                }
                return true;
            }
        }

        #endregion

        #region Bounding range for arrays

        /// <summary>
        /// Returns the bounding range of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1us GetBoundingRange(this ushort[] pointArray)
        {
            return pointArray.GetBoundingRange(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1us GetBoundingRange(this ushort[] pointArray, long count)
        {
            return pointArray.GetBoundingRange(0, count);
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1us GetBoundingRange(
                this ushort[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1us GetBoundingRange<T>(this T[] array, long start, long count, Func<T, ushort> pointSelector)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding range for lists

        /// <summary>
        /// Returns the bounding range of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1us GetBoundingRange(this List<ushort> pointList)
        {
            return pointList.GetBoundingRange(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the list.
        /// </summary>
        public static Range1us GetBoundingRange(this List<ushort> pointList, int count)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding range for indexed arrays

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1us GetBoundingRange(this int[] indexArray, ushort[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1us GetBoundingRange(this int[] indexArray, int count, ushort[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1us GetBoundingRange(this int[] indexArray, int start, int count, ushort[] pointArray)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1us GetBoundingRange<T>(this int[] indexArray, int start, int count, T[] array, Func<T, ushort> pointSelector)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1us GetBoundingRange(this long[] indexArray, ushort[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1us GetBoundingRange(this long[] indexArray, long count, ushort[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1us GetBoundingRange(this long[] indexArray, long start, long count, ushort[] pointArray)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1us GetBoundingRange<T>(this long[] indexArray, long start, long count, T[] array, Func<T, ushort> pointSelector)
        {
            if (count <= 0) return Range1us.Invalid;
            var box = new Range1us(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding range for IEnumerable

        /// <summary>
        /// Returns the bounding range of the elements of the collection.
        /// </summary>
        public static Range1us GetBoundingRange(this IEnumerable<ushort> points)
        {
            var box = Range1us.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #region Range extensions

    public static partial class RangeExtensions
    {
        /// <summary>
        /// Returns the int sequence 0 ... count-1.
        /// </summary>
        public static IEnumerable<ushort> Range(this ushort count)
        {
            for (ushort i = 0; i < count; i++) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<ushort> UpTo(this ushort self, ushort upToInclusive)
        {
            return self.UpTo(upToInclusive, 1);
        }

        public static IEnumerable<ushort> UpTo(this ushort self, ushort upToInclusive, ushort step)
        {
            for (ushort i = self; i <= upToInclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<ushort> UpToExclusive(this ushort self, ushort upToExclusive)
        {
            return self.UpToExclusive(upToExclusive, 1);
        }

        public static IEnumerable<ushort> UpToExclusive(this ushort self, ushort upToExclusive, ushort step)
        {
            for (ushort i = self; i < upToExclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<ushort> DownTo(this ushort self, ushort downToInclusive)
        {
            return self.DownTo(downToInclusive, 1);
        }

        public static IEnumerable<ushort> DownTo(this ushort self, ushort downToInclusive, ushort step)
        {
            for (ushort i = self; i >= downToInclusive; i -= step) yield return i;
        }
    }

    #endregion

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1us a, Range1us b)
        {
            return ApproximateEquals(a, b, Constant<ushort>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1us a, Range1us b, ushort tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Range1i

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1i
        : IEquatable<Range1i>, IRange<int, Range1i>,  IFormattable
    {
        [DataMember]
        public int Min;
        [DataMember]
        public int Max;

        #region Constructors

        /// <summary>
        /// Construct a Range1i from a Range1b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(Range1b b)
        {
            Min = (int) b.Min;
            Max = (int) b.Max;
        }

        /// <summary>
        /// Construct a Range1i from a Range1sb.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(Range1sb b)
        {
            Min = (int) b.Min;
            Max = (int) b.Max;
        }

        /// <summary>
        /// Construct a Range1i from a Range1s.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(Range1s b)
        {
            Min = (int) b.Min;
            Max = (int) b.Max;
        }

        /// <summary>
        /// Construct a Range1i from a Range1us.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(Range1us b)
        {
            Min = (int) b.Min;
            Max = (int) b.Max;
        }

        /// <summary>
        /// Construct a Range1i from a Range1ui.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(Range1ui b)
        {
            Min = (int) b.Min;
            Max = (int) b.Max;
        }

        /// <summary>
        /// Construct a Range1i from a Range1l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(Range1l b)
        {
            Min = (int) b.Min;
            Max = (int) b.Max;
        }

        /// <summary>
        /// Construct a Range1i from a Range1ul.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(Range1ul b)
        {
            Min = (int) b.Min;
            Max = (int) b.Max;
        }

        /// <summary>
        /// Construct a Range1i from a Range1f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(Range1f b)
        {
            Min = (int) b.Min;
            Max = (int) b.Max;
        }

        /// <summary>
        /// Construct a Range1i from a Range1d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(Range1d b)
        {
            Min = (int) b.Min;
            Max = (int) b.Max;
        }

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(int min, int max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(int pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(int p0, int p1, int p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(int p0, int p1, int p2, int p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(Range1i range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(Range1i b0, Range1i b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(Range1i b0, Range1i b1, Range1i b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(Range1i b0, Range1i b1, Range1i b2, Range1i b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(int[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(int[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i(IEnumerable<int> values)
        {
            Min = int.MaxValue;
            Max = int.MinValue;
            foreach (int v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1i FromMinAndSize(int min, int size)
        {
            return new Range1i(min, (min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1i FromCenterAndSize(int center, int size)
        {
            return new Range1i((center - size / 2), (center + size / 2));
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1i(Range1b b)
            => new Range1i(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1i(Range1sb b)
            => new Range1i(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1i(Range1s b)
            => new Range1i(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1i(Range1us b)
            => new Range1i(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1i(Range1ui b)
            => new Range1i(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1i(Range1l b)
            => new Range1i(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1i(Range1ul b)
            => new Range1i(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1i(Range1f b)
            => new Range1i(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1i(Range1d b)
            => new Range1i(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Range1i Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1i(int.MaxValue, int.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Range1i Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1i(int.MinValue, int.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Range1i Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1i(0, 1); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }


        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        [XmlIgnore]
        public int Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (Min + value); }
        }

        public int Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return ((Min + Max) / 2); }
        }

        public IEnumerable<int> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i EnlargedBy(int increment)
        {
            return new Range1i((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i EnlargedBy(int deltaMin, int deltaMax)
        {
            return new Range1i((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i ShrunkBy(int delta)
        {
            return new Range1i((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i ShrunkBy(int deltaMin, int deltaMax)
        {
            return new Range1i((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(int delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(int deltaMin, int deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(int delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(int deltaMin, int deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int Clamped(int x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i SplitRight(int splitValue)
        {
            if (splitValue > Max) return Range1i.Invalid;
            if (splitValue <= Min) return this;
            return new Range1i(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i SplitLeft(int splitValue)
        {
            if (splitValue < Min) return Range1i.Invalid;
            if (splitValue >= Max) return this;
            return new Range1i(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i ExtendedBy(Range1i range)
        {
            return new Range1i(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i ExtendedBy(int value)
        {
            return new Range1i(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Range1i range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(int value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(int value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Range1i b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1i range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1i range, int eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1i Repair()
        {
            if (this.Equals(Range1i.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Range1i a, Range1i b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Range1i a, Range1i b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1i operator +(Range1i box, int v)
        {
            return new Range1i((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1i operator -(Range1i box, int v)
        {
            return new Range1i((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Range1i other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Range1i o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1i, int, int> Setter =
            (ref Range1i box, int i, int value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1i(int.Parse(x[0], CultureInfo.InvariantCulture),
                                int.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1i Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<int>.Parse, Range1i.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion
    }

    public static partial class Range
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1i Union(this Range1i a, Range1i b)
        {
            return new Range1i(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1i Intersection(this Range1i a, Range1i b)
        {
            return new Range1i(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        /// <summary>
        /// Checks if two ranges intersect each other with a tolerance parameter.
        /// </summary>
        // TODO: Implement for d > 2
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Intersects(this Range1i a, Range1i b, int eps, out Range1i result)
        {
            result = Range1i.Invalid;
            if (a.Min - eps > b.Max) return false;
            else if (a.Max + eps < b.Min) return false;
            else
            {
                result = new Range1i(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
                if (result.Size < eps)
                {
                    int center = result.Center;
                    result.Min = (center - eps);
                    result.Max = (center + eps);
                }
                return true;
            }
        }

        #endregion

        #region Bounding range for arrays

        /// <summary>
        /// Returns the bounding range of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1i GetBoundingRange(this int[] pointArray)
        {
            return pointArray.GetBoundingRange(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1i GetBoundingRange(this int[] pointArray, long count)
        {
            return pointArray.GetBoundingRange(0, count);
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1i GetBoundingRange(
                this int[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1i GetBoundingRange<T>(this T[] array, long start, long count, Func<T, int> pointSelector)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding range for lists

        /// <summary>
        /// Returns the bounding range of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1i GetBoundingRange(this List<int> pointList)
        {
            return pointList.GetBoundingRange(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the list.
        /// </summary>
        public static Range1i GetBoundingRange(this List<int> pointList, int count)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding range for indexed arrays

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1i GetBoundingRange(this int[] indexArray, int[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1i GetBoundingRange(this int[] indexArray, int count, int[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1i GetBoundingRange(this int[] indexArray, int start, int count, int[] pointArray)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1i GetBoundingRange<T>(this int[] indexArray, int start, int count, T[] array, Func<T, int> pointSelector)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1i GetBoundingRange(this long[] indexArray, int[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1i GetBoundingRange(this long[] indexArray, long count, int[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1i GetBoundingRange(this long[] indexArray, long start, long count, int[] pointArray)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1i GetBoundingRange<T>(this long[] indexArray, long start, long count, T[] array, Func<T, int> pointSelector)
        {
            if (count <= 0) return Range1i.Invalid;
            var box = new Range1i(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding range for IEnumerable

        /// <summary>
        /// Returns the bounding range of the elements of the collection.
        /// </summary>
        public static Range1i GetBoundingRange(this IEnumerable<int> points)
        {
            var box = Range1i.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #region Range extensions

    public static partial class RangeExtensions
    {
        /// <summary>
        /// Returns the int sequence 0 ... count-1.
        /// </summary>
        public static IEnumerable<int> Range(this int count)
        {
            for (int i = 0; i < count; i++) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<int> UpTo(this int self, int upToInclusive)
        {
            return self.UpTo(upToInclusive, 1);
        }

        public static IEnumerable<int> UpTo(this int self, int upToInclusive, int step)
        {
            for (int i = self; i <= upToInclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<int> UpToExclusive(this int self, int upToExclusive)
        {
            return self.UpToExclusive(upToExclusive, 1);
        }

        public static IEnumerable<int> UpToExclusive(this int self, int upToExclusive, int step)
        {
            for (int i = self; i < upToExclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<int> DownTo(this int self, int downToInclusive)
        {
            return self.DownTo(downToInclusive, 1);
        }

        public static IEnumerable<int> DownTo(this int self, int downToInclusive, int step)
        {
            for (int i = self; i >= downToInclusive; i -= step) yield return i;
        }
    }

    #endregion

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1i a, Range1i b)
        {
            return ApproximateEquals(a, b, Constant<int>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1i a, Range1i b, int tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Range1ui

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1ui
        : IEquatable<Range1ui>, IRange<uint, Range1ui>,  IFormattable
    {
        [DataMember]
        public uint Min;
        [DataMember]
        public uint Max;

        #region Constructors

        /// <summary>
        /// Construct a Range1ui from a Range1b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(Range1b b)
        {
            Min = (uint) b.Min;
            Max = (uint) b.Max;
        }

        /// <summary>
        /// Construct a Range1ui from a Range1sb.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(Range1sb b)
        {
            Min = (uint) b.Min;
            Max = (uint) b.Max;
        }

        /// <summary>
        /// Construct a Range1ui from a Range1s.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(Range1s b)
        {
            Min = (uint) b.Min;
            Max = (uint) b.Max;
        }

        /// <summary>
        /// Construct a Range1ui from a Range1us.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(Range1us b)
        {
            Min = (uint) b.Min;
            Max = (uint) b.Max;
        }

        /// <summary>
        /// Construct a Range1ui from a Range1i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(Range1i b)
        {
            Min = (uint) b.Min;
            Max = (uint) b.Max;
        }

        /// <summary>
        /// Construct a Range1ui from a Range1l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(Range1l b)
        {
            Min = (uint) b.Min;
            Max = (uint) b.Max;
        }

        /// <summary>
        /// Construct a Range1ui from a Range1ul.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(Range1ul b)
        {
            Min = (uint) b.Min;
            Max = (uint) b.Max;
        }

        /// <summary>
        /// Construct a Range1ui from a Range1f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(Range1f b)
        {
            Min = (uint) b.Min;
            Max = (uint) b.Max;
        }

        /// <summary>
        /// Construct a Range1ui from a Range1d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(Range1d b)
        {
            Min = (uint) b.Min;
            Max = (uint) b.Max;
        }

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(uint min, uint max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(uint pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(uint p0, uint p1, uint p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(uint p0, uint p1, uint p2, uint p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(Range1ui range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(Range1ui b0, Range1ui b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(Range1ui b0, Range1ui b1, Range1ui b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(Range1ui b0, Range1ui b1, Range1ui b2, Range1ui b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(uint[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(uint[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui(IEnumerable<uint> values)
        {
            Min = uint.MaxValue;
            Max = uint.MinValue;
            foreach (uint v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ui FromMinAndSize(uint min, uint size)
        {
            return new Range1ui(min, (uint)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ui FromCenterAndSize(uint center, uint size)
        {
            return new Range1ui((uint)(center - size / 2), (uint)(center + size / 2));
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ui(Range1b b)
            => new Range1ui(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ui(Range1sb b)
            => new Range1ui(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ui(Range1s b)
            => new Range1ui(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ui(Range1us b)
            => new Range1ui(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ui(Range1i b)
            => new Range1ui(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ui(Range1l b)
            => new Range1ui(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ui(Range1ul b)
            => new Range1ui(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ui(Range1f b)
            => new Range1ui(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ui(Range1d b)
            => new Range1ui(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Range1ui Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1ui(uint.MaxValue, uint.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Range1ui Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1ui(uint.MinValue, uint.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Range1ui Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1ui(0, 1); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }


        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        [XmlIgnore]
        public uint Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (uint)(Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (uint)(Min + value); }
        }

        public uint Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (uint)((Min + Max) / 2); }
        }

        public IEnumerable<uint> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui EnlargedBy(uint increment)
        {
            return new Range1ui((uint)(Min - increment), (uint)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui EnlargedBy(uint deltaMin, uint deltaMax)
        {
            return new Range1ui((uint)(Min - deltaMin), (uint)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui ShrunkBy(uint delta)
        {
            return new Range1ui((uint)(Min + delta), (uint)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui ShrunkBy(uint deltaMin, uint deltaMax)
        {
            return new Range1ui((uint)(Min + deltaMin), (uint)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(uint delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(uint deltaMin, uint deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(uint delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(uint deltaMin, uint deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint Clamped(uint x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui SplitRight(uint splitValue)
        {
            if (splitValue > Max) return Range1ui.Invalid;
            if (splitValue <= Min) return this;
            return new Range1ui(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui SplitLeft(uint splitValue)
        {
            if (splitValue < Min) return Range1ui.Invalid;
            if (splitValue >= Max) return this;
            return new Range1ui(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui ExtendedBy(Range1ui range)
        {
            return new Range1ui(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui ExtendedBy(uint value)
        {
            return new Range1ui(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Range1ui range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(uint value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(uint value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Range1ui b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1ui range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1ui range, uint eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ui Repair()
        {
            if (this.Equals(Range1ui.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Range1ui a, Range1ui b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Range1ui a, Range1ui b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ui operator +(Range1ui box, uint v)
        {
            return new Range1ui((uint)(box.Min + v), (uint)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ui operator -(Range1ui box, uint v)
        {
            return new Range1ui((uint)(box.Min - v), (uint)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Range1ui other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Range1ui o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1ui, int, uint> Setter =
            (ref Range1ui box, int i, uint value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1ui Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1ui(uint.Parse(x[0], CultureInfo.InvariantCulture),
                                uint.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1ui Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<uint>.Parse, Range1ui.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion
    }

    public static partial class Range
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ui Union(this Range1ui a, Range1ui b)
        {
            return new Range1ui(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ui Intersection(this Range1ui a, Range1ui b)
        {
            return new Range1ui(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        /// <summary>
        /// Checks if two ranges intersect each other with a tolerance parameter.
        /// </summary>
        // TODO: Implement for d > 2
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Intersects(this Range1ui a, Range1ui b, uint eps, out Range1ui result)
        {
            result = Range1ui.Invalid;
            if (a.Min - eps > b.Max) return false;
            else if (a.Max + eps < b.Min) return false;
            else
            {
                result = new Range1ui(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
                if (result.Size < eps)
                {
                    uint center = result.Center;
                    result.Min = (uint)(center - eps);
                    result.Max = (uint)(center + eps);
                }
                return true;
            }
        }

        #endregion

        #region Bounding range for arrays

        /// <summary>
        /// Returns the bounding range of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ui GetBoundingRange(this uint[] pointArray)
        {
            return pointArray.GetBoundingRange(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ui GetBoundingRange(this uint[] pointArray, long count)
        {
            return pointArray.GetBoundingRange(0, count);
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1ui GetBoundingRange(
                this uint[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1ui GetBoundingRange<T>(this T[] array, long start, long count, Func<T, uint> pointSelector)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding range for lists

        /// <summary>
        /// Returns the bounding range of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ui GetBoundingRange(this List<uint> pointList)
        {
            return pointList.GetBoundingRange(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the list.
        /// </summary>
        public static Range1ui GetBoundingRange(this List<uint> pointList, int count)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding range for indexed arrays

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ui GetBoundingRange(this int[] indexArray, uint[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ui GetBoundingRange(this int[] indexArray, int count, uint[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1ui GetBoundingRange(this int[] indexArray, int start, int count, uint[] pointArray)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1ui GetBoundingRange<T>(this int[] indexArray, int start, int count, T[] array, Func<T, uint> pointSelector)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ui GetBoundingRange(this long[] indexArray, uint[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ui GetBoundingRange(this long[] indexArray, long count, uint[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1ui GetBoundingRange(this long[] indexArray, long start, long count, uint[] pointArray)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1ui GetBoundingRange<T>(this long[] indexArray, long start, long count, T[] array, Func<T, uint> pointSelector)
        {
            if (count <= 0) return Range1ui.Invalid;
            var box = new Range1ui(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding range for IEnumerable

        /// <summary>
        /// Returns the bounding range of the elements of the collection.
        /// </summary>
        public static Range1ui GetBoundingRange(this IEnumerable<uint> points)
        {
            var box = Range1ui.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #region Range extensions

    public static partial class RangeExtensions
    {
        /// <summary>
        /// Returns the int sequence 0 ... count-1.
        /// </summary>
        public static IEnumerable<uint> Range(this uint count)
        {
            for (uint i = 0; i < count; i++) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<uint> UpTo(this uint self, uint upToInclusive)
        {
            return self.UpTo(upToInclusive, 1);
        }

        public static IEnumerable<uint> UpTo(this uint self, uint upToInclusive, uint step)
        {
            for (uint i = self; i <= upToInclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<uint> UpToExclusive(this uint self, uint upToExclusive)
        {
            return self.UpToExclusive(upToExclusive, 1);
        }

        public static IEnumerable<uint> UpToExclusive(this uint self, uint upToExclusive, uint step)
        {
            for (uint i = self; i < upToExclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<uint> DownTo(this uint self, uint downToInclusive)
        {
            return self.DownTo(downToInclusive, 1);
        }

        public static IEnumerable<uint> DownTo(this uint self, uint downToInclusive, uint step)
        {
            for (uint i = self; i >= downToInclusive; i -= step) yield return i;
        }
    }

    #endregion

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1ui a, Range1ui b)
        {
            return ApproximateEquals(a, b, Constant<uint>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1ui a, Range1ui b, uint tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Range1l

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1l
        : IEquatable<Range1l>, IRange<long, Range1l>,  IFormattable
    {
        [DataMember]
        public long Min;
        [DataMember]
        public long Max;

        #region Constructors

        /// <summary>
        /// Construct a Range1l from a Range1b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(Range1b b)
        {
            Min = (long) b.Min;
            Max = (long) b.Max;
        }

        /// <summary>
        /// Construct a Range1l from a Range1sb.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(Range1sb b)
        {
            Min = (long) b.Min;
            Max = (long) b.Max;
        }

        /// <summary>
        /// Construct a Range1l from a Range1s.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(Range1s b)
        {
            Min = (long) b.Min;
            Max = (long) b.Max;
        }

        /// <summary>
        /// Construct a Range1l from a Range1us.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(Range1us b)
        {
            Min = (long) b.Min;
            Max = (long) b.Max;
        }

        /// <summary>
        /// Construct a Range1l from a Range1i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(Range1i b)
        {
            Min = (long) b.Min;
            Max = (long) b.Max;
        }

        /// <summary>
        /// Construct a Range1l from a Range1ui.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(Range1ui b)
        {
            Min = (long) b.Min;
            Max = (long) b.Max;
        }

        /// <summary>
        /// Construct a Range1l from a Range1ul.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(Range1ul b)
        {
            Min = (long) b.Min;
            Max = (long) b.Max;
        }

        /// <summary>
        /// Construct a Range1l from a Range1f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(Range1f b)
        {
            Min = (long) b.Min;
            Max = (long) b.Max;
        }

        /// <summary>
        /// Construct a Range1l from a Range1d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(Range1d b)
        {
            Min = (long) b.Min;
            Max = (long) b.Max;
        }

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(long min, long max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(long pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(long p0, long p1, long p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(long p0, long p1, long p2, long p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(Range1l range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(Range1l b0, Range1l b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(Range1l b0, Range1l b1, Range1l b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(Range1l b0, Range1l b1, Range1l b2, Range1l b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(long[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(long[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l(IEnumerable<long> values)
        {
            Min = long.MaxValue;
            Max = long.MinValue;
            foreach (long v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1l FromMinAndSize(long min, long size)
        {
            return new Range1l(min, (long)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1l FromCenterAndSize(long center, long size)
        {
            return new Range1l((long)(center - size / 2), (long)(center + size / 2));
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1l(Range1b b)
            => new Range1l(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1l(Range1sb b)
            => new Range1l(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1l(Range1s b)
            => new Range1l(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1l(Range1us b)
            => new Range1l(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1l(Range1i b)
            => new Range1l(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1l(Range1ui b)
            => new Range1l(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1l(Range1ul b)
            => new Range1l(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1l(Range1f b)
            => new Range1l(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1l(Range1d b)
            => new Range1l(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Range1l Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1l(long.MaxValue, long.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Range1l Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1l(long.MinValue, long.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Range1l Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1l(0, 1); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }


        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        [XmlIgnore]
        public long Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (long)(Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (long)(Min + value); }
        }

        public long Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (long)((Min + Max) / 2); }
        }

        public IEnumerable<long> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l EnlargedBy(long increment)
        {
            return new Range1l((long)(Min - increment), (long)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l EnlargedBy(long deltaMin, long deltaMax)
        {
            return new Range1l((long)(Min - deltaMin), (long)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l ShrunkBy(long delta)
        {
            return new Range1l((long)(Min + delta), (long)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l ShrunkBy(long deltaMin, long deltaMax)
        {
            return new Range1l((long)(Min + deltaMin), (long)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(long delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(long deltaMin, long deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(long delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(long deltaMin, long deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public long Clamped(long x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l SplitRight(long splitValue)
        {
            if (splitValue > Max) return Range1l.Invalid;
            if (splitValue <= Min) return this;
            return new Range1l(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l SplitLeft(long splitValue)
        {
            if (splitValue < Min) return Range1l.Invalid;
            if (splitValue >= Max) return this;
            return new Range1l(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l ExtendedBy(Range1l range)
        {
            return new Range1l(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l ExtendedBy(long value)
        {
            return new Range1l(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Range1l range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(long value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(long value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Range1l b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1l range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1l range, long eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1l Repair()
        {
            if (this.Equals(Range1l.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Range1l a, Range1l b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Range1l a, Range1l b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1l operator +(Range1l box, long v)
        {
            return new Range1l((long)(box.Min + v), (long)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1l operator -(Range1l box, long v)
        {
            return new Range1l((long)(box.Min - v), (long)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Range1l other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Range1l o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1l, int, long> Setter =
            (ref Range1l box, int i, long value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1l(long.Parse(x[0], CultureInfo.InvariantCulture),
                                long.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1l Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<long>.Parse, Range1l.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion
    }

    public static partial class Range
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1l Union(this Range1l a, Range1l b)
        {
            return new Range1l(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1l Intersection(this Range1l a, Range1l b)
        {
            return new Range1l(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        /// <summary>
        /// Checks if two ranges intersect each other with a tolerance parameter.
        /// </summary>
        // TODO: Implement for d > 2
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Intersects(this Range1l a, Range1l b, long eps, out Range1l result)
        {
            result = Range1l.Invalid;
            if (a.Min - eps > b.Max) return false;
            else if (a.Max + eps < b.Min) return false;
            else
            {
                result = new Range1l(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
                if (result.Size < eps)
                {
                    long center = result.Center;
                    result.Min = (long)(center - eps);
                    result.Max = (long)(center + eps);
                }
                return true;
            }
        }

        #endregion

        #region Bounding range for arrays

        /// <summary>
        /// Returns the bounding range of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1l GetBoundingRange(this long[] pointArray)
        {
            return pointArray.GetBoundingRange(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1l GetBoundingRange(this long[] pointArray, long count)
        {
            return pointArray.GetBoundingRange(0, count);
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1l GetBoundingRange(
                this long[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1l GetBoundingRange<T>(this T[] array, long start, long count, Func<T, long> pointSelector)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding range for lists

        /// <summary>
        /// Returns the bounding range of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1l GetBoundingRange(this List<long> pointList)
        {
            return pointList.GetBoundingRange(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the list.
        /// </summary>
        public static Range1l GetBoundingRange(this List<long> pointList, int count)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding range for indexed arrays

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1l GetBoundingRange(this int[] indexArray, long[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1l GetBoundingRange(this int[] indexArray, int count, long[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1l GetBoundingRange(this int[] indexArray, int start, int count, long[] pointArray)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1l GetBoundingRange<T>(this int[] indexArray, int start, int count, T[] array, Func<T, long> pointSelector)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1l GetBoundingRange(this long[] indexArray, long[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1l GetBoundingRange(this long[] indexArray, long count, long[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1l GetBoundingRange(this long[] indexArray, long start, long count, long[] pointArray)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1l GetBoundingRange<T>(this long[] indexArray, long start, long count, T[] array, Func<T, long> pointSelector)
        {
            if (count <= 0) return Range1l.Invalid;
            var box = new Range1l(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding range for IEnumerable

        /// <summary>
        /// Returns the bounding range of the elements of the collection.
        /// </summary>
        public static Range1l GetBoundingRange(this IEnumerable<long> points)
        {
            var box = Range1l.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #region Range extensions

    public static partial class RangeExtensions
    {
        /// <summary>
        /// Returns the int sequence 0 ... count-1.
        /// </summary>
        public static IEnumerable<long> Range(this long count)
        {
            for (long i = 0; i < count; i++) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<long> UpTo(this long self, long upToInclusive)
        {
            return self.UpTo(upToInclusive, 1);
        }

        public static IEnumerable<long> UpTo(this long self, long upToInclusive, long step)
        {
            for (long i = self; i <= upToInclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<long> UpToExclusive(this long self, long upToExclusive)
        {
            return self.UpToExclusive(upToExclusive, 1);
        }

        public static IEnumerable<long> UpToExclusive(this long self, long upToExclusive, long step)
        {
            for (long i = self; i < upToExclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<long> DownTo(this long self, long downToInclusive)
        {
            return self.DownTo(downToInclusive, 1);
        }

        public static IEnumerable<long> DownTo(this long self, long downToInclusive, long step)
        {
            for (long i = self; i >= downToInclusive; i -= step) yield return i;
        }
    }

    #endregion

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1l a, Range1l b)
        {
            return ApproximateEquals(a, b, Constant<long>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1l a, Range1l b, long tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Range1ul

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1ul
        : IEquatable<Range1ul>, IRange<ulong, Range1ul>,  IFormattable
    {
        [DataMember]
        public ulong Min;
        [DataMember]
        public ulong Max;

        #region Constructors

        /// <summary>
        /// Construct a Range1ul from a Range1b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(Range1b b)
        {
            Min = (ulong) b.Min;
            Max = (ulong) b.Max;
        }

        /// <summary>
        /// Construct a Range1ul from a Range1sb.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(Range1sb b)
        {
            Min = (ulong) b.Min;
            Max = (ulong) b.Max;
        }

        /// <summary>
        /// Construct a Range1ul from a Range1s.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(Range1s b)
        {
            Min = (ulong) b.Min;
            Max = (ulong) b.Max;
        }

        /// <summary>
        /// Construct a Range1ul from a Range1us.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(Range1us b)
        {
            Min = (ulong) b.Min;
            Max = (ulong) b.Max;
        }

        /// <summary>
        /// Construct a Range1ul from a Range1i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(Range1i b)
        {
            Min = (ulong) b.Min;
            Max = (ulong) b.Max;
        }

        /// <summary>
        /// Construct a Range1ul from a Range1ui.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(Range1ui b)
        {
            Min = (ulong) b.Min;
            Max = (ulong) b.Max;
        }

        /// <summary>
        /// Construct a Range1ul from a Range1l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(Range1l b)
        {
            Min = (ulong) b.Min;
            Max = (ulong) b.Max;
        }

        /// <summary>
        /// Construct a Range1ul from a Range1f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(Range1f b)
        {
            Min = (ulong) b.Min;
            Max = (ulong) b.Max;
        }

        /// <summary>
        /// Construct a Range1ul from a Range1d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(Range1d b)
        {
            Min = (ulong) b.Min;
            Max = (ulong) b.Max;
        }

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(ulong min, ulong max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(ulong pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(ulong p0, ulong p1, ulong p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(ulong p0, ulong p1, ulong p2, ulong p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(Range1ul range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(Range1ul b0, Range1ul b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(Range1ul b0, Range1ul b1, Range1ul b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(Range1ul b0, Range1ul b1, Range1ul b2, Range1ul b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(ulong[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(ulong[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul(IEnumerable<ulong> values)
        {
            Min = ulong.MaxValue;
            Max = ulong.MinValue;
            foreach (ulong v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ul FromMinAndSize(ulong min, ulong size)
        {
            return new Range1ul(min, (ulong)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ul FromCenterAndSize(ulong center, ulong size)
        {
            return new Range1ul((ulong)(center - size / 2), (ulong)(center + size / 2));
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ul(Range1b b)
            => new Range1ul(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ul(Range1sb b)
            => new Range1ul(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ul(Range1s b)
            => new Range1ul(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ul(Range1us b)
            => new Range1ul(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ul(Range1i b)
            => new Range1ul(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ul(Range1ui b)
            => new Range1ul(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ul(Range1l b)
            => new Range1ul(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ul(Range1f b)
            => new Range1ul(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1ul(Range1d b)
            => new Range1ul(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Range1ul Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1ul(ulong.MaxValue, ulong.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Range1ul Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1ul(ulong.MinValue, ulong.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Range1ul Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1ul(0, 1); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }


        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        [XmlIgnore]
        public ulong Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (ulong)(Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (ulong)(Min + value); }
        }

        public ulong Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (ulong)((Min + Max) / 2); }
        }

        public IEnumerable<ulong> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul EnlargedBy(ulong increment)
        {
            return new Range1ul((ulong)(Min - increment), (ulong)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul EnlargedBy(ulong deltaMin, ulong deltaMax)
        {
            return new Range1ul((ulong)(Min - deltaMin), (ulong)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul ShrunkBy(ulong delta)
        {
            return new Range1ul((ulong)(Min + delta), (ulong)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul ShrunkBy(ulong deltaMin, ulong deltaMax)
        {
            return new Range1ul((ulong)(Min + deltaMin), (ulong)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(ulong delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(ulong deltaMin, ulong deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(ulong delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(ulong deltaMin, ulong deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ulong Clamped(ulong x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul SplitRight(ulong splitValue)
        {
            if (splitValue > Max) return Range1ul.Invalid;
            if (splitValue <= Min) return this;
            return new Range1ul(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul SplitLeft(ulong splitValue)
        {
            if (splitValue < Min) return Range1ul.Invalid;
            if (splitValue >= Max) return this;
            return new Range1ul(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul ExtendedBy(Range1ul range)
        {
            return new Range1ul(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul ExtendedBy(ulong value)
        {
            return new Range1ul(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Range1ul range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(ulong value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(ulong value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Range1ul b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1ul range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1ul range, ulong eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1ul Repair()
        {
            if (this.Equals(Range1ul.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Range1ul a, Range1ul b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Range1ul a, Range1ul b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ul operator +(Range1ul box, ulong v)
        {
            return new Range1ul((ulong)(box.Min + v), (ulong)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ul operator -(Range1ul box, ulong v)
        {
            return new Range1ul((ulong)(box.Min - v), (ulong)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Range1ul other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Range1ul o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1ul, int, ulong> Setter =
            (ref Range1ul box, int i, ulong value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1ul Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1ul(ulong.Parse(x[0], CultureInfo.InvariantCulture),
                                ulong.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1ul Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<ulong>.Parse, Range1ul.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion
    }

    public static partial class Range
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ul Union(this Range1ul a, Range1ul b)
        {
            return new Range1ul(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ul Intersection(this Range1ul a, Range1ul b)
        {
            return new Range1ul(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        /// <summary>
        /// Checks if two ranges intersect each other with a tolerance parameter.
        /// </summary>
        // TODO: Implement for d > 2
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Intersects(this Range1ul a, Range1ul b, ulong eps, out Range1ul result)
        {
            result = Range1ul.Invalid;
            if (a.Min - eps > b.Max) return false;
            else if (a.Max + eps < b.Min) return false;
            else
            {
                result = new Range1ul(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
                if (result.Size < eps)
                {
                    ulong center = result.Center;
                    result.Min = (ulong)(center - eps);
                    result.Max = (ulong)(center + eps);
                }
                return true;
            }
        }

        #endregion

        #region Bounding range for arrays

        /// <summary>
        /// Returns the bounding range of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ul GetBoundingRange(this ulong[] pointArray)
        {
            return pointArray.GetBoundingRange(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ul GetBoundingRange(this ulong[] pointArray, long count)
        {
            return pointArray.GetBoundingRange(0, count);
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1ul GetBoundingRange(
                this ulong[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1ul GetBoundingRange<T>(this T[] array, long start, long count, Func<T, ulong> pointSelector)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding range for lists

        /// <summary>
        /// Returns the bounding range of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ul GetBoundingRange(this List<ulong> pointList)
        {
            return pointList.GetBoundingRange(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the list.
        /// </summary>
        public static Range1ul GetBoundingRange(this List<ulong> pointList, int count)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding range for indexed arrays

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ul GetBoundingRange(this int[] indexArray, ulong[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ul GetBoundingRange(this int[] indexArray, int count, ulong[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1ul GetBoundingRange(this int[] indexArray, int start, int count, ulong[] pointArray)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1ul GetBoundingRange<T>(this int[] indexArray, int start, int count, T[] array, Func<T, ulong> pointSelector)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ul GetBoundingRange(this long[] indexArray, ulong[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1ul GetBoundingRange(this long[] indexArray, long count, ulong[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1ul GetBoundingRange(this long[] indexArray, long start, long count, ulong[] pointArray)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1ul GetBoundingRange<T>(this long[] indexArray, long start, long count, T[] array, Func<T, ulong> pointSelector)
        {
            if (count <= 0) return Range1ul.Invalid;
            var box = new Range1ul(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding range for IEnumerable

        /// <summary>
        /// Returns the bounding range of the elements of the collection.
        /// </summary>
        public static Range1ul GetBoundingRange(this IEnumerable<ulong> points)
        {
            var box = Range1ul.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #region Range extensions

    public static partial class RangeExtensions
    {
        /// <summary>
        /// Returns the int sequence 0 ... count-1.
        /// </summary>
        public static IEnumerable<ulong> Range(this ulong count)
        {
            for (ulong i = 0; i < count; i++) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<ulong> UpTo(this ulong self, ulong upToInclusive)
        {
            return self.UpTo(upToInclusive, 1);
        }

        public static IEnumerable<ulong> UpTo(this ulong self, ulong upToInclusive, ulong step)
        {
            for (ulong i = self; i <= upToInclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<ulong> UpToExclusive(this ulong self, ulong upToExclusive)
        {
            return self.UpToExclusive(upToExclusive, 1);
        }

        public static IEnumerable<ulong> UpToExclusive(this ulong self, ulong upToExclusive, ulong step)
        {
            for (ulong i = self; i < upToExclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<ulong> DownTo(this ulong self, ulong downToInclusive)
        {
            return self.DownTo(downToInclusive, 1);
        }

        public static IEnumerable<ulong> DownTo(this ulong self, ulong downToInclusive, ulong step)
        {
            for (ulong i = self; i >= downToInclusive; i -= step) yield return i;
        }
    }

    #endregion

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1ul a, Range1ul b)
        {
            return ApproximateEquals(a, b, Constant<ulong>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1ul a, Range1ul b, ulong tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Range1f

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1f
        : IEquatable<Range1f>, IRange<float, Range1f>,  IFormattable
    {
        [DataMember]
        public float Min;
        [DataMember]
        public float Max;

        #region Constructors

        /// <summary>
        /// Construct a Range1f from a Range1b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(Range1b b)
        {
            Min = (float) b.Min;
            Max = (float) b.Max;
        }

        /// <summary>
        /// Construct a Range1f from a Range1sb.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(Range1sb b)
        {
            Min = (float) b.Min;
            Max = (float) b.Max;
        }

        /// <summary>
        /// Construct a Range1f from a Range1s.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(Range1s b)
        {
            Min = (float) b.Min;
            Max = (float) b.Max;
        }

        /// <summary>
        /// Construct a Range1f from a Range1us.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(Range1us b)
        {
            Min = (float) b.Min;
            Max = (float) b.Max;
        }

        /// <summary>
        /// Construct a Range1f from a Range1i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(Range1i b)
        {
            Min = (float) b.Min;
            Max = (float) b.Max;
        }

        /// <summary>
        /// Construct a Range1f from a Range1ui.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(Range1ui b)
        {
            Min = (float) b.Min;
            Max = (float) b.Max;
        }

        /// <summary>
        /// Construct a Range1f from a Range1l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(Range1l b)
        {
            Min = (float) b.Min;
            Max = (float) b.Max;
        }

        /// <summary>
        /// Construct a Range1f from a Range1ul.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(Range1ul b)
        {
            Min = (float) b.Min;
            Max = (float) b.Max;
        }

        /// <summary>
        /// Construct a Range1f from a Range1d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(Range1d b)
        {
            Min = (float) b.Min;
            Max = (float) b.Max;
        }

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(float min, float max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(float pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(float p0, float p1, float p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(float p0, float p1, float p2, float p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(Range1f range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(Range1f b0, Range1f b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(Range1f b0, Range1f b1, Range1f b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(Range1f b0, Range1f b1, Range1f b2, Range1f b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(float[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(float[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f(IEnumerable<float> values)
        {
            Min = Constant<float>.ParseableMaxValue;
            Max = Constant<float>.ParseableMinValue;
            foreach (float v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1f FromMinAndSize(float min, float size)
        {
            return new Range1f(min, (float)(min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1f FromCenterAndSize(float center, float size)
        {
            return new Range1f((float)(center - size / 2), (float)(center + size / 2));
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1f(Range1b b)
            => new Range1f(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1f(Range1sb b)
            => new Range1f(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1f(Range1s b)
            => new Range1f(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1f(Range1us b)
            => new Range1f(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1f(Range1i b)
            => new Range1f(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1f(Range1ui b)
            => new Range1f(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1f(Range1l b)
            => new Range1f(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1f(Range1ul b)
            => new Range1f(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1f(Range1d b)
            => new Range1f(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Range1f Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1f(Constant<float>.ParseableMaxValue, Constant<float>.ParseableMinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Range1f Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1f(Constant<float>.ParseableMinValue, Constant<float>.ParseableMaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Range1f Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1f(0, 1); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }


        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        [XmlIgnore]
        public float Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (float)(Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (float)(Min + value); }
        }

        public float Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (float)((Min + Max) / 2); }
        }

        public IEnumerable<float> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f EnlargedBy(float increment)
        {
            return new Range1f((float)(Min - increment), (float)(Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f EnlargedBy(float deltaMin, float deltaMax)
        {
            return new Range1f((float)(Min - deltaMin), (float)(Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f ShrunkBy(float delta)
        {
            return new Range1f((float)(Min + delta), (float)(Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f ShrunkBy(float deltaMin, float deltaMax)
        {
            return new Range1f((float)(Min + deltaMin), (float)(Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(float delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(float deltaMin, float deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(float delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(float deltaMin, float deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float Clamped(float x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }

        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        /// <param name="x">Position between min and max [0,1].</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float Lerp(float x)
        {
            return Fun.Lerp(x, Min, Max);
        }

        /// <summary>
        /// Performs the inverse of Lerp.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float InvLerp(float x)
        {
            return Fun.InvLerp(x, Min, Max);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f SplitRight(float splitValue)
        {
            if (splitValue > Max) return Range1f.Invalid;
            if (splitValue <= Min) return this;
            return new Range1f(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f SplitLeft(float splitValue)
        {
            if (splitValue < Min) return Range1f.Invalid;
            if (splitValue >= Max) return this;
            return new Range1f(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f ExtendedBy(Range1f range)
        {
            return new Range1f(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f ExtendedBy(float value)
        {
            return new Range1f(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Range1f range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(float value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(float value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Range1f b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1f range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1f range, float eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1f Repair()
        {
            if (this.Equals(Range1f.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Range1f a, Range1f b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Range1f a, Range1f b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1f operator +(Range1f box, float v)
        {
            return new Range1f((float)(box.Min + v), (float)(box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1f operator -(Range1f box, float v)
        {
            return new Range1f((float)(box.Min - v), (float)(box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Range1f other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Range1f o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1f, int, float> Setter =
            (ref Range1f box, int i, float value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1f(float.Parse(x[0], CultureInfo.InvariantCulture),
                                float.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1f Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<float>.Parse, Range1f.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion
    }

    public static partial class Range
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1f Union(this Range1f a, Range1f b)
        {
            return new Range1f(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1f Intersection(this Range1f a, Range1f b)
        {
            return new Range1f(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        /// <summary>
        /// Checks if two ranges intersect each other with a tolerance parameter.
        /// </summary>
        // TODO: Implement for d > 2
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Intersects(this Range1f a, Range1f b, float eps, out Range1f result)
        {
            result = Range1f.Invalid;
            if (a.Min - eps > b.Max) return false;
            else if (a.Max + eps < b.Min) return false;
            else
            {
                result = new Range1f(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
                if (result.Size < eps)
                {
                    float center = result.Center;
                    result.Min = (float)(center - eps);
                    result.Max = (float)(center + eps);
                }
                return true;
            }
        }

        #endregion

        #region Bounding range for arrays

        /// <summary>
        /// Returns the bounding range of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1f GetBoundingRange(this float[] pointArray)
        {
            return pointArray.GetBoundingRange(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1f GetBoundingRange(this float[] pointArray, long count)
        {
            return pointArray.GetBoundingRange(0, count);
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1f GetBoundingRange(
                this float[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1f GetBoundingRange<T>(this T[] array, long start, long count, Func<T, float> pointSelector)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding range for lists

        /// <summary>
        /// Returns the bounding range of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1f GetBoundingRange(this List<float> pointList)
        {
            return pointList.GetBoundingRange(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the list.
        /// </summary>
        public static Range1f GetBoundingRange(this List<float> pointList, int count)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding range for indexed arrays

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1f GetBoundingRange(this int[] indexArray, float[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1f GetBoundingRange(this int[] indexArray, int count, float[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1f GetBoundingRange(this int[] indexArray, int start, int count, float[] pointArray)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1f GetBoundingRange<T>(this int[] indexArray, int start, int count, T[] array, Func<T, float> pointSelector)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1f GetBoundingRange(this long[] indexArray, float[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1f GetBoundingRange(this long[] indexArray, long count, float[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1f GetBoundingRange(this long[] indexArray, long start, long count, float[] pointArray)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1f GetBoundingRange<T>(this long[] indexArray, long start, long count, T[] array, Func<T, float> pointSelector)
        {
            if (count <= 0) return Range1f.Invalid;
            var box = new Range1f(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding range for IEnumerable

        /// <summary>
        /// Returns the bounding range of the elements of the collection.
        /// </summary>
        public static Range1f GetBoundingRange(this IEnumerable<float> points)
        {
            var box = Range1f.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #region Range extensions

    public static partial class RangeExtensions
    {
        /// <summary>
        /// Returns the int sequence 0 ... count-1.
        /// </summary>
        public static IEnumerable<float> Range(this float count)
        {
            for (float i = 0; i < count; i++) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<float> UpTo(this float self, float upToInclusive)
        {
            return self.UpTo(upToInclusive, 1);
        }

        public static IEnumerable<float> UpTo(this float self, float upToInclusive, float step)
        {
            for (float i = self; i <= upToInclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<float> UpToExclusive(this float self, float upToExclusive)
        {
            return self.UpToExclusive(upToExclusive, 1);
        }

        public static IEnumerable<float> UpToExclusive(this float self, float upToExclusive, float step)
        {
            for (float i = self; i < upToExclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<float> DownTo(this float self, float downToInclusive)
        {
            return self.DownTo(downToInclusive, 1);
        }

        public static IEnumerable<float> DownTo(this float self, float downToInclusive, float step)
        {
            for (float i = self; i >= downToInclusive; i -= step) yield return i;
        }
    }

    #endregion

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1f a, Range1f b)
        {
            return ApproximateEquals(a, b, Constant<float>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1f a, Range1f b, float tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Range1d

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Range1d
        : IEquatable<Range1d>, IRange<double, Range1d>,  IFormattable
    {
        [DataMember]
        public double Min;
        [DataMember]
        public double Max;

        #region Constructors

        /// <summary>
        /// Construct a Range1d from a Range1b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(Range1b b)
        {
            Min = (double) b.Min;
            Max = (double) b.Max;
        }

        /// <summary>
        /// Construct a Range1d from a Range1sb.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(Range1sb b)
        {
            Min = (double) b.Min;
            Max = (double) b.Max;
        }

        /// <summary>
        /// Construct a Range1d from a Range1s.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(Range1s b)
        {
            Min = (double) b.Min;
            Max = (double) b.Max;
        }

        /// <summary>
        /// Construct a Range1d from a Range1us.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(Range1us b)
        {
            Min = (double) b.Min;
            Max = (double) b.Max;
        }

        /// <summary>
        /// Construct a Range1d from a Range1i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(Range1i b)
        {
            Min = (double) b.Min;
            Max = (double) b.Max;
        }

        /// <summary>
        /// Construct a Range1d from a Range1ui.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(Range1ui b)
        {
            Min = (double) b.Min;
            Max = (double) b.Max;
        }

        /// <summary>
        /// Construct a Range1d from a Range1l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(Range1l b)
        {
            Min = (double) b.Min;
            Max = (double) b.Max;
        }

        /// <summary>
        /// Construct a Range1d from a Range1ul.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(Range1ul b)
        {
            Min = (double) b.Min;
            Max = (double) b.Max;
        }

        /// <summary>
        /// Construct a Range1d from a Range1f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(Range1f b)
        {
            Min = (double) b.Min;
            Max = (double) b.Max;
        }

        /// <summary>
        /// Creates a range from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(double min, double max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(double pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a range from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(double p0, double p1, double p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a range from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(double p0, double p1, double p2, double p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(Range1d range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(Range1d b0, Range1d b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(Range1d b0, Range1d b1, Range1d b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied ranges.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(Range1d b0, Range1d b1, Range1d b2, Range1d b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates range as the bounding range of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(double[] values)
        {
            Min = Max = values[0];
            long count = values.LongLength;
            for (long i = 1; i < count; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(double[] values, long start, long count)
        {
            Min = Max = values[start];
            for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(values[i]);
        }

        /// <summary>
        /// Creates range as the bounding range of given values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d(IEnumerable<double> values)
        {
            Min = Constant<double>.ParseableMaxValue;
            Max = Constant<double>.ParseableMinValue;
            foreach (double v in values) ExtendBy(v);
        }

        /// <summary>
        /// Returns new range [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1d FromMinAndSize(double min, double size)
        {
            return new Range1d(min, (min + size));
        }

        /// <summary>
        /// Returns new range [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1d FromCenterAndSize(double center, double size)
        {
            return new Range1d((center - size / 2), (center + size / 2));
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1d(Range1b b)
            => new Range1d(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1d(Range1sb b)
            => new Range1d(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1d(Range1s b)
            => new Range1d(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1d(Range1us b)
            => new Range1d(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1d(Range1i b)
            => new Range1d(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1d(Range1ui b)
            => new Range1d(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1d(Range1l b)
            => new Range1d(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1d(Range1ul b)
            => new Range1d(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Range1d(Range1f b)
            => new Range1d(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Range1d Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1d(Constant<double>.ParseableMaxValue, Constant<double>.ParseableMinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Range1d Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1d(Constant<double>.ParseableMinValue, Constant<double>.ParseableMaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Range1d Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Range1d(0, 1); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min >= Max; }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min <= Max; }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min > Max; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }


        /// <summary>
        /// Calculates size of the range.
        /// </summary>
        [XmlIgnore]
        public double Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (Min + value); }
        }

        public double Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return ((Min + Max) / 2); }
        }

        public IEnumerable<double> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) yield break; //Todo: check should not be necessary
                for (var i = Min; i <= Max; i++)
                    yield return i;
            }
        }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return range enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d EnlargedBy(double increment)
        {
            return new Range1d((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return range enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d EnlargedBy(double deltaMin, double deltaMax)
        {
            return new Range1d((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return range shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d ShrunkBy(double delta)
        {
            return new Range1d((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return range shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d ShrunkBy(double deltaMin, double deltaMax)
        {
            return new Range1d((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(double delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(double deltaMin, double deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks range by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(double delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks range by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(double deltaMin, double deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the value in the Range that is closest to the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double Clamped(double x)
        {
            return x < Min ? Min : (x > Max ? Max : x);
        }

        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        /// <param name="x">Position between min and max [0,1].</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double Lerp(double x)
        {
            return Fun.Lerp(x, Min, Max);
        }

        /// <summary>
        /// Performs the inverse of Lerp.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double InvLerp(double x)
        {
            return Fun.InvLerp(x, Min, Max);
        }


        /// <summary>
        /// Returns the range with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d SplitRight(double splitValue)
        {
            if (splitValue > Max) return Range1d.Invalid;
            if (splitValue <= Min) return this;
            return new Range1d(splitValue, Max);
        }

        /// <summary>
        /// Returns the range with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d SplitLeft(double splitValue)
        {
            if (splitValue < Min) return Range1d.Invalid;
            if (splitValue >= Max) return this;
            return new Range1d(Min, splitValue);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d ExtendedBy(Range1d range)
        {
            return new Range1d(
                            range.Min < Min ? range.Min : Min,
                            range.Max > Max ? range.Max : Max);
        }

        /// <summary>
        /// Returns the range extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d ExtendedBy(double value)
        {
            return new Range1d(
                            value < Min ? value : Min,
                            value > Max ? value : Max);
        }

        /// <summary>
        /// Extends the range to contain the supplied range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Range1d range)
        {
            if (range.Min < Min) Min = range.Min;
            if (range.Max > Max) Max = range.Max;
        }

        /// <summary>
        /// Extends the range to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(double value)
        {
            if (value < Min) Min = value;
            if (value > Max) Max = value;
        }

        /// <summary>
        /// Returns true if the range contains the given value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(double value)
        {
            return value >= Min && value <= Max;
        }

        /// <summary>
        /// Returns true if the range completely contains the given range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Range1d b)
        {
            return b.Min >= Min && b.Max <= Max;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1d range)
        {
            if (Min >= range.Max) return false;
            if (Max <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if 2 ranges intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Range1d range, double eps)
        {
            if (Min - eps >= range.Max) return false;
            if (Max + eps <= range.Min) return false;
            return true;
        }

        /// <summary>
        /// Checks if the range is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Range1d Repair()
        {
            if (this.Equals(Range1d.Invalid)) return this;
            if (Min > Max) Fun.Swap(ref Min, ref Max);
            return this;
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Range1d a, Range1d b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Range1d a, Range1d b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a range shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1d operator +(Range1d box, double v)
        {
            return new Range1d((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a range shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1d operator -(Range1d box, double v)
        {
            return new Range1d((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Range1d other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Range1d o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Range1d, int, double> Setter =
            (ref Range1d box, int i, double value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Range1d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Range1d(double.Parse(x[0], CultureInfo.InvariantCulture),
                                double.Parse(x[1], CultureInfo.InvariantCulture));
        }

        public static Range1d Parse(Text t)
        {
            return t.NestedBracketSplit(1, Text<double>.Parse, Range1d.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp) + betweenB
                          + Max.ToString(format, fp) + endB;
        }

        #endregion
    }

    public static partial class Range
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1d Union(this Range1d a, Range1d b)
        {
            return new Range1d(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1d Intersection(this Range1d a, Range1d b)
        {
            return new Range1d(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        /// <summary>
        /// Checks if two ranges intersect each other with a tolerance parameter.
        /// </summary>
        // TODO: Implement for d > 2
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Intersects(this Range1d a, Range1d b, double eps, out Range1d result)
        {
            result = Range1d.Invalid;
            if (a.Min - eps > b.Max) return false;
            else if (a.Max + eps < b.Min) return false;
            else
            {
                result = new Range1d(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
                if (result.Size < eps)
                {
                    double center = result.Center;
                    result.Min = (center - eps);
                    result.Max = (center + eps);
                }
                return true;
            }
        }

        #endregion

        #region Bounding range for arrays

        /// <summary>
        /// Returns the bounding range of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1d GetBoundingRange(this double[] pointArray)
        {
            return pointArray.GetBoundingRange(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1d GetBoundingRange(this double[] pointArray, long count)
        {
            return pointArray.GetBoundingRange(0, count);
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1d GetBoundingRange(
                this double[] pointArray, long start, long count)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of count elements of the array starting at start.
        /// </summary>
        public static Range1d GetBoundingRange<T>(this T[] array, long start, long count, Func<T, double> pointSelector)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding range for lists

        /// <summary>
        /// Returns the bounding range of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1d GetBoundingRange(this List<double> pointList)
        {
            return pointList.GetBoundingRange(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding range of the first count elements of the list.
        /// </summary>
        public static Range1d GetBoundingRange(this List<double> pointList, int count)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding range for indexed arrays

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1d GetBoundingRange(this int[] indexArray, double[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1d GetBoundingRange(this int[] indexArray, int count, double[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1d GetBoundingRange(this int[] indexArray, int start, int count, double[] pointArray)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1d GetBoundingRange<T>(this int[] indexArray, int start, int count, T[] array, Func<T, double> pointSelector)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1d GetBoundingRange(this long[] indexArray, double[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range1d GetBoundingRange(this long[] indexArray, long count, double[] pointArray)
        {
            return indexArray.GetBoundingRange(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1d GetBoundingRange(this long[] indexArray, long start, long count, double[] pointArray)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding range of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Range1d GetBoundingRange<T>(this long[] indexArray, long start, long count, T[] array, Func<T, double> pointSelector)
        {
            if (count <= 0) return Range1d.Invalid;
            var box = new Range1d(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding range for IEnumerable

        /// <summary>
        /// Returns the bounding range of the elements of the collection.
        /// </summary>
        public static Range1d GetBoundingRange(this IEnumerable<double> points)
        {
            var box = Range1d.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    #region Range extensions

    public static partial class RangeExtensions
    {
        /// <summary>
        /// Returns the int sequence 0 ... count-1.
        /// </summary>
        public static IEnumerable<double> Range(this double count)
        {
            for (double i = 0; i < count; i++) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<double> UpTo(this double self, double upToInclusive)
        {
            return self.UpTo(upToInclusive, 1);
        }

        public static IEnumerable<double> UpTo(this double self, double upToInclusive, double step)
        {
            for (double i = self; i <= upToInclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<double> UpToExclusive(this double self, double upToExclusive)
        {
            return self.UpToExclusive(upToExclusive, 1);
        }

        public static IEnumerable<double> UpToExclusive(this double self, double upToExclusive, double step)
        {
            for (double i = self; i < upToExclusive; i += step) yield return i;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static IEnumerable<double> DownTo(this double self, double downToInclusive)
        {
            return self.DownTo(downToInclusive, 1);
        }

        public static IEnumerable<double> DownTo(this double self, double downToInclusive, double step)
        {
            for (double i = self; i >= downToInclusive; i -= step) yield return i;
        }
    }

    #endregion

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1d a, Range1d b)
        {
            return ApproximateEquals(a, b, Constant<double>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Range1d a, Range1d b, double tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Box2i

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box2i
        : IEquatable<Box2i>, IRange<V2i, Box2i>, IBoundingBox2i, ISize2i, IFormattable
    {
        [DataMember]
        public V2i Min;
        [DataMember]
        public V2i Max;

        #region Constructors

        /// <summary>
        /// Construct a Box2i from a Box2l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(Box2l b)
        {
            Min = (V2i) b.Min;
            Max = (V2i) b.Max;
        }

        /// <summary>
        /// Construct a Box2i from a Box2f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(Box2f b)
        {
            Min = (V2i) b.Min;
            Max = (V2i) b.Max;
        }

        /// <summary>
        /// Construct a Box2i from a Box2d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(Box2d b)
        {
            Min = (V2i) b.Min;
            Max = (V2i) b.Max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(V2i min, V2i max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(int minX, int minY, int maxX, int maxY)
        {
            Min.X = minX;
            Min.Y = minY;
            Max.X = maxX;
            Max.Y = maxY;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(V2i pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(V2i p0, V2i p1, V2i p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(V2i p0, V2i p1, V2i p2, V2i p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(Box2i range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(Box2i b0, Box2i b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(Box2i b0, Box2i b1, Box2i b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(Box2i b0, Box2i b1, Box2i b2, Box2i b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(V2i[] points)
        {
            Min = V2i.MaxValue;
            Max = V2i.MinValue;
            if (points == null) return;
            var count = points.Length;
            for (var i = 0; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(V2i[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i(IEnumerable<V2i> points)
        {
            Min = V2i.MaxValue;
            Max = V2i.MinValue;
            if (points == null) return;
            foreach (V2i p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box2i(IEnumerable<Box2i> boxes)
        {
            Min = V2i.MaxValue;
            Max = V2i.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box2i(Range1i rangeX, Range1i rangeY)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box2i(Box2l b)
            => new Box2i(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box2i(Box2f b)
            => new Box2i(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box2i(Box2d b)
            => new Box2i(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Box2i Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box2i(V2i.MaxValue, V2i.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Box2i Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box2i(V2i.MinValue, V2i.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Box2i Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box2i(V2i.Zero, V2i.One); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreater(Max); }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }

        /// <summary>
        /// Same as Min.X.
        /// </summary>
        [XmlIgnore]
        public int Left
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Min.X = value; }
        }

        /// <summary>
        /// Same as Max.X.
        /// </summary>
        [XmlIgnore]
        public int Right
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.X = value; }
        }

        /// <summary>
        /// Same as Min.Y.
        /// </summary>
        [XmlIgnore]
        public int Top
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Min.Y = value; }
        }

        /// <summary>
        /// Same as Max.Y.
        /// </summary>
        [XmlIgnore]
        public int Bottom
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Y = value; }
        }

        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        [XmlIgnore]
        public V2i Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (Min + value); }
        }

        public V2i Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return ((Min + Max) / 2); }
        }

        [XmlIgnore]
        public int SizeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.X - Min.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.X = Min.X + value; }
        }

        public Range1i RangeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1i(Min.X, Max.X); }
        }

        [XmlIgnore]
        public int SizeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Y - Min.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Y = Min.Y + value; }
        }

        public Range1i RangeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1i(Min.Y, Max.Y); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeY > SizeX ? 1 : 0; }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeY < SizeX ? 1 : 0; }
        }

        public int Area
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeX * SizeY; }
        }

        public V2i OO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Min; } }
        public V2i IO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V2i(Max.X, Min.Y); } }
        public V2i OI { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V2i(Min.X, Max.Y); } }
        public V2i II { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i EnlargedBy(V2i increment)
        {
            return new Box2i((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i EnlargedBy(V2i deltaMin, V2i deltaMax)
        {
            return new Box2i((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i ShrunkBy(V2i delta)
        {
            return new Box2i((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i ShrunkBy(V2i deltaMin, V2i deltaMax)
        {
            return new Box2i((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V2i delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V2i deltaMin, V2i deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V2i delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V2i deltaMin, V2i deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i EnlargedBy(int delta)
        {
            return new Box2i(
                    new V2i(Min.X - delta, Min.Y - delta),
                    new V2i(Max.X + delta, Max.Y + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i ShrunkBy(int delta)
        {
            return new Box2i(
                    new V2i(Min.X + delta, Min.Y + delta),
                    new V2i(Max.X - delta, Max.Y - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i EnlargedBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY)
        {
            return new Box2i(
                    new V2i(Min.X - deltaMinX, Min.Y - deltaMinY),
                    new V2i(Max.X + deltaMaxX, Max.Y + deltaMaxY));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i ShrunkBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY)
        {
            return new Box2i(
                    new V2i(Min.X + deltaMinX, Min.Y + deltaMinY),
                    new V2i(Max.X - deltaMaxX, Max.Y - deltaMaxY));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(int delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(int delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2i Clamped(V2i p)
        {
            return new V2i(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y));
        }


        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i SplitRight(V2i splitValue)
        {
            var result = new Box2i(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i SplitLeft(V2i splitValue)
        {
            var result = new Box2i(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Min.X clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i SplitRight(int splitAtX)
        {
            if (splitAtX > Max.X) return Box2i.Invalid;
            if (splitAtX <= Min.X) return this;
            return new Box2i(new V2i(splitAtX, Min.Y), Max);
        }

        /// <summary>
        /// Returns a box with Max.X clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i SplitLeft(int splitAtX)
        {
            if (splitAtX < Min.X) return Box2i.Invalid;
            if (splitAtX >= Max.X) return this;
            return new Box2i(Min, new V2i(splitAtX, Max.Y));
        }

        /// <summary>
        /// Returns the box with Min.Y clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i SplitTop(int splitAtY)
        {
            if (splitAtY > Max.Y) return Box2i.Invalid;
            if (splitAtY <= Min.Y) return this;
            return new Box2i(new V2i(Min.X, splitAtY), Max);
        }

        /// <summary>
        /// Returns the box with Max.Y clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i SplitBottom(int splitAtY)
        {
            if (splitAtY < Min.Y) return Box2i.Invalid;
            if (splitAtY >= Max.Y) return this;
            return new Box2i(Min, new V2i(Max.X, splitAtY));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i SplitLeftBottom(V2i splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y < Min.Y) return Box2i.Invalid;
            return new Box2i(Min, splitAt);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i SplitRightBottom(V2i splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y < Min.Y) return Box2i.Invalid;
            return new Box2i(new V2i(splitAt.X, Min.Y), new V2i(Max.X, splitAt.Y));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i SplitLeftTop(V2i splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y > Max.Y) return Box2i.Invalid;
            return new Box2i(new V2i(Min.X, splitAt.Y), new V2i(splitAt.X, Max.Y));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i SplitRightTop(V2i splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y > Max.Y) return Box2i.Invalid;
            return new Box2i(splitAt, Max);
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i ExtendedBy(Box2i b)
        {
            return new Box2i(
                    new V2i(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y),
                    new V2i(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i ExtendedBy(V2i v)
        {
            return new Box2i(
                    new V2i(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y),
                    new V2i(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Box2i box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(V2i point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i ExtendXBy(int x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i ExtendYBy(int y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i ExtendDimBy(int dim, int x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(V2i p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Box2i b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i Repair()
        {
            if (Equals(Box2i.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box2i box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box2i box, V2i eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box2i box, int eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i Invalidate()
        {
            Min = V2i.MaxValue;
            Max = V2i.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(V2i p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(Box2i b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinMaxInDirection(V2i v, out V2i vMin, out V2i vMax)
        {
            vMin = V2i.MinValue;
            vMax = V2i.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Box2i a, Box2i b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Box2i a, Box2i b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i operator +(Box2i box, V2i v)
        {
            return new Box2i((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i operator -(Box2i box, V2i v)
        {
            return new Box2i((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Box2i other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Box2i o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box2i, int, V2i> Setter =
            (ref Box2i box, int i, V2i value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box2i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box2i(V2i.Parse(x[0].ToString()),
                                V2i.Parse(x[1].ToString()));
        }

        public static Box2i Parse(Text t)
        {
            return t.NestedBracketSplit(1, V2i.Parse, Box2i.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i FromSize(V2i size)
        {
            return new Box2i(V2i.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i FromMinAndSize(V2i min, V2i size)
        {
            return new Box2i(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i FromCenterAndSize(V2i center, V2i size)
        {
            return new Box2i(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i FromSize(ISize2i iSize)
        {
            return new Box2i(
                V2i.Zero, iSize.Size2i);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i FromMinAndSize(V2i min, ISize2i iSize)
        {
            return new Box2i(
                min, min + iSize.Size2i);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i FromCenterAndSize(V2i center, ISize2i iSize)
        {
            var size = iSize.Size2i;
            return new Box2i(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i FromPoints(V2i p0, V2i p1)
        {
            return new Box2i(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i FromSize(int width, int height)
        {
            return Box2i.FromSize(new V2i(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i FromMinAndSize(V2i min, int width, int height)
        {
            return new Box2i(min, min + new V2i(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i FromMinAndSize(
            int minX, int minY, int width, int height
            )
        {
            return Box2i.FromMinAndSize(new V2i(minX, minY), new V2i(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i FromCenterAndSize(V2i center, int width, int height)
        {
            return FromCenterAndSize(center, new V2i(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i FromCenterAndSize(
            int centerX, int centerY, int width, int height
            )
        {
            return FromCenterAndSize(new V2i(centerX, centerY), new V2i(width, height));
        }

        #endregion

        #region Transforms

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i Translated(V2i shift)
        {
            return IsInvalid ? Box2i.Invalid
                             : new Box2i(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2i Scaled(V2i factor)
        {
            return IsInvalid ? Box2i.Invalid
                             : new Box2i(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box2d Transformed(M33d trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y) return Box2d.Invalid; 
            var t = new V2d(trafo.M02, trafo.M12);
            var res = new Box2d(t, t);
            double av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            return res;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d Transformed(Trafo2d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2i Corner(int index)
        {
            return
                new V2i(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2i[] ComputeCorners()
        {
            return new V2i[] {
                Min,
                new V2i(Max.X, Min.Y),
                new V2i(Min.X, Max.Y),
                Max
            };
        }

        // TODO: Comment and implement for dimensions other than 2.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2i[] ComputeCornersCCW()
        {
            return new V2i[] {
                Min,
                new V2i(Max.X, Min.Y),
                Max,
                new V2i(Min.X, Max.Y),
            };
        }

        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V2i> Corners
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return Min;
                yield return new V2i(Max.X, Min.Y);
                yield return new V2i(Min.X, Max.Y);
                yield return Max;
            }
        }

        #endregion

        #region Swizzle methods


        #endregion

        #region Enumerators

        /// <summary>
        /// Returns all points from [Min,Max[ with X-Variable in the outer loop.
        /// </summary>
        public IEnumerable<V2i> EnumerateInsidePoints()
        {
            var p = new V2i();
            for (p.X = Min.X; p.X < Max.X; p.X++)
            for (p.Y = Min.Y; p.Y < Max.Y; p.Y++)
                yield return p;
        }

        #endregion

        #region IBoundingBox2i Members

        public Box2i BoundingBox2i
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this; }
        }

        #endregion

        #region ISize2i Members

        public V2i Size2i
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Size; }
        }

        #endregion
    }

    public static partial class Box
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i Union(this Box2i a, Box2i b)
        {
            return new Box2i(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i Intersection(this Box2i a, Box2i b)
        {
            return new Box2i(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        #endregion

        #region Bounding box for arrays

        /// <summary>
        /// Returns the bounding box of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i GetBoundingBox(this V2i[] pointArray)
        {
            return pointArray.GetBoundingBox(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i GetBoundingBox(this V2i[] pointArray, long count)
        {
            return pointArray.GetBoundingBox(0, count);
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box2i GetBoundingBox(
                this V2i[] pointArray, long start, long count)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box2i GetBoundingBox<T>(this T[] array, long start, long count, Func<T, V2i> pointSelector)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding box for lists

        /// <summary>
        /// Returns the bounding box of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i GetBoundingBox(this List<V2i> pointList)
        {
            return pointList.GetBoundingBox(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the list.
        /// </summary>
        public static Box2i GetBoundingBox(this List<V2i> pointList, int count)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding box for indexed arrays

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i GetBoundingBox(this int[] indexArray, V2i[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i GetBoundingBox(this int[] indexArray, int count, V2i[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2i GetBoundingBox(this int[] indexArray, int start, int count, V2i[] pointArray)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2i GetBoundingBox<T>(this int[] indexArray, int start, int count, T[] array, Func<T, V2i> pointSelector)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i GetBoundingBox(this long[] indexArray, V2i[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2i GetBoundingBox(this long[] indexArray, long count, V2i[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2i GetBoundingBox(this long[] indexArray, long start, long count, V2i[] pointArray)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2i GetBoundingBox<T>(this long[] indexArray, long start, long count, T[] array, Func<T, V2i> pointSelector)
        {
            if (count <= 0) return Box2i.Invalid;
            var box = new Box2i(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding box for IEnumerable

        /// <summary>
        /// Returns the bounding box of the elements of the collection.
        /// </summary>
        public static Box2i GetBoundingBox(this IEnumerable<V2i> points)
        {
            var box = Box2i.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box2i a, Box2i b)
        {
            return ApproximateEquals(a, b, Constant<int>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box2i a, Box2i b, int tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Box2l

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box2l
        : IEquatable<Box2l>, IRange<V2l, Box2l>, IBoundingBox2l, ISize2l, IFormattable
    {
        [DataMember]
        public V2l Min;
        [DataMember]
        public V2l Max;

        #region Constructors

        /// <summary>
        /// Construct a Box2l from a Box2i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(Box2i b)
        {
            Min = (V2l) b.Min;
            Max = (V2l) b.Max;
        }

        /// <summary>
        /// Construct a Box2l from a Box2f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(Box2f b)
        {
            Min = (V2l) b.Min;
            Max = (V2l) b.Max;
        }

        /// <summary>
        /// Construct a Box2l from a Box2d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(Box2d b)
        {
            Min = (V2l) b.Min;
            Max = (V2l) b.Max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(V2l min, V2l max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(long minX, long minY, long maxX, long maxY)
        {
            Min.X = minX;
            Min.Y = minY;
            Max.X = maxX;
            Max.Y = maxY;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(V2l pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(V2l p0, V2l p1, V2l p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(V2l p0, V2l p1, V2l p2, V2l p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(Box2l range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(Box2l b0, Box2l b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(Box2l b0, Box2l b1, Box2l b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(Box2l b0, Box2l b1, Box2l b2, Box2l b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(V2l[] points)
        {
            Min = V2l.MaxValue;
            Max = V2l.MinValue;
            if (points == null) return;
            var count = points.Length;
            for (var i = 0; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(V2l[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l(IEnumerable<V2l> points)
        {
            Min = V2l.MaxValue;
            Max = V2l.MinValue;
            if (points == null) return;
            foreach (V2l p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box2l(IEnumerable<Box2l> boxes)
        {
            Min = V2l.MaxValue;
            Max = V2l.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box2l(Range1l rangeX, Range1l rangeY)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box2l(Box2i b)
            => new Box2l(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box2l(Box2f b)
            => new Box2l(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box2l(Box2d b)
            => new Box2l(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Box2l Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box2l(V2l.MaxValue, V2l.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Box2l Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box2l(V2l.MinValue, V2l.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Box2l Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box2l(V2l.Zero, V2l.One); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreater(Max); }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }

        /// <summary>
        /// Same as Min.X.
        /// </summary>
        [XmlIgnore]
        public long Left
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Min.X = value; }
        }

        /// <summary>
        /// Same as Max.X.
        /// </summary>
        [XmlIgnore]
        public long Right
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.X = value; }
        }

        /// <summary>
        /// Same as Min.Y.
        /// </summary>
        [XmlIgnore]
        public long Top
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Min.Y = value; }
        }

        /// <summary>
        /// Same as Max.Y.
        /// </summary>
        [XmlIgnore]
        public long Bottom
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Y = value; }
        }

        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        [XmlIgnore]
        public V2l Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (Min + value); }
        }

        public V2l Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return ((Min + Max) / 2); }
        }

        [XmlIgnore]
        public long SizeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.X - Min.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.X = Min.X + value; }
        }

        public Range1l RangeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1l(Min.X, Max.X); }
        }

        [XmlIgnore]
        public long SizeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Y - Min.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Y = Min.Y + value; }
        }

        public Range1l RangeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1l(Min.Y, Max.Y); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeY > SizeX ? 1 : 0; }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeY < SizeX ? 1 : 0; }
        }

        public long Area
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeX * SizeY; }
        }

        public V2l OO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Min; } }
        public V2l IO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V2l(Max.X, Min.Y); } }
        public V2l OI { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V2l(Min.X, Max.Y); } }
        public V2l II { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l EnlargedBy(V2l increment)
        {
            return new Box2l((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l EnlargedBy(V2l deltaMin, V2l deltaMax)
        {
            return new Box2l((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l ShrunkBy(V2l delta)
        {
            return new Box2l((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l ShrunkBy(V2l deltaMin, V2l deltaMax)
        {
            return new Box2l((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V2l delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V2l deltaMin, V2l deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V2l delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V2l deltaMin, V2l deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l EnlargedBy(long delta)
        {
            return new Box2l(
                    new V2l(Min.X - delta, Min.Y - delta),
                    new V2l(Max.X + delta, Max.Y + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l ShrunkBy(long delta)
        {
            return new Box2l(
                    new V2l(Min.X + delta, Min.Y + delta),
                    new V2l(Max.X - delta, Max.Y - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l EnlargedBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY)
        {
            return new Box2l(
                    new V2l(Min.X - deltaMinX, Min.Y - deltaMinY),
                    new V2l(Max.X + deltaMaxX, Max.Y + deltaMaxY));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l ShrunkBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY)
        {
            return new Box2l(
                    new V2l(Min.X + deltaMinX, Min.Y + deltaMinY),
                    new V2l(Max.X - deltaMaxX, Max.Y - deltaMaxY));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(long delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(long delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2l Clamped(V2l p)
        {
            return new V2l(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y));
        }


        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l SplitRight(V2l splitValue)
        {
            var result = new Box2l(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l SplitLeft(V2l splitValue)
        {
            var result = new Box2l(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Min.X clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l SplitRight(long splitAtX)
        {
            if (splitAtX > Max.X) return Box2l.Invalid;
            if (splitAtX <= Min.X) return this;
            return new Box2l(new V2l(splitAtX, Min.Y), Max);
        }

        /// <summary>
        /// Returns a box with Max.X clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l SplitLeft(long splitAtX)
        {
            if (splitAtX < Min.X) return Box2l.Invalid;
            if (splitAtX >= Max.X) return this;
            return new Box2l(Min, new V2l(splitAtX, Max.Y));
        }

        /// <summary>
        /// Returns the box with Min.Y clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l SplitTop(long splitAtY)
        {
            if (splitAtY > Max.Y) return Box2l.Invalid;
            if (splitAtY <= Min.Y) return this;
            return new Box2l(new V2l(Min.X, splitAtY), Max);
        }

        /// <summary>
        /// Returns the box with Max.Y clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l SplitBottom(long splitAtY)
        {
            if (splitAtY < Min.Y) return Box2l.Invalid;
            if (splitAtY >= Max.Y) return this;
            return new Box2l(Min, new V2l(Max.X, splitAtY));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l SplitLeftBottom(V2l splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y < Min.Y) return Box2l.Invalid;
            return new Box2l(Min, splitAt);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l SplitRightBottom(V2l splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y < Min.Y) return Box2l.Invalid;
            return new Box2l(new V2l(splitAt.X, Min.Y), new V2l(Max.X, splitAt.Y));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l SplitLeftTop(V2l splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y > Max.Y) return Box2l.Invalid;
            return new Box2l(new V2l(Min.X, splitAt.Y), new V2l(splitAt.X, Max.Y));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l SplitRightTop(V2l splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y > Max.Y) return Box2l.Invalid;
            return new Box2l(splitAt, Max);
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l ExtendedBy(Box2l b)
        {
            return new Box2l(
                    new V2l(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y),
                    new V2l(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l ExtendedBy(V2l v)
        {
            return new Box2l(
                    new V2l(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y),
                    new V2l(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Box2l box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(V2l point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l ExtendXBy(long x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l ExtendYBy(long y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l ExtendDimBy(int dim, long x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(V2l p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Box2l b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l Repair()
        {
            if (Equals(Box2l.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box2l box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box2l box, V2l eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box2l box, long eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l Invalidate()
        {
            Min = V2l.MaxValue;
            Max = V2l.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(V2l p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(Box2l b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinMaxInDirection(V2l v, out V2l vMin, out V2l vMax)
        {
            vMin = V2l.MinValue;
            vMax = V2l.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Box2l a, Box2l b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Box2l a, Box2l b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l operator +(Box2l box, V2l v)
        {
            return new Box2l((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l operator -(Box2l box, V2l v)
        {
            return new Box2l((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Box2l other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Box2l o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box2l, int, V2l> Setter =
            (ref Box2l box, int i, V2l value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box2l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box2l(V2l.Parse(x[0].ToString()),
                                V2l.Parse(x[1].ToString()));
        }

        public static Box2l Parse(Text t)
        {
            return t.NestedBracketSplit(1, V2l.Parse, Box2l.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l FromSize(V2l size)
        {
            return new Box2l(V2l.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l FromMinAndSize(V2l min, V2l size)
        {
            return new Box2l(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l FromCenterAndSize(V2l center, V2l size)
        {
            return new Box2l(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l FromSize(ISize2l iSize)
        {
            return new Box2l(
                V2l.Zero, iSize.Size2l);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l FromMinAndSize(V2l min, ISize2l iSize)
        {
            return new Box2l(
                min, min + iSize.Size2l);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l FromCenterAndSize(V2l center, ISize2l iSize)
        {
            var size = iSize.Size2l;
            return new Box2l(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l FromPoints(V2l p0, V2l p1)
        {
            return new Box2l(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l FromSize(long width, long height)
        {
            return Box2l.FromSize(new V2l(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l FromMinAndSize(V2l min, long width, long height)
        {
            return new Box2l(min, min + new V2l(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l FromMinAndSize(
            long minX, long minY, long width, long height
            )
        {
            return Box2l.FromMinAndSize(new V2l(minX, minY), new V2l(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l FromCenterAndSize(V2l center, long width, long height)
        {
            return FromCenterAndSize(center, new V2l(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l FromCenterAndSize(
            long centerX, long centerY, long width, long height
            )
        {
            return FromCenterAndSize(new V2l(centerX, centerY), new V2l(width, height));
        }

        #endregion

        #region Transforms

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l Translated(V2l shift)
        {
            return IsInvalid ? Box2l.Invalid
                             : new Box2l(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2l Scaled(V2l factor)
        {
            return IsInvalid ? Box2l.Invalid
                             : new Box2l(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box2d Transformed(M33d trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y) return Box2d.Invalid; 
            var t = new V2d(trafo.M02, trafo.M12);
            var res = new Box2d(t, t);
            double av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            return res;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d Transformed(Trafo2d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2l Corner(int index)
        {
            return
                new V2l(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2l[] ComputeCorners()
        {
            return new V2l[] {
                Min,
                new V2l(Max.X, Min.Y),
                new V2l(Min.X, Max.Y),
                Max
            };
        }

        // TODO: Comment and implement for dimensions other than 2.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2l[] ComputeCornersCCW()
        {
            return new V2l[] {
                Min,
                new V2l(Max.X, Min.Y),
                Max,
                new V2l(Min.X, Max.Y),
            };
        }

        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V2l> Corners
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return Min;
                yield return new V2l(Max.X, Min.Y);
                yield return new V2l(Min.X, Max.Y);
                yield return Max;
            }
        }

        #endregion

        #region Swizzle methods


        #endregion

        #region Enumerators

        /// <summary>
        /// Returns all points from [Min,Max[ with X-Variable in the outer loop.
        /// </summary>
        public IEnumerable<V2l> EnumerateInsidePoints()
        {
            var p = new V2l();
            for (p.X = Min.X; p.X < Max.X; p.X++)
            for (p.Y = Min.Y; p.Y < Max.Y; p.Y++)
                yield return p;
        }

        #endregion

        #region IBoundingBox2l Members

        public Box2l BoundingBox2l
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this; }
        }

        #endregion

        #region ISize2l Members

        public V2l Size2l
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Size; }
        }

        #endregion
    }

    public static partial class Box
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l Union(this Box2l a, Box2l b)
        {
            return new Box2l(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l Intersection(this Box2l a, Box2l b)
        {
            return new Box2l(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        #endregion

        #region Bounding box for arrays

        /// <summary>
        /// Returns the bounding box of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l GetBoundingBox(this V2l[] pointArray)
        {
            return pointArray.GetBoundingBox(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l GetBoundingBox(this V2l[] pointArray, long count)
        {
            return pointArray.GetBoundingBox(0, count);
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box2l GetBoundingBox(
                this V2l[] pointArray, long start, long count)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box2l GetBoundingBox<T>(this T[] array, long start, long count, Func<T, V2l> pointSelector)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding box for lists

        /// <summary>
        /// Returns the bounding box of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l GetBoundingBox(this List<V2l> pointList)
        {
            return pointList.GetBoundingBox(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the list.
        /// </summary>
        public static Box2l GetBoundingBox(this List<V2l> pointList, int count)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding box for indexed arrays

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l GetBoundingBox(this int[] indexArray, V2l[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l GetBoundingBox(this int[] indexArray, int count, V2l[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2l GetBoundingBox(this int[] indexArray, int start, int count, V2l[] pointArray)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2l GetBoundingBox<T>(this int[] indexArray, int start, int count, T[] array, Func<T, V2l> pointSelector)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l GetBoundingBox(this long[] indexArray, V2l[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2l GetBoundingBox(this long[] indexArray, long count, V2l[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2l GetBoundingBox(this long[] indexArray, long start, long count, V2l[] pointArray)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2l GetBoundingBox<T>(this long[] indexArray, long start, long count, T[] array, Func<T, V2l> pointSelector)
        {
            if (count <= 0) return Box2l.Invalid;
            var box = new Box2l(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding box for IEnumerable

        /// <summary>
        /// Returns the bounding box of the elements of the collection.
        /// </summary>
        public static Box2l GetBoundingBox(this IEnumerable<V2l> points)
        {
            var box = Box2l.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box2l a, Box2l b)
        {
            return ApproximateEquals(a, b, Constant<long>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box2l a, Box2l b, long tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Box2f

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box2f
        : IEquatable<Box2f>, IRange<V2f, Box2f>, IBoundingBox2f, ISize2f, IFormattable
    {
        [DataMember]
        public V2f Min;
        [DataMember]
        public V2f Max;

        #region Constructors

        /// <summary>
        /// Construct a Box2f from a Box2i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(Box2i b)
        {
            Min = (V2f) b.Min;
            Max = (V2f) b.Max;
        }

        /// <summary>
        /// Construct a Box2f from a Box2l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(Box2l b)
        {
            Min = (V2f) b.Min;
            Max = (V2f) b.Max;
        }

        /// <summary>
        /// Construct a Box2f from a Box2d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(Box2d b)
        {
            Min = (V2f) b.Min;
            Max = (V2f) b.Max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(V2f min, V2f max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(float minX, float minY, float maxX, float maxY)
        {
            Min.X = minX;
            Min.Y = minY;
            Max.X = maxX;
            Max.Y = maxY;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(V2f pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(V2f p0, V2f p1, V2f p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(V2f p0, V2f p1, V2f p2, V2f p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(Box2f range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(Box2f b0, Box2f b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(Box2f b0, Box2f b1, Box2f b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(Box2f b0, Box2f b1, Box2f b2, Box2f b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(V2f[] points)
        {
            Min = V2f.MaxValue;
            Max = V2f.MinValue;
            if (points == null) return;
            var count = points.Length;
            for (var i = 0; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(V2f[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f(IEnumerable<V2f> points)
        {
            Min = V2f.MaxValue;
            Max = V2f.MinValue;
            if (points == null) return;
            foreach (V2f p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box2f(IEnumerable<Box2f> boxes)
        {
            Min = V2f.MaxValue;
            Max = V2f.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box2f(Range1f rangeX, Range1f rangeY)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box2f(Box2i b)
            => new Box2f(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box2f(Box2l b)
            => new Box2f(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box2f(Box2d b)
            => new Box2f(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Box2f Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box2f(V2f.MaxValue, V2f.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Box2f Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box2f(V2f.MinValue, V2f.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Box2f Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box2f(V2f.Zero, V2f.One); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreater(Max) || Min.IsNaN || Max.IsNaN; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }

        /// <summary>
        /// Same as Min.X.
        /// </summary>
        [XmlIgnore]
        public float Left
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Min.X = value; }
        }

        /// <summary>
        /// Same as Max.X.
        /// </summary>
        [XmlIgnore]
        public float Right
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.X = value; }
        }

        /// <summary>
        /// Same as Min.Y.
        /// </summary>
        [XmlIgnore]
        public float Top
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Min.Y = value; }
        }

        /// <summary>
        /// Same as Max.Y.
        /// </summary>
        [XmlIgnore]
        public float Bottom
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Y = value; }
        }

        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        [XmlIgnore]
        public V2f Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (Min + value); }
        }

        public V2f Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return ((Min + Max) / 2); }
        }

        [XmlIgnore]
        public float SizeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.X - Min.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.X = Min.X + value; }
        }

        public Range1f RangeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1f(Min.X, Max.X); }
        }

        [XmlIgnore]
        public float SizeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Y - Min.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Y = Min.Y + value; }
        }

        public Range1f RangeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1f(Min.Y, Max.Y); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeY > SizeX ? 1 : 0; }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeY < SizeX ? 1 : 0; }
        }

        public float Area
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeX * SizeY; }
        }

        public V2f OO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Min; } }
        public V2f IO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V2f(Max.X, Min.Y); } }
        public V2f OI { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V2f(Min.X, Max.Y); } }
        public V2f II { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f EnlargedBy(V2f increment)
        {
            return new Box2f((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f EnlargedBy(V2f deltaMin, V2f deltaMax)
        {
            return new Box2f((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f ShrunkBy(V2f delta)
        {
            return new Box2f((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f ShrunkBy(V2f deltaMin, V2f deltaMax)
        {
            return new Box2f((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V2f delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V2f deltaMin, V2f deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V2f delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V2f deltaMin, V2f deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f EnlargedBy(float delta)
        {
            return new Box2f(
                    new V2f(Min.X - delta, Min.Y - delta),
                    new V2f(Max.X + delta, Max.Y + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f ShrunkBy(float delta)
        {
            return new Box2f(
                    new V2f(Min.X + delta, Min.Y + delta),
                    new V2f(Max.X - delta, Max.Y - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f EnlargedBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY)
        {
            return new Box2f(
                    new V2f(Min.X - deltaMinX, Min.Y - deltaMinY),
                    new V2f(Max.X + deltaMaxX, Max.Y + deltaMaxY));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f ShrunkBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY)
        {
            return new Box2f(
                    new V2f(Min.X + deltaMinX, Min.Y + deltaMinY),
                    new V2f(Max.X - deltaMaxX, Max.Y - deltaMaxY));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(float delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(float delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f ScaledFromCenterBy(float factor)
        {
            var size = Size;
            var increment = (size * factor - size) / 2;
            return new Box2f(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f ScaledFromCenterBy(V2f vectorFactor)
        {
            var size = Size;
            var increment = (size * vectorFactor - size) / 2;
            return new Box2f(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return a box enlarged in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f EnlargedByRelativeEps(float eps)
        {
            return EnlargedBy(eps * Size.Length);
        }

        /// <summary>
        /// Enlarge the box in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeByRelativeEps(float eps)
        {
            EnlargeBy(eps * Size.Length);
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2f Clamped(V2f p)
        {
            return new V2f(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y));
        }

        /// <summary>
        /// Returns the squared distance to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double DistanceSquared(V2f p)
        {
            return 
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0));
        }

        /// <summary>
        /// Returns the distance to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double Distance(V2f p)
        {
            return Fun.Sqrt(
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0)));
        }

        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        /// <param name="x">Position between min and max [0,1].</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2f Lerp(float x)
        {
            return Fun.Lerp(x, Min, Max);
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2f Lerp(V2f p)
        {
            return new V2f(
                        Fun.Lerp(p.X, Min.X, Max.X), 
                        Fun.Lerp(p.Y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2f Lerp(float x, float y)
        {
            return new V2f(
                         Fun.Lerp(x, Min.X, Max.X), 
                         Fun.Lerp(y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2f InvLerp(V2f p)
        {
            return new V2f(
                        Fun.InvLerp(p.X, Min.X, Max.X), 
                        Fun.InvLerp(p.Y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2f InvLerp(float x, float y)
        {
            return new V2f(
                        Fun.InvLerp(x, Min.X, Max.X), 
                        Fun.InvLerp(y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f SplitRight(V2f splitValue)
        {
            var result = new Box2f(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f SplitLeft(V2f splitValue)
        {
            var result = new Box2f(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Min.X clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f SplitRight(float splitAtX)
        {
            if (splitAtX > Max.X) return Box2f.Invalid;
            if (splitAtX <= Min.X) return this;
            return new Box2f(new V2f(splitAtX, Min.Y), Max);
        }

        /// <summary>
        /// Returns a box with Max.X clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f SplitLeft(float splitAtX)
        {
            if (splitAtX < Min.X) return Box2f.Invalid;
            if (splitAtX >= Max.X) return this;
            return new Box2f(Min, new V2f(splitAtX, Max.Y));
        }

        /// <summary>
        /// Returns the box with Min.Y clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f SplitTop(float splitAtY)
        {
            if (splitAtY > Max.Y) return Box2f.Invalid;
            if (splitAtY <= Min.Y) return this;
            return new Box2f(new V2f(Min.X, splitAtY), Max);
        }

        /// <summary>
        /// Returns the box with Max.Y clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f SplitBottom(float splitAtY)
        {
            if (splitAtY < Min.Y) return Box2f.Invalid;
            if (splitAtY >= Max.Y) return this;
            return new Box2f(Min, new V2f(Max.X, splitAtY));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f SplitLeftBottom(V2f splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y < Min.Y) return Box2f.Invalid;
            return new Box2f(Min, splitAt);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f SplitRightBottom(V2f splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y < Min.Y) return Box2f.Invalid;
            return new Box2f(new V2f(splitAt.X, Min.Y), new V2f(Max.X, splitAt.Y));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f SplitLeftTop(V2f splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y > Max.Y) return Box2f.Invalid;
            return new Box2f(new V2f(Min.X, splitAt.Y), new V2f(splitAt.X, Max.Y));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f SplitRightTop(V2f splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y > Max.Y) return Box2f.Invalid;
            return new Box2f(splitAt, Max);
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f ExtendedBy(Box2f b)
        {
            return new Box2f(
                    new V2f(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y),
                    new V2f(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f ExtendedBy(V2f v)
        {
            return new Box2f(
                    new V2f(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y),
                    new V2f(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Box2f box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(V2f point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f ExtendXBy(float x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f ExtendYBy(float y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f ExtendDimBy(int dim, float x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(V2f p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Box2f b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f Repair()
        {
            if (Equals(Box2f.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box2f box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box2f box, V2f eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box2f box, float eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f Invalidate()
        {
            Min = V2f.MaxValue;
            Max = V2f.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(V2f p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(Box2f b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinMaxInDirection(V2f v, out V2f vMin, out V2f vMax)
        {
            vMin = V2f.MinValue;
            vMax = V2f.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Box2f a, Box2f b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Box2f a, Box2f b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f operator +(Box2f box, V2f v)
        {
            return new Box2f((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f operator -(Box2f box, V2f v)
        {
            return new Box2f((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Box2f other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Box2f o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box2f, int, V2f> Setter =
            (ref Box2f box, int i, V2f value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box2f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box2f(V2f.Parse(x[0].ToString()),
                                V2f.Parse(x[1].ToString()));
        }

        public static Box2f Parse(Text t)
        {
            return t.NestedBracketSplit(1, V2f.Parse, Box2f.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f FromSize(V2f size)
        {
            return new Box2f(V2f.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f FromMinAndSize(V2f min, V2f size)
        {
            return new Box2f(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f FromCenterAndSize(V2f center, V2f size)
        {
            return new Box2f(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f FromSize(ISize2f iSize)
        {
            return new Box2f(
                V2f.Zero, iSize.Size2f);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f FromMinAndSize(V2f min, ISize2f iSize)
        {
            return new Box2f(
                min, min + iSize.Size2f);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f FromCenterAndSize(V2f center, ISize2f iSize)
        {
            var size = iSize.Size2f;
            return new Box2f(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f FromPoints(V2f p0, V2f p1)
        {
            return new Box2f(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f FromSize(float width, float height)
        {
            return Box2f.FromSize(new V2f(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f FromMinAndSize(V2f min, float width, float height)
        {
            return new Box2f(min, min + new V2f(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f FromMinAndSize(
            float minX, float minY, float width, float height
            )
        {
            return Box2f.FromMinAndSize(new V2f(minX, minY), new V2f(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f FromCenterAndSize(V2f center, float width, float height)
        {
            return FromCenterAndSize(center, new V2f(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f FromCenterAndSize(
            float centerX, float centerY, float width, float height
            )
        {
            return FromCenterAndSize(new V2f(centerX, centerY), new V2f(width, height));
        }

        #endregion

        #region Transforms

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f Translated(V2f shift)
        {
            return IsInvalid ? Box2f.Invalid
                             : new Box2f(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f Scaled(V2f factor)
        {
            return IsInvalid ? Box2f.Invalid
                             : new Box2f(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box2f Transformed(M33f trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y) return Box2f.Invalid; 
            var t = new V2f(trafo.M02, trafo.M12);
            var res = new Box2f(t, t);
            float av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            return res;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2f Transformed(Trafo2f trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2f Corner(int index)
        {
            return
                new V2f(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2f[] ComputeCorners()
        {
            return new V2f[] {
                Min,
                new V2f(Max.X, Min.Y),
                new V2f(Min.X, Max.Y),
                Max
            };
        }

        // TODO: Comment and implement for dimensions other than 2.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2f[] ComputeCornersCCW()
        {
            return new V2f[] {
                Min,
                new V2f(Max.X, Min.Y),
                Max,
                new V2f(Min.X, Max.Y),
            };
        }

        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V2f> Corners
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return Min;
                yield return new V2f(Max.X, Min.Y);
                yield return new V2f(Min.X, Max.Y);
                yield return Max;
            }
        }

        #endregion

        #region Swizzle methods


        #endregion

        #region Enumerators

        #endregion

        #region IBoundingBox2f Members

        public Box2f BoundingBox2f
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this; }
        }

        #endregion

        #region ISize2f Members

        public V2f Size2f
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Size; }
        }

        #endregion
    }

    public static partial class Box
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f Union(this Box2f a, Box2f b)
        {
            return new Box2f(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f Intersection(this Box2f a, Box2f b)
        {
            return new Box2f(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        #endregion

        #region Bounding box for arrays

        /// <summary>
        /// Returns the bounding box of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f GetBoundingBox(this V2f[] pointArray)
        {
            return pointArray.GetBoundingBox(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f GetBoundingBox(this V2f[] pointArray, long count)
        {
            return pointArray.GetBoundingBox(0, count);
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box2f GetBoundingBox(
                this V2f[] pointArray, long start, long count)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box2f GetBoundingBox<T>(this T[] array, long start, long count, Func<T, V2f> pointSelector)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding box for lists

        /// <summary>
        /// Returns the bounding box of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f GetBoundingBox(this List<V2f> pointList)
        {
            return pointList.GetBoundingBox(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the list.
        /// </summary>
        public static Box2f GetBoundingBox(this List<V2f> pointList, int count)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding box for indexed arrays

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f GetBoundingBox(this int[] indexArray, V2f[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f GetBoundingBox(this int[] indexArray, int count, V2f[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2f GetBoundingBox(this int[] indexArray, int start, int count, V2f[] pointArray)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2f GetBoundingBox<T>(this int[] indexArray, int start, int count, T[] array, Func<T, V2f> pointSelector)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f GetBoundingBox(this long[] indexArray, V2f[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2f GetBoundingBox(this long[] indexArray, long count, V2f[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2f GetBoundingBox(this long[] indexArray, long start, long count, V2f[] pointArray)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2f GetBoundingBox<T>(this long[] indexArray, long start, long count, T[] array, Func<T, V2f> pointSelector)
        {
            if (count <= 0) return Box2f.Invalid;
            var box = new Box2f(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding box for IEnumerable

        /// <summary>
        /// Returns the bounding box of the elements of the collection.
        /// </summary>
        public static Box2f GetBoundingBox(this IEnumerable<V2f> points)
        {
            var box = Box2f.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box2f a, Box2f b)
        {
            return ApproximateEquals(a, b, Constant<float>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box2f a, Box2f b, float tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Box2d

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box2d
        : IEquatable<Box2d>, IRange<V2d, Box2d>, IBoundingBox2d, ISize2d, IFormattable
    {
        [DataMember]
        public V2d Min;
        [DataMember]
        public V2d Max;

        #region Constructors

        /// <summary>
        /// Construct a Box2d from a Box2i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(Box2i b)
        {
            Min = (V2d) b.Min;
            Max = (V2d) b.Max;
        }

        /// <summary>
        /// Construct a Box2d from a Box2l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(Box2l b)
        {
            Min = (V2d) b.Min;
            Max = (V2d) b.Max;
        }

        /// <summary>
        /// Construct a Box2d from a Box2f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(Box2f b)
        {
            Min = (V2d) b.Min;
            Max = (V2d) b.Max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(V2d min, V2d max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(double minX, double minY, double maxX, double maxY)
        {
            Min.X = minX;
            Min.Y = minY;
            Max.X = maxX;
            Max.Y = maxY;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(V2d pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(V2d p0, V2d p1, V2d p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(V2d p0, V2d p1, V2d p2, V2d p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(Box2d range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(Box2d b0, Box2d b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(Box2d b0, Box2d b1, Box2d b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(Box2d b0, Box2d b1, Box2d b2, Box2d b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(V2d[] points)
        {
            Min = V2d.MaxValue;
            Max = V2d.MinValue;
            if (points == null) return;
            var count = points.Length;
            for (var i = 0; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(V2d[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d(IEnumerable<V2d> points)
        {
            Min = V2d.MaxValue;
            Max = V2d.MinValue;
            if (points == null) return;
            foreach (V2d p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box2d(IEnumerable<Box2d> boxes)
        {
            Min = V2d.MaxValue;
            Max = V2d.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box2d(Range1d rangeX, Range1d rangeY)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box2d(Box2i b)
            => new Box2d(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box2d(Box2l b)
            => new Box2d(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box2d(Box2f b)
            => new Box2d(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Box2d Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box2d(V2d.MaxValue, V2d.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Box2d Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box2d(V2d.MinValue, V2d.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Box2d Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box2d(V2d.Zero, V2d.One); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreater(Max) || Min.IsNaN || Max.IsNaN; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }

        /// <summary>
        /// Same as Min.X.
        /// </summary>
        [XmlIgnore]
        public double Left
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Min.X = value; }
        }

        /// <summary>
        /// Same as Max.X.
        /// </summary>
        [XmlIgnore]
        public double Right
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.X = value; }
        }

        /// <summary>
        /// Same as Min.Y.
        /// </summary>
        [XmlIgnore]
        public double Top
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Min.Y = value; }
        }

        /// <summary>
        /// Same as Max.Y.
        /// </summary>
        [XmlIgnore]
        public double Bottom
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Y = value; }
        }

        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        [XmlIgnore]
        public V2d Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (Min + value); }
        }

        public V2d Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return ((Min + Max) / 2); }
        }

        [XmlIgnore]
        public double SizeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.X - Min.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.X = Min.X + value; }
        }

        public Range1d RangeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1d(Min.X, Max.X); }
        }

        [XmlIgnore]
        public double SizeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Y - Min.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Y = Min.Y + value; }
        }

        public Range1d RangeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1d(Min.Y, Max.Y); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeY > SizeX ? 1 : 0; }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeY < SizeX ? 1 : 0; }
        }

        public double Area
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return SizeX * SizeY; }
        }

        public V2d OO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Min; } }
        public V2d IO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V2d(Max.X, Min.Y); } }
        public V2d OI { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V2d(Min.X, Max.Y); } }
        public V2d II { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d EnlargedBy(V2d increment)
        {
            return new Box2d((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d EnlargedBy(V2d deltaMin, V2d deltaMax)
        {
            return new Box2d((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d ShrunkBy(V2d delta)
        {
            return new Box2d((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d ShrunkBy(V2d deltaMin, V2d deltaMax)
        {
            return new Box2d((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V2d delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V2d deltaMin, V2d deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V2d delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V2d deltaMin, V2d deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d EnlargedBy(double delta)
        {
            return new Box2d(
                    new V2d(Min.X - delta, Min.Y - delta),
                    new V2d(Max.X + delta, Max.Y + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d ShrunkBy(double delta)
        {
            return new Box2d(
                    new V2d(Min.X + delta, Min.Y + delta),
                    new V2d(Max.X - delta, Max.Y - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d EnlargedBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY)
        {
            return new Box2d(
                    new V2d(Min.X - deltaMinX, Min.Y - deltaMinY),
                    new V2d(Max.X + deltaMaxX, Max.Y + deltaMaxY));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d ShrunkBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY)
        {
            return new Box2d(
                    new V2d(Min.X + deltaMinX, Min.Y + deltaMinY),
                    new V2d(Max.X - deltaMaxX, Max.Y - deltaMaxY));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(double delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(double delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d ScaledFromCenterBy(double factor)
        {
            var size = Size;
            var increment = (size * factor - size) / 2;
            return new Box2d(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d ScaledFromCenterBy(V2d vectorFactor)
        {
            var size = Size;
            var increment = (size * vectorFactor - size) / 2;
            return new Box2d(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return a box enlarged in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d EnlargedByRelativeEps(double eps)
        {
            return EnlargedBy(eps * Size.Length);
        }

        /// <summary>
        /// Enlarge the box in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeByRelativeEps(double eps)
        {
            EnlargeBy(eps * Size.Length);
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2d Clamped(V2d p)
        {
            return new V2d(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y));
        }

        /// <summary>
        /// Returns the squared distance to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double DistanceSquared(V2d p)
        {
            return 
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0));
        }

        /// <summary>
        /// Returns the distance to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double Distance(V2d p)
        {
            return Fun.Sqrt(
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0)));
        }

        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        /// <param name="x">Position between min and max [0,1].</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2d Lerp(double x)
        {
            return Fun.Lerp(x, Min, Max);
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2d Lerp(V2d p)
        {
            return new V2d(
                        Fun.Lerp(p.X, Min.X, Max.X), 
                        Fun.Lerp(p.Y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2d Lerp(double x, double y)
        {
            return new V2d(
                         Fun.Lerp(x, Min.X, Max.X), 
                         Fun.Lerp(y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2d InvLerp(V2d p)
        {
            return new V2d(
                        Fun.InvLerp(p.X, Min.X, Max.X), 
                        Fun.InvLerp(p.Y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2d InvLerp(double x, double y)
        {
            return new V2d(
                        Fun.InvLerp(x, Min.X, Max.X), 
                        Fun.InvLerp(y, Min.Y, Max.Y));
        }

        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d SplitRight(V2d splitValue)
        {
            var result = new Box2d(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d SplitLeft(V2d splitValue)
        {
            var result = new Box2d(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            return result;
        }

        /// <summary>
        /// Returns the box with Min.X clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d SplitRight(double splitAtX)
        {
            if (splitAtX > Max.X) return Box2d.Invalid;
            if (splitAtX <= Min.X) return this;
            return new Box2d(new V2d(splitAtX, Min.Y), Max);
        }

        /// <summary>
        /// Returns a box with Max.X clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d SplitLeft(double splitAtX)
        {
            if (splitAtX < Min.X) return Box2d.Invalid;
            if (splitAtX >= Max.X) return this;
            return new Box2d(Min, new V2d(splitAtX, Max.Y));
        }

        /// <summary>
        /// Returns the box with Min.Y clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d SplitTop(double splitAtY)
        {
            if (splitAtY > Max.Y) return Box2d.Invalid;
            if (splitAtY <= Min.Y) return this;
            return new Box2d(new V2d(Min.X, splitAtY), Max);
        }

        /// <summary>
        /// Returns the box with Max.Y clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d SplitBottom(double splitAtY)
        {
            if (splitAtY < Min.Y) return Box2d.Invalid;
            if (splitAtY >= Max.Y) return this;
            return new Box2d(Min, new V2d(Max.X, splitAtY));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d SplitLeftBottom(V2d splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y < Min.Y) return Box2d.Invalid;
            return new Box2d(Min, splitAt);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d SplitRightBottom(V2d splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y < Min.Y) return Box2d.Invalid;
            return new Box2d(new V2d(splitAt.X, Min.Y), new V2d(Max.X, splitAt.Y));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d SplitLeftTop(V2d splitAt)
        {
            if (splitAt.X < Min.X || splitAt.Y > Max.Y) return Box2d.Invalid;
            return new Box2d(new V2d(Min.X, splitAt.Y), new V2d(splitAt.X, Max.Y));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d SplitRightTop(V2d splitAt)
        {
            if (splitAt.X > Max.X || splitAt.Y > Max.Y) return Box2d.Invalid;
            return new Box2d(splitAt, Max);
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d ExtendedBy(Box2d b)
        {
            return new Box2d(
                    new V2d(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y),
                    new V2d(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d ExtendedBy(V2d v)
        {
            return new Box2d(
                    new V2d(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y),
                    new V2d(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Box2d box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(V2d point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d ExtendXBy(double x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d ExtendYBy(double y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d ExtendDimBy(int dim, double x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(V2d p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Box2d b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d Repair()
        {
            if (Equals(Box2d.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box2d box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box2d box, V2d eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box2d box, double eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d Invalidate()
        {
            Min = V2d.MaxValue;
            Max = V2d.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(V2d p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(Box2d b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinMaxInDirection(V2d v, out V2d vMin, out V2d vMax)
        {
            vMin = V2d.MinValue;
            vMax = V2d.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Box2d a, Box2d b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Box2d a, Box2d b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d operator +(Box2d box, V2d v)
        {
            return new Box2d((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d operator -(Box2d box, V2d v)
        {
            return new Box2d((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Box2d other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Box2d o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box2d, int, V2d> Setter =
            (ref Box2d box, int i, V2d value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box2d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box2d(V2d.Parse(x[0].ToString()),
                                V2d.Parse(x[1].ToString()));
        }

        public static Box2d Parse(Text t)
        {
            return t.NestedBracketSplit(1, V2d.Parse, Box2d.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d FromSize(V2d size)
        {
            return new Box2d(V2d.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d FromMinAndSize(V2d min, V2d size)
        {
            return new Box2d(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d FromCenterAndSize(V2d center, V2d size)
        {
            return new Box2d(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d FromSize(ISize2d iSize)
        {
            return new Box2d(
                V2d.Zero, iSize.Size2d);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d FromMinAndSize(V2d min, ISize2d iSize)
        {
            return new Box2d(
                min, min + iSize.Size2d);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d FromCenterAndSize(V2d center, ISize2d iSize)
        {
            var size = iSize.Size2d;
            return new Box2d(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d FromPoints(V2d p0, V2d p1)
        {
            return new Box2d(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d FromSize(double width, double height)
        {
            return Box2d.FromSize(new V2d(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d FromMinAndSize(V2d min, double width, double height)
        {
            return new Box2d(min, min + new V2d(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d FromMinAndSize(
            double minX, double minY, double width, double height
            )
        {
            return Box2d.FromMinAndSize(new V2d(minX, minY), new V2d(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d FromCenterAndSize(V2d center, double width, double height)
        {
            return FromCenterAndSize(center, new V2d(width, height));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d FromCenterAndSize(
            double centerX, double centerY, double width, double height
            )
        {
            return FromCenterAndSize(new V2d(centerX, centerY), new V2d(width, height));
        }

        #endregion

        #region Transforms

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d Translated(V2d shift)
        {
            return IsInvalid ? Box2d.Invalid
                             : new Box2d(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d Scaled(V2d factor)
        {
            return IsInvalid ? Box2d.Invalid
                             : new Box2d(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box2d Transformed(M33d trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y) return Box2d.Invalid; 
            var t = new V2d(trafo.M02, trafo.M12);
            var res = new Box2d(t, t);
            double av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            return res;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box2d Transformed(Trafo2d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2d Corner(int index)
        {
            return
                new V2d(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2d[] ComputeCorners()
        {
            return new V2d[] {
                Min,
                new V2d(Max.X, Min.Y),
                new V2d(Min.X, Max.Y),
                Max
            };
        }

        // TODO: Comment and implement for dimensions other than 2.
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V2d[] ComputeCornersCCW()
        {
            return new V2d[] {
                Min,
                new V2d(Max.X, Min.Y),
                Max,
                new V2d(Min.X, Max.Y),
            };
        }

        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V2d> Corners
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return Min;
                yield return new V2d(Max.X, Min.Y);
                yield return new V2d(Min.X, Max.Y);
                yield return Max;
            }
        }

        #endregion

        #region Swizzle methods


        #endregion

        #region Enumerators

        #endregion

        #region IBoundingBox2d Members

        public Box2d BoundingBox2d
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this; }
        }

        #endregion

        #region ISize2d Members

        public V2d Size2d
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Size; }
        }

        #endregion
    }

    public static partial class Box
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d Union(this Box2d a, Box2d b)
        {
            return new Box2d(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d Intersection(this Box2d a, Box2d b)
        {
            return new Box2d(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        #endregion

        #region Bounding box for arrays

        /// <summary>
        /// Returns the bounding box of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d GetBoundingBox(this V2d[] pointArray)
        {
            return pointArray.GetBoundingBox(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d GetBoundingBox(this V2d[] pointArray, long count)
        {
            return pointArray.GetBoundingBox(0, count);
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box2d GetBoundingBox(
                this V2d[] pointArray, long start, long count)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box2d GetBoundingBox<T>(this T[] array, long start, long count, Func<T, V2d> pointSelector)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding box for lists

        /// <summary>
        /// Returns the bounding box of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d GetBoundingBox(this List<V2d> pointList)
        {
            return pointList.GetBoundingBox(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the list.
        /// </summary>
        public static Box2d GetBoundingBox(this List<V2d> pointList, int count)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding box for indexed arrays

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d GetBoundingBox(this int[] indexArray, V2d[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d GetBoundingBox(this int[] indexArray, int count, V2d[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2d GetBoundingBox(this int[] indexArray, int start, int count, V2d[] pointArray)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2d GetBoundingBox<T>(this int[] indexArray, int start, int count, T[] array, Func<T, V2d> pointSelector)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d GetBoundingBox(this long[] indexArray, V2d[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box2d GetBoundingBox(this long[] indexArray, long count, V2d[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2d GetBoundingBox(this long[] indexArray, long start, long count, V2d[] pointArray)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box2d GetBoundingBox<T>(this long[] indexArray, long start, long count, T[] array, Func<T, V2d> pointSelector)
        {
            if (count <= 0) return Box2d.Invalid;
            var box = new Box2d(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding box for IEnumerable

        /// <summary>
        /// Returns the bounding box of the elements of the collection.
        /// </summary>
        public static Box2d GetBoundingBox(this IEnumerable<V2d> points)
        {
            var box = Box2d.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box2d a, Box2d b)
        {
            return ApproximateEquals(a, b, Constant<double>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box2d a, Box2d b, double tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Box3i

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box3i
        : IEquatable<Box3i>, IRange<V3i, Box3i>, IBoundingBox3i, ISize3i, IFormattable
    {
        [DataMember]
        public V3i Min;
        [DataMember]
        public V3i Max;

        #region Constructors

        /// <summary>
        /// Construct a Box3i from a Box3l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(Box3l b)
        {
            Min = (V3i) b.Min;
            Max = (V3i) b.Max;
        }

        /// <summary>
        /// Construct a Box3i from a Box3f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(Box3f b)
        {
            Min = (V3i) b.Min;
            Max = (V3i) b.Max;
        }

        /// <summary>
        /// Construct a Box3i from a Box3d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(Box3d b)
        {
            Min = (V3i) b.Min;
            Max = (V3i) b.Max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(V3i min, V3i max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(int minX, int minY, int minZ, int maxX, int maxY, int maxZ)
        {
            Min.X = minX;
            Min.Y = minY;
            Min.Z = minZ;
            Max.X = maxX;
            Max.Y = maxY;
            Max.Z = maxZ;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(V3i pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(V3i p0, V3i p1, V3i p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(V3i p0, V3i p1, V3i p2, V3i p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(Box3i range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(Box3i b0, Box3i b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(Box3i b0, Box3i b1, Box3i b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(Box3i b0, Box3i b1, Box3i b2, Box3i b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(V3i[] points)
        {
            Min = V3i.MaxValue;
            Max = V3i.MinValue;
            if (points == null) return;
            var count = points.Length;
            for (var i = 0; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(V3i[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i(IEnumerable<V3i> points)
        {
            Min = V3i.MaxValue;
            Max = V3i.MinValue;
            if (points == null) return;
            foreach (V3i p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box3i(IEnumerable<Box3i> boxes)
        {
            Min = V3i.MaxValue;
            Max = V3i.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box3i(Range1i rangeX, Range1i rangeY, Range1i rangeZ)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
            Min.Z = rangeZ.Min;
            Max.Z = rangeZ.Max;
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box3i(Box3l b)
            => new Box3i(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box3i(Box3f b)
            => new Box3i(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box3i(Box3d b)
            => new Box3i(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Box3i Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box3i(V3i.MaxValue, V3i.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Box3i Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box3i(V3i.MinValue, V3i.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Box3i Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box3i(V3i.Zero, V3i.One); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreater(Max); }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }


        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        [XmlIgnore]
        public V3i Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (Min + value); }
        }

        public V3i Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return ((Min + Max) / 2); }
        }

        [XmlIgnore]
        public int SizeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.X - Min.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.X = Min.X + value; }
        }

        public Range1i RangeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1i(Min.X, Max.X); }
        }

        [XmlIgnore]
        public int SizeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Y - Min.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Y = Min.Y + value; }
        }

        public Range1i RangeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1i(Min.Y, Max.Y); }
        }

        [XmlIgnore]
        public int SizeZ
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Z - Min.Z; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Z = Min.Z + value; }
        }

        public Range1i RangeZ
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1i(Min.Z, Max.Z); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                int major = 0;
                var s = Size;
                if (s.Y > s.X) major = 1;
                if (s.Z > s[major]) major = 2;
                return major;
            }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                int minor = 0;
                var s = Size;
                if (s.Y < s.X) minor = 1;
                if (s.Z < s[minor]) minor = 2;
                return minor;
            }
        }

        public int SurfaceArea
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var s = Size;
                return (s.X * s.Y + s.X * s.Z + s.Y * s.Z) * 2;
            }
        }

        public int Volume
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) return 0;
                return SizeX * SizeY * SizeZ;
            }
        }

        public V3i OOO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Min; } }
        public V3i IOO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3i(Max.X, Min.Y, Min.Z); } }
        public V3i OIO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3i(Min.X, Max.Y, Min.Z); } }
        public V3i IIO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3i(Max.X, Max.Y, Min.Z); } }
        public V3i OOI { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3i(Min.X, Min.Y, Max.Z); } }
        public V3i IOI { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3i(Max.X, Min.Y, Max.Z); } }
        public V3i OII { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3i(Min.X, Max.Y, Max.Z); } }
        public V3i III { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i EnlargedBy(V3i increment)
        {
            return new Box3i((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i EnlargedBy(V3i deltaMin, V3i deltaMax)
        {
            return new Box3i((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i ShrunkBy(V3i delta)
        {
            return new Box3i((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i ShrunkBy(V3i deltaMin, V3i deltaMax)
        {
            return new Box3i((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V3i delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V3i deltaMin, V3i deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V3i delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V3i deltaMin, V3i deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i EnlargedBy(int delta)
        {
            return new Box3i(
                    new V3i(Min.X - delta, Min.Y - delta, Min.Z - delta),
                    new V3i(Max.X + delta, Max.Y + delta, Max.Z + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i ShrunkBy(int delta)
        {
            return new Box3i(
                    new V3i(Min.X + delta, Min.Y + delta, Min.Z + delta),
                    new V3i(Max.X - delta, Max.Y - delta, Max.Z - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i EnlargedBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY, 
                int deltaMinZ, int deltaMaxZ)
        {
            return new Box3i(
                    new V3i(Min.X - deltaMinX, Min.Y - deltaMinY, Min.Z - deltaMinZ),
                    new V3i(Max.X + deltaMaxX, Max.Y + deltaMaxY, Max.Z + deltaMaxZ));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i ShrunkBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY, 
                int deltaMinZ, int deltaMaxZ)
        {
            return new Box3i(
                    new V3i(Min.X + deltaMinX, Min.Y + deltaMinY, Min.Z + deltaMinZ),
                    new V3i(Max.X - deltaMaxX, Max.Y - deltaMaxY, Max.Z - deltaMaxZ));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(int delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
            Min.Z -= delta; Max.Z += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(int delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
            Min.Z += delta; Max.Z -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY, 
                int deltaMinZ, int deltaMaxZ)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
            Min.Z -= deltaMinZ; Max.Z += deltaMaxZ;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(
                int deltaMinX, int deltaMaxX, 
                int deltaMinY, int deltaMaxY, 
                int deltaMinZ, int deltaMaxZ)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
            Min.Z += deltaMinZ; Max.Z -= deltaMaxZ;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3i Clamped(V3i p)
        {
            return new V3i(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y), 
                        p.Z < Min.Z ? Min.Z : (p.Z > Max.Z ? Max.Z : p.Z));
        }


        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i SplitRight(V3i splitValue)
        {
            var result = new Box3i(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            if (splitValue.Z > result.Min.Z) result.Min.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i SplitLeft(V3i splitValue)
        {
            var result = new Box3i(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            if (splitValue.Z < result.Max.Z) result.Max.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i ExtendedBy(Box3i b)
        {
            return new Box3i(
                    new V3i(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y, 
                        b.Min.Z < Min.Z ? b.Min.Z : Min.Z),
                    new V3i(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y, 
                        b.Max.Z > Max.Z ? b.Max.Z : Max.Z));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i ExtendedBy(V3i v)
        {
            return new Box3i(
                    new V3i(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y, 
                        v.Z < Min.Z ? v.Z : Min.Z),
                    new V3i(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y, 
                        v.Z > Max.Z ? v.Z : Max.Z));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Box3i box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
            if (box.Min.Z < Min.Z) Min.Z = box.Min.Z;
            if (box.Max.Z > Max.Z) Max.Z = box.Max.Z;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(V3i point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
            if (point.Z < Min.Z) Min.Z = point.Z;
            if (point.Z > Max.Z) Max.Z = point.Z;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i ExtendXBy(int x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i ExtendYBy(int y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i ExtendZBy(int z)
        {
            if (z < Min.Z) Min.Z = z;
            if (z > Max.Z) Max.Z = z;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i ExtendDimBy(int dim, int x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(V3i p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y && 
                p.Z >= Min.Z && p.Z <= Max.Z;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Box3i b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y && 
                b.Min.Z >= Min.Z && b.Max.Z <= Max.Z;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i Repair()
        {
            if (Equals(Box3i.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            if (Min.Z > Max.Z) Fun.Swap(ref Min.Z, ref Max.Z);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box3i box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            if (Min.Z >= box.Max.Z) return false;
            if (Max.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box3i box, V3i eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            if (Min.Z - eps.Z >= box.Max.Z) return false;
            if (Max.Z + eps.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box3i box, int eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            if (Min.Z - eps >= box.Max.Z) return false;
            if (Max.Z + eps <= box.Min.Z) return false;
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i Invalidate()
        {
            Min = V3i.MaxValue;
            Max = V3i.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(V3i p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (p0.Z < Min.Z) bf |= Box.Flags.MinZ;
            else if (p0.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(Box3i b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (b.Min.Z < Min.Z) bf |= Box.Flags.MinZ;
            if (b.Max.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinMaxInDirection(V3i v, out V3i vMin, out V3i vMax)
        {
            vMin = V3i.MinValue;
            vMax = V3i.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
            if (v.Z >= 0)
            {
                vMin.Z = Min.Z;
                vMax.Z = Max.Z;
            }
            else
            {
                vMin.Z = Max.Z;
                vMax.Z = Min.Z;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Box3i a, Box3i b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Box3i a, Box3i b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i operator +(Box3i box, V3i v)
        {
            return new Box3i((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i operator -(Box3i box, V3i v)
        {
            return new Box3i((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Box3i other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Box3i o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box3i, int, V3i> Setter =
            (ref Box3i box, int i, V3i value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box3i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box3i(V3i.Parse(x[0].ToString()),
                                V3i.Parse(x[1].ToString()));
        }

        public static Box3i Parse(Text t)
        {
            return t.NestedBracketSplit(1, V3i.Parse, Box3i.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i FromSize(V3i size)
        {
            return new Box3i(V3i.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i FromMinAndSize(V3i min, V3i size)
        {
            return new Box3i(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i FromCenterAndSize(V3i center, V3i size)
        {
            return new Box3i(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i FromSize(ISize3i iSize)
        {
            return new Box3i(
                V3i.Zero, iSize.Size3i);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i FromMinAndSize(V3i min, ISize3i iSize)
        {
            return new Box3i(
                min, min + iSize.Size3i);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i FromCenterAndSize(V3i center, ISize3i iSize)
        {
            var size = iSize.Size3i;
            return new Box3i(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i FromPoints(V3i p0, V3i p1)
        {
            return new Box3i(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        #endregion

        #region Transforms

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i Translated(V3i shift)
        {
            return IsInvalid ? Box3i.Invalid
                             : new Box3i(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3i Scaled(V3i factor)
        {
            return IsInvalid ? Box3i.Invalid
                             : new Box3i(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box3d Transformed(M44d trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y || Min.Z > Max.Z) return Box3d.Invalid; 
            var t = new V3d(trafo.M03, trafo.M13, trafo.M23);
            var res = new Box3d(t, t);
            double av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M02 * Min.Z;
            bv = trafo.M02 * Max.Z;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M12 * Min.Z;
            bv = trafo.M12 * Max.Z;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M20 * Min.X;
            bv = trafo.M20 * Max.X;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M21 * Min.Y;
            bv = trafo.M21 * Max.Y;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M22 * Min.Z;
            bv = trafo.M22 * Max.Z;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            return res;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d Transformed(Trafo3d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3i Corner(int index)
        {
            return
                new V3i(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y, 
                        (index & 4) == 0 ? Min.Z : Max.Z);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3i[] ComputeCorners()
        {
            return new V3i[] {
                Min,
                new V3i(Max.X, Min.Y, Min.Z),
                new V3i(Min.X, Max.Y, Min.Z),
                new V3i(Max.X, Max.Y, Min.Z),
                new V3i(Min.X, Min.Y, Max.Z),
                new V3i(Max.X, Min.Y, Max.Z),
                new V3i(Min.X, Max.Y, Max.Z),
                Max
            };
        }


        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V3i> Corners
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return Min;
                yield return new V3i(Max.X, Min.Y, Min.Z);
                yield return new V3i(Min.X, Max.Y, Min.Z);
                yield return new V3i(Max.X, Max.Y, Min.Z);
                yield return new V3i(Min.X, Min.Y, Max.Z);
                yield return new V3i(Max.X, Min.Y, Max.Z);
                yield return new V3i(Min.X, Max.Y, Max.Z);
                yield return Max;
            }
        }

        #endregion

        #region Swizzle methods

        // TODO: Implement for other dimensions
        public Range1i X { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1i(Min.X, Max.X); } }
        public Range1i Y { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1i(Min.Y, Max.Y); } }
        public Range1i Z { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1i(Min.Z, Max.Z); } }
        public Box2i XY { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2i(Min.XY, Max.XY); } }
        public Box2i XZ { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2i(Min.XZ, Max.XZ); } }
        public Box2i YX { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2i(Min.YX, Max.YX); } }
        public Box2i YZ { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2i(Min.YZ, Max.YZ); } }
        public Box2i ZX { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2i(Min.ZX, Max.ZX); } }
        public Box2i ZY { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2i(Min.ZY, Max.ZY); } }

        #endregion

        #region Enumerators

        /// <summary>
        /// Returns all points from [Min,Max[ with X-Variable in the outer loop.
        /// </summary>
        public IEnumerable<V3i> EnumerateInsidePoints()
        {
            var p = new V3i();
            for (p.X = Min.X; p.X < Max.X; p.X++)
            for (p.Y = Min.Y; p.Y < Max.Y; p.Y++)
            for (p.Z = Min.Z; p.Z < Max.Z; p.Z++)
                yield return p;
        }

        #endregion

        #region IBoundingBox3i Members

        public Box3i BoundingBox3i
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this; }
        }

        #endregion

        #region ISize3i Members

        public V3i Size3i
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Size; }
        }

        #endregion
    }

    public static partial class Box
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i Union(this Box3i a, Box3i b)
        {
            return new Box3i(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i Intersection(this Box3i a, Box3i b)
        {
            return new Box3i(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        #endregion

        #region Bounding box for arrays

        /// <summary>
        /// Returns the bounding box of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i GetBoundingBox(this V3i[] pointArray)
        {
            return pointArray.GetBoundingBox(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i GetBoundingBox(this V3i[] pointArray, long count)
        {
            return pointArray.GetBoundingBox(0, count);
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box3i GetBoundingBox(
                this V3i[] pointArray, long start, long count)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box3i GetBoundingBox<T>(this T[] array, long start, long count, Func<T, V3i> pointSelector)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding box for lists

        /// <summary>
        /// Returns the bounding box of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i GetBoundingBox(this List<V3i> pointList)
        {
            return pointList.GetBoundingBox(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the list.
        /// </summary>
        public static Box3i GetBoundingBox(this List<V3i> pointList, int count)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding box for indexed arrays

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i GetBoundingBox(this int[] indexArray, V3i[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i GetBoundingBox(this int[] indexArray, int count, V3i[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3i GetBoundingBox(this int[] indexArray, int start, int count, V3i[] pointArray)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3i GetBoundingBox<T>(this int[] indexArray, int start, int count, T[] array, Func<T, V3i> pointSelector)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i GetBoundingBox(this long[] indexArray, V3i[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3i GetBoundingBox(this long[] indexArray, long count, V3i[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3i GetBoundingBox(this long[] indexArray, long start, long count, V3i[] pointArray)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3i GetBoundingBox<T>(this long[] indexArray, long start, long count, T[] array, Func<T, V3i> pointSelector)
        {
            if (count <= 0) return Box3i.Invalid;
            var box = new Box3i(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding box for IEnumerable

        /// <summary>
        /// Returns the bounding box of the elements of the collection.
        /// </summary>
        public static Box3i GetBoundingBox(this IEnumerable<V3i> points)
        {
            var box = Box3i.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion

        #region Get octant

        /// <summary>
        /// Octant 0-7.
        /// 0th, 1st and 2nd bit encodes x-, y-, z-axis, respectively.
        /// E.g. 0 is octant [box.Min, box.Center], 7 is octant [box.Center, box.Max].
        /// </summary>
        public static Box3i GetOctant(this Box3i box, int i)
        {
            if (i < 0 || i > 7) throw new IndexOutOfRangeException();

            int x0, x1, y0, y1, z0, z1;
            var c = box.Center;
            if ((i & 1) == 0) { x0 = box.Min.X; x1 = c.X; } else { x0 = c.X; x1 = box.Max.X; }
            if ((i & 2) == 0) { y0 = box.Min.Y; y1 = c.Y; } else { y0 = c.Y; y1 = box.Max.Y; }
            if (i < 4) { z0 = box.Min.Z; z1 = c.Z; } else { z0 = c.Z; z1 = box.Max.Z; }
            return new Box3i(new V3i(x0, y0, z0), new V3i(x1, y1, z1));
        }

        #endregion

        #region Outline corners

        /// <summary>
        /// Gets outline corner indices of a box as seen from given position (in counter-clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static int[] GetOutlineCornerIndicesCCW(this Box3i box, V3i fromPosition)
        {
            if (fromPosition.X < box.Min.X)
            { //-X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X -Y -Z
                        return new[] { 1, 5, 4, 6, 2, 3 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X -Y +Z
                        return new[] { 0, 1, 5, 7, 6, 2 };
                    }
                    else
                    { // -X -Y  Z
                        return new[] { 1, 5, 6, 2 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X +Y -Z
                        return new[] { 0, 4, 6, 7, 3, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X +Y +Z
                        return new[] { 0, 4, 5, 7, 3, 2 };
                    }
                    else
                    { // -X +Y  Z
                        return new[] { 0, 4, 7, 3 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X  Y -Z
                        return new[] { 1, 4, 6, 3 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X  Y +Z
                        return new[] { 0, 5, 7, 2 };
                    }
                    else
                    { // -X  Y  Z
                        return new[] { 0, 4, 6, 2 };
                    }
                }
            }
            else if (fromPosition.X > box.Max.X)
            { // +X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X -Y -Z
                        return new[] { 0, 2, 3, 7, 5, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X -Y +Z
                        return new[] { 0, 1, 3, 7, 6, 4 };
                    }
                    else
                    { // +X -Y  Z
                        return new[] { 0, 3, 7, 4 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X +Y -Z
                        return new[] { 0, 2, 6, 7, 5, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X +Y +Z
                        return new[] { 1, 3, 2, 6, 4, 5 };
                    }
                    else
                    { // +X +Y  Z
                        return new[] { 1, 2, 6, 5 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X  Y -Z
                        return new[] { 0, 2, 7, 5 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X  Y +Z
                        return new[] { 1, 3, 6, 4 };
                    }
                    else
                    { // +X  Y  Z
                        return new[] { 1, 3, 7, 5 };
                    }
                }
            }
            else
            { // X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X -Y -Z
                        return new[] { 2, 3, 5, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X -Y +Z
                        return new[] { 0, 1, 7, 6 };
                    }
                    else
                    { //  X -Y  Z
                        return new[] { 0, 1, 5, 4 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X +Y -Z
                        return new[] { 0, 6, 7, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X +Y +Z
                        return new[] { 2, 4, 5, 3 };
                    }
                    else
                    { //  X +Y  Z
                        return new[] { 2, 6, 7, 3 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X  Y -Z
                        return new[] { 0, 2, 3, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X  Y +Z
                        return new[] { 4, 5, 7, 6 };
                    }
                    else
                    { //  X  Y  Z
                        return null;
                    }
                }
            }
        }

        /// <summary>
        /// Gets outline corner indices of a box as seen from given position (in clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static int[] GetOutlineCornerIndicesCW(this Box3i box, V3i fromPosition)
        {
            if (fromPosition.X < box.Min.X)
            { //-X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X -Y -Z
                        return new[] { 1, 3, 2, 6, 4, 5 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X -Y +Z
                        return new[] { 0, 2, 6, 7, 5, 1 };
                    }
                    else
                    { // -X -Y  Z
                        return new[] { 1, 2, 6, 5 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X +Y -Z
                        return new[] { 0, 1, 3, 7, 6, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X +Y +Z
                        return new[] { 0, 2, 3, 7, 5, 4 };
                    }
                    else
                    { // -X +Y  Z
                        return new[] { 0, 3, 7, 4 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X  Y -Z
                        return new[] { 1, 3, 6, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X  Y +Z
                        return new[] { 0, 2, 7, 5 };
                    }
                    else
                    { // -X  Y  Z
                        return new[] { 0, 2, 6, 4 };
                    }
                }
            }
            else if (fromPosition.X > box.Max.X)
            { // +X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X -Y -Z
                        return new[] { 0, 4, 5, 7, 3, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X -Y +Z
                        return new[] { 0, 4, 6, 7, 3, 1 };
                    }
                    else
                    { // +X -Y  Z
                        return new[] { 0, 4, 7, 3 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X +Y -Z
                        return new[] { 0, 1, 5, 7, 6, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X +Y +Z
                        return new[] { 1, 5, 4, 6, 2, 3 };
                    }
                    else
                    { // +X +Y  Z
                        return new[] { 1, 5, 6, 2 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X  Y -Z
                        return new[] { 0, 5, 7, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X  Y +Z
                        return new[] { 1, 4, 6, 3 };
                    }
                    else
                    { // +X  Y  Z
                        return new[] { 1, 5, 7, 3 };
                    }
                }
            }
            else
            { // X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X -Y -Z
                        return new[] { 2, 4, 5, 3 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X -Y +Z
                        return new[] { 0, 6, 7, 1 };
                    }
                    else
                    { //  X -Y  Z
                        return new[] { 0, 4, 5, 1 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X +Y -Z
                        return new[] { 0, 1, 7, 6 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X +Y +Z
                        return new[] { 2, 3, 5, 4 };
                    }
                    else
                    { //  X +Y  Z
                        return new[] { 2, 3, 7, 6 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X  Y -Z
                        return new[] { 0, 1, 3, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X  Y +Z
                        return new[] { 4, 6, 7, 5 };
                    }
                    else
                    { //  X  Y  Z
                        return null;
                    }
                }
            }
        }

        /// <summary>
        /// Gets outline corners of a box as seen from given position (in counter-clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static V3i[] GetOutlineCornersCCW(this Box3i box, V3i fromPosition)
        {
            var cs = box.ComputeCorners();
            return GetOutlineCornerIndicesCCW(box, fromPosition)?.Map(i => cs[i]);
        }

        /// <summary>
        /// Gets outline corners of a box as seen from given position (in clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static V3i[] GetOutlineCornersCW(this Box3i box, V3i fromPosition)
        {
            var cs = box.ComputeCorners();
            return GetOutlineCornerIndicesCW(box, fromPosition)?.Map(i => cs[i]);
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box3i a, Box3i b)
        {
            return ApproximateEquals(a, b, Constant<int>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box3i a, Box3i b, int tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Box3iAndFlags

    [DataContract]
    public struct Box3iAndFlags
    {
        [DataMember]
        public Box.Flags BFlags;
        [DataMember]
        public Box3i BBox;

        public Box3iAndFlags(Box3i union, Box3i box0, Box3i box1)
        {
            BFlags = 0;
            BBox = union;
            if (box0.Min.X > union.Min.X) { BBox.Min.X = box0.Min.X; BFlags |= Box.Flags.MinX0; }
            if (box0.Min.Y > union.Min.Y) { BBox.Min.Y = box0.Min.Y; BFlags |= Box.Flags.MinY0; }
            if (box0.Min.Z > union.Min.Z) { BBox.Min.Z = box0.Min.Z; BFlags |= Box.Flags.MinZ0; }
            if (box0.Max.X < union.Max.X) { BBox.Max.X = box0.Max.X; BFlags |= Box.Flags.MaxX0; }
            if (box0.Max.Y < union.Max.Y) { BBox.Max.Y = box0.Max.Y; BFlags |= Box.Flags.MaxY0; }
            if (box0.Max.Z < union.Max.Z) { BBox.Max.Z = box0.Max.Z; BFlags |= Box.Flags.MaxZ0; }
            if (box1.Min.X > union.Min.X) { BBox.Min.X = box1.Min.X; BFlags |= Box.Flags.MinX1; }
            if (box1.Min.Y > union.Min.Y) { BBox.Min.Y = box1.Min.Y; BFlags |= Box.Flags.MinY1; }
            if (box1.Min.Z > union.Min.Z) { BBox.Min.Z = box1.Min.Z; BFlags |= Box.Flags.MinZ1; }
            if (box1.Max.X < union.Max.X) { BBox.Max.X = box1.Max.X; BFlags |= Box.Flags.MaxX1; }
            if (box1.Max.Y < union.Max.Y) { BBox.Max.Y = box1.Max.Y; BFlags |= Box.Flags.MaxY1; }
            if (box1.Max.Z < union.Max.Z) { BBox.Max.Z = box1.Max.Z; BFlags |= Box.Flags.MaxZ1; }
        }
    }

    #endregion

    #region Box3l

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box3l
        : IEquatable<Box3l>, IRange<V3l, Box3l>, IBoundingBox3l, ISize3l, IFormattable
    {
        [DataMember]
        public V3l Min;
        [DataMember]
        public V3l Max;

        #region Constructors

        /// <summary>
        /// Construct a Box3l from a Box3i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(Box3i b)
        {
            Min = (V3l) b.Min;
            Max = (V3l) b.Max;
        }

        /// <summary>
        /// Construct a Box3l from a Box3f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(Box3f b)
        {
            Min = (V3l) b.Min;
            Max = (V3l) b.Max;
        }

        /// <summary>
        /// Construct a Box3l from a Box3d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(Box3d b)
        {
            Min = (V3l) b.Min;
            Max = (V3l) b.Max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(V3l min, V3l max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(long minX, long minY, long minZ, long maxX, long maxY, long maxZ)
        {
            Min.X = minX;
            Min.Y = minY;
            Min.Z = minZ;
            Max.X = maxX;
            Max.Y = maxY;
            Max.Z = maxZ;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(V3l pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(V3l p0, V3l p1, V3l p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(V3l p0, V3l p1, V3l p2, V3l p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(Box3l range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(Box3l b0, Box3l b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(Box3l b0, Box3l b1, Box3l b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(Box3l b0, Box3l b1, Box3l b2, Box3l b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(V3l[] points)
        {
            Min = V3l.MaxValue;
            Max = V3l.MinValue;
            if (points == null) return;
            var count = points.Length;
            for (var i = 0; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(V3l[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l(IEnumerable<V3l> points)
        {
            Min = V3l.MaxValue;
            Max = V3l.MinValue;
            if (points == null) return;
            foreach (V3l p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box3l(IEnumerable<Box3l> boxes)
        {
            Min = V3l.MaxValue;
            Max = V3l.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box3l(Range1l rangeX, Range1l rangeY, Range1l rangeZ)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
            Min.Z = rangeZ.Min;
            Max.Z = rangeZ.Max;
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box3l(Box3i b)
            => new Box3l(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box3l(Box3f b)
            => new Box3l(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box3l(Box3d b)
            => new Box3l(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Box3l Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box3l(V3l.MaxValue, V3l.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Box3l Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box3l(V3l.MinValue, V3l.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Box3l Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box3l(V3l.Zero, V3l.One); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreater(Max); }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }


        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        [XmlIgnore]
        public V3l Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (Min + value); }
        }

        public V3l Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return ((Min + Max) / 2); }
        }

        [XmlIgnore]
        public long SizeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.X - Min.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.X = Min.X + value; }
        }

        public Range1l RangeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1l(Min.X, Max.X); }
        }

        [XmlIgnore]
        public long SizeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Y - Min.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Y = Min.Y + value; }
        }

        public Range1l RangeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1l(Min.Y, Max.Y); }
        }

        [XmlIgnore]
        public long SizeZ
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Z - Min.Z; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Z = Min.Z + value; }
        }

        public Range1l RangeZ
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1l(Min.Z, Max.Z); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                int major = 0;
                var s = Size;
                if (s.Y > s.X) major = 1;
                if (s.Z > s[major]) major = 2;
                return major;
            }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                int minor = 0;
                var s = Size;
                if (s.Y < s.X) minor = 1;
                if (s.Z < s[minor]) minor = 2;
                return minor;
            }
        }

        public long SurfaceArea
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var s = Size;
                return (s.X * s.Y + s.X * s.Z + s.Y * s.Z) * 2;
            }
        }

        public long Volume
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) return 0;
                return SizeX * SizeY * SizeZ;
            }
        }

        public V3l OOO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Min; } }
        public V3l IOO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3l(Max.X, Min.Y, Min.Z); } }
        public V3l OIO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3l(Min.X, Max.Y, Min.Z); } }
        public V3l IIO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3l(Max.X, Max.Y, Min.Z); } }
        public V3l OOI { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3l(Min.X, Min.Y, Max.Z); } }
        public V3l IOI { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3l(Max.X, Min.Y, Max.Z); } }
        public V3l OII { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3l(Min.X, Max.Y, Max.Z); } }
        public V3l III { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l EnlargedBy(V3l increment)
        {
            return new Box3l((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l EnlargedBy(V3l deltaMin, V3l deltaMax)
        {
            return new Box3l((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l ShrunkBy(V3l delta)
        {
            return new Box3l((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l ShrunkBy(V3l deltaMin, V3l deltaMax)
        {
            return new Box3l((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V3l delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V3l deltaMin, V3l deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V3l delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V3l deltaMin, V3l deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l EnlargedBy(long delta)
        {
            return new Box3l(
                    new V3l(Min.X - delta, Min.Y - delta, Min.Z - delta),
                    new V3l(Max.X + delta, Max.Y + delta, Max.Z + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l ShrunkBy(long delta)
        {
            return new Box3l(
                    new V3l(Min.X + delta, Min.Y + delta, Min.Z + delta),
                    new V3l(Max.X - delta, Max.Y - delta, Max.Z - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l EnlargedBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY, 
                long deltaMinZ, long deltaMaxZ)
        {
            return new Box3l(
                    new V3l(Min.X - deltaMinX, Min.Y - deltaMinY, Min.Z - deltaMinZ),
                    new V3l(Max.X + deltaMaxX, Max.Y + deltaMaxY, Max.Z + deltaMaxZ));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l ShrunkBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY, 
                long deltaMinZ, long deltaMaxZ)
        {
            return new Box3l(
                    new V3l(Min.X + deltaMinX, Min.Y + deltaMinY, Min.Z + deltaMinZ),
                    new V3l(Max.X - deltaMaxX, Max.Y - deltaMaxY, Max.Z - deltaMaxZ));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(long delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
            Min.Z -= delta; Max.Z += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(long delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
            Min.Z += delta; Max.Z -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY, 
                long deltaMinZ, long deltaMaxZ)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
            Min.Z -= deltaMinZ; Max.Z += deltaMaxZ;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(
                long deltaMinX, long deltaMaxX, 
                long deltaMinY, long deltaMaxY, 
                long deltaMinZ, long deltaMaxZ)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
            Min.Z += deltaMinZ; Max.Z -= deltaMaxZ;
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3l Clamped(V3l p)
        {
            return new V3l(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y), 
                        p.Z < Min.Z ? Min.Z : (p.Z > Max.Z ? Max.Z : p.Z));
        }


        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l SplitRight(V3l splitValue)
        {
            var result = new Box3l(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            if (splitValue.Z > result.Min.Z) result.Min.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l SplitLeft(V3l splitValue)
        {
            var result = new Box3l(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            if (splitValue.Z < result.Max.Z) result.Max.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l ExtendedBy(Box3l b)
        {
            return new Box3l(
                    new V3l(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y, 
                        b.Min.Z < Min.Z ? b.Min.Z : Min.Z),
                    new V3l(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y, 
                        b.Max.Z > Max.Z ? b.Max.Z : Max.Z));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l ExtendedBy(V3l v)
        {
            return new Box3l(
                    new V3l(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y, 
                        v.Z < Min.Z ? v.Z : Min.Z),
                    new V3l(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y, 
                        v.Z > Max.Z ? v.Z : Max.Z));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Box3l box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
            if (box.Min.Z < Min.Z) Min.Z = box.Min.Z;
            if (box.Max.Z > Max.Z) Max.Z = box.Max.Z;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(V3l point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
            if (point.Z < Min.Z) Min.Z = point.Z;
            if (point.Z > Max.Z) Max.Z = point.Z;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l ExtendXBy(long x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l ExtendYBy(long y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l ExtendZBy(long z)
        {
            if (z < Min.Z) Min.Z = z;
            if (z > Max.Z) Max.Z = z;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l ExtendDimBy(int dim, long x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(V3l p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y && 
                p.Z >= Min.Z && p.Z <= Max.Z;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Box3l b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y && 
                b.Min.Z >= Min.Z && b.Max.Z <= Max.Z;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l Repair()
        {
            if (Equals(Box3l.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            if (Min.Z > Max.Z) Fun.Swap(ref Min.Z, ref Max.Z);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box3l box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            if (Min.Z >= box.Max.Z) return false;
            if (Max.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box3l box, V3l eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            if (Min.Z - eps.Z >= box.Max.Z) return false;
            if (Max.Z + eps.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box3l box, long eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            if (Min.Z - eps >= box.Max.Z) return false;
            if (Max.Z + eps <= box.Min.Z) return false;
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l Invalidate()
        {
            Min = V3l.MaxValue;
            Max = V3l.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(V3l p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (p0.Z < Min.Z) bf |= Box.Flags.MinZ;
            else if (p0.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(Box3l b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (b.Min.Z < Min.Z) bf |= Box.Flags.MinZ;
            if (b.Max.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinMaxInDirection(V3l v, out V3l vMin, out V3l vMax)
        {
            vMin = V3l.MinValue;
            vMax = V3l.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
            if (v.Z >= 0)
            {
                vMin.Z = Min.Z;
                vMax.Z = Max.Z;
            }
            else
            {
                vMin.Z = Max.Z;
                vMax.Z = Min.Z;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Box3l a, Box3l b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Box3l a, Box3l b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l operator +(Box3l box, V3l v)
        {
            return new Box3l((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l operator -(Box3l box, V3l v)
        {
            return new Box3l((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Box3l other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Box3l o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box3l, int, V3l> Setter =
            (ref Box3l box, int i, V3l value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box3l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box3l(V3l.Parse(x[0].ToString()),
                                V3l.Parse(x[1].ToString()));
        }

        public static Box3l Parse(Text t)
        {
            return t.NestedBracketSplit(1, V3l.Parse, Box3l.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l FromSize(V3l size)
        {
            return new Box3l(V3l.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l FromMinAndSize(V3l min, V3l size)
        {
            return new Box3l(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l FromCenterAndSize(V3l center, V3l size)
        {
            return new Box3l(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l FromSize(ISize3l iSize)
        {
            return new Box3l(
                V3l.Zero, iSize.Size3l);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l FromMinAndSize(V3l min, ISize3l iSize)
        {
            return new Box3l(
                min, min + iSize.Size3l);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l FromCenterAndSize(V3l center, ISize3l iSize)
        {
            var size = iSize.Size3l;
            return new Box3l(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l FromPoints(V3l p0, V3l p1)
        {
            return new Box3l(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        #endregion

        #region Transforms

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l Translated(V3l shift)
        {
            return IsInvalid ? Box3l.Invalid
                             : new Box3l(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3l Scaled(V3l factor)
        {
            return IsInvalid ? Box3l.Invalid
                             : new Box3l(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box3d Transformed(M44d trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y || Min.Z > Max.Z) return Box3d.Invalid; 
            var t = new V3d(trafo.M03, trafo.M13, trafo.M23);
            var res = new Box3d(t, t);
            double av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M02 * Min.Z;
            bv = trafo.M02 * Max.Z;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M12 * Min.Z;
            bv = trafo.M12 * Max.Z;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M20 * Min.X;
            bv = trafo.M20 * Max.X;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M21 * Min.Y;
            bv = trafo.M21 * Max.Y;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M22 * Min.Z;
            bv = trafo.M22 * Max.Z;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            return res;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d Transformed(Trafo3d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3l Corner(int index)
        {
            return
                new V3l(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y, 
                        (index & 4) == 0 ? Min.Z : Max.Z);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3l[] ComputeCorners()
        {
            return new V3l[] {
                Min,
                new V3l(Max.X, Min.Y, Min.Z),
                new V3l(Min.X, Max.Y, Min.Z),
                new V3l(Max.X, Max.Y, Min.Z),
                new V3l(Min.X, Min.Y, Max.Z),
                new V3l(Max.X, Min.Y, Max.Z),
                new V3l(Min.X, Max.Y, Max.Z),
                Max
            };
        }


        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V3l> Corners
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return Min;
                yield return new V3l(Max.X, Min.Y, Min.Z);
                yield return new V3l(Min.X, Max.Y, Min.Z);
                yield return new V3l(Max.X, Max.Y, Min.Z);
                yield return new V3l(Min.X, Min.Y, Max.Z);
                yield return new V3l(Max.X, Min.Y, Max.Z);
                yield return new V3l(Min.X, Max.Y, Max.Z);
                yield return Max;
            }
        }

        #endregion

        #region Swizzle methods

        // TODO: Implement for other dimensions
        public Range1l X { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1l(Min.X, Max.X); } }
        public Range1l Y { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1l(Min.Y, Max.Y); } }
        public Range1l Z { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1l(Min.Z, Max.Z); } }
        public Box2l XY { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2l(Min.XY, Max.XY); } }
        public Box2l XZ { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2l(Min.XZ, Max.XZ); } }
        public Box2l YX { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2l(Min.YX, Max.YX); } }
        public Box2l YZ { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2l(Min.YZ, Max.YZ); } }
        public Box2l ZX { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2l(Min.ZX, Max.ZX); } }
        public Box2l ZY { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2l(Min.ZY, Max.ZY); } }

        #endregion

        #region Enumerators

        /// <summary>
        /// Returns all points from [Min,Max[ with X-Variable in the outer loop.
        /// </summary>
        public IEnumerable<V3l> EnumerateInsidePoints()
        {
            var p = new V3l();
            for (p.X = Min.X; p.X < Max.X; p.X++)
            for (p.Y = Min.Y; p.Y < Max.Y; p.Y++)
            for (p.Z = Min.Z; p.Z < Max.Z; p.Z++)
                yield return p;
        }

        #endregion

        #region IBoundingBox3l Members

        public Box3l BoundingBox3l
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this; }
        }

        #endregion

        #region ISize3l Members

        public V3l Size3l
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Size; }
        }

        #endregion
    }

    public static partial class Box
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l Union(this Box3l a, Box3l b)
        {
            return new Box3l(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l Intersection(this Box3l a, Box3l b)
        {
            return new Box3l(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        #endregion

        #region Bounding box for arrays

        /// <summary>
        /// Returns the bounding box of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l GetBoundingBox(this V3l[] pointArray)
        {
            return pointArray.GetBoundingBox(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l GetBoundingBox(this V3l[] pointArray, long count)
        {
            return pointArray.GetBoundingBox(0, count);
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box3l GetBoundingBox(
                this V3l[] pointArray, long start, long count)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box3l GetBoundingBox<T>(this T[] array, long start, long count, Func<T, V3l> pointSelector)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding box for lists

        /// <summary>
        /// Returns the bounding box of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l GetBoundingBox(this List<V3l> pointList)
        {
            return pointList.GetBoundingBox(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the list.
        /// </summary>
        public static Box3l GetBoundingBox(this List<V3l> pointList, int count)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding box for indexed arrays

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l GetBoundingBox(this int[] indexArray, V3l[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l GetBoundingBox(this int[] indexArray, int count, V3l[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3l GetBoundingBox(this int[] indexArray, int start, int count, V3l[] pointArray)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3l GetBoundingBox<T>(this int[] indexArray, int start, int count, T[] array, Func<T, V3l> pointSelector)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l GetBoundingBox(this long[] indexArray, V3l[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3l GetBoundingBox(this long[] indexArray, long count, V3l[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3l GetBoundingBox(this long[] indexArray, long start, long count, V3l[] pointArray)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3l GetBoundingBox<T>(this long[] indexArray, long start, long count, T[] array, Func<T, V3l> pointSelector)
        {
            if (count <= 0) return Box3l.Invalid;
            var box = new Box3l(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding box for IEnumerable

        /// <summary>
        /// Returns the bounding box of the elements of the collection.
        /// </summary>
        public static Box3l GetBoundingBox(this IEnumerable<V3l> points)
        {
            var box = Box3l.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion

        #region Get octant

        /// <summary>
        /// Octant 0-7.
        /// 0th, 1st and 2nd bit encodes x-, y-, z-axis, respectively.
        /// E.g. 0 is octant [box.Min, box.Center], 7 is octant [box.Center, box.Max].
        /// </summary>
        public static Box3l GetOctant(this Box3l box, int i)
        {
            if (i < 0 || i > 7) throw new IndexOutOfRangeException();

            long x0, x1, y0, y1, z0, z1;
            var c = box.Center;
            if ((i & 1) == 0) { x0 = box.Min.X; x1 = c.X; } else { x0 = c.X; x1 = box.Max.X; }
            if ((i & 2) == 0) { y0 = box.Min.Y; y1 = c.Y; } else { y0 = c.Y; y1 = box.Max.Y; }
            if (i < 4) { z0 = box.Min.Z; z1 = c.Z; } else { z0 = c.Z; z1 = box.Max.Z; }
            return new Box3l(new V3l(x0, y0, z0), new V3l(x1, y1, z1));
        }

        #endregion

        #region Outline corners

        /// <summary>
        /// Gets outline corner indices of a box as seen from given position (in counter-clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static int[] GetOutlineCornerIndicesCCW(this Box3l box, V3l fromPosition)
        {
            if (fromPosition.X < box.Min.X)
            { //-X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X -Y -Z
                        return new[] { 1, 5, 4, 6, 2, 3 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X -Y +Z
                        return new[] { 0, 1, 5, 7, 6, 2 };
                    }
                    else
                    { // -X -Y  Z
                        return new[] { 1, 5, 6, 2 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X +Y -Z
                        return new[] { 0, 4, 6, 7, 3, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X +Y +Z
                        return new[] { 0, 4, 5, 7, 3, 2 };
                    }
                    else
                    { // -X +Y  Z
                        return new[] { 0, 4, 7, 3 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X  Y -Z
                        return new[] { 1, 4, 6, 3 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X  Y +Z
                        return new[] { 0, 5, 7, 2 };
                    }
                    else
                    { // -X  Y  Z
                        return new[] { 0, 4, 6, 2 };
                    }
                }
            }
            else if (fromPosition.X > box.Max.X)
            { // +X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X -Y -Z
                        return new[] { 0, 2, 3, 7, 5, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X -Y +Z
                        return new[] { 0, 1, 3, 7, 6, 4 };
                    }
                    else
                    { // +X -Y  Z
                        return new[] { 0, 3, 7, 4 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X +Y -Z
                        return new[] { 0, 2, 6, 7, 5, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X +Y +Z
                        return new[] { 1, 3, 2, 6, 4, 5 };
                    }
                    else
                    { // +X +Y  Z
                        return new[] { 1, 2, 6, 5 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X  Y -Z
                        return new[] { 0, 2, 7, 5 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X  Y +Z
                        return new[] { 1, 3, 6, 4 };
                    }
                    else
                    { // +X  Y  Z
                        return new[] { 1, 3, 7, 5 };
                    }
                }
            }
            else
            { // X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X -Y -Z
                        return new[] { 2, 3, 5, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X -Y +Z
                        return new[] { 0, 1, 7, 6 };
                    }
                    else
                    { //  X -Y  Z
                        return new[] { 0, 1, 5, 4 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X +Y -Z
                        return new[] { 0, 6, 7, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X +Y +Z
                        return new[] { 2, 4, 5, 3 };
                    }
                    else
                    { //  X +Y  Z
                        return new[] { 2, 6, 7, 3 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X  Y -Z
                        return new[] { 0, 2, 3, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X  Y +Z
                        return new[] { 4, 5, 7, 6 };
                    }
                    else
                    { //  X  Y  Z
                        return null;
                    }
                }
            }
        }

        /// <summary>
        /// Gets outline corner indices of a box as seen from given position (in clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static int[] GetOutlineCornerIndicesCW(this Box3l box, V3l fromPosition)
        {
            if (fromPosition.X < box.Min.X)
            { //-X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X -Y -Z
                        return new[] { 1, 3, 2, 6, 4, 5 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X -Y +Z
                        return new[] { 0, 2, 6, 7, 5, 1 };
                    }
                    else
                    { // -X -Y  Z
                        return new[] { 1, 2, 6, 5 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X +Y -Z
                        return new[] { 0, 1, 3, 7, 6, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X +Y +Z
                        return new[] { 0, 2, 3, 7, 5, 4 };
                    }
                    else
                    { // -X +Y  Z
                        return new[] { 0, 3, 7, 4 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X  Y -Z
                        return new[] { 1, 3, 6, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X  Y +Z
                        return new[] { 0, 2, 7, 5 };
                    }
                    else
                    { // -X  Y  Z
                        return new[] { 0, 2, 6, 4 };
                    }
                }
            }
            else if (fromPosition.X > box.Max.X)
            { // +X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X -Y -Z
                        return new[] { 0, 4, 5, 7, 3, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X -Y +Z
                        return new[] { 0, 4, 6, 7, 3, 1 };
                    }
                    else
                    { // +X -Y  Z
                        return new[] { 0, 4, 7, 3 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X +Y -Z
                        return new[] { 0, 1, 5, 7, 6, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X +Y +Z
                        return new[] { 1, 5, 4, 6, 2, 3 };
                    }
                    else
                    { // +X +Y  Z
                        return new[] { 1, 5, 6, 2 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X  Y -Z
                        return new[] { 0, 5, 7, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X  Y +Z
                        return new[] { 1, 4, 6, 3 };
                    }
                    else
                    { // +X  Y  Z
                        return new[] { 1, 5, 7, 3 };
                    }
                }
            }
            else
            { // X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X -Y -Z
                        return new[] { 2, 4, 5, 3 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X -Y +Z
                        return new[] { 0, 6, 7, 1 };
                    }
                    else
                    { //  X -Y  Z
                        return new[] { 0, 4, 5, 1 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X +Y -Z
                        return new[] { 0, 1, 7, 6 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X +Y +Z
                        return new[] { 2, 3, 5, 4 };
                    }
                    else
                    { //  X +Y  Z
                        return new[] { 2, 3, 7, 6 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X  Y -Z
                        return new[] { 0, 1, 3, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X  Y +Z
                        return new[] { 4, 6, 7, 5 };
                    }
                    else
                    { //  X  Y  Z
                        return null;
                    }
                }
            }
        }

        /// <summary>
        /// Gets outline corners of a box as seen from given position (in counter-clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static V3l[] GetOutlineCornersCCW(this Box3l box, V3l fromPosition)
        {
            var cs = box.ComputeCorners();
            return GetOutlineCornerIndicesCCW(box, fromPosition)?.Map(i => cs[i]);
        }

        /// <summary>
        /// Gets outline corners of a box as seen from given position (in clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static V3l[] GetOutlineCornersCW(this Box3l box, V3l fromPosition)
        {
            var cs = box.ComputeCorners();
            return GetOutlineCornerIndicesCW(box, fromPosition)?.Map(i => cs[i]);
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box3l a, Box3l b)
        {
            return ApproximateEquals(a, b, Constant<long>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box3l a, Box3l b, long tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Box3lAndFlags

    [DataContract]
    public struct Box3lAndFlags
    {
        [DataMember]
        public Box.Flags BFlags;
        [DataMember]
        public Box3l BBox;

        public Box3lAndFlags(Box3l union, Box3l box0, Box3l box1)
        {
            BFlags = 0;
            BBox = union;
            if (box0.Min.X > union.Min.X) { BBox.Min.X = box0.Min.X; BFlags |= Box.Flags.MinX0; }
            if (box0.Min.Y > union.Min.Y) { BBox.Min.Y = box0.Min.Y; BFlags |= Box.Flags.MinY0; }
            if (box0.Min.Z > union.Min.Z) { BBox.Min.Z = box0.Min.Z; BFlags |= Box.Flags.MinZ0; }
            if (box0.Max.X < union.Max.X) { BBox.Max.X = box0.Max.X; BFlags |= Box.Flags.MaxX0; }
            if (box0.Max.Y < union.Max.Y) { BBox.Max.Y = box0.Max.Y; BFlags |= Box.Flags.MaxY0; }
            if (box0.Max.Z < union.Max.Z) { BBox.Max.Z = box0.Max.Z; BFlags |= Box.Flags.MaxZ0; }
            if (box1.Min.X > union.Min.X) { BBox.Min.X = box1.Min.X; BFlags |= Box.Flags.MinX1; }
            if (box1.Min.Y > union.Min.Y) { BBox.Min.Y = box1.Min.Y; BFlags |= Box.Flags.MinY1; }
            if (box1.Min.Z > union.Min.Z) { BBox.Min.Z = box1.Min.Z; BFlags |= Box.Flags.MinZ1; }
            if (box1.Max.X < union.Max.X) { BBox.Max.X = box1.Max.X; BFlags |= Box.Flags.MaxX1; }
            if (box1.Max.Y < union.Max.Y) { BBox.Max.Y = box1.Max.Y; BFlags |= Box.Flags.MaxY1; }
            if (box1.Max.Z < union.Max.Z) { BBox.Max.Z = box1.Max.Z; BFlags |= Box.Flags.MaxZ1; }
        }
    }

    #endregion

    #region Box3f

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box3f
        : IEquatable<Box3f>, IRange<V3f, Box3f>, IBoundingBox3f, ISize3f, IFormattable
    {
        [DataMember]
        public V3f Min;
        [DataMember]
        public V3f Max;

        #region Constructors

        /// <summary>
        /// Construct a Box3f from a Box3i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(Box3i b)
        {
            Min = (V3f) b.Min;
            Max = (V3f) b.Max;
        }

        /// <summary>
        /// Construct a Box3f from a Box3l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(Box3l b)
        {
            Min = (V3f) b.Min;
            Max = (V3f) b.Max;
        }

        /// <summary>
        /// Construct a Box3f from a Box3d.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(Box3d b)
        {
            Min = (V3f) b.Min;
            Max = (V3f) b.Max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(V3f min, V3f max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(float minX, float minY, float minZ, float maxX, float maxY, float maxZ)
        {
            Min.X = minX;
            Min.Y = minY;
            Min.Z = minZ;
            Max.X = maxX;
            Max.Y = maxY;
            Max.Z = maxZ;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(V3f pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(V3f p0, V3f p1, V3f p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(V3f p0, V3f p1, V3f p2, V3f p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(Box3f range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(Box3f b0, Box3f b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(Box3f b0, Box3f b1, Box3f b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(Box3f b0, Box3f b1, Box3f b2, Box3f b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(V3f[] points)
        {
            Min = V3f.MaxValue;
            Max = V3f.MinValue;
            if (points == null) return;
            var count = points.Length;
            for (var i = 0; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(V3f[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f(IEnumerable<V3f> points)
        {
            Min = V3f.MaxValue;
            Max = V3f.MinValue;
            if (points == null) return;
            foreach (V3f p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box3f(IEnumerable<Box3f> boxes)
        {
            Min = V3f.MaxValue;
            Max = V3f.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box3f(Range1f rangeX, Range1f rangeY, Range1f rangeZ)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
            Min.Z = rangeZ.Min;
            Max.Z = rangeZ.Max;
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box3f(Box3i b)
            => new Box3f(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box3f(Box3l b)
            => new Box3f(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box3f(Box3d b)
            => new Box3f(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Box3f Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box3f(V3f.MaxValue, V3f.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Box3f Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box3f(V3f.MinValue, V3f.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Box3f Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box3f(V3f.Zero, V3f.One); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreater(Max) || Min.IsNaN || Max.IsNaN; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }


        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        [XmlIgnore]
        public V3f Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (Min + value); }
        }

        public V3f Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return ((Min + Max) / 2); }
        }

        [XmlIgnore]
        public float SizeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.X - Min.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.X = Min.X + value; }
        }

        public Range1f RangeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1f(Min.X, Max.X); }
        }

        [XmlIgnore]
        public float SizeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Y - Min.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Y = Min.Y + value; }
        }

        public Range1f RangeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1f(Min.Y, Max.Y); }
        }

        [XmlIgnore]
        public float SizeZ
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Z - Min.Z; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Z = Min.Z + value; }
        }

        public Range1f RangeZ
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1f(Min.Z, Max.Z); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                int major = 0;
                var s = Size;
                if (s.Y > s.X) major = 1;
                if (s.Z > s[major]) major = 2;
                return major;
            }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                int minor = 0;
                var s = Size;
                if (s.Y < s.X) minor = 1;
                if (s.Z < s[minor]) minor = 2;
                return minor;
            }
        }

        public float SurfaceArea
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var s = Size;
                return (s.X * s.Y + s.X * s.Z + s.Y * s.Z) * 2;
            }
        }

        public float Volume
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) return 0;
                return SizeX * SizeY * SizeZ;
            }
        }

        public V3f OOO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Min; } }
        public V3f IOO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3f(Max.X, Min.Y, Min.Z); } }
        public V3f OIO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3f(Min.X, Max.Y, Min.Z); } }
        public V3f IIO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3f(Max.X, Max.Y, Min.Z); } }
        public V3f OOI { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3f(Min.X, Min.Y, Max.Z); } }
        public V3f IOI { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3f(Max.X, Min.Y, Max.Z); } }
        public V3f OII { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3f(Min.X, Max.Y, Max.Z); } }
        public V3f III { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f EnlargedBy(V3f increment)
        {
            return new Box3f((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f EnlargedBy(V3f deltaMin, V3f deltaMax)
        {
            return new Box3f((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f ShrunkBy(V3f delta)
        {
            return new Box3f((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f ShrunkBy(V3f deltaMin, V3f deltaMax)
        {
            return new Box3f((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V3f delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V3f deltaMin, V3f deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V3f delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V3f deltaMin, V3f deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f EnlargedBy(float delta)
        {
            return new Box3f(
                    new V3f(Min.X - delta, Min.Y - delta, Min.Z - delta),
                    new V3f(Max.X + delta, Max.Y + delta, Max.Z + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f ShrunkBy(float delta)
        {
            return new Box3f(
                    new V3f(Min.X + delta, Min.Y + delta, Min.Z + delta),
                    new V3f(Max.X - delta, Max.Y - delta, Max.Z - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f EnlargedBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY, 
                float deltaMinZ, float deltaMaxZ)
        {
            return new Box3f(
                    new V3f(Min.X - deltaMinX, Min.Y - deltaMinY, Min.Z - deltaMinZ),
                    new V3f(Max.X + deltaMaxX, Max.Y + deltaMaxY, Max.Z + deltaMaxZ));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f ShrunkBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY, 
                float deltaMinZ, float deltaMaxZ)
        {
            return new Box3f(
                    new V3f(Min.X + deltaMinX, Min.Y + deltaMinY, Min.Z + deltaMinZ),
                    new V3f(Max.X - deltaMaxX, Max.Y - deltaMaxY, Max.Z - deltaMaxZ));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(float delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
            Min.Z -= delta; Max.Z += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(float delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
            Min.Z += delta; Max.Z -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY, 
                float deltaMinZ, float deltaMaxZ)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
            Min.Z -= deltaMinZ; Max.Z += deltaMaxZ;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(
                float deltaMinX, float deltaMaxX, 
                float deltaMinY, float deltaMaxY, 
                float deltaMinZ, float deltaMaxZ)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
            Min.Z += deltaMinZ; Max.Z -= deltaMaxZ;
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f ScaledFromCenterBy(float factor)
        {
            var size = Size;
            var increment = (size * factor - size) / 2;
            return new Box3f(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f ScaledFromCenterBy(V3f vectorFactor)
        {
            var size = Size;
            var increment = (size * vectorFactor - size) / 2;
            return new Box3f(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return a box enlarged in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f EnlargedByRelativeEps(float eps)
        {
            return EnlargedBy(eps * Size.Length);
        }

        /// <summary>
        /// Enlarge the box in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeByRelativeEps(float eps)
        {
            EnlargeBy(eps * Size.Length);
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3f Clamped(V3f p)
        {
            return new V3f(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y), 
                        p.Z < Min.Z ? Min.Z : (p.Z > Max.Z ? Max.Z : p.Z));
        }

        /// <summary>
        /// Returns the squared distance to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double DistanceSquared(V3f p)
        {
            return 
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0)) + 
                (p.Z < Min.Z ? (Min.Z - p.Z) * (Min.Z - p.Z) : (p.Z > Max.Z ? (p.Z - Max.Z) * (p.Z - Max.Z) : 0.0));
        }

        /// <summary>
        /// Returns the distance to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double Distance(V3f p)
        {
            return Fun.Sqrt(
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0)) + 
                (p.Z < Min.Z ? (Min.Z - p.Z) * (Min.Z - p.Z) : (p.Z > Max.Z ? (p.Z - Max.Z) * (p.Z - Max.Z) : 0.0)));
        }

        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        /// <param name="x">Position between min and max [0,1].</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3f Lerp(float x)
        {
            return Fun.Lerp(x, Min, Max);
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3f Lerp(V3f p)
        {
            return new V3f(
                        Fun.Lerp(p.X, Min.X, Max.X), 
                        Fun.Lerp(p.Y, Min.Y, Max.Y), 
                        Fun.Lerp(p.Z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3f Lerp(float x, float y, float z)
        {
            return new V3f(
                         Fun.Lerp(x, Min.X, Max.X), 
                         Fun.Lerp(y, Min.Y, Max.Y), 
                         Fun.Lerp(z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3f InvLerp(V3f p)
        {
            return new V3f(
                        Fun.InvLerp(p.X, Min.X, Max.X), 
                        Fun.InvLerp(p.Y, Min.Y, Max.Y), 
                        Fun.InvLerp(p.Z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3f InvLerp(float x, float y, float z)
        {
            return new V3f(
                        Fun.InvLerp(x, Min.X, Max.X), 
                        Fun.InvLerp(y, Min.Y, Max.Y), 
                        Fun.InvLerp(z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f SplitRight(V3f splitValue)
        {
            var result = new Box3f(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            if (splitValue.Z > result.Min.Z) result.Min.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f SplitLeft(V3f splitValue)
        {
            var result = new Box3f(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            if (splitValue.Z < result.Max.Z) result.Max.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f ExtendedBy(Box3f b)
        {
            return new Box3f(
                    new V3f(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y, 
                        b.Min.Z < Min.Z ? b.Min.Z : Min.Z),
                    new V3f(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y, 
                        b.Max.Z > Max.Z ? b.Max.Z : Max.Z));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f ExtendedBy(V3f v)
        {
            return new Box3f(
                    new V3f(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y, 
                        v.Z < Min.Z ? v.Z : Min.Z),
                    new V3f(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y, 
                        v.Z > Max.Z ? v.Z : Max.Z));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Box3f box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
            if (box.Min.Z < Min.Z) Min.Z = box.Min.Z;
            if (box.Max.Z > Max.Z) Max.Z = box.Max.Z;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(V3f point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
            if (point.Z < Min.Z) Min.Z = point.Z;
            if (point.Z > Max.Z) Max.Z = point.Z;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f ExtendXBy(float x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f ExtendYBy(float y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f ExtendZBy(float z)
        {
            if (z < Min.Z) Min.Z = z;
            if (z > Max.Z) Max.Z = z;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f ExtendDimBy(int dim, float x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(V3f p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y && 
                p.Z >= Min.Z && p.Z <= Max.Z;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Box3f b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y && 
                b.Min.Z >= Min.Z && b.Max.Z <= Max.Z;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f Repair()
        {
            if (Equals(Box3f.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            if (Min.Z > Max.Z) Fun.Swap(ref Min.Z, ref Max.Z);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box3f box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            if (Min.Z >= box.Max.Z) return false;
            if (Max.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box3f box, V3f eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            if (Min.Z - eps.Z >= box.Max.Z) return false;
            if (Max.Z + eps.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box3f box, float eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            if (Min.Z - eps >= box.Max.Z) return false;
            if (Max.Z + eps <= box.Min.Z) return false;
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f Invalidate()
        {
            Min = V3f.MaxValue;
            Max = V3f.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(V3f p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (p0.Z < Min.Z) bf |= Box.Flags.MinZ;
            else if (p0.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(Box3f b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (b.Min.Z < Min.Z) bf |= Box.Flags.MinZ;
            if (b.Max.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinMaxInDirection(V3f v, out V3f vMin, out V3f vMax)
        {
            vMin = V3f.MinValue;
            vMax = V3f.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
            if (v.Z >= 0)
            {
                vMin.Z = Min.Z;
                vMax.Z = Max.Z;
            }
            else
            {
                vMin.Z = Max.Z;
                vMax.Z = Min.Z;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Box3f a, Box3f b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Box3f a, Box3f b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f operator +(Box3f box, V3f v)
        {
            return new Box3f((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f operator -(Box3f box, V3f v)
        {
            return new Box3f((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Box3f other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Box3f o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box3f, int, V3f> Setter =
            (ref Box3f box, int i, V3f value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box3f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box3f(V3f.Parse(x[0].ToString()),
                                V3f.Parse(x[1].ToString()));
        }

        public static Box3f Parse(Text t)
        {
            return t.NestedBracketSplit(1, V3f.Parse, Box3f.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f FromSize(V3f size)
        {
            return new Box3f(V3f.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f FromMinAndSize(V3f min, V3f size)
        {
            return new Box3f(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f FromCenterAndSize(V3f center, V3f size)
        {
            return new Box3f(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f FromSize(ISize3f iSize)
        {
            return new Box3f(
                V3f.Zero, iSize.Size3f);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f FromMinAndSize(V3f min, ISize3f iSize)
        {
            return new Box3f(
                min, min + iSize.Size3f);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f FromCenterAndSize(V3f center, ISize3f iSize)
        {
            var size = iSize.Size3f;
            return new Box3f(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f FromPoints(V3f p0, V3f p1)
        {
            return new Box3f(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        #endregion

        #region Transforms

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f Translated(V3f shift)
        {
            return IsInvalid ? Box3f.Invalid
                             : new Box3f(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f Scaled(V3f factor)
        {
            return IsInvalid ? Box3f.Invalid
                             : new Box3f(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box3f Transformed(M44f trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y || Min.Z > Max.Z) return Box3f.Invalid; 
            var t = new V3f(trafo.M03, trafo.M13, trafo.M23);
            var res = new Box3f(t, t);
            float av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M02 * Min.Z;
            bv = trafo.M02 * Max.Z;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M12 * Min.Z;
            bv = trafo.M12 * Max.Z;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M20 * Min.X;
            bv = trafo.M20 * Max.X;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M21 * Min.Y;
            bv = trafo.M21 * Max.Y;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M22 * Min.Z;
            bv = trafo.M22 * Max.Z;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            return res;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3f Transformed(Trafo3f trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3f Corner(int index)
        {
            return
                new V3f(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y, 
                        (index & 4) == 0 ? Min.Z : Max.Z);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3f[] ComputeCorners()
        {
            return new V3f[] {
                Min,
                new V3f(Max.X, Min.Y, Min.Z),
                new V3f(Min.X, Max.Y, Min.Z),
                new V3f(Max.X, Max.Y, Min.Z),
                new V3f(Min.X, Min.Y, Max.Z),
                new V3f(Max.X, Min.Y, Max.Z),
                new V3f(Min.X, Max.Y, Max.Z),
                Max
            };
        }


        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V3f> Corners
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return Min;
                yield return new V3f(Max.X, Min.Y, Min.Z);
                yield return new V3f(Min.X, Max.Y, Min.Z);
                yield return new V3f(Max.X, Max.Y, Min.Z);
                yield return new V3f(Min.X, Min.Y, Max.Z);
                yield return new V3f(Max.X, Min.Y, Max.Z);
                yield return new V3f(Min.X, Max.Y, Max.Z);
                yield return Max;
            }
        }

        #endregion

        #region Swizzle methods

        // TODO: Implement for other dimensions
        public Range1f X { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1f(Min.X, Max.X); } }
        public Range1f Y { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1f(Min.Y, Max.Y); } }
        public Range1f Z { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1f(Min.Z, Max.Z); } }
        public Box2f XY { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2f(Min.XY, Max.XY); } }
        public Box2f XZ { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2f(Min.XZ, Max.XZ); } }
        public Box2f YX { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2f(Min.YX, Max.YX); } }
        public Box2f YZ { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2f(Min.YZ, Max.YZ); } }
        public Box2f ZX { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2f(Min.ZX, Max.ZX); } }
        public Box2f ZY { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2f(Min.ZY, Max.ZY); } }

        #endregion

        #region Enumerators

        #endregion

        #region IBoundingBox3f Members

        public Box3f BoundingBox3f
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this; }
        }

        #endregion

        #region ISize3f Members

        public V3f Size3f
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Size; }
        }

        #endregion
    }

    public static partial class Box
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f Union(this Box3f a, Box3f b)
        {
            return new Box3f(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f Intersection(this Box3f a, Box3f b)
        {
            return new Box3f(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        #endregion

        #region Bounding box for arrays

        /// <summary>
        /// Returns the bounding box of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f GetBoundingBox(this V3f[] pointArray)
        {
            return pointArray.GetBoundingBox(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f GetBoundingBox(this V3f[] pointArray, long count)
        {
            return pointArray.GetBoundingBox(0, count);
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box3f GetBoundingBox(
                this V3f[] pointArray, long start, long count)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box3f GetBoundingBox<T>(this T[] array, long start, long count, Func<T, V3f> pointSelector)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding box for lists

        /// <summary>
        /// Returns the bounding box of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f GetBoundingBox(this List<V3f> pointList)
        {
            return pointList.GetBoundingBox(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the list.
        /// </summary>
        public static Box3f GetBoundingBox(this List<V3f> pointList, int count)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding box for indexed arrays

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f GetBoundingBox(this int[] indexArray, V3f[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f GetBoundingBox(this int[] indexArray, int count, V3f[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3f GetBoundingBox(this int[] indexArray, int start, int count, V3f[] pointArray)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3f GetBoundingBox<T>(this int[] indexArray, int start, int count, T[] array, Func<T, V3f> pointSelector)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f GetBoundingBox(this long[] indexArray, V3f[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3f GetBoundingBox(this long[] indexArray, long count, V3f[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3f GetBoundingBox(this long[] indexArray, long start, long count, V3f[] pointArray)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3f GetBoundingBox<T>(this long[] indexArray, long start, long count, T[] array, Func<T, V3f> pointSelector)
        {
            if (count <= 0) return Box3f.Invalid;
            var box = new Box3f(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding box for IEnumerable

        /// <summary>
        /// Returns the bounding box of the elements of the collection.
        /// </summary>
        public static Box3f GetBoundingBox(this IEnumerable<V3f> points)
        {
            var box = Box3f.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion

        #region Get octant

        /// <summary>
        /// Octant 0-7.
        /// 0th, 1st and 2nd bit encodes x-, y-, z-axis, respectively.
        /// E.g. 0 is octant [box.Min, box.Center], 7 is octant [box.Center, box.Max].
        /// </summary>
        public static Box3f GetOctant(this Box3f box, int i)
        {
            if (i < 0 || i > 7) throw new IndexOutOfRangeException();

            float x0, x1, y0, y1, z0, z1;
            var c = box.Center;
            if ((i & 1) == 0) { x0 = box.Min.X; x1 = c.X; } else { x0 = c.X; x1 = box.Max.X; }
            if ((i & 2) == 0) { y0 = box.Min.Y; y1 = c.Y; } else { y0 = c.Y; y1 = box.Max.Y; }
            if (i < 4) { z0 = box.Min.Z; z1 = c.Z; } else { z0 = c.Z; z1 = box.Max.Z; }
            return new Box3f(new V3f(x0, y0, z0), new V3f(x1, y1, z1));
        }

        #endregion

        #region Outline corners

        /// <summary>
        /// Gets outline corner indices of a box as seen from given position (in counter-clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static int[] GetOutlineCornerIndicesCCW(this Box3f box, V3f fromPosition)
        {
            if (fromPosition.X < box.Min.X)
            { //-X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X -Y -Z
                        return new[] { 1, 5, 4, 6, 2, 3 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X -Y +Z
                        return new[] { 0, 1, 5, 7, 6, 2 };
                    }
                    else
                    { // -X -Y  Z
                        return new[] { 1, 5, 6, 2 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X +Y -Z
                        return new[] { 0, 4, 6, 7, 3, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X +Y +Z
                        return new[] { 0, 4, 5, 7, 3, 2 };
                    }
                    else
                    { // -X +Y  Z
                        return new[] { 0, 4, 7, 3 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X  Y -Z
                        return new[] { 1, 4, 6, 3 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X  Y +Z
                        return new[] { 0, 5, 7, 2 };
                    }
                    else
                    { // -X  Y  Z
                        return new[] { 0, 4, 6, 2 };
                    }
                }
            }
            else if (fromPosition.X > box.Max.X)
            { // +X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X -Y -Z
                        return new[] { 0, 2, 3, 7, 5, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X -Y +Z
                        return new[] { 0, 1, 3, 7, 6, 4 };
                    }
                    else
                    { // +X -Y  Z
                        return new[] { 0, 3, 7, 4 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X +Y -Z
                        return new[] { 0, 2, 6, 7, 5, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X +Y +Z
                        return new[] { 1, 3, 2, 6, 4, 5 };
                    }
                    else
                    { // +X +Y  Z
                        return new[] { 1, 2, 6, 5 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X  Y -Z
                        return new[] { 0, 2, 7, 5 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X  Y +Z
                        return new[] { 1, 3, 6, 4 };
                    }
                    else
                    { // +X  Y  Z
                        return new[] { 1, 3, 7, 5 };
                    }
                }
            }
            else
            { // X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X -Y -Z
                        return new[] { 2, 3, 5, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X -Y +Z
                        return new[] { 0, 1, 7, 6 };
                    }
                    else
                    { //  X -Y  Z
                        return new[] { 0, 1, 5, 4 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X +Y -Z
                        return new[] { 0, 6, 7, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X +Y +Z
                        return new[] { 2, 4, 5, 3 };
                    }
                    else
                    { //  X +Y  Z
                        return new[] { 2, 6, 7, 3 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X  Y -Z
                        return new[] { 0, 2, 3, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X  Y +Z
                        return new[] { 4, 5, 7, 6 };
                    }
                    else
                    { //  X  Y  Z
                        return null;
                    }
                }
            }
        }

        /// <summary>
        /// Gets outline corner indices of a box as seen from given position (in clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static int[] GetOutlineCornerIndicesCW(this Box3f box, V3f fromPosition)
        {
            if (fromPosition.X < box.Min.X)
            { //-X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X -Y -Z
                        return new[] { 1, 3, 2, 6, 4, 5 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X -Y +Z
                        return new[] { 0, 2, 6, 7, 5, 1 };
                    }
                    else
                    { // -X -Y  Z
                        return new[] { 1, 2, 6, 5 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X +Y -Z
                        return new[] { 0, 1, 3, 7, 6, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X +Y +Z
                        return new[] { 0, 2, 3, 7, 5, 4 };
                    }
                    else
                    { // -X +Y  Z
                        return new[] { 0, 3, 7, 4 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X  Y -Z
                        return new[] { 1, 3, 6, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X  Y +Z
                        return new[] { 0, 2, 7, 5 };
                    }
                    else
                    { // -X  Y  Z
                        return new[] { 0, 2, 6, 4 };
                    }
                }
            }
            else if (fromPosition.X > box.Max.X)
            { // +X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X -Y -Z
                        return new[] { 0, 4, 5, 7, 3, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X -Y +Z
                        return new[] { 0, 4, 6, 7, 3, 1 };
                    }
                    else
                    { // +X -Y  Z
                        return new[] { 0, 4, 7, 3 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X +Y -Z
                        return new[] { 0, 1, 5, 7, 6, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X +Y +Z
                        return new[] { 1, 5, 4, 6, 2, 3 };
                    }
                    else
                    { // +X +Y  Z
                        return new[] { 1, 5, 6, 2 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X  Y -Z
                        return new[] { 0, 5, 7, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X  Y +Z
                        return new[] { 1, 4, 6, 3 };
                    }
                    else
                    { // +X  Y  Z
                        return new[] { 1, 5, 7, 3 };
                    }
                }
            }
            else
            { // X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X -Y -Z
                        return new[] { 2, 4, 5, 3 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X -Y +Z
                        return new[] { 0, 6, 7, 1 };
                    }
                    else
                    { //  X -Y  Z
                        return new[] { 0, 4, 5, 1 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X +Y -Z
                        return new[] { 0, 1, 7, 6 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X +Y +Z
                        return new[] { 2, 3, 5, 4 };
                    }
                    else
                    { //  X +Y  Z
                        return new[] { 2, 3, 7, 6 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X  Y -Z
                        return new[] { 0, 1, 3, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X  Y +Z
                        return new[] { 4, 6, 7, 5 };
                    }
                    else
                    { //  X  Y  Z
                        return null;
                    }
                }
            }
        }

        /// <summary>
        /// Gets outline corners of a box as seen from given position (in counter-clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static V3f[] GetOutlineCornersCCW(this Box3f box, V3f fromPosition)
        {
            var cs = box.ComputeCorners();
            return GetOutlineCornerIndicesCCW(box, fromPosition)?.Map(i => cs[i]);
        }

        /// <summary>
        /// Gets outline corners of a box as seen from given position (in clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static V3f[] GetOutlineCornersCW(this Box3f box, V3f fromPosition)
        {
            var cs = box.ComputeCorners();
            return GetOutlineCornerIndicesCW(box, fromPosition)?.Map(i => cs[i]);
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box3f a, Box3f b)
        {
            return ApproximateEquals(a, b, Constant<float>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box3f a, Box3f b, float tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Box3fAndFlags

    [DataContract]
    public struct Box3fAndFlags
    {
        [DataMember]
        public Box.Flags BFlags;
        [DataMember]
        public Box3f BBox;

        public Box3fAndFlags(Box3f union, Box3f box0, Box3f box1)
        {
            BFlags = 0;
            BBox = union;
            if (box0.Min.X > union.Min.X) { BBox.Min.X = box0.Min.X; BFlags |= Box.Flags.MinX0; }
            if (box0.Min.Y > union.Min.Y) { BBox.Min.Y = box0.Min.Y; BFlags |= Box.Flags.MinY0; }
            if (box0.Min.Z > union.Min.Z) { BBox.Min.Z = box0.Min.Z; BFlags |= Box.Flags.MinZ0; }
            if (box0.Max.X < union.Max.X) { BBox.Max.X = box0.Max.X; BFlags |= Box.Flags.MaxX0; }
            if (box0.Max.Y < union.Max.Y) { BBox.Max.Y = box0.Max.Y; BFlags |= Box.Flags.MaxY0; }
            if (box0.Max.Z < union.Max.Z) { BBox.Max.Z = box0.Max.Z; BFlags |= Box.Flags.MaxZ0; }
            if (box1.Min.X > union.Min.X) { BBox.Min.X = box1.Min.X; BFlags |= Box.Flags.MinX1; }
            if (box1.Min.Y > union.Min.Y) { BBox.Min.Y = box1.Min.Y; BFlags |= Box.Flags.MinY1; }
            if (box1.Min.Z > union.Min.Z) { BBox.Min.Z = box1.Min.Z; BFlags |= Box.Flags.MinZ1; }
            if (box1.Max.X < union.Max.X) { BBox.Max.X = box1.Max.X; BFlags |= Box.Flags.MaxX1; }
            if (box1.Max.Y < union.Max.Y) { BBox.Max.Y = box1.Max.Y; BFlags |= Box.Flags.MaxY1; }
            if (box1.Max.Z < union.Max.Z) { BBox.Max.Z = box1.Max.Z; BFlags |= Box.Flags.MaxZ1; }
        }
    }

    #endregion

    #region Box3d

    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Box3d
        : IEquatable<Box3d>, IRange<V3d, Box3d>, IBoundingBox3d, ISize3d, IFormattable
    {
        [DataMember]
        public V3d Min;
        [DataMember]
        public V3d Max;

        #region Constructors

        /// <summary>
        /// Construct a Box3d from a Box3i.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(Box3i b)
        {
            Min = (V3d) b.Min;
            Max = (V3d) b.Max;
        }

        /// <summary>
        /// Construct a Box3d from a Box3l.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(Box3l b)
        {
            Min = (V3d) b.Min;
            Max = (V3d) b.Max;
        }

        /// <summary>
        /// Construct a Box3d from a Box3f.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(Box3f b)
        {
            Min = (V3d) b.Min;
            Max = (V3d) b.Max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(V3d min, V3d max)
        {
            Min = min;
            Max = max;
        }

        /// <summary>
        /// Creates a box from minimum and maximum limits.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(double minX, double minY, double minZ, double maxX, double maxY, double maxZ)
        {
            Min.X = minX;
            Min.Y = minY;
            Min.Z = minZ;
            Max.X = maxX;
            Max.Y = maxY;
            Max.Z = maxZ;
        }

        /// <summary>
        /// Creates infinitesimal box from single point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(V3d pnt)
        {
            Min = pnt;
            Max = pnt;
        }

        /// <summary>
        /// Creates a box from 3 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(V3d p0, V3d p1, V3d p2)
        {
            Min = Fun.Min(p0, p1, p2);
            Max = Fun.Max(p0, p1, p2);
        }

        /// <summary>
        /// Creates a box from 4 points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(V3d p0, V3d p1, V3d p2, V3d p3)
        {
            Min = Fun.Min(p0, p1, p2, p3);
            Max = Fun.Max(p0, p1, p2, p3);
        }

        /// <summary>
        /// Creates copy of existing range.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(Box3d range)
        {
            Min = range.Min;
            Max = range.Max;
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(Box3d b0, Box3d b1)
        {
            Min = Fun.Min(b0.Min, b1.Min);
            Max = Fun.Max(b0.Max, b1.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(Box3d b0, Box3d b1, Box3d b2)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max);
        }

        /// <summary>
        /// Create a box containing all supplied boxs.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(Box3d b0, Box3d b1, Box3d b2, Box3d b3)
        {
            Min = Fun.Min(b0.Min, b1.Min, b2.Min, b3.Min);
            Max = Fun.Max(b0.Max, b1.Max, b2.Max, b3.Max);
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(V3d[] points)
        {
            Min = V3d.MaxValue;
            Max = V3d.MinValue;
            if (points == null) return;
            var count = points.Length;
            for (var i = 0; i < count; i++) ExtendBy(points[i]);
        }

        /// <summary>
        /// Creates box as the bounding box of count of the given points
        /// starting at start.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(V3d[] points, long start, long count)
        {
            if (count <= 0)
            {
                Min = Invalid.Min;
                Max = Invalid.Max;
            }
            else
            {
                Min = Max = points[start];
                for (long i = start + 1, e = start + count; i < e; i++) ExtendBy(points[i]);
            }
        }

        /// <summary>
        /// Creates box as the bounding box of given points.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d(IEnumerable<V3d> points)
        {
            Min = V3d.MaxValue;
            Max = V3d.MinValue;
            if (points == null) return;
            foreach (V3d p in points) ExtendBy(p);
        }

        /// <summary>
        /// Creates box as the bounding box of given boxes.
        /// </summary>
        public Box3d(IEnumerable<Box3d> boxes)
        {
            Min = V3d.MaxValue;
            Max = V3d.MinValue;
            if (boxes == null) return;
            foreach (var box in boxes) ExtendBy(box);
        }

        /// <summary>
        /// Creates box from a Range1 in each direction.
        /// </summary>
        public Box3d(Range1d rangeX, Range1d rangeY, Range1d rangeZ)
        {
            Min.X = rangeX.Min;
            Max.X = rangeX.Max;
            Min.Y = rangeY.Min;
            Max.Y = rangeY.Max;
            Min.Z = rangeZ.Min;
            Max.Z = rangeZ.Max;
        }

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box3d(Box3i b)
            => new Box3d(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box3d(Box3l b)
            => new Box3d(b);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Box3d(Box3f b)
            => new Box3d(b);

        #endregion

        #region Constants

        /// <summary>
        /// A range with crossed limits.
        /// </summary>
        public static Box3d Invalid { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box3d(V3d.MaxValue, V3d.MinValue); }

        /// <summary>
        /// The largest possible range.
        /// </summary>
        public static Box3d Infinite { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box3d(V3d.MinValue, V3d.MaxValue); }

        /// <summary>
        /// The unit interval [0, 1].
        /// </summary>
        public static Box3d Unit { [MethodImpl(MethodImplOptions.AggressiveInlining)] get => new Box3d(V3d.Zero, V3d.One); }
        #endregion

        #region Properties

        /// <summary>
        /// True if the box is invalid or has a zero volume.
        /// </summary>
        public bool IsEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreaterOrEqual(Max); }
        }

        /// <summary>
        /// True if the box has a non-zero volume.
        /// </summary>
        public bool IsNonEmpty
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return !IsEmpty; }
        }

        /// <summary>
        /// True if the box is valid.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AllSmallerOrEqual(Max); }
        }

        /// <summary>
        /// True if the box is invalid.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Min.AnyGreater(Max) || Min.IsNaN || Max.IsNaN; }
        }

        /// <summary>
        /// True if the box is infinite.
        /// </summary>
        public bool IsInfinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this == Infinite; }
        }


        /// <summary>
        /// Calculates size of the box.
        /// </summary>
        [XmlIgnore]
        public V3d Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return (Max - Min); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max = (Min + value); }
        }

        public V3d Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return ((Min + Max) / 2); }
        }

        [XmlIgnore]
        public double SizeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.X - Min.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.X = Min.X + value; }
        }

        public Range1d RangeX
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1d(Min.X, Max.X); }
        }

        [XmlIgnore]
        public double SizeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Y - Min.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Y = Min.Y + value; }
        }

        public Range1d RangeY
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1d(Min.Y, Max.Y); }
        }

        [XmlIgnore]
        public double SizeZ
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Max.Z - Min.Z; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { Max.Z = Min.Z + value; }
        }

        public Range1d RangeZ
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Range1d(Min.Z, Max.Z); }
        }

        /// <summary>
        /// Index of the longest dimension of the box.
        /// </summary>
        public int MajorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                int major = 0;
                var s = Size;
                if (s.Y > s.X) major = 1;
                if (s.Z > s[major]) major = 2;
                return major;
            }
        }

        /// <summary>
        /// Index of the shortest dimension of the box.
        /// </summary>
        public int MinorDim
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                int minor = 0;
                var s = Size;
                if (s.Y < s.X) minor = 1;
                if (s.Z < s[minor]) minor = 2;
                return minor;
            }
        }

        public double SurfaceArea
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var s = Size;
                return (s.X * s.Y + s.X * s.Z + s.Y * s.Z) * 2;
            }
        }

        public double Volume
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (IsInvalid) return 0;
                return SizeX * SizeY * SizeZ;
            }
        }

        public V3d OOO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Min; } }
        public V3d IOO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3d(Max.X, Min.Y, Min.Z); } }
        public V3d OIO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3d(Min.X, Max.Y, Min.Z); } }
        public V3d IIO { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3d(Max.X, Max.Y, Min.Z); } }
        public V3d OOI { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3d(Min.X, Min.Y, Max.Z); } }
        public V3d IOI { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3d(Max.X, Min.Y, Max.Z); } }
        public V3d OII { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new V3d(Min.X, Max.Y, Max.Z); } }
        public V3d III { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return Max; } }

        #endregion

        #region Size Manipulations

        /// <summary>
        /// Return box enlarged by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d EnlargedBy(V3d increment)
        {
            return new Box3d((Min - increment), (Max + increment));
        }

        /// <summary>
        /// Return box enlarged by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d EnlargedBy(V3d deltaMin, V3d deltaMax)
        {
            return new Box3d((Min - deltaMin), (Max + deltaMax));
        }

        /// <summary>
        /// Return box shrunk by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d ShrunkBy(V3d delta)
        {
            return new Box3d((Min + delta), (Max - delta));
        }

        /// <summary>
        /// Return box shrunk by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d ShrunkBy(V3d deltaMin, V3d deltaMax)
        {
            return new Box3d((Min + deltaMin), (Max - deltaMax));
        }

        /// <summary>
        /// Enlarges box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V3d delta)
        {
            Min -= delta;
            Max += delta;
        }

        /// <summary>
        /// Enlarges box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(V3d deltaMin, V3d deltaMax)
        {
            Min -= deltaMin;
            Max += deltaMax;
        }

        /// <summary>
        /// Shrinks box by the supplied value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V3d delta)
        {
            Min += delta;
            Max -= delta;
        }

        /// <summary>
        /// Shrinks box by the supplied values.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(V3d deltaMin, V3d deltaMax)
        {
            Min += deltaMin;
            Max -= deltaMax;
        }

        /// <summary>
        /// Returns a box enlarged by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d EnlargedBy(double delta)
        {
            return new Box3d(
                    new V3d(Min.X - delta, Min.Y - delta, Min.Z - delta),
                    new V3d(Max.X + delta, Max.Y + delta, Max.Z + delta));
        }

        /// <summary>
        /// Returns a box shrunk by the specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d ShrunkBy(double delta)
        {
            return new Box3d(
                    new V3d(Min.X + delta, Min.Y + delta, Min.Z + delta),
                    new V3d(Max.X - delta, Max.Y - delta, Max.Z - delta));
        }

        /// <summary>
        /// Returns the box enlarged by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d EnlargedBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY, 
                double deltaMinZ, double deltaMaxZ)
        {
            return new Box3d(
                    new V3d(Min.X - deltaMinX, Min.Y - deltaMinY, Min.Z - deltaMinZ),
                    new V3d(Max.X + deltaMaxX, Max.Y + deltaMaxY, Max.Z + deltaMaxZ));
        }

        /// <summary>
        /// Returns the box shrunk by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d ShrunkBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY, 
                double deltaMinZ, double deltaMaxZ)
        {
            return new Box3d(
                    new V3d(Min.X + deltaMinX, Min.Y + deltaMinY, Min.Z + deltaMinZ),
                    new V3d(Max.X - deltaMaxX, Max.Y - deltaMaxY, Max.Z - deltaMaxZ));
        }

        /// <summary>
        /// Enlarges box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(double delta)
        {
            Min.X -= delta; Max.X += delta;
            Min.Y -= delta; Max.Y += delta;
            Min.Z -= delta; Max.Z += delta;
        }

        /// <summary>
        /// Shrinks box by specified value in all directions.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(double delta)
        {
            Min.X += delta; Max.X -= delta;
            Min.Y += delta; Max.Y -= delta;
            Min.Z += delta; Max.Z -= delta;
        }

        /// <summary>
        /// Enlarges the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY, 
                double deltaMinZ, double deltaMaxZ)
        {
            Min.X -= deltaMinX; Max.X += deltaMaxX;
            Min.Y -= deltaMinY; Max.Y += deltaMaxY;
            Min.Z -= deltaMinZ; Max.Z += deltaMaxZ;
        }

        /// <summary>
        /// Shrinks the box by the specified values (paddings).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ShrinkBy(
                double deltaMinX, double deltaMaxX, 
                double deltaMinY, double deltaMaxY, 
                double deltaMinZ, double deltaMaxZ)
        {
            Min.X += deltaMinX; Max.X -= deltaMaxX;
            Min.Y += deltaMinY; Max.Y -= deltaMaxY;
            Min.Z += deltaMinZ; Max.Z -= deltaMaxZ;
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d ScaledFromCenterBy(double factor)
        {
            var size = Size;
            var increment = (size * factor - size) / 2;
            return new Box3d(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return box scaled by the supplied factor around its center.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d ScaledFromCenterBy(V3d vectorFactor)
        {
            var size = Size;
            var increment = (size * vectorFactor - size) / 2;
            return new Box3d(Min - increment, Max + increment);
        }

        /// <summary>
        /// Return a box enlarged in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d EnlargedByRelativeEps(double eps)
        {
            return EnlargedBy(eps * Size.Length);
        }

        /// <summary>
        /// Enlarge the box in all directions by the supplied epsilon which is
        /// measured with respect to the box diagonal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnlargeByRelativeEps(double eps)
        {
            EnlargeBy(eps * Size.Length);
        }

        #endregion

        #region Box Arithmetics

        /// <summary>
        /// Return the point in the Box that is closest to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3d Clamped(V3d p)
        {
            return new V3d(
                        p.X < Min.X ? Min.X : (p.X > Max.X ? Max.X : p.X), 
                        p.Y < Min.Y ? Min.Y : (p.Y > Max.Y ? Max.Y : p.Y), 
                        p.Z < Min.Z ? Min.Z : (p.Z > Max.Z ? Max.Z : p.Z));
        }

        /// <summary>
        /// Returns the squared distance to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double DistanceSquared(V3d p)
        {
            return 
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0)) + 
                (p.Z < Min.Z ? (Min.Z - p.Z) * (Min.Z - p.Z) : (p.Z > Max.Z ? (p.Z - Max.Z) * (p.Z - Max.Z) : 0.0));
        }

        /// <summary>
        /// Returns the distance to the supplied point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double Distance(V3d p)
        {
            return Fun.Sqrt(
                (p.X < Min.X ? (Min.X - p.X) * (Min.X - p.X) : (p.X > Max.X ? (p.X - Max.X) * (p.X - Max.X) : 0.0)) + 
                (p.Y < Min.Y ? (Min.Y - p.Y) * (Min.Y - p.Y) : (p.Y > Max.Y ? (p.Y - Max.Y) * (p.Y - Max.Y) : 0.0)) + 
                (p.Z < Min.Z ? (Min.Z - p.Z) * (Min.Z - p.Z) : (p.Z > Max.Z ? (p.Z - Max.Z) * (p.Z - Max.Z) : 0.0)));
        }

        /// <summary>
        /// Linearly interpolates between min and max.
        /// </summary>
        /// <param name="x">Position between min and max [0,1].</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3d Lerp(double x)
        {
            return Fun.Lerp(x, Min, Max);
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3d Lerp(V3d p)
        {
            return new V3d(
                        Fun.Lerp(p.X, Min.X, Max.X), 
                        Fun.Lerp(p.Y, Min.Y, Max.Y), 
                        Fun.Lerp(p.Z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Interpolate linearly in each dimension.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3d Lerp(double x, double y, double z)
        {
            return new V3d(
                         Fun.Lerp(x, Min.X, Max.X), 
                         Fun.Lerp(y, Min.Y, Max.Y), 
                         Fun.Lerp(z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3d InvLerp(V3d p)
        {
            return new V3d(
                        Fun.InvLerp(p.X, Min.X, Max.X), 
                        Fun.InvLerp(p.Y, Min.Y, Max.Y), 
                        Fun.InvLerp(p.Z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Inverse of Lerp.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3d InvLerp(double x, double y, double z)
        {
            return new V3d(
                        Fun.InvLerp(x, Min.X, Max.X), 
                        Fun.InvLerp(y, Min.Y, Max.Y), 
                        Fun.InvLerp(z, Min.Z, Max.Z));
        }

        /// <summary>
        /// Returns the box with Min value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d SplitRight(V3d splitValue)
        {
            var result = new Box3d(Min, Max);
            if (splitValue.X > result.Min.X) result.Min.X = splitValue.X;
            if (splitValue.Y > result.Min.Y) result.Min.Y = splitValue.Y;
            if (splitValue.Z > result.Min.Z) result.Min.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box with Max value clamped to splitValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d SplitLeft(V3d splitValue)
        {
            var result = new Box3d(Min, Max);
            if (splitValue.X < result.Max.X) result.Max.X = splitValue.X;
            if (splitValue.Y < result.Max.Y) result.Max.Y = splitValue.Y;
            if (splitValue.Z < result.Max.Z) result.Max.Z = splitValue.Z;
            return result;
        }

        /// <summary>
        /// Returns the box extended to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d ExtendedBy(Box3d b)
        {
            return new Box3d(
                    new V3d(
                        b.Min.X < Min.X ? b.Min.X : Min.X, 
                        b.Min.Y < Min.Y ? b.Min.Y : Min.Y, 
                        b.Min.Z < Min.Z ? b.Min.Z : Min.Z),
                    new V3d(
                        b.Max.X > Max.X ? b.Max.X : Max.X, 
                        b.Max.Y > Max.Y ? b.Max.Y : Max.Y, 
                        b.Max.Z > Max.Z ? b.Max.Z : Max.Z));
        }

        /// <summary>
        /// Returns the box extended to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d ExtendedBy(V3d v)
        {
            return new Box3d(
                    new V3d(
                        v.X < Min.X ? v.X : Min.X, 
                        v.Y < Min.Y ? v.Y : Min.Y, 
                        v.Z < Min.Z ? v.Z : Min.Z),
                    new V3d(
                        v.X > Max.X ? v.X : Max.X, 
                        v.Y > Max.Y ? v.Y : Max.Y, 
                        v.Z > Max.Z ? v.Z : Max.Z));
        }

        /// <summary>
        /// Extends the box to contain the supplied box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(Box3d box)
        {
            if (box.Min.X < Min.X) Min.X = box.Min.X;
            if (box.Max.X > Max.X) Max.X = box.Max.X;
            if (box.Min.Y < Min.Y) Min.Y = box.Min.Y;
            if (box.Max.Y > Max.Y) Max.Y = box.Max.Y;
            if (box.Min.Z < Min.Z) Min.Z = box.Min.Z;
            if (box.Max.Z > Max.Z) Max.Z = box.Max.Z;
        }

        /// <summary>
        /// Extends the box to contain the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ExtendBy(V3d point)
        {
            if (point.X < Min.X) Min.X = point.X;
            if (point.X > Max.X) Max.X = point.X;
            if (point.Y < Min.Y) Min.Y = point.Y;
            if (point.Y > Max.Y) Max.Y = point.Y;
            if (point.Z < Min.Z) Min.Z = point.Z;
            if (point.Z > Max.Z) Max.Z = point.Z;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d ExtendXBy(double x)
        {
            if (x < Min.X) Min.X = x;
            if (x > Max.X) Max.X = x;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d ExtendYBy(double y)
        {
            if (y < Min.Y) Min.Y = y;
            if (y > Max.Y) Max.Y = y;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d ExtendZBy(double z)
        {
            if (z < Min.Z) Min.Z = z;
            if (z > Max.Z) Max.Z = z;
            return this;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d ExtendDimBy(int dim, double x)
        {
            if (x < Min[dim]) Min[dim] = x;
            if (x > Max[dim]) Max[dim] = x;
            return this;
        }

        /// <summary>
        /// Returns true if the box contains the given point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(V3d p)
        {
            return
                p.X >= Min.X && p.X <= Max.X && 
                p.Y >= Min.Y && p.Y <= Max.Y && 
                p.Z >= Min.Z && p.Z <= Max.Z;
        }

        /// <summary>
        /// Returns true if the box completely contains the other box.
        /// A box contains itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Box3d b)
        {
            return
                b.Min.X >= Min.X && b.Max.X <= Max.X && 
                b.Min.Y >= Min.Y && b.Max.Y <= Max.Y && 
                b.Min.Z >= Min.Z && b.Max.Z <= Max.Z;
        }

        /// <summary>
        /// Checks if the box is still valid and repairs if not.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d Repair()
        {
            if (Equals(Box3d.Invalid)) return this;
            if (Min.X > Max.X) Fun.Swap(ref Min.X, ref Max.X);
            if (Min.Y > Max.Y) Fun.Swap(ref Min.Y, ref Max.Y);
            if (Min.Z > Max.Z) Fun.Swap(ref Min.Z, ref Max.Z);
            return this;
        }

        /// <summary>
        /// Returns true if two boxes intersect each other (or one contains the other).
        /// Boxes DO NOT intersect if only touching from the outside.
        /// A box intersects itself.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box3d box)
        {
            if (Min.X >= box.Max.X) return false;
            if (Max.X <= box.Min.X) return false;
            if (Min.Y >= box.Max.Y) return false;
            if (Max.Y <= box.Min.Y) return false;
            if (Min.Z >= box.Max.Z) return false;
            if (Max.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box3d box, V3d eps)
        {
            if (Min.X - eps.X >= box.Max.X) return false;
            if (Max.X + eps.X <= box.Min.X) return false;
            if (Min.Y - eps.Y >= box.Max.Y) return false;
            if (Max.Y + eps.Y <= box.Min.Y) return false;
            if (Min.Z - eps.Z >= box.Max.Z) return false;
            if (Max.Z + eps.Z <= box.Min.Z) return false;
            return true;
        }

        /// <summary>
        /// Returns true if 2 boxes intersect each other with tolerance parameter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Box3d box, double eps)
        {
            if (Min.X - eps >= box.Max.X) return false;
            if (Max.X + eps <= box.Min.X) return false;
            if (Min.Y - eps >= box.Max.Y) return false;
            if (Max.Y + eps <= box.Min.Y) return false;
            if (Min.Z - eps >= box.Max.Z) return false;
            if (Max.Z + eps <= box.Min.Z) return false;
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d Invalidate()
        {
            Min = V3d.MaxValue;
            Max = V3d.MinValue;
            return this;
        }

        /// <summary>
        /// Returns where a points coordinates are outside a given box
        /// </summary>
        /// <returns>All outside Flags</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(V3d p0)
        {
            Box.Flags bf = Box.Flags.None;
            if (p0.X < Min.X) bf |= Box.Flags.MinX;
            else if (p0.X > Max.X) bf |= Box.Flags.MaxX;
            if (p0.Y < Min.Y) bf |= Box.Flags.MinY;
            else if (p0.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (p0.Z < Min.Z) bf |= Box.Flags.MinZ;
            else if (p0.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Returns where the planes of the supplied box b are outside
        /// of the box.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box.Flags OutsideFlags(Box3d b)
        {
            Box.Flags bf = Box.Flags.None;
            if (b.Min.X < Min.X) bf |= Box.Flags.MinX;
            if (b.Max.X > Max.X) bf |= Box.Flags.MaxX;
            if (b.Min.Y < Min.Y) bf |= Box.Flags.MinY;
            if (b.Max.Y > Max.Y) bf |= Box.Flags.MaxY;
            if (b.Min.Z < Min.Z) bf |= Box.Flags.MinZ;
            if (b.Max.Z > Max.Z) bf |= Box.Flags.MaxZ;
            return bf;
        }

        /// <summary>
        /// Gets the minimal and maximal points of the box when seen from the
        /// supplied direction vector v.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void GetMinMaxInDirection(V3d v, out V3d vMin, out V3d vMax)
        {
            vMin = V3d.MinValue;
            vMax = V3d.MaxValue;
            if (v.X >= 0)
            {
                vMin.X = Min.X;
                vMax.X = Max.X;
            }
            else
            {
                vMin.X = Max.X;
                vMax.X = Min.X;
            }
            if (v.Y >= 0)
            {
                vMin.Y = Min.Y;
                vMax.Y = Max.Y;
            }
            else
            {
                vMin.Y = Max.Y;
                vMax.Y = Min.Y;
            }
            if (v.Z >= 0)
            {
                vMin.Z = Min.Z;
                vMax.Z = Max.Z;
            }
            else
            {
                vMin.Z = Max.Z;
                vMax.Z = Min.Z;
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Checks if 2 boxes are equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Box3d a, Box3d b)
        {
            return (a.Min == b.Min) && (a.Max == b.Max);
        }

        /// <summary>
        /// Checks if 2 boxes are not equal.
        /// </summary>
        /// <returns>Result of comparison.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Box3d a, Box3d b)
        {
            return (a.Min != b.Min) || (a.Max != b.Max);
        }

        /// <summary>
        /// Returns a box shifted by the supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d operator +(Box3d box, V3d v)
        {
            return new Box3d((box.Min + v), (box.Max + v));
        }

        /// <summary>
        /// Returns a box shifted by the negative supplied value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d operator -(Box3d box, V3d v)
        {
            return new Box3d((box.Min - v), (box.Max - v));
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Min, Max);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Box3d other)
            => Min.Equals(other.Min) && Max.Equals(other.Max);

        public override bool Equals(object obj) =>
            (obj is Box3d o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        #endregion

        #region Static Methods

        /// <summary>
        /// Element setter action.
        /// </summary>
        public static readonly ActionRefValVal<Box3d, int, V3d> Setter =
            (ref Box3d box, int i, V3d value) =>
            {
                switch (i)
                {
                    case 0: box.Min = value; return;
                    case 1: box.Max = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            };

        #endregion

        #region Parsing

        public static Box3d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Box3d(V3d.Parse(x[0].ToString()),
                                V3d.Parse(x[1].ToString()));
        }

        public static Box3d Parse(Text t)
        {
            return t.NestedBracketSplit(1, V3d.Parse, Box3d.Setter);
        }

        #endregion

        #region IFormattable Members

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a Box2 in the form "(beginB)(beginV)min.x(betweenV)min.y(endV)(betweenB)(beginV)max.x(betweenV)max.y(endV)(endB)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginB, string betweenB, string endB, string beginV, string betweenV, string endV)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginB + Min.ToString(format, fp, beginV, betweenV, endV) + betweenB
                          + Max.ToString(format, fp, beginV, betweenV, endV) + endB;
        }

        #endregion

        #region Static Factories

        /// <summary>
        /// Returns new box [0, size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d FromSize(V3d size)
        {
            return new Box3d(V3d.Zero, size);
        }

        /// <summary>
        /// Returns new box [min, min + size].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d FromMinAndSize(V3d min, V3d size)
        {
            return new Box3d(min, min + size);
        }

        /// <summary>
        /// Returns new box [center - size / 2, center + size / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d FromCenterAndSize(V3d center, V3d size)
        {
            return new Box3d(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Returns new box [0, iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d FromSize(ISize3d iSize)
        {
            return new Box3d(
                V3d.Zero, iSize.Size3d);
        }

        /// <summary>
        /// Returns new box [min, min + iSize].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d FromMinAndSize(V3d min, ISize3d iSize)
        {
            return new Box3d(
                min, min + iSize.Size3d);
        }

        /// <summary>
        /// Returns new box [center - iSize / 2, center + iSize / 2].
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d FromCenterAndSize(V3d center, ISize3d iSize)
        {
            var size = iSize.Size3d;
            return new Box3d(center - size / 2, center + size / 2);
        }

        /// <summary>
        /// Creates box from 2 points which need not be Min and Max.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d FromPoints(V3d p0, V3d p1)
        {
            return new Box3d(Fun.Min(p0, p1), Fun.Max(p0, p1));
        }

        #endregion

        #region Transforms

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d Translated(V3d shift)
        {
            return IsInvalid ? Box3d.Invalid
                             : new Box3d(Min + shift, Max + shift);
        }

        /// <summary>
        /// Returns a scaled box. WARNING: scaling is performed around the origin!
        /// A negative scale factor will resut in an invalid box!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d Scaled(V3d factor)
        {
            return IsInvalid ? Box3d.Invalid
                             : new Box3d(Min * factor, Max * factor);
        }

        /// <summary>
        /// Transforms the box by the given transformation matrix.
        /// NOTE: Performs IsValid check at 10% CPU time overhead.
        ///       -> Empty bounds (crossed min and max) will remain empty.
        /// </summary>
        public Box3d Transformed(M44d trafo)
        {
            if (Min.X > Max.X || Min.Y > Max.Y || Min.Z > Max.Z) return Box3d.Invalid; 
            var t = new V3d(trafo.M03, trafo.M13, trafo.M23);
            var res = new Box3d(t, t);
            double av, bv;
            av = trafo.M00 * Min.X;
            bv = trafo.M00 * Max.X;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M01 * Min.Y;
            bv = trafo.M01 * Max.Y;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M02 * Min.Z;
            bv = trafo.M02 * Max.Z;
            if (av < bv) { res.Min.X += av; res.Max.X += bv; }
            else { res.Min.X += bv; res.Max.X += av; }
            av = trafo.M10 * Min.X;
            bv = trafo.M10 * Max.X;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M11 * Min.Y;
            bv = trafo.M11 * Max.Y;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M12 * Min.Z;
            bv = trafo.M12 * Max.Z;
            if (av < bv) { res.Min.Y += av; res.Max.Y += bv; }
            else { res.Min.Y += bv; res.Max.Y += av; }
            av = trafo.M20 * Min.X;
            bv = trafo.M20 * Max.X;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M21 * Min.Y;
            bv = trafo.M21 * Max.Y;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            av = trafo.M22 * Min.Z;
            bv = trafo.M22 * Max.Z;
            if (av < bv) { res.Min.Z += av; res.Max.Z += bv; }
            else { res.Min.Z += bv; res.Max.Z += av; }
            return res;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Box3d Transformed(Trafo3d trafo)
        {
            return Transformed(trafo.Forward);
        }

        #endregion

        #region Corners

        /// <summary>
        /// Return the corner of the box with the given index. The corner
        /// index is constructed in such a way, that bit 0 enumerates the
        /// x coordinate (0 ... min, 1 ... max), bit 1 enumerates the y
        /// coordinate, and bit 2 enumerates the z coordinate.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3d Corner(int index)
        {
            return
                new V3d(
                        (index & 1) == 0 ? Min.X : Max.X, 
                        (index & 2) == 0 ? Min.Y : Max.Y, 
                        (index & 4) == 0 ? Min.Z : Max.Z);
        }

        /// <summary>
        /// Computes the corners of the box and returns them in an array.
        /// The order of the corners is determined by their index which is
        /// constructed as in the method <see cref="Corner"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public V3d[] ComputeCorners()
        {
            return new V3d[] {
                Min,
                new V3d(Max.X, Min.Y, Min.Z),
                new V3d(Min.X, Max.Y, Min.Z),
                new V3d(Max.X, Max.Y, Min.Z),
                new V3d(Min.X, Min.Y, Max.Z),
                new V3d(Max.X, Min.Y, Max.Z),
                new V3d(Min.X, Max.Y, Max.Z),
                Max
            };
        }


        /// <summary>
        /// Enumeration of the corners of the box.
        /// </summary>
        public IEnumerable<V3d> Corners
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return Min;
                yield return new V3d(Max.X, Min.Y, Min.Z);
                yield return new V3d(Min.X, Max.Y, Min.Z);
                yield return new V3d(Max.X, Max.Y, Min.Z);
                yield return new V3d(Min.X, Min.Y, Max.Z);
                yield return new V3d(Max.X, Min.Y, Max.Z);
                yield return new V3d(Min.X, Max.Y, Max.Z);
                yield return Max;
            }
        }

        #endregion

        #region Swizzle methods

        // TODO: Implement for other dimensions
        public Range1d X { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1d(Min.X, Max.X); } }
        public Range1d Y { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1d(Min.Y, Max.Y); } }
        public Range1d Z { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Range1d(Min.Z, Max.Z); } }
        public Box2d XY { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2d(Min.XY, Max.XY); } }
        public Box2d XZ { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2d(Min.XZ, Max.XZ); } }
        public Box2d YX { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2d(Min.YX, Max.YX); } }
        public Box2d YZ { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2d(Min.YZ, Max.YZ); } }
        public Box2d ZX { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2d(Min.ZX, Max.ZX); } }
        public Box2d ZY { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { return new Box2d(Min.ZY, Max.ZY); } }

        #endregion

        #region Enumerators

        #endregion

        #region IBoundingBox3d Members

        public Box3d BoundingBox3d
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return this; }
        }

        #endregion

        #region ISize3d Members

        public V3d Size3d
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Size; }
        }

        #endregion
    }

    public static partial class Box
    {
        #region Set operations

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d Union(this Box3d a, Box3d b)
        {
            return new Box3d(Fun.Min(a.Min, b.Min), Fun.Max(a.Max, b.Max));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d Intersection(this Box3d a, Box3d b)
        {
            return new Box3d(Fun.Max(a.Min, b.Min), Fun.Min(a.Max, b.Max));
        }

        #endregion

        #region Bounding box for arrays

        /// <summary>
        /// Returns the bounding box of the elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d GetBoundingBox(this V3d[] pointArray)
        {
            return pointArray.GetBoundingBox(0, pointArray.LongLength);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d GetBoundingBox(this V3d[] pointArray, long count)
        {
            return pointArray.GetBoundingBox(0, count);
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box3d GetBoundingBox(
                this V3d[] pointArray, long start, long count)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointArray[start]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[i]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of count elements of the array starting at start.
        /// </summary>
        public static Box3d GetBoundingBox<T>(this T[] array, long start, long count, Func<T, V3d> pointSelector)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointSelector(array[start]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[i]));
            return box;
        }

        #endregion

        #region Bounding box for lists

        /// <summary>
        /// Returns the bounding box of the elements of the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d GetBoundingBox(this List<V3d> pointList)
        {
            return pointList.GetBoundingBox(pointList.Count);
        }

        /// <summary>
        /// Returns the bounding box of the first count elements of the list.
        /// </summary>
        public static Box3d GetBoundingBox(this List<V3d> pointList, int count)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointList[0]);
            for (int i = 1; i < count; i++)
                box.ExtendBy(pointList[i]);
            return box;
        }

        #endregion

        #region Bounding box for indexed arrays

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d GetBoundingBox(this int[] indexArray, V3d[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d GetBoundingBox(this int[] indexArray, int count, V3d[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.Length, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3d GetBoundingBox(this int[] indexArray, int start, int count, V3d[] pointArray)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointArray[indexArray[start]]);
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3d GetBoundingBox<T>(this int[] indexArray, int start, int count, T[] array, Func<T, V3d> pointSelector)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointSelector(array[indexArray[start]]));
            for (int i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d GetBoundingBox(this long[] indexArray, V3d[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by the first count indices in indexArray.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Box3d GetBoundingBox(this long[] indexArray, long count, V3d[] pointArray)
        {
            return indexArray.GetBoundingBox(0, indexArray.LongLength, pointArray);
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3d GetBoundingBox(this long[] indexArray, long start, long count, V3d[] pointArray)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointArray[indexArray[start]]);
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointArray[indexArray[i]]);
            return box;
        }

        /// <summary>
        /// Returns the bounding box of the elements of pointArray indexed by count indices
        /// in indexArray starting at start.
        /// </summary>
        public static Box3d GetBoundingBox<T>(this long[] indexArray, long start, long count, T[] array, Func<T, V3d> pointSelector)
        {
            if (count <= 0) return Box3d.Invalid;
            var box = new Box3d(pointSelector(array[indexArray[start]]));
            for (long i = start + 1, e = start + count; i < e; i++)
                box.ExtendBy(pointSelector(array[indexArray[i]]));
            return box;
        }

        #endregion

        #region Bounding box for IEnumerable

        /// <summary>
        /// Returns the bounding box of the elements of the collection.
        /// </summary>
        public static Box3d GetBoundingBox(this IEnumerable<V3d> points)
        {
            var box = Box3d.Invalid;
            foreach (var p in points) box.ExtendBy(p);
            return box;
        }

        #endregion

        #region Get octant

        /// <summary>
        /// Octant 0-7.
        /// 0th, 1st and 2nd bit encodes x-, y-, z-axis, respectively.
        /// E.g. 0 is octant [box.Min, box.Center], 7 is octant [box.Center, box.Max].
        /// </summary>
        public static Box3d GetOctant(this Box3d box, int i)
        {
            if (i < 0 || i > 7) throw new IndexOutOfRangeException();

            double x0, x1, y0, y1, z0, z1;
            var c = box.Center;
            if ((i & 1) == 0) { x0 = box.Min.X; x1 = c.X; } else { x0 = c.X; x1 = box.Max.X; }
            if ((i & 2) == 0) { y0 = box.Min.Y; y1 = c.Y; } else { y0 = c.Y; y1 = box.Max.Y; }
            if (i < 4) { z0 = box.Min.Z; z1 = c.Z; } else { z0 = c.Z; z1 = box.Max.Z; }
            return new Box3d(new V3d(x0, y0, z0), new V3d(x1, y1, z1));
        }

        #endregion

        #region Outline corners

        /// <summary>
        /// Gets outline corner indices of a box as seen from given position (in counter-clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static int[] GetOutlineCornerIndicesCCW(this Box3d box, V3d fromPosition)
        {
            if (fromPosition.X < box.Min.X)
            { //-X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X -Y -Z
                        return new[] { 1, 5, 4, 6, 2, 3 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X -Y +Z
                        return new[] { 0, 1, 5, 7, 6, 2 };
                    }
                    else
                    { // -X -Y  Z
                        return new[] { 1, 5, 6, 2 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X +Y -Z
                        return new[] { 0, 4, 6, 7, 3, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X +Y +Z
                        return new[] { 0, 4, 5, 7, 3, 2 };
                    }
                    else
                    { // -X +Y  Z
                        return new[] { 0, 4, 7, 3 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X  Y -Z
                        return new[] { 1, 4, 6, 3 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X  Y +Z
                        return new[] { 0, 5, 7, 2 };
                    }
                    else
                    { // -X  Y  Z
                        return new[] { 0, 4, 6, 2 };
                    }
                }
            }
            else if (fromPosition.X > box.Max.X)
            { // +X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X -Y -Z
                        return new[] { 0, 2, 3, 7, 5, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X -Y +Z
                        return new[] { 0, 1, 3, 7, 6, 4 };
                    }
                    else
                    { // +X -Y  Z
                        return new[] { 0, 3, 7, 4 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X +Y -Z
                        return new[] { 0, 2, 6, 7, 5, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X +Y +Z
                        return new[] { 1, 3, 2, 6, 4, 5 };
                    }
                    else
                    { // +X +Y  Z
                        return new[] { 1, 2, 6, 5 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X  Y -Z
                        return new[] { 0, 2, 7, 5 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X  Y +Z
                        return new[] { 1, 3, 6, 4 };
                    }
                    else
                    { // +X  Y  Z
                        return new[] { 1, 3, 7, 5 };
                    }
                }
            }
            else
            { // X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X -Y -Z
                        return new[] { 2, 3, 5, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X -Y +Z
                        return new[] { 0, 1, 7, 6 };
                    }
                    else
                    { //  X -Y  Z
                        return new[] { 0, 1, 5, 4 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X +Y -Z
                        return new[] { 0, 6, 7, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X +Y +Z
                        return new[] { 2, 4, 5, 3 };
                    }
                    else
                    { //  X +Y  Z
                        return new[] { 2, 6, 7, 3 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X  Y -Z
                        return new[] { 0, 2, 3, 1 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X  Y +Z
                        return new[] { 4, 5, 7, 6 };
                    }
                    else
                    { //  X  Y  Z
                        return null;
                    }
                }
            }
        }

        /// <summary>
        /// Gets outline corner indices of a box as seen from given position (in clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static int[] GetOutlineCornerIndicesCW(this Box3d box, V3d fromPosition)
        {
            if (fromPosition.X < box.Min.X)
            { //-X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X -Y -Z
                        return new[] { 1, 3, 2, 6, 4, 5 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X -Y +Z
                        return new[] { 0, 2, 6, 7, 5, 1 };
                    }
                    else
                    { // -X -Y  Z
                        return new[] { 1, 2, 6, 5 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X +Y -Z
                        return new[] { 0, 1, 3, 7, 6, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X +Y +Z
                        return new[] { 0, 2, 3, 7, 5, 4 };
                    }
                    else
                    { // -X +Y  Z
                        return new[] { 0, 3, 7, 4 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // -X  Y -Z
                        return new[] { 1, 3, 6, 4 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // -X  Y +Z
                        return new[] { 0, 2, 7, 5 };
                    }
                    else
                    { // -X  Y  Z
                        return new[] { 0, 2, 6, 4 };
                    }
                }
            }
            else if (fromPosition.X > box.Max.X)
            { // +X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X -Y -Z
                        return new[] { 0, 4, 5, 7, 3, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X -Y +Z
                        return new[] { 0, 4, 6, 7, 3, 1 };
                    }
                    else
                    { // +X -Y  Z
                        return new[] { 0, 4, 7, 3 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X +Y -Z
                        return new[] { 0, 1, 5, 7, 6, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X +Y +Z
                        return new[] { 1, 5, 4, 6, 2, 3 };
                    }
                    else
                    { // +X +Y  Z
                        return new[] { 1, 5, 6, 2 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { // +X  Y -Z
                        return new[] { 0, 5, 7, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { // +X  Y +Z
                        return new[] { 1, 4, 6, 3 };
                    }
                    else
                    { // +X  Y  Z
                        return new[] { 1, 5, 7, 3 };
                    }
                }
            }
            else
            { // X
                if (fromPosition.Y < box.Min.Y)
                { //-Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X -Y -Z
                        return new[] { 2, 4, 5, 3 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X -Y +Z
                        return new[] { 0, 6, 7, 1 };
                    }
                    else
                    { //  X -Y  Z
                        return new[] { 0, 4, 5, 1 };
                    }
                }
                else if (fromPosition.Y > box.Max.Y)
                { // +Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X +Y -Z
                        return new[] { 0, 1, 7, 6 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X +Y +Z
                        return new[] { 2, 3, 5, 4 };
                    }
                    else
                    { //  X +Y  Z
                        return new[] { 2, 3, 7, 6 };
                    }
                }
                else
                { // Y
                    if (fromPosition.Z < box.Min.Z)
                    { //  X  Y -Z
                        return new[] { 0, 1, 3, 2 };
                    }
                    else if (fromPosition.Z > box.Max.Z)
                    { //  X  Y +Z
                        return new[] { 4, 6, 7, 5 };
                    }
                    else
                    { //  X  Y  Z
                        return null;
                    }
                }
            }
        }

        /// <summary>
        /// Gets outline corners of a box as seen from given position (in counter-clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static V3d[] GetOutlineCornersCCW(this Box3d box, V3d fromPosition)
        {
            var cs = box.ComputeCorners();
            return GetOutlineCornerIndicesCCW(box, fromPosition)?.Map(i => cs[i]);
        }

        /// <summary>
        /// Gets outline corners of a box as seen from given position (in clockwise order).
        /// Returns null if position is inside the box.
        /// </summary>
        public static V3d[] GetOutlineCornersCW(this Box3d box, V3d fromPosition)
        {
            var cs = box.ComputeCorners();
            return GetOutlineCornerIndicesCW(box, fromPosition)?.Map(i => cs[i]);
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box3d a, Box3d b)
        {
            return ApproximateEquals(a, b, Constant<double>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Box3d a, Box3d b, double tolerance)
            => ApproximateEquals(a.Min, b.Min, tolerance) && ApproximateEquals(a.Max, b.Max, tolerance);

        #endregion
    }

    #endregion

    #region Box3dAndFlags

    [DataContract]
    public struct Box3dAndFlags
    {
        [DataMember]
        public Box.Flags BFlags;
        [DataMember]
        public Box3d BBox;

        public Box3dAndFlags(Box3d union, Box3d box0, Box3d box1)
        {
            BFlags = 0;
            BBox = union;
            if (box0.Min.X > union.Min.X) { BBox.Min.X = box0.Min.X; BFlags |= Box.Flags.MinX0; }
            if (box0.Min.Y > union.Min.Y) { BBox.Min.Y = box0.Min.Y; BFlags |= Box.Flags.MinY0; }
            if (box0.Min.Z > union.Min.Z) { BBox.Min.Z = box0.Min.Z; BFlags |= Box.Flags.MinZ0; }
            if (box0.Max.X < union.Max.X) { BBox.Max.X = box0.Max.X; BFlags |= Box.Flags.MaxX0; }
            if (box0.Max.Y < union.Max.Y) { BBox.Max.Y = box0.Max.Y; BFlags |= Box.Flags.MaxY0; }
            if (box0.Max.Z < union.Max.Z) { BBox.Max.Z = box0.Max.Z; BFlags |= Box.Flags.MaxZ0; }
            if (box1.Min.X > union.Min.X) { BBox.Min.X = box1.Min.X; BFlags |= Box.Flags.MinX1; }
            if (box1.Min.Y > union.Min.Y) { BBox.Min.Y = box1.Min.Y; BFlags |= Box.Flags.MinY1; }
            if (box1.Min.Z > union.Min.Z) { BBox.Min.Z = box1.Min.Z; BFlags |= Box.Flags.MinZ1; }
            if (box1.Max.X < union.Max.X) { BBox.Max.X = box1.Max.X; BFlags |= Box.Flags.MaxX1; }
            if (box1.Max.Y < union.Max.Y) { BBox.Max.Y = box1.Max.Y; BFlags |= Box.Flags.MaxY1; }
            if (box1.Max.Z < union.Max.Z) { BBox.Max.Z = box1.Max.Z; BFlags |= Box.Flags.MaxZ1; }
        }
    }

    #endregion

}
