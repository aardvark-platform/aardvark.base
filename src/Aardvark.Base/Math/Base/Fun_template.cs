using System;
using System.Collections.Generic;
using System.Diagnostics.Contracts;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    //# Action comma = () => Out(", ");
    //# Action add = () => Out(" + ");
    //# var signedtypes = Meta.SignedTypes;
    //# var unsignedtypes = Meta.UnsignedTypes;
    //# var numtypes = Meta.StandardNumericTypes;
    //# var numdectypes = Meta.BuiltInNumericTypes;
    //# var modtypes = new [] { Meta.IntType, Meta.LongType, Meta.UIntType, Meta.ULongType };
    //# var smalltypes = new [] { Meta.SByteType, Meta.ShortType, Meta.ByteType, Meta.UShortType };
    //# var iltypes = new[] { Meta.IntType, Meta.LongType };
    //# var fdtypes = new[] { Meta.FloatType, Meta.DoubleType };
    //# var ilfdtypes = Meta.VecFieldTypes;
    public static partial class Fun
    {
        #region Min and Max

        //# Meta.ComparableTypes.ForEach(t => { var type = t.Name;
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ Min(this __type__ a, __type__ b)
            => a < b ? a : b;

        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ Max(this __type__ a, __type__ b)
            => a > b ? a : b;

        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ Min(this __type__ a, __type__ b, __type__ c)
            => a < b ? (a < c ? a : c) : (b < c ? b : c);

        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ Max(this __type__ a, __type__ b, __type__ c)
            => a > b ? (a > c ? a : c) : (b > c ? b : c);

        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ Min(this __type__ a, __type__ b, __type__ c, __type__ d)
            => Min(Min(a, b), Min(c, d));

        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ Max(this __type__ a, __type__ b, __type__ c, __type__ d)
            => Max(Max(a, b), Max(c, d));

        //# });
        #endregion

        #region Abs

        //# signedtypes.ForEach(t => {
        /// <summary>
        /// Returns the absolute value of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Abs(this __t.Name__ x) => Math.Abs(x);

        //# });
        #endregion

        #region ApproximateEquals

        //# signedtypes.ForEach(t => {
        /// <summary>
        /// Returns whether the distance between x and y is not more than epsilon.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this __t.Name__ x, __t.Name__ y, __t.Name__ epsilon)
            => Abs(x - y) <= epsilon;

        //# });
        //# fdtypes.ForEach(t => {
        /// <summary>
        /// Returns whether the distance between x and y is not more than
        /// Constant{__t.Name__}.PositiveTinyValue.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this __t.Name__ x, __t.Name__ y)
            => ApproximateEquals(x, y, Constant<__t.Name__>.PositiveTinyValue);

        //# });
        #endregion

        #region Floor

        //# fdtypes.ForEach(t => {
        /// <summary>
        /// Returns the largest integer less than or equal to the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Floor(this __t.Name__ x)
            => /*# if (t != Meta.DoubleType) { */(__t.Name__)/*# } */Math.Floor(x);

        //# });
        #endregion

        #region Ceiling

        //# fdtypes.ForEach(t => {
        /// <summary>
        /// Returns the smallest integer greater than or equal to the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Ceiling(this __t.Name__ x)
            => /*# if (t != Meta.DoubleType) { */(__t.Name__)/*# } */System.Math.Ceiling(x);

        //# });
        #endregion

        #region Round

        //# fdtypes.ForEach(t => {
        /// <summary>
        /// Rounds a floating-point value to the nearest integral value.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Round(this __t.Name__ x)
            => /*# if (t != Meta.DoubleType) { */(__t.Name__)/*# } */System.Math.Round(x);

        //# });
        #endregion

        #region Truncate

        //# fdtypes.ForEach(t => {
        /// <summary>
        /// Rounds a floating-point value to the nearest integar towards zero.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Truncate(this __t.Name__ x)
            => /*# if (t != Meta.DoubleType) { */(__t.Name__)/*# } */Math.Truncate(x);

        //# });
        #endregion

        #region Frac

        //# fdtypes.ForEach(t => {
        /// <summary>
        /// Returns fractional part of t. Calculated as t - floor(t).
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Frac(this __t.Name__ t) => t - Floor(t);

        //# });
        #endregion

        #region Clamp

        //# numdectypes.ForEach(t => {
        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Clamp(this __t.Name__ x, __t.Name__ a, __t.Name__ b)
        {
            if (x < a) return a;
            if (x > b) return b;
            return x;
        }

        //# });
        //# ilfdtypes.ForEach(t => {
        /// <summary>
        /// Clamps value to interval [a,b].
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Clamp(this __t.Name__ x, Range1__t.Char__ range)
        {
            if (x < range.Min) return range.Min;
            if (x > range.Max) return range.Max;
            return x;
        }

        //# });
        #endregion

        #region ClampExcl

        //# numdectypes.Where(t => !t.IsReal).ForEach(t => {
        /// <summary>
        /// Clamps value to interval [a,b[.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ ClampExcl(this __t.Name__ x, __t.Name__ a, __t.Name__ b)
        {
            if (x < a) return a;
            if (x >= b) return (__t.Name__)(b - 1);
            return x;
        }

        //# });
        //# ilfdtypes.Where(t => !t.IsReal).ForEach(t => {
        /// <summary>
        /// Clamps value to interval [a,b[.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ ClampExcl(this __t.Name__ x, Range1__t.Char__ range)
        {
            if (x < range.Min) return range.Min;
            if (x >= range.Max) return (__t.Name__)(range.Max - 1);
            return x;
        }

        //# });
        #endregion

        #region ClampWrap

        //# numdectypes.Where(t => t.Name != "ulong").ForEach(t => { //ulong cannot be wrapped in a larger integer variable for subtraction
        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ ClampWrap(this __t.Name__ x, __t.Name__ a, __t.Name__ b)
            => (__t.Name__)(ModP(x - a, b - a) + a);

        //# });
        //# ilfdtypes.Where(t => t.Name != "ulong").ForEach(t => { //ulong cannot be wrapped in a larger integer variable for subtraction
        /// <summary>
        /// Clamps value to interval [a,b[ and cyclically wraps around values outside this interval.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ ClampWrap(this __t.Name__ x, Range1__t.Char__ range)
            => (__t.Name__)(ModP(x - range.Min, range.Max - range.Min) + range.Min);

        //# });
        #endregion

        #region Saturate
        //# numdectypes.ForEach(t => {
        //# var cast = smalltypes.Contains(t) ? "(" + t.Name + ")" : "";
        /// <summary>
        /// Clamps value to interval [0,1].
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Saturate(this __t.Name__ x)
            => Clamp(x, __cast__0, __cast__1);

        //# });
        #endregion

        #region MapToUnitInterval

        //# fdtypes.ForEach(t => {
        //# var half = (t != Meta.DoubleType) ? "0.5f" : "0.5";
        /// <summary>
        /// Maps value from interval [0, tMax] to interval [0, 1].
        /// Values outside [0, tMax] are clamped - if t is greater than tMax
        /// then 1 is returned, if t is less than 0 then 0 is returned.
        /// If 'repeat' is true, then every interval [i * tMax, (i+1) * tMax]
        /// (for i from integers) is mapped to [0, 1].
        /// If 'mirror' is true, then every second interval is flipped, such
        /// that [0, tMax) [tMax, 2*tMax) [2*tMax, 3*tMax] ... is mapped to
        /// [0,1)[1,0)[0,1)...
        /// </summary>
        [Pure]
        public static __t.Name__ MapToUnitInterval(
            this __t.Name__ t, __t.Name__ tMax,
            bool repeat, bool mirror
            )
        {
            t = t / tMax;
            if (!repeat)
            {
                if (t >= 1) return 1;
                if (t <= 0) return 0;
            }
            if (mirror)
            {
                t = t - Floor(t * __half__) * 2;
                return t < 1 ? t : 2 - t;
            }
            else
            {
                return t - Floor(t);
            }
        }

        /// <summary>
        /// Maps value from interval [0, tMax] to interval [0, 1].
        /// If 'repeat' is true, then every interval [i * tMax, (i+1) * tMax]
        /// (for i from integers) is mapped to [0, 1].
        /// </summary>
        [Pure]
        public static __t.Name__ MapToUnitInterval(this __t.Name__ t, __t.Name__ tMax, bool repeat)
        {
            t = t / tMax;
            if (!repeat)
            {
                if (t >= 1) return 1;
                if (t <= 0) return 0;
            }
            return t - Floor(t);
        }

        /// <summary>
        /// Maps value from interval [0, tMax] to interval [0, 1].
        /// </summary>
        [Pure]
        public static __t.Name__ MapToUnitInterval(this __t.Name__ t, __t.Name__ tMax)
        {
            t = t / tMax;
            if (t > 1) return 1;
            if (t < 0) return 0;
            return t;
        }

        /// <summary>
        /// Maps value from interval [tMin, tMax] to interval [0, 1].
        /// </summary>
        [Pure]
        public static __t.Name__ MapToUnitInterval(this __t.Name__ t, __t.Name__ tMin, __t.Name__ tMax)
        {
            t = (t - tMin) / (tMax - tMin);
            if (t > 1) return 1;
            if (t < 0) return 0;
            return t;
        }

        //# });

        #endregion

        #region Sign

        //# signedtypes.ForEach(t => {
        /// <summary>
        /// Returns either -1, 0, or +1, indicating the sign of the specified value.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Sign(this __t.Name__ x)
            => Math.Sign(x);

        /// <summary>
        /// Returns either -1, 0, or +1, indicating the sign of the specified value.
        /// </summary>
        // Same as Fun.Sign(), we need this for the F# generic math library!
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Signumi(this __t.Name__ x)
            => Sign(x);

        /// <summary>
        /// Returns either -1, 0, or +1, indicating the sign of the specified value.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Signum(this __t.Name__ x)
            => (__t.Name__) Math.Sign(x);

        //# });
        #endregion

        #region Comparisons

        //# fdtypes.ForEach(t => {
        /// <summary>
        /// Returns true if the absolulte value of the supplied float is
        /// smaller than 4 times the machine epsilon.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this __t.Name__ x)
            => x.Abs() < Constant<__t.Name__>.PositiveTinyValue;

        /// <summary>
        /// Returns true if the absolulte value of the supplied float <paramref name="x"/> is
        /// smaller than the supplied <paramref name="epsilon"/> .
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this __t.Name__ x, __t.Name__ epsilon)
            => x.Abs() < epsilon;

        //# });
        #endregion

        #region AbsSum

        //# signedtypes.ForEach(t => { var st = Meta.SummationTypeOf(t);
        /// <summary>
        /// Returns the sum of the absolute values of the given numbers.
        /// </summary>
        [Pure]
        public static __st.Name__ AbsSum(this IEnumerable<__t.Name__> array)
        {
            __st.Name__ sum = 0;
            foreach (var i in array) sum += i.Abs();
            return sum;
        }

        //# });
        #endregion

        #region Roots

        //# numdectypes.ForEach(t => {
        //# var cast = (t == Meta.DecimalType) ? "(double)" : "";
        //# var rtype = (t != Meta.FloatType) ? Meta.DoubleType : Meta.FloatType;
        //# var rcast = (rtype != Meta.DoubleType) ? "(" + rtype.Name + ")" : "";
        /// <summary>
        /// Returns the square root of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __rtype.Name__ Sqrt(this __t.Name__ x) =>
            __rcast__Math.Sqrt(__cast__x);

        //# });
        //# signedtypes.ForEach(t => {
        //# var cast = (t == Meta.DecimalType) ? "(double)" : "";
        //# var rtype = (t != Meta.FloatType) ? Meta.DoubleType : Meta.FloatType;
        //# var rcast = (rtype != Meta.DoubleType) ? "(" + rtype.Name + ")" : "";
        /// <summary>
        /// Returns the cubic root of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __rtype.Name__ Cbrt(this __t.Name__ x)
            => x < 0 ? __rcast__-Math.Pow(-(__cast__x), Constant.OneThird)
                         : __rcast__Math.Pow(__cast__x, Constant.OneThird);

        //# });
        //# unsignedtypes.ForEach(t => {
        /// <summary>
        /// Returns the cubic root of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Cbrt(this __t.Name__ x)
            => Math.Pow(x, Constant.OneThird);

        //# });
        #endregion

        #region Square and Power

        //# numdectypes.ForEach(t => {
        /// <summary>
        /// Returns the square of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Square(this __t.Name__ x)
            => (__t.Name__)(x * x);

        //# if (fdtypes.Contains(t)) { 
        //# var rcast = (t != Meta.DoubleType) ? "(" + t.Name + ")" : "";
        /// <summary>
        /// Returns the square of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Pow(this __t.Name__ x, __t.Name__ y)
            => __rcast__Math.Pow(x, y);

        //# } else {
        //# fdtypes.ForEach(rt => {
        //# var rcast = (rt != Meta.DoubleType) ? "(" + rt.Name + ")" : "";
        //# var cast = (t == Meta.DecimalType) ? "(double)" : "";
        /// <summary>
        /// Returns the square of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __rt.Name__ Pow(this __t.Name__ x, __rt.Name__ y)
            => __rcast__Math.Pow(__cast__x, y);

        //# });
        //# }
        //# });
        #endregion

        #region Exp and Log

        //# numdectypes.ForEach(t => {
        //# var cast = (t == Meta.DecimalType) ? "(double)" : "";
        //# var rtype = (t != Meta.FloatType) ? Meta.DoubleType : Meta.FloatType;
        //# var rcast = (rtype != Meta.DoubleType) ? "(" + rtype.Name + ")" : "";
        /// <summary>
        /// Returns the square root of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __rtype.Name__ Exp(this __t.Name__ x) =>
            __rcast__Math.Exp(__cast__x);

        /// <summary>
        /// Returns the natural (base e) logarithm of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __rtype.Name__ Log(this __t.Name__ x) =>
            __rcast__Math.Log(__cast__x);

        /// <summary>
        /// Returns the base 10 logarithm of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __rtype.Name__ Log10(this __t.Name__ x) =>
            __rcast__Math.Log10(__cast__x);

        /// <summary>
        /// Returns the base 2 logarithm of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __rtype.Name__ Log2(this __t.Name__ x) =>
            x.Log() * __rcast__Constant.Ln2Inv;

        /// <summary>
        /// Returns the values logarithm of the specified basis.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __rtype.Name__ Log(this __t.Name__ x, __rtype.Name__ basis) =>
            x.Log() / basis.Log();

        //# });
        #endregion

        #region LinCom

        //# foreach (var it in Meta.IntegerTypes) { var itn = it.Name;
        //# for (int tpc = 4; tpc < 7; tpc+=2) {
        //# foreach (var rt in Meta.RealTypes) { var rtn = rt.Name; var rtc = rt.Caps[0];
        public static __itn__ LinCom(
                /*# tpc.ForEach(i => { */__itn__ p__i__/*# }, comma); */, ref Tup__tpc__<__rtn__> w)
        {
            return (__itn__)Fun.Clamp(/*# tpc.ForEach(i => { */p__i__ * w.E__i__/*# }, add); */, (__rtn__)__itn__.MinValue, (__rtn__)__itn__.MaxValue);
        }

        public static __rtn__ LinComRaw__rtc__(
                /*# tpc.ForEach(i => { */__itn__ p__i__/*# }, comma); */, ref Tup__tpc__<__rtn__> w)
        {
            return /*# tpc.ForEach(i => { */p__i__ * w.E__i__/*# }, add); */;
        }

        //# } // rt
        //# } // tpc
        //# } // it
        //# for (int tpc = 2; tpc < 8; tpc++ ) {
        //# foreach (var rt in Meta.RealTypes) { var rtn = rt.Name;
        public static __rtn__ LinCom(/*# tpc.ForEach(i => { */__rtn__ p__i__/*# }, comma); */, ref Tup__tpc__<__rtn__> w)
        {
            return /*# tpc.ForEach(i => { */p__i__ * w.E__i__/*# }, add); */;
        }

        //# } // rt
        //# } // tpc       
        #endregion

        #region ModP

        //# signedtypes.ForEach(t => {
        /// <summary>
        /// Returns the positive modulo operation a mod b giving values between [0,b[ 
        /// instead of a % b giving values between ]-b,b[.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ ModP(this __t.Name__ a, __t.Name__ b)
        {
            var m = a % b;
            if (m < 0)
                m += b;
            return (__t.Name__)m;
        }

        //# });
        #endregion

        #region PowerOfTwo

        //# iltypes.ForEach(t => {
        /// <summary>
        /// Returns true if the supplied number is 0
        /// or a power of two.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPowerOfTwo(this __t.Name__ x) => (x & (x - 1)) == 0;

        //# });
        /// <summary>
        /// Returns 2 raised to the power of the value.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long PowerOfTwo(this long x) => 1L << (int)x;

        //# fdtypes.ForEach(t => {
        /// <summary>
        /// Returns 2 raised to the power of the value.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ PowerOfTwo(this __t.Name__ x)
            => /*# if (t != Meta.DoubleType) { */(__t.Name__)/*# } */System.Math.Pow(2, x);

        //# });
        //# iltypes.ForEach(t => {
        /// <summary>
        /// Returns the nearest superior power of two of the value.
        /// E.g. x = 401 -> 512.
        /// E.g. x = 256 -> 256.
        /// </summary>
        [Pure]
        public static __t.Name__ NextPowerOfTwo(this __t.Name__ x)
        {
            --x;
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            x |= x >> 16;
            //# if (t == Meta.LongType) {
            x |= x >> 32;
            //# }
            return ++x;
        }

        /// <summary>
        /// Returns the nearest inferior power of two of the value.
        /// E.g. x = 401 -> 256.
        /// E.g. x = 512 -> 512.
        /// </summary>
        [Pure]
        public static __t.Name__ PrevPowerOfTwo(this __t.Name__ x)
        {
            if (x <= 0) return 0;
            x >>= 1;
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            x |= x >> 16;
            //# if (t == Meta.LongType) {
            x |= x >> 32;
            //# }
            return ++x;
        }

        //# });
        #endregion

        #region Trigonometry

        //# fdtypes.ForEach(t => { var cast = t != Meta.DoubleType ? "(" + t.Name + ")" : "";
        /// <summary>
        /// Returns the cosine of the specified angle in radians.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Sin(this __t.Name__ x) => __cast__System.Math.Sin(x);

        /// <summary>
        /// Returns the cosine of the specified angle in radians.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Cos(this __t.Name__ x) => __cast__System.Math.Cos(x);

        /// <summary>
        /// Returns the tangent of the specified angle in radians.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Tan(this __t.Name__ x) => __cast__System.Math.Tan(x);

        /// <summary>
        /// Returns the angle in radians whose sine is the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Asin(this __t.Name__ x) => __cast__System.Math.Asin(x);

        /// <summary>
        /// Returns the angle in radians whose sine is the specified number while clamping the input to [-1, 1] in order to avoid numerical problems.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ AsinClamped(this __t.Name__ x) => __cast__System.Math.Asin(Clamp(x, -1, 1));

        /// <summary>
        /// Returns the angle in radians whose cosine is the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Acos(this __t.Name__ x) => __cast__System.Math.Acos(x);

        /// <summary>
        /// Returns the angle in radians whose cosine is the specified number while clamping the input to [-1, 1] in order to avoid numerical problems.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ AcosClamped(this __t.Name__ x) => __cast__System.Math.Acos(Clamp(x, -1, 1));

        /// <summary>
        /// Returns the angle in radians whose tangent is the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Atan(this __t.Name__ x) => __cast__System.Math.Atan(x);

        /// <summary>
        /// Returns the angle in radians whose tangent is
        /// the quotient of the two specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Atan2(__t.Name__ y, __t.Name__ x) => __cast__System.Math.Atan2(y, x);

        /// <summary>
        /// Returns the angle in radians whose tangent is
        /// the quotient of the two specified number using
        /// a faster algorithm than Math.Atan2.
        /// NOTE: Accuracy untested
        /// </summary>
        [Pure]
        public static __t.Name__ FastAtan2(__t.Name__ y, __t.Name__ x)
        {
            __t.Name__ angle;
            double piThreeFourths = Constant.Pi * 3 / 4;
            double yAbs = y.Abs() + Constant<double>.PositiveTinyValue; // prevent 0/0 condition
            if (x >= 0)
            {
                double r = (x - yAbs) / (x + yAbs);
                angle = __cast__(Constant.PiQuarter * (1 - r));
            }
            else
            {
                double r = (x + yAbs) / (yAbs - x);
                angle = __cast__(piThreeFourths - Constant.PiQuarter * r);
            }

            return y < 0 ? -angle : angle; // negate if in quad III or IV
        }

        /// <summary>
        /// Returns the hyperbolic sine of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Sinh(this __t.Name__ x) => __cast__System.Math.Sinh(x);

        /// <summary>
        /// Returns the hyperbolic cosine of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Cosh(this __t.Name__ x) => __cast__System.Math.Cosh(x);

        /// <summary>
        /// Returns the hyperbolic tangent of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Tanh(this __t.Name__ x) => __cast__System.Math.Tanh(x);

        /// <summary>
        /// Returns the inverse hyperbolic sine of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Asinh(this __t.Name__ x)
            => __cast__System.Math.Log(x + System.Math.Sqrt(x * x + 1.0));

        /// <summary>
        /// Returns the inverse hyperbolic cosine of the specified number.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Acosh(this __t.Name__ x)
            => __cast__System.Math.Log(x + System.Math.Sqrt(x * x - 1.0));

        /// <summary>
        /// Returns the inverse hyperbolic tangent of the specified number.
        /// Note that the absolute value of the argument must be smaller than 1.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Atanh(this __t.Name__ x)
            => __cast__(0.5 * System.Math.Log((1.0 + x) / (1.0 - x)));

        //# });
        #endregion

        #region Interpolation

        //# numdectypes.ForEach(t => {
        //# if (fdtypes.Contains(t)) {
        /// <summary>
        /// Linearly interpolates between a and b according to t.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Lerp(this __t.Name__ t, __t.Name__ a, __t.Name__ b)
            => a * (1 - t) + b * t;

        /// <summary>
        /// Performs smooth Hermite interpolation between 0 and 1 when edge0 &lt; x &lt; edge1.
        /// </summary>
        [Pure]
        public static __t.Name__ Smoothstep(this __t.Name__ x, __t.Name__ edge0, __t.Name__ edge1)
        {
            var t = Saturate((x - edge0) / (edge1 - edge0));
            return t * t * (3 - 2 * t);
        }

        /// <summary>
        /// Inverse linear interpolation. Computes t of y = a * (1 - t) + b * t.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ InvLerp(this __t.Name__ y, __t.Name__ a, __t.Name__ b)
            => (a - y) / (a - b);

        //# } else {
        //# fdtypes.ForEach(rt => {
        //# var one = (rt != Meta.DoubleType) ? "1.0f" : "1.0";
        //# var cast = (t == Meta.DecimalType) ? "(" + rt.Name + ")" : "";
        /// <summary>
        /// Linearly interpolates between a and b according to t.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ Lerp(this __rt.Name__ t, __t.Name__ a, __t.Name__ b)
            => (__t.Name__)Round(__cast__a * (1 - t) + __cast__b * t);

        //# });
        /// <summary>
        /// Inverse linear interpolation. Computes t of y = a * (1 - t) + b * t.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double InvLerp(this __t.Name__ y, __t.Name__ a, __t.Name__ b)
            => ((double)a - (double)y) / ((double)a - (double)b);

        //# }
        //# });

        #endregion

        #region Mean

        //# numtypes.ForEach(t => { var st = Meta.SummationTypeOf(t);
        /// <summary>
        /// Returns the mean of the given values.
        /// </summary>
        [Pure]
        public static double Mean(this IEnumerable<__t.Name__> array)
        {
            int count = 0;
            __st.Name__ sum = 0;
            foreach (var x in array) { sum += x; ++count; }
            return (double)sum / count;
        }

        //# });
        [Pure]
        public static decimal Mean(this IEnumerable<decimal> array)
        {
            int count = 0; decimal sum = 0;
            foreach (var x in array) { sum += x; ++count; }
            return (decimal)sum / count;
        }

        /// <summary>
        /// Returns the mean of the given values.
        /// </summary>
        [Pure]
        public static double Mean<T>(
            this IEnumerable<T> array,
            Func<T, double> selector
            )
        {
            int count = 0; double sum = 0;
            foreach (var x in array) { sum += selector(x); ++count; }
            return sum / count;
        }

        #endregion

        #region Variance & Standard Deviation

        //# ilfdtypes.ForEach(t => { var type = t.Name;
        /// <summary>
        /// Calculates the variance of given elements.
        /// </summary>
        [Pure]
        public static double Variance(this IEnumerable<__type__> data)
        {
            int count = 0;
            double sum = 0, mean = data.Mean();

            foreach (var x in data)
            {
                sum += (x - mean).Square();
                count++;
            }

            return sum / count;
        }

        /// <summary>
        /// Calculates the standard deviation of given elements.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double StandardDeviation(this IEnumerable<__type__> data) => data.Variance().Sqrt();

        //# });
        /// <summary>
        /// Calculates the variance of given elements.
        /// </summary>
        [Pure]
        public static double Variance<T>(
            this IEnumerable<T> data,
            Func<T, double> selector
            )
        {
            int count = 0;
            double sum = 0, mean = data.Mean(selector);

            foreach (var x in data)
            {
                sum += (selector(x) - mean).Square();
                count++;
            }

            return sum / count;
        }

        /// <summary>
        /// Calculates the standard deviation of given elements.
        /// </summary>
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double StandardDeviation<T>(this IEnumerable<T> data, Func<T, double> selector)
            => data.Variance(selector).Sqrt();

        #endregion

        #region CountPositives

        //# signedtypes.ForEach(t => {
        /// <summary>
        /// Return the number of values greater than 0.
        /// </summary>
        [Pure]
        public static int CountPositives(this IEnumerable<__t.Name__> array)
        {
            int count = 0;
            foreach (var x in array) if (x > 0) ++count;
            return count;
        }

        //# });

        #endregion 

        #region CountNegatives

        //# signedtypes.ForEach(t => {
        /// <summary>
        /// Return the number of values less than 0.
        /// </summary>
        [Pure]
        public static int CountNegatives(this IEnumerable<__t.Name__> array)
        {
            int count = 0;
            foreach (var x in array) if (x < 0) ++count;
            return count;
        }

        //# });
        #endregion
        
        #region Primes

        //# iltypes.ForEach(t => {
        /// <summary>
        /// Checks if the given value is a prime number.
        /// </summary>
        /// <param name="value">The number to check.</param>
        /// <returns><c>True</c> if the number is a prime; otherwise, <c>False</c>.</returns>
        [Pure]
        public static bool IsPrime(this __t.Name__ value)
        {
            __t.Name__ imax = (__t.Name__)System.Math.Sqrt(value);

            for (__t.Name__ i = 2; i <= imax; i++)
                if (value % i == 0) return false;

            return true;
        }

        //# });

        #endregion

        #region Swap

        /// <summary>
        /// Swaps <paramref name="a"/> and <paramref name="b"/>,
        /// so that afterwards a=b and b=a.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Swap<T>(ref T a, ref T b)
        {
            T t = a; a = b; b = t;
        }

        /// <summary>
        /// Rotates left <paramref name="a"/>, <paramref name="b"/>, and <paramref name="c"/>,
        /// so that afterwards a=b, b=c and c=a.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Rotate<T>(ref T a, ref T b, ref T c)
        {
            T t = a; a = b; b = c; c = t;
        }

        /// <summary>
        /// Rotates left <paramref name="a"/>, <paramref name="b"/>, <paramref name="c"/>, and <paramref name="d"/>,
        /// so that afterwards a=b, b=c, c=b and d=a.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Rotate<T>(ref T a, ref T b, ref T c, ref T d)
        {
            T t = a; a = b; b = c; c = d; d = t;
        }

        /// <summary>
        /// Rotates left <paramref name="a"/>, <paramref name="b"/>, <paramref name="c"/>, <paramref name="d"/>, and <paramref name="e"/>,
        /// so that afterwards a=b, b=c, c=b and d=c and e=a.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Rotate<T>(ref T a, ref T b, ref T c, ref T d, ref T e)
        {
            T t = a; a = b; b = c; c = d; d = e; e = t;
        }

        #endregion

        #region Common Divisor and Multiple

        //# modtypes.ForEach(t => {
        /// TODO: Handle negative inputs?
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ GreatestCommonDivisor(this __t.Name__ a, __t.Name__ b)
            => b == 0 ? a : GreatestCommonDivisor(b, a % b);

        /// TODO: Handle negative inputs?
        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __t.Name__ LeastCommonMultiple(this __t.Name__ a, __t.Name__ b)
            => a * b / GreatestCommonDivisor(a, b);

        //# });
        #endregion

        #region Conversion

        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ToInt(this float x) => (int)x;

        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long ToLong(this float x) => (long)x;

        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int ToInt(this double x) => (int)x;

        [Pure]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long ToLong(this double x) => (long)x;

        #endregion

        #region Weighted Sum

        [Pure]
        public static double WeightedSum(this double[] items, double[] weights)
        {
            var r = 0.0;
            var count = weights.LongLength;
            for (long i = 0; i < count; i++) r += weights[i] * items[i];
            return r;
        }

        #endregion
    }
}