using System;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;
using System.Xml.Serialization;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    #region QuaternionF

    /// <summary>
    /// Struct for general quaternions, for rotations in 3-dimensional space use <see cref="Rot3f"/>.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct QuaternionF
    {
        /// <summary>
        /// Scalar (real) part of the quaternion.
        /// </summary>
        [DataMember]
        public float W;

        /// <summary>
        /// First component of vector (imaginary) part of the quaternion.
        /// </summary>
        [DataMember]
        public float X;

        /// <summary>
        /// Second component of vector (imaginary) part of the quaternion.
        /// </summary>
        [DataMember]
        public float Y;

        /// <summary>
        /// Third component of vector (imaginary) part of the quaternion.
        /// </summary>
        [DataMember]
        public float Z;

        #region Constructors

        /// <summary>
        /// Creates a <see cref="QuaternionF"/> (a, (a, a, a)).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionF(float a)
        {
            W = a;
            X = a; Y = a; Z = a;
        }

        /// <summary>
        /// Creates a <see cref="QuaternionF"/> (w, (x, y, z)).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionF(float w, float x, float y, float z)
        {
            W = w;
            X = x; Y = y; Z = z;
        }

        /// <summary>
        /// Creates a <see cref="QuaternionF"/> (v.x, (v.y, v.z, v.w)).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionF(V4f v)
        {
            W = v.X;
            X = v.Y; Y = v.Z; Z = v.W;
        }

        /// <summary>
        /// Creates a <see cref="QuaternionF"/> (w, (v.x, v.y, v.z)).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionF(float w, V3f v)
        {
            W = w;
            X = v.X; Y = v.Y; Z = v.Z;
        }

        /// <summary>
        /// Creates a copy of the given <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionF(QuaternionF q)
        {
            W = q.W; X = q.X; Y = q.Y; Z = q.Z; 
        }

        /// <summary>
        /// Creates a <see cref="QuaternionF"/> from the given <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionF(QuaternionD q)
        {
            W = (float)q.W; X = (float)q.X; Y = (float)q.Y; Z = (float)q.Z; 
        }

        /// <summary>
        /// Creates a <see cref="QuaternionF"/> from the given <see cref="Rot3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionF(Rot3f r)
        {
            W = r.W; X = r.X; Y = r.Y; Z = r.Z; 
        }

        /// <summary>
        /// Creates a <see cref="QuaternionF"/> from the given <see cref="Rot3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionF(Rot3d r)
        {
            W = (float)r.W; X = (float)r.X; Y = (float)r.Y; Z = (float)r.Z; 
        }

        /// <summary>
        /// Creates a <see cref="QuaternionF"/> from an array.
        /// (w = a[0], (x = a[1], y = a[2], z = a[3])).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionF(float[] a)
        {
            W = a[0];
            X = a[1]; Y = a[2]; Z = a[3];
        }

        /// <summary>
        /// Creates a <see cref="QuaternionF"/> from an array starting at specified index.
        /// (w = a[start], (x = a[start+1], y = a[start+2], z = a[start+3])).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionF(float[] a, int start)
        {
            W = a[start];
            X = a[start + 1]; Y = a[start + 2]; Z = a[start + 3];
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets or sets the vector part (x, y, z) of this <see cref="QuaternionF"/>.
        /// </summary>
        [XmlIgnore]
        public V3f V
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3f(X, Y, Z); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { X = value.X; Y = value.Y; Z = value.Z; }
        }

        /// <summary>
        /// Gets the squared norm (or squared length) of this <see cref="QuaternionF"/>.
        /// </summary>
        public float NormSquared
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => W * W + X * X + Y * Y + Z * Z;
        }

        /// <summary>
        /// Gets the norm (or length) of this <see cref="QuaternionF"/>.
        /// </summary>
        public float Norm
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => NormSquared.Sqrt();
        }

        /// <summary>
        /// Gets normalized (unit) quaternion from this <see cref="QuaternionF"/>
        /// </summary>
        public QuaternionF Normalized
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var rs = new QuaternionF(this);
                rs.Normalize();
                return rs;
            }
        }

        /// <summary>
        /// Gets the (multiplicative) inverse of this <see cref="QuaternionF"/>.
        /// The zero quaternion is returned, if this quaternion is zero.
        /// </summary>
        public QuaternionF Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var rs = new QuaternionF(this);
                rs.Invert();
                return rs;
            }
        }

        /// <summary>
        /// Gets the conjugate of this <see cref="QuaternionF"/>.
        /// For unit quaternions this is the same as its inverse.
        /// </summary>
        public QuaternionF Conjugated
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new QuaternionF(W, -V);
        }

        /// <summary>
        /// Gets if this <see cref="QuaternionF"/> is zero.
        /// </summary>
        public bool IsZero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (W == 0) && (X == 0) && (Y == 0) && (Z == 0);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets a <see cref="QuaternionF"/> with (0, (0, 0, 0)).
        /// </summary>
        public static QuaternionF Zero
        { 
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new QuaternionF(0);
        }

        /// <summary>
        /// Gets a <see cref="QuaternionF"/> with (1, (0, 0, 0)).
        /// </summary>
        public static QuaternionF One
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new QuaternionF(1, 0, 0, 0);
        }

        /// <summary>
        /// Gets the identity <see cref="QuaternionF"/> with (1, (0, 0, 0)).
        /// </summary>
        public static QuaternionF Identity
        { 
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new QuaternionF(1, 0, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="QuaternionF"/> with (0, (1, 0, 0)).
        /// </summary>
        public static QuaternionF I
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new QuaternionF(0, 1, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="QuaternionF"/> with (0, (0, 1, 0)).
        /// </summary>
        public static QuaternionF J
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new QuaternionF(0, 0, 1, 0);
        }

        /// <summary>
        /// Gets a <see cref="QuaternionF"/> with (0, (0, 0, 1)).
        /// </summary>
        public static QuaternionF K
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new QuaternionF(0, 0, 0, 1);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Returns the component-wise negation of a <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF operator -(QuaternionF q)
            => new QuaternionF(-q.W, -q.X, -q.Y, -q.Z);

        /// <summary>
        /// Returns the sum of two <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF operator +(QuaternionF a, QuaternionF b)
            => new QuaternionF(a.W + b.W, a.X + b.X, a.Y + b.Y, a.Z + b.Z);

        /// <summary>
        /// Returns the sum of a <see cref="QuaternionF"/> and a real scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF operator +(QuaternionF q, float s)
            => new QuaternionF(q.W + s, q.X, q.Y, q.Z);

        /// <summary>
        /// Returns the sum of a real scalar and a <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF operator +(float s, QuaternionF q)
            => new QuaternionF(q.W + s, q.X, q.Y, q.Z);

        /// <summary>
        /// Returns the difference between two <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF operator -(QuaternionF a, QuaternionF b)
            => new QuaternionF(a.W - b.W, a.X - b.X, a.Y - b.Y, a.Z - b.Z);

        /// <summary>
        /// Returns the difference between a <see cref="QuaternionF"/> and a real scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF operator -(QuaternionF q, float s)
            => new QuaternionF(q.W - s, q.X, q.Y, q.Z);

        /// <summary>
        /// Returns the difference between a real scalar and a <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF operator -(float s, QuaternionF q)
            => new QuaternionF(s - q.W, -q.X, -q.Y, -q.Z);

        /// <summary>
        /// Returns the product of a <see cref="QuaternionF"/> and a scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF operator *(QuaternionF q, float s)
            => new QuaternionF(q.W * s, q.X * s, q.Y * s, q.Z * s);

        /// <summary>
        /// Returns the product of a scalar and a <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF operator *(float s, QuaternionF q)
            => new QuaternionF(q.W * s, q.X * s, q.Y * s, q.Z * s);

        /// <summary>
        /// Multiplies two <see cref="QuaternionF"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF operator *(QuaternionF a, QuaternionF b)
        {
            return new QuaternionF(
                a.W * b.W - a.X * b.X - a.Y * b.Y - a.Z * b.Z,
                a.W * b.X + a.X * b.W + a.Y * b.Z - a.Z * b.Y,
                a.W * b.Y + a.Y * b.W + a.Z * b.X - a.X * b.Z,
                a.W * b.Z + a.Z * b.W + a.X * b.Y - a.Y * b.X);
        }

        /// <summary>
        /// Divides two <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF operator /(QuaternionF a, QuaternionF b)
            => a * b.Inverse;

        /// <summary>
        /// Divides a <see cref="QuaternionF"/> by a scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF operator /(QuaternionF q, float s)
            => new QuaternionF(q.W / s, q.X / s, q.Y / s, q.Z / s);

        /// <summary>
        /// Divides a scalar by a <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF operator /(float s, QuaternionF q)
            => new QuaternionF(s / q.W, s / q.X, s / q.Y, s / q.Z);

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="QuaternionF"/> are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(QuaternionF q0, QuaternionF q1)
            => q0.W == q1.W && q0.X == q1.X && q0.Y == q1.Y && q0.Z == q1.Z;

        /// <summary>
        /// Checks whether two <see cref="QuaternionF"/> are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(QuaternionF q0, QuaternionF q1)
            => q0.W != q1.W || q0.X != q1.X || q0.Y != q1.Y || q0.Z != q1.Z;

        #endregion

        #region Conversions

        /// <summary>
        /// Conversion from a <see cref="QuaternionF"/> to a <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator QuaternionD(QuaternionF q)
            => new QuaternionD(q);

        /// <summary>
        /// Returns this <see cref="QuaternionF"/> as a 4x4 matrix. Quaternions are represented as matrices in such
        /// a way that quaternion multiplication and addition is equivalent to matrix multiplication and addition.
        /// Note that there are 48 distinct such matrix representations for a single quaternion.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44f(QuaternionF q)
        {
            return new M44f(
                q.W, -q.X, -q.Y, -q.Z,
                q.X,  q.W, -q.Z,  q.Y,
                q.Y,  q.Z,  q.W, -q.X,
                q.Z, -q.Y,  q.X,  q.W);
        }

        /// <summary>
        /// Returns this <see cref="QuaternionF"/> as a <see cref="V4f"/> vector.
        /// Note that the components are ordered (w, x, y, z).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator V4f(QuaternionF q)
            => new V4f(q.W, q.X, q.Y, q.Z);

        /// <summary>
        /// Returns all values of a <see cref="QuaternionF"/> instance
        /// in a float[] array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator float[](QuaternionF q)
        {
            float[] array = new float[4];
            array[0] = q.W;
            array[1] = q.X;
            array[2] = q.Y;
            array[3] = q.Z;
            return array;
        }

        #endregion

        #region Indexing

        /// <summary>
        /// Gets or sets the <paramref name="i"/>-th component of the <see cref="QuaternionF"/> with components (w, (x, y, z)).
        /// </summary>
        public unsafe float this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (float* ptr = &W) { return ptr[i]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (float* ptr = &W) { ptr[i] = value; }
            }
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(W, X, Y, Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(QuaternionF other)
            => W.Equals(other.W) && X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z);

        public override bool Equals(object other)
            => (other is QuaternionF o) ? Equals(o) : false;

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}, {2}, {3}]", W, X, Y, Z);
        }

        public static QuaternionF Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new QuaternionF(float.Parse(x[0], CultureInfo.InvariantCulture), float.Parse(x[1], CultureInfo.InvariantCulture), float.Parse(x[2], CultureInfo.InvariantCulture), float.Parse(x[3], CultureInfo.InvariantCulture));
        }

        #endregion
    }

    public static partial class Quaternion
    {
        #region Invert, Normalize, Conjugate, Dot

        /// <summary>
        /// Returns the inverse of a <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF Inverse(QuaternionF q)
            => q.Inverse;

        /// <summary>
        /// Inverts a <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref QuaternionF q)
        {
            var norm = q.NormSquared;
            if (norm > 0)
            {
                var scale = 1 / norm;
                q.W *= scale;
                q.X *= -scale;
                q.Y *= -scale;
                q.Z *= -scale;
            }
        }

        /// <summary>
        /// Returns a normalized copy of a <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF Normalized(QuaternionF q)
            => q.Normalized;

        /// <summary>
        /// Normalizes a <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Normalize(this ref QuaternionF q)
        {
            var norm = q.Norm;
            if (norm > 0)
            {
                var scale = 1 / norm;
                q.W *= scale;
                q.X *= scale;
                q.Y *= scale;
                q.Z *= scale;
            }
        }

        /// <summary>
        /// Returns the conjugate of a <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionF Conjugated(QuaternionF q)
            => q.Conjugated;

        /// <summary>
        /// Conjugates a <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Conjugate(this ref QuaternionF q)
        {
            q.X = -q.X;
            q.Y = -q.Y;
            q.Z = -q.Z;
        }

        /// <summary> 
        /// Returns the dot product of two <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Dot(this QuaternionF a, QuaternionF b)
        {
            return a.W * b.W + a.X * b.X + a.Y * b.Y + a.Z * b.Z;
        }

        #endregion

        #region Norm

        /// <summary>
        /// Gets the squared norm (or length) of a <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormSquared(QuaternionF q)
            => q.NormSquared;

        /// <summary>
        /// Gets the norm (or length) of a <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm(QuaternionF q)
            => q.Norm;

        #endregion

        #region Spherical Linear Interpolation

        /// <summary>
        /// Spherical linear interpolation.
        ///
        /// Assumes q1 and q2 are normalized and that t in [0,1].
        ///
        /// This method interpolates along the shortest arc between q1 and q2.
        /// </summary>
        public static QuaternionF SlerpShortest(this QuaternionF q1, QuaternionF q2, float t)
        {
            QuaternionF q3 = q2;
            float cosomega = Dot(q1, q3);

            if (cosomega < 0)
            {
                cosomega = -cosomega;
                q3 = -q3;
            }

            if (cosomega >= 1)
            {
                // Special case: q1 and q2 are the same, so just return one of them.
                // This also catches the case where cosomega is very slightly > 1.0
                return q1;
            }

            float sinomega = Fun.Sqrt(1 - cosomega * cosomega);

            QuaternionF result;

            if (sinomega * float.MaxValue > 1)
            {
                float omega = Fun.Acos(cosomega);
                float s1 = Fun.Sin((1 - t) * omega) / sinomega;
                float s2 = Fun.Sin(t * omega) / sinomega;

                result = new QuaternionF(s1 * q1 + s2 * q3);
            }
            else if (cosomega > 0)
            {
                // omega == 0
                float s1 = 1 - t;
                float s2 = t;

                result = new QuaternionF(s1 * q1 + s2 * q3);
            }
            else
            {
                // omega == -pi
                result = new QuaternionF(q1.Z, -q1.Y, q1.X, -q1.W);

                float s1 = Fun.Sin((0.5f - t) * ConstantF.Pi);
                float s2 = Fun.Sin(t * ConstantF.Pi);

                result = new QuaternionF(s1 * q1 + s2 * result);
            }

            return result;
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this QuaternionF q0, QuaternionF q1)
        {
            return ApproximateEquals(q0, q1, Constant<float>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this QuaternionF q0, QuaternionF q1, float tolerance)
        {
            return ApproximateEquals(q0.W, q1.W, tolerance) && ApproximateEquals(q0.X, q1.X, tolerance) && ApproximateEquals(q0.Y, q1.Y, tolerance) && ApproximateEquals(q0.Z, q1.Z, tolerance);
        }

        #endregion
    }

    #endregion

    #region QuaternionD

    /// <summary>
    /// Struct for general quaternions, for rotations in 3-dimensional space use <see cref="Rot3d"/>.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct QuaternionD
    {
        /// <summary>
        /// Scalar (real) part of the quaternion.
        /// </summary>
        [DataMember]
        public double W;

        /// <summary>
        /// First component of vector (imaginary) part of the quaternion.
        /// </summary>
        [DataMember]
        public double X;

        /// <summary>
        /// Second component of vector (imaginary) part of the quaternion.
        /// </summary>
        [DataMember]
        public double Y;

        /// <summary>
        /// Third component of vector (imaginary) part of the quaternion.
        /// </summary>
        [DataMember]
        public double Z;

        #region Constructors

        /// <summary>
        /// Creates a <see cref="QuaternionD"/> (a, (a, a, a)).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionD(double a)
        {
            W = a;
            X = a; Y = a; Z = a;
        }

        /// <summary>
        /// Creates a <see cref="QuaternionD"/> (w, (x, y, z)).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionD(double w, double x, double y, double z)
        {
            W = w;
            X = x; Y = y; Z = z;
        }

        /// <summary>
        /// Creates a <see cref="QuaternionD"/> (v.x, (v.y, v.z, v.w)).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionD(V4d v)
        {
            W = v.X;
            X = v.Y; Y = v.Z; Z = v.W;
        }

        /// <summary>
        /// Creates a <see cref="QuaternionD"/> (w, (v.x, v.y, v.z)).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionD(double w, V3d v)
        {
            W = w;
            X = v.X; Y = v.Y; Z = v.Z;
        }

        /// <summary>
        /// Creates a copy of the given <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionD(QuaternionD q)
        {
            W = q.W; X = q.X; Y = q.Y; Z = q.Z; 
        }

        /// <summary>
        /// Creates a <see cref="QuaternionD"/> from the given <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionD(QuaternionF q)
        {
            W = (double)q.W; X = (double)q.X; Y = (double)q.Y; Z = (double)q.Z; 
        }

        /// <summary>
        /// Creates a <see cref="QuaternionD"/> from the given <see cref="Rot3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionD(Rot3d r)
        {
            W = r.W; X = r.X; Y = r.Y; Z = r.Z; 
        }

        /// <summary>
        /// Creates a <see cref="QuaternionD"/> from the given <see cref="Rot3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionD(Rot3f r)
        {
            W = (double)r.W; X = (double)r.X; Y = (double)r.Y; Z = (double)r.Z; 
        }

        /// <summary>
        /// Creates a <see cref="QuaternionD"/> from an array.
        /// (w = a[0], (x = a[1], y = a[2], z = a[3])).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionD(double[] a)
        {
            W = a[0];
            X = a[1]; Y = a[2]; Z = a[3];
        }

        /// <summary>
        /// Creates a <see cref="QuaternionD"/> from an array starting at specified index.
        /// (w = a[start], (x = a[start+1], y = a[start+2], z = a[start+3])).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public QuaternionD(double[] a, int start)
        {
            W = a[start];
            X = a[start + 1]; Y = a[start + 2]; Z = a[start + 3];
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets or sets the vector part (x, y, z) of this <see cref="QuaternionD"/>.
        /// </summary>
        [XmlIgnore]
        public V3d V
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3d(X, Y, Z); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { X = value.X; Y = value.Y; Z = value.Z; }
        }

        /// <summary>
        /// Gets the squared norm (or squared length) of this <see cref="QuaternionD"/>.
        /// </summary>
        public double NormSquared
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => W * W + X * X + Y * Y + Z * Z;
        }

        /// <summary>
        /// Gets the norm (or length) of this <see cref="QuaternionD"/>.
        /// </summary>
        public double Norm
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => NormSquared.Sqrt();
        }

        /// <summary>
        /// Gets normalized (unit) quaternion from this <see cref="QuaternionD"/>
        /// </summary>
        public QuaternionD Normalized
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var rs = new QuaternionD(this);
                rs.Normalize();
                return rs;
            }
        }

        /// <summary>
        /// Gets the (multiplicative) inverse of this <see cref="QuaternionD"/>.
        /// The zero quaternion is returned, if this quaternion is zero.
        /// </summary>
        public QuaternionD Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var rs = new QuaternionD(this);
                rs.Invert();
                return rs;
            }
        }

        /// <summary>
        /// Gets the conjugate of this <see cref="QuaternionD"/>.
        /// For unit quaternions this is the same as its inverse.
        /// </summary>
        public QuaternionD Conjugated
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new QuaternionD(W, -V);
        }

        /// <summary>
        /// Gets if this <see cref="QuaternionD"/> is zero.
        /// </summary>
        public bool IsZero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (W == 0) && (X == 0) && (Y == 0) && (Z == 0);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets a <see cref="QuaternionD"/> with (0, (0, 0, 0)).
        /// </summary>
        public static QuaternionD Zero
        { 
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new QuaternionD(0);
        }

        /// <summary>
        /// Gets a <see cref="QuaternionD"/> with (1, (0, 0, 0)).
        /// </summary>
        public static QuaternionD One
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new QuaternionD(1, 0, 0, 0);
        }

        /// <summary>
        /// Gets the identity <see cref="QuaternionD"/> with (1, (0, 0, 0)).
        /// </summary>
        public static QuaternionD Identity
        { 
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new QuaternionD(1, 0, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="QuaternionD"/> with (0, (1, 0, 0)).
        /// </summary>
        public static QuaternionD I
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new QuaternionD(0, 1, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="QuaternionD"/> with (0, (0, 1, 0)).
        /// </summary>
        public static QuaternionD J
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new QuaternionD(0, 0, 1, 0);
        }

        /// <summary>
        /// Gets a <see cref="QuaternionD"/> with (0, (0, 0, 1)).
        /// </summary>
        public static QuaternionD K
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new QuaternionD(0, 0, 0, 1);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Returns the component-wise negation of a <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD operator -(QuaternionD q)
            => new QuaternionD(-q.W, -q.X, -q.Y, -q.Z);

        /// <summary>
        /// Returns the sum of two <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD operator +(QuaternionD a, QuaternionD b)
            => new QuaternionD(a.W + b.W, a.X + b.X, a.Y + b.Y, a.Z + b.Z);

        /// <summary>
        /// Returns the sum of a <see cref="QuaternionD"/> and a real scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD operator +(QuaternionD q, double s)
            => new QuaternionD(q.W + s, q.X, q.Y, q.Z);

        /// <summary>
        /// Returns the sum of a real scalar and a <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD operator +(double s, QuaternionD q)
            => new QuaternionD(q.W + s, q.X, q.Y, q.Z);

        /// <summary>
        /// Returns the difference between two <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD operator -(QuaternionD a, QuaternionD b)
            => new QuaternionD(a.W - b.W, a.X - b.X, a.Y - b.Y, a.Z - b.Z);

        /// <summary>
        /// Returns the difference between a <see cref="QuaternionD"/> and a real scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD operator -(QuaternionD q, double s)
            => new QuaternionD(q.W - s, q.X, q.Y, q.Z);

        /// <summary>
        /// Returns the difference between a real scalar and a <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD operator -(double s, QuaternionD q)
            => new QuaternionD(s - q.W, -q.X, -q.Y, -q.Z);

        /// <summary>
        /// Returns the product of a <see cref="QuaternionD"/> and a scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD operator *(QuaternionD q, double s)
            => new QuaternionD(q.W * s, q.X * s, q.Y * s, q.Z * s);

        /// <summary>
        /// Returns the product of a scalar and a <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD operator *(double s, QuaternionD q)
            => new QuaternionD(q.W * s, q.X * s, q.Y * s, q.Z * s);

        /// <summary>
        /// Multiplies two <see cref="QuaternionD"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD operator *(QuaternionD a, QuaternionD b)
        {
            return new QuaternionD(
                a.W * b.W - a.X * b.X - a.Y * b.Y - a.Z * b.Z,
                a.W * b.X + a.X * b.W + a.Y * b.Z - a.Z * b.Y,
                a.W * b.Y + a.Y * b.W + a.Z * b.X - a.X * b.Z,
                a.W * b.Z + a.Z * b.W + a.X * b.Y - a.Y * b.X);
        }

        /// <summary>
        /// Divides two <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD operator /(QuaternionD a, QuaternionD b)
            => a * b.Inverse;

        /// <summary>
        /// Divides a <see cref="QuaternionD"/> by a scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD operator /(QuaternionD q, double s)
            => new QuaternionD(q.W / s, q.X / s, q.Y / s, q.Z / s);

        /// <summary>
        /// Divides a scalar by a <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD operator /(double s, QuaternionD q)
            => new QuaternionD(s / q.W, s / q.X, s / q.Y, s / q.Z);

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="QuaternionD"/> are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(QuaternionD q0, QuaternionD q1)
            => q0.W == q1.W && q0.X == q1.X && q0.Y == q1.Y && q0.Z == q1.Z;

        /// <summary>
        /// Checks whether two <see cref="QuaternionD"/> are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(QuaternionD q0, QuaternionD q1)
            => q0.W != q1.W || q0.X != q1.X || q0.Y != q1.Y || q0.Z != q1.Z;

        #endregion

        #region Conversions

        /// <summary>
        /// Conversion from a <see cref="QuaternionD"/> to a <see cref="QuaternionF"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator QuaternionF(QuaternionD q)
            => new QuaternionF(q);

        /// <summary>
        /// Returns this <see cref="QuaternionD"/> as a 4x4 matrix. Quaternions are represented as matrices in such
        /// a way that quaternion multiplication and addition is equivalent to matrix multiplication and addition.
        /// Note that there are 48 distinct such matrix representations for a single quaternion.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44d(QuaternionD q)
        {
            return new M44d(
                q.W, -q.X, -q.Y, -q.Z,
                q.X,  q.W, -q.Z,  q.Y,
                q.Y,  q.Z,  q.W, -q.X,
                q.Z, -q.Y,  q.X,  q.W);
        }

        /// <summary>
        /// Returns this <see cref="QuaternionD"/> as a <see cref="V4d"/> vector.
        /// Note that the components are ordered (w, x, y, z).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator V4d(QuaternionD q)
            => new V4d(q.W, q.X, q.Y, q.Z);

        /// <summary>
        /// Returns all values of a <see cref="QuaternionD"/> instance
        /// in a double[] array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator double[](QuaternionD q)
        {
            double[] array = new double[4];
            array[0] = q.W;
            array[1] = q.X;
            array[2] = q.Y;
            array[3] = q.Z;
            return array;
        }

        #endregion

        #region Indexing

        /// <summary>
        /// Gets or sets the <paramref name="i"/>-th component of the <see cref="QuaternionD"/> with components (w, (x, y, z)).
        /// </summary>
        public unsafe double this[int i]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (double* ptr = &W) { return ptr[i]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (double* ptr = &W) { ptr[i] = value; }
            }
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(W, X, Y, Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(QuaternionD other)
            => W.Equals(other.W) && X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z);

        public override bool Equals(object other)
            => (other is QuaternionD o) ? Equals(o) : false;

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}, {2}, {3}]", W, X, Y, Z);
        }

        public static QuaternionD Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new QuaternionD(double.Parse(x[0], CultureInfo.InvariantCulture), double.Parse(x[1], CultureInfo.InvariantCulture), double.Parse(x[2], CultureInfo.InvariantCulture), double.Parse(x[3], CultureInfo.InvariantCulture));
        }

        #endregion
    }

    public static partial class Quaternion
    {
        #region Invert, Normalize, Conjugate, Dot

        /// <summary>
        /// Returns the inverse of a <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD Inverse(QuaternionD q)
            => q.Inverse;

        /// <summary>
        /// Inverts a <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref QuaternionD q)
        {
            var norm = q.NormSquared;
            if (norm > 0)
            {
                var scale = 1 / norm;
                q.W *= scale;
                q.X *= -scale;
                q.Y *= -scale;
                q.Z *= -scale;
            }
        }

        /// <summary>
        /// Returns a normalized copy of a <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD Normalized(QuaternionD q)
            => q.Normalized;

        /// <summary>
        /// Normalizes a <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Normalize(this ref QuaternionD q)
        {
            var norm = q.Norm;
            if (norm > 0)
            {
                var scale = 1 / norm;
                q.W *= scale;
                q.X *= scale;
                q.Y *= scale;
                q.Z *= scale;
            }
        }

        /// <summary>
        /// Returns the conjugate of a <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static QuaternionD Conjugated(QuaternionD q)
            => q.Conjugated;

        /// <summary>
        /// Conjugates a <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Conjugate(this ref QuaternionD q)
        {
            q.X = -q.X;
            q.Y = -q.Y;
            q.Z = -q.Z;
        }

        /// <summary> 
        /// Returns the dot product of two <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Dot(this QuaternionD a, QuaternionD b)
        {
            return a.W * b.W + a.X * b.X + a.Y * b.Y + a.Z * b.Z;
        }

        #endregion

        #region Norm

        /// <summary>
        /// Gets the squared norm (or length) of a <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormSquared(QuaternionD q)
            => q.NormSquared;

        /// <summary>
        /// Gets the norm (or length) of a <see cref="QuaternionD"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(QuaternionD q)
            => q.Norm;

        #endregion

        #region Spherical Linear Interpolation

        /// <summary>
        /// Spherical linear interpolation.
        ///
        /// Assumes q1 and q2 are normalized and that t in [0,1].
        ///
        /// This method interpolates along the shortest arc between q1 and q2.
        /// </summary>
        public static QuaternionD SlerpShortest(this QuaternionD q1, QuaternionD q2, double t)
        {
            QuaternionD q3 = q2;
            double cosomega = Dot(q1, q3);

            if (cosomega < 0)
            {
                cosomega = -cosomega;
                q3 = -q3;
            }

            if (cosomega >= 1)
            {
                // Special case: q1 and q2 are the same, so just return one of them.
                // This also catches the case where cosomega is very slightly > 1.0
                return q1;
            }

            double sinomega = Fun.Sqrt(1 - cosomega * cosomega);

            QuaternionD result;

            if (sinomega * double.MaxValue > 1)
            {
                double omega = Fun.Acos(cosomega);
                double s1 = Fun.Sin((1 - t) * omega) / sinomega;
                double s2 = Fun.Sin(t * omega) / sinomega;

                result = new QuaternionD(s1 * q1 + s2 * q3);
            }
            else if (cosomega > 0)
            {
                // omega == 0
                double s1 = 1 - t;
                double s2 = t;

                result = new QuaternionD(s1 * q1 + s2 * q3);
            }
            else
            {
                // omega == -pi
                result = new QuaternionD(q1.Z, -q1.Y, q1.X, -q1.W);

                double s1 = Fun.Sin((0.5 - t) * Constant.Pi);
                double s2 = Fun.Sin(t * Constant.Pi);

                result = new QuaternionD(s1 * q1 + s2 * result);
            }

            return result;
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this QuaternionD q0, QuaternionD q1)
        {
            return ApproximateEquals(q0, q1, Constant<double>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this QuaternionD q0, QuaternionD q1, double tolerance)
        {
            return ApproximateEquals(q0.W, q1.W, tolerance) && ApproximateEquals(q0.X, q1.X, tolerance) && ApproximateEquals(q0.Y, q1.Y, tolerance) && ApproximateEquals(q0.Z, q1.Z, tolerance);
        }

        #endregion
    }

    #endregion

}