/*
    Copyright 2006-2025. The Aardvark Platform Team.

        https://aardvark.graphics

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
using System;
using System.Collections.Generic;
using System.Linq;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!


    /// <summary>
    /// Walker 1974: https://en.wikipedia.org/wiki/Alias_method
    /// Algorithm to sample a discrete probability distribution function (PDF) in O(1).
    /// The PDF does not need to be normalized, but the normalization factor "1/Sum(pdf)" needs to be supplied.
    /// </summary>
    public class AliasTableF
    {
        readonly float[] _probablity; // U[i]
        readonly int[] _alias;         // K[i]

        public float[] U => _probablity;
        public int[] K => _alias;

        /// <summary>
        /// Creates an alias table from a genral PDF that does not integrate to 1.
        /// The normalization factor will be calculated for the construction.
        /// </summary>
        public static AliasTableF FromPdf(float[] pdf, IRandomUniform rnd = null)
        {
            return new AliasTableF(pdf, 1 / pdf.Sum(), rnd);
        }

        /// <summary>
        /// Creates an alias table from an already normalized PDF (integrates to 1).
        /// </summary>
        public static AliasTableF FromNormalizedPdf(float[] pdf, IRandomUniform rnd = null)
        {
            return new AliasTableF(pdf, 1, rnd);
        }

        /// <summary>
        /// Create an alias table from a PDf and its normalization factor: 1.0 / Sum(pdf)
        /// </summary>
        public AliasTableF(float[] pdf, float pdfNorm, IRandomUniform rnd = null)
        {
            var n = pdf.Length;
            _probablity = new float[n];
            _alias = new int[n];
            Update(pdf, pdfNorm, rnd);
        }

        /// <summary>
        /// Updates the alias table with the given PDF and its norm.
        /// The length of the PDF is expected to match the length of AliasTable.
        /// </summary>
        public void Update(float[] pdf, float pdfNorm, IRandomUniform rnd = null)
        {
            if (pdf.Length != _alias.Length) throw new ArgumentException("The length of the PDF does not match the length of the AliasTable!");

            rnd ??= new RandomSystem();

            var n = pdf.Length;
            var overfull = new List<int>(n);
            var underfull = new List<int>(n);

            for (int i = 0; i < n; i++)
            {
                var ui = pdf[i] * pdfNorm * n;
                _probablity[i] = ui;
                if (ui > 1) overfull.Add(i);
                else if (ui < 1) underfull.Add(i);
            }

            while (overfull.Count > 0 && underfull.Count > 0)
            {
                var ii = rnd.UniformInt(overfull.Count);  // random overfull
                var jj = rnd.UniformInt(underfull.Count); // random underfull
                var ri = overfull[ii];
                var rj = underfull[jj];
#if NETSTANDARD2_0
                underfull[jj] = underfull[underfull.Count - 1];
#else
                underfull[jj] = underfull[^1];
#endif
                underfull.RemoveAt(underfull.Count - 1);
                // rj will become exactly full (with own probability + alias for remainder)
                _alias[rj] = ri; // K[j] = i
                var uri = _probablity[ri];
                var urj = _probablity[rj];
                var uinew = uri + urj - 1; // U[i] + U[j] - 1
                _probablity[ri] = uinew;
                if (uinew <= 1) // otherwise keep in overfull
                {
#if NETSTANDARD2_0
                    overfull[ii] = overfull[overfull.Count - 1];
#else
                    overfull[ii] = overfull[^1];
#endif
                    overfull.RemoveAt(overfull.Count - 1);
                    if (uinew < 1)
                        underfull.Add(ri);
                }
            }

            while (underfull.Count > 0)
            {
#if NETSTANDARD2_0
                var i = underfull[underfull.Count - 1];
#else
                var i = underfull[^1];
#endif
                _probablity[i] = 1;
                underfull.RemoveAt(underfull.Count - 1);
            }

            while (overfull.Count > 0)
            {
#if NETSTANDARD2_0
                var i = overfull[overfull.Count - 1];
#else
                var i = overfull[^1];
#endif
                _probablity[i] = 1;
                overfull.RemoveAt(overfull.Count - 1);
            }
        }

        /// <summary>
        /// Sample pdf using the alias table with random variable x: [0, 1) in O(1).
        /// NOTE: About x2-4 faster than sampling a CDF with a binary search.
        /// </summary>
        public int Sample(float x1)
        {
            var nx = _probablity.Length * x1;
            var i = (int)nx;
            var y = nx - i;
            return y < _probablity[i] ? i : _alias[i];
        }
    }


    /// <summary>
    /// Walker 1974: https://en.wikipedia.org/wiki/Alias_method
    /// Algorithm to sample a discrete probability distribution function (PDF) in O(1).
    /// The PDF does not need to be normalized, but the normalization factor "1/Sum(pdf)" needs to be supplied.
    /// </summary>
    public class AliasTableD
    {
        readonly double[] _probablity; // U[i]
        readonly int[] _alias;         // K[i]

        public double[] U => _probablity;
        public int[] K => _alias;

        /// <summary>
        /// Creates an alias table from a genral PDF that does not integrate to 1.
        /// The normalization factor will be calculated for the construction.
        /// </summary>
        public static AliasTableD FromPdf(double[] pdf, IRandomUniform rnd = null)
        {
            return new AliasTableD(pdf, 1 / pdf.Sum(), rnd);
        }

        /// <summary>
        /// Creates an alias table from an already normalized PDF (integrates to 1).
        /// </summary>
        public static AliasTableD FromNormalizedPdf(double[] pdf, IRandomUniform rnd = null)
        {
            return new AliasTableD(pdf, 1, rnd);
        }

        /// <summary>
        /// Create an alias table from a PDf and its normalization factor: 1.0 / Sum(pdf)
        /// </summary>
        public AliasTableD(double[] pdf, double pdfNorm, IRandomUniform rnd = null)
        {
            var n = pdf.Length;
            _probablity = new double[n];
            _alias = new int[n];
            Update(pdf, pdfNorm, rnd);
        }

        /// <summary>
        /// Updates the alias table with the given PDF and its norm.
        /// The length of the PDF is expected to match the length of AliasTable.
        /// </summary>
        public void Update(double[] pdf, double pdfNorm, IRandomUniform rnd = null)
        {
            if (pdf.Length != _alias.Length) throw new ArgumentException("The length of the PDF does not match the length of the AliasTable!");

            rnd ??= new RandomSystem();

            var n = pdf.Length;
            var overfull = new List<int>(n);
            var underfull = new List<int>(n);

            for (int i = 0; i < n; i++)
            {
                var ui = pdf[i] * pdfNorm * n;
                _probablity[i] = ui;
                if (ui > 1) overfull.Add(i);
                else if (ui < 1) underfull.Add(i);
            }

            while (overfull.Count > 0 && underfull.Count > 0)
            {
                var ii = rnd.UniformInt(overfull.Count);  // random overfull
                var jj = rnd.UniformInt(underfull.Count); // random underfull
                var ri = overfull[ii];
                var rj = underfull[jj];
#if NETSTANDARD2_0
                underfull[jj] = underfull[underfull.Count - 1];
#else
                underfull[jj] = underfull[^1];
#endif
                underfull.RemoveAt(underfull.Count - 1);
                // rj will become exactly full (with own probability + alias for remainder)
                _alias[rj] = ri; // K[j] = i
                var uri = _probablity[ri];
                var urj = _probablity[rj];
                var uinew = uri + urj - 1; // U[i] + U[j] - 1
                _probablity[ri] = uinew;
                if (uinew <= 1) // otherwise keep in overfull
                {
#if NETSTANDARD2_0
                    overfull[ii] = overfull[overfull.Count - 1];
#else
                    overfull[ii] = overfull[^1];
#endif
                    overfull.RemoveAt(overfull.Count - 1);
                    if (uinew < 1)
                        underfull.Add(ri);
                }
            }

            while (underfull.Count > 0)
            {
#if NETSTANDARD2_0
                var i = underfull[underfull.Count - 1];
#else
                var i = underfull[^1];
#endif
                _probablity[i] = 1;
                underfull.RemoveAt(underfull.Count - 1);
            }

            while (overfull.Count > 0)
            {
#if NETSTANDARD2_0
                var i = overfull[overfull.Count - 1];
#else
                var i = overfull[^1];
#endif
                _probablity[i] = 1;
                overfull.RemoveAt(overfull.Count - 1);
            }
        }

        /// <summary>
        /// Sample pdf using the alias table with random variable x: [0, 1) in O(1).
        /// NOTE: About x2-4 faster than sampling a CDF with a binary search.
        /// </summary>
        public int Sample(double x1)
        {
            var nx = _probablity.Length * x1;
            var i = (int)nx;
            var y = nx - i;
            return y < _probablity[i] ? i : _alias[i];
        }
    }

}
