/*
    Copyright 2006-2025. The Aardvark Platform Team.

        https://aardvark.graphics

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
using System;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;
using System.Xml.Serialization;

namespace Aardvark.Base;

// AUTOGENERATED CODE - DO NOT CHANGE!

#region Shift2f

/// <summary>
/// A 2-dimensional translational transform with different translation values
/// in each dimension.
/// </summary>
[DataContract]
[StructLayout(LayoutKind.Sequential)]
public partial struct Shift2f : IEquatable<Shift2f>
{
    [DataMember]
    [XmlIgnore]
    public V2f V;

    #region Constructors

    /// <summary>
    /// Constructs a <see cref="Shift2f"/> transformation from 2 floats.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift2f(float x, float y)
    {
        V = new(x, y);
    }

    /// <summary>
    /// Constructs a <see cref="Shift2f"/> from a <see cref="V2f"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift2f(V2f v)
    {
        V = v;
    }

    /// <summary>
    /// Constructs a copy of a <see cref="Shift2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift2f(Shift2f s)
    {
        V = s.V;
    }

    /// <summary>
    /// Constructs a <see cref="Shift2f"/> transformation from a <see cref="Shift2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift2f(Shift2d shift)
    {
        V = (V2f)shift.V;
    }

    /// <summary>
    /// Constructs a <see cref="Shift2f"/> transformation from a float-array.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift2f(float[] array)
    {
        V = new(array);
    }

    /// <summary>
    /// Constructs a <see cref="Shift2f"/> transformation from a float-array starting from the given index.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift2f(float[] array, int start)
    {
        V = new(array, start);
    }

    #endregion

    #region Properties

    /// <summary>
    /// Gets and sets the X coordinate.
    /// </summary>
    public float X
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.X; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.X = value; }
    }

    /// <summary>
    /// Gets and sets the Y coordinate.
    /// </summary>
    public float Y
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.Y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.Y = value; }
    }

    /// <summary>
    /// Gets the length of this <see cref="Shift2f"/> transformation.
    /// </summary>
    public readonly float Length
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return V.Length; }
    }

    /// <summary>
    /// Gets the squared length of this <see cref="Shift2f"/> transformation.
    /// </summary>
    public readonly float LengthSquared
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return V.LengthSquared; }
    }

    /// <summary>
    /// Gets the inverse of this <see cref="Shift2f"/> transformation.
    /// </summary>
    public readonly Shift2f Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return new(-V); }
    }

    /// <summary>
    /// Gets the reciprocal of this <see cref="Shift2f"/> transformation.
    /// </summary>
    public readonly Shift2f Reciprocal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1 / V);
    }

    #endregion

    #region Constants

    /// <summary>
    /// Gets the identity <see cref="Shift2f"/> transformation.
    /// </summary>
    public static Shift2f Identity
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 0);
    }

    /// <summary>
    /// Gets a <see cref="Shift2f"/> transformation with all components set to zero.
    /// Note: Equivalent to Identity.
    /// </summary>
    public static Shift2f Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Identity;
    }

    /// <summary>
    /// Gets a <see cref="Shift2f"/> transformation with components (1, 0).
    /// </summary>
    public static Shift2f XAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1, 0);
    }

    /// <summary>
    /// Gets a <see cref="Shift2f"/> transformation with components (0, 1).
    /// </summary>
    public static Shift2f YAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 1);
    }

    #endregion

    #region Arithmetic Operators

    /// <summary>
    /// Negates the values of a <see cref="Shift2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2f operator -(Shift2f shift)
        => new(-shift.X, -shift.Y);

    #region Shift / Scalar

    /// <summary>
    /// Multiplies a <see cref="Shift2f"/> transformation with a float scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2f operator *(Shift2f shift, float scalar)
        => new(shift.X * scalar, shift.Y * scalar);

    /// <summary>
    /// Multiplies a float scalar with a <see cref="Shift2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2f operator *(float scalar, Shift2f shift)
        => new(shift.X * scalar, shift.Y * scalar);

    /// <summary>
    /// Divides a <see cref="Shift2f"/> transformation by a float scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2f operator /(Shift2f shift, float scalar)
        => new(shift.X / scalar, shift.Y / scalar);

    /// <summary>
    /// Divides a float scalar by a <see cref="Shift2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2f operator /(float scalar, Shift2f shift)
        => new(scalar / shift.X, scalar / shift.Y);

    #endregion

    #region Shift / Vector Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift2f"/> transformation with a <see cref="V2f"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V2f operator *(Shift2f shift, V2f vector)
        => new(vector.X + shift.X, vector.Y + shift.Y);

    #endregion

    #region Shift / Shift Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift2f"/> transformation with a <see cref="Shift2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2f operator *(Shift2f a, Shift2f b)
        => new(a.X + b.X, a.Y + b.Y);

    /// <summary>
    /// Multiplies a <see cref="Shift2f"/> transformation with a <see cref="Shift3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f operator *(Shift2f a, Shift3f b)
        => new(a.X + b.X, a.Y + b.Y, b.Z);

    #endregion

    #region Shift / Matrix Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift2f"/> transformation (as a 2x3 matrix) with a <see cref="M22f"/> (as a 3x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M23f operator *(Shift2f shift, M22f matrix)
        => new(matrix, shift.V);

    /// <summary>
    /// Multiplies a <see cref="M22f"/> with a <see cref="Shift2f"/> transformation (as a 2x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M23f operator *(M22f matrix, Shift2f shift)
        => new(matrix, matrix * shift.V);

    /// <summary>
    /// Multiplies a <see cref="Shift2f"/> transformation (as a 3x3 matrix) with a <see cref="M33f"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M33f operator *(Shift2f s, M33f m)
        => new(
            m.M00 + s.X * m.M20, 
            m.M01 + s.X * m.M21, 
            m.M02 + s.X * m.M22,

            m.M10 + s.Y * m.M20, 
            m.M11 + s.Y * m.M21, 
            m.M12 + s.Y * m.M22,

            m.M20, m.M21, m.M22);

    /// <summary>
    /// Multiplies a <see cref="M33f"/> with a <see cref="Shift2f"/> transformation (as a 3x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M33f operator *(M33f m, Shift2f s)
        => new(
            m.M00, 
            m.M01,
            s.X * m.M00 + s.Y * m.M01 + m.M02,

            m.M10, 
            m.M11,
            s.X * m.M10 + s.Y * m.M11 + m.M12,

            m.M20, 
            m.M21,
            s.X * m.M20 + s.Y * m.M21 + m.M22);

    /// <summary>
    /// Multiplies a <see cref="Shift2f"/> transformation (as a 2x3 matrix) with a <see cref="M23f"/> (as a 3x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M23f operator *(Shift2f s, M23f m)
        => new(
            m.M00, m.M01, m.M02 + s.X, 
            m.M10, m.M11, m.M12 + s.Y);

    /// <summary>
    /// Multiplies a <see cref="M23f"/> with a <see cref="Shift2f"/> transformation (as a 3x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M23f operator *(M23f m, Shift2f s)
        => new(
            m.M00, 
            m.M01,
            s.X * m.M00 + s.Y * m.M01 + m.M02,

            m.M10, 
            m.M11,
            s.X * m.M10 + s.Y * m.M11 + m.M12);

    #endregion

    #region Shift / Rot, Scale Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift2f"/> transformation with a <see cref="Rot2f"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Euclidean2f operator *(Shift2f a, Rot2f b)
        => new(b, a.V);

    /// <summary>
    /// Multiplies a <see cref="Shift2f"/> transformation with a <see cref="Scale2f"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Affine2f operator *(Shift2f a, Scale2f b)
        => new((M22f)b, a.V);

    #endregion

    #endregion

    #region Comparison Operators

    /// <summary>
    /// Checks whether two <see cref="Shift2f"/> transformations are equal.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Shift2f s0, Shift2f s1)
        => s0.X == s1.X && s0.Y == s1.Y;

    /// <summary>
    /// Checks whether two <see cref="Shift2f"/> transformations are different.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Shift2f s0, Shift2f s1)
        => s0.X != s1.X || s0.Y != s1.Y;

    #endregion

    #region Static Creators

    /// <summary>
    /// Creates a <see cref="Shift2f"/> transformation from a <see cref="M23f"/> matrix.
    /// The matrix must only contain translation components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2f FromM23f(M23f m, float epsilon = (float)1e-6)
    {
        if (!M22f.Identity.ApproximateEquals((M22f)m, epsilon))
            throw new ArgumentException("Matrix is not a pure translation matrix.");

        return new(m.C2);
    }

    /// <summary>
    /// Creates a <see cref="Shift2f"/> transformation from a translation <see cref="M33f"/> matrix.
    /// The matrix has to be homogeneous and must not contain perspective components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2f FromM33f(M33f m, float epsilon = (float)1e-6)
    {
        if (!M22f.Identity.ApproximateEquals((M22f)m, epsilon))
            throw new ArgumentException("Matrix is not a pure translation matrix.");

        if (!(m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon)))
            throw new ArgumentException("Matrix contains perspective components.");

        if (m.M22.IsTiny(epsilon))
            throw new ArgumentException("Matrix is not homogeneous.");

        return new(m.C2.XY / m.M22);
    }

    /// <summary>
    /// Creates a <see cref="Shift2f"/> transformation from a <see cref="Euclidean2f"/>.
    /// The transformation <paramref name="euclidean"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2f FromEuclidean2f(Euclidean2f euclidean, float epsilon = 1e-5f)
    {
        if (!euclidean.Rot.ApproximateEquals(Rot2f.Identity, epsilon))
            throw new ArgumentException("Euclidean transformation contains rotational component");

        return new(euclidean.Trans);
    }

    /// <summary>
    /// Creates a <see cref="Shift2f"/> transformation from a <see cref="Similarity2f"/>.
    /// The transformation <paramref name="similarity"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2f FromSimilarity2f(Similarity2f similarity, float epsilon = 1e-5f)
    {
        if (!similarity.Scale.ApproximateEquals(1, epsilon))
            throw new ArgumentException("Similarity transformation contains scaling component");

        if (!similarity.Rot.ApproximateEquals(Rot2f.Identity, epsilon))
            throw new ArgumentException("Similarity transformation contains rotational component");

        return new(similarity.Trans);
    }

    /// <summary>
    /// Creates a <see cref="Shift2f"/> transformation from an <see cref="Affine2f"/>.
    /// The transformation <paramref name="affine"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2f FromAffine2f(Affine2f affine, float epsilon = 1e-5f)
        => FromM33f((M33f)affine, epsilon);

    /// <summary>
    /// Creates a <see cref="Shift2f"/> transformation from a <see cref="Trafo2f"/>.
    /// The transformation <paramref name="trafo"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2f FromTrafo2f(Trafo2f trafo, float epsilon = 1e-5f)
        => FromM33f(trafo.Forward, epsilon);

    #endregion

    #region Conversion

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M33f(Shift2f s)
        => new(
            1, 0, s.X, 
            0, 1, s.Y,
            0, 0, 1);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M23f(Shift2f s)
        => new(
            1, 0, s.X, 
            0, 1, s.Y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M44f(Shift2f s)
        => new(
            1, 0, 0, s.X, 
            0, 1, 0, s.Y, 
            0, 0, 1, 0,
            0, 0, 0, 1);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M34f(Shift2f s)
        => new(
            1, 0, 0, s.X, 
            0, 1, 0, s.Y, 
            0, 0, 1, 0);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Euclidean2f(Shift2f s)
        => new(Rot2f.Identity, s.V);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Similarity2f(Shift2f s)
        => new(1, Rot2f.Identity, s.V);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Affine2f(Shift2f s)
        => new(M22f.Identity, s.V);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Trafo2f(Shift2f s)
        => new((M33f)s, (M33f)s.Inverse);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Shift2d(Shift2f s)
        => new((V2d)s.V);

    /// <summary>
    /// Returns all values of a <see cref="Shift2f"/> instance
    /// in a float[] array.
    /// </summary>
    public static explicit operator float[](Shift2f shift)
    {
        var array = new float[2];
        array[0] = shift.X;
        array[1] = shift.Y;
        return array;
    }

    #endregion

    #region Indexing

    public float this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get => V[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => V[index] = value;
    }

    #endregion

    #region Overrides

    public override readonly int GetHashCode()
        => V.GetHashCode();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Equals(Shift2f other)
        => X.Equals(other.X) && Y.Equals(other.Y);

    public override readonly bool Equals(object other)
        => (other is Shift2f o) && Equals(o);

    public override readonly string ToString()
        => string.Format(CultureInfo.InvariantCulture, "[{0}, {1}]", X, Y);

    public static Shift2f Parse(string s)
    {
        var x = s.NestedBracketSplitLevelOne().ToArray();
        return new(
            float.Parse(x[0], CultureInfo.InvariantCulture), 
            float.Parse(x[1], CultureInfo.InvariantCulture)
        );
    }

    #endregion
}

public static partial class Shift
{
    #region Invert

    /// <summary>
    /// Returns the inverse of a <see cref="Shift2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2f Inverse(Shift2f shift)
        => shift.Inverse;

    /// <summary>
    /// Inverts a <see cref="Shift2f"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Invert(this ref Shift2f shift)
    {
        shift.V.X = -shift.V.X;
        shift.V.Y = -shift.V.Y;
    }

    #endregion

    #region Transformations

    /// <summary>
    /// Transforms a <see cref="V2f"/> vector by a <see cref="Shift2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V2f Transform(this Shift2f s, V2f v)
        => new(v.X + s.X, v.Y + s.Y);

    /// <summary>
    /// Transforms a <see cref="V2f"/> vector by the inverse of a <see cref="Shift2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V2f InvTransform(this Shift2f s, V2f v)
        => new(v.X - s.X, v.Y - s.Y);

    /// <summary>
    /// Transforms a <see cref="V3f"/> vector by a <see cref="Shift2f"/> transformation.
    /// v.Z is not modified.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3f Transform(this Shift2f s, V3f v)
        => new(v.X + s.X, v.Y + s.Y, v.Z);

    /// <summary>
    /// Transforms a <see cref="V3f"/> vector by the inverse of a <see cref="Shift2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3f InvTransform(this Shift2f s, V3f v)
        => new(v.X - s.X, v.Y - s.Y, v.Z);

    /// <summary>
    /// Transforms a <see cref="V4f"/> vector by a <see cref="Shift2f"/> transformation.
    /// v.Z and v.W are not modified.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4f Transform(this Shift2f s, V4f v)
        => new(v.X + s.X, v.Y + s.Y, v.Z, v.W);

    /// <summary>
    /// Transforms a <see cref="V4f"/> vector by the inverse of a <see cref="Shift2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4f InvTransform(this Shift2f s, V4f v)
        => new(v.X - s.X, v.Y - s.Y, v.Z, v.W);

    #endregion
}

public static partial class Fun
{
    #region ApproximateEquals

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Shift2f s0, Shift2f s1)
        => ApproximateEquals(s0.V, s1.V, Constant<float>.PositiveTinyValue);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Shift2f s0, Shift2f s1, float tolerance)
        => ApproximateEquals(s0.V, s1.V, tolerance);

    #endregion
}

#endregion

#region Shift3f

/// <summary>
/// A 3-dimensional translational transform with different translation values
/// in each dimension.
/// </summary>
[DataContract]
[StructLayout(LayoutKind.Sequential)]
public partial struct Shift3f : IEquatable<Shift3f>
{
    [DataMember]
    [XmlIgnore]
    public V3f V;

    #region Constructors

    /// <summary>
    /// Constructs a <see cref="Shift3f"/> transformation from 3 floats.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift3f(float x, float y, float z)
    {
        V = new(x, y, z);
    }

    /// <summary>
    /// Constructs a <see cref="Shift3f"/> from a <see cref="V3f"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift3f(V3f v)
    {
        V = v;
    }

    /// <summary>
    /// Constructs a copy of a <see cref="Shift3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift3f(Shift3f s)
    {
        V = s.V;
    }

    /// <summary>
    /// Constructs a <see cref="Shift3f"/> transformation from a <see cref="Shift3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift3f(Shift3d shift)
    {
        V = (V3f)shift.V;
    }

    /// <summary>
    /// Constructs a <see cref="Shift3f"/> transformation from a float-array.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift3f(float[] array)
    {
        V = new(array);
    }

    /// <summary>
    /// Constructs a <see cref="Shift3f"/> transformation from a float-array starting from the given index.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift3f(float[] array, int start)
    {
        V = new(array, start);
    }

    #endregion

    #region Properties

    /// <summary>
    /// Gets and sets the X coordinate.
    /// </summary>
    public float X
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.X; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.X = value; }
    }

    /// <summary>
    /// Gets and sets the Y coordinate.
    /// </summary>
    public float Y
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.Y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.Y = value; }
    }

    /// <summary>
    /// Gets and sets the Z coordinate.
    /// </summary>
    public float Z
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.Z; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.Z = value; }
    }

    /// <summary>
    /// Gets the length of this <see cref="Shift3f"/> transformation.
    /// </summary>
    public readonly float Length
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return V.Length; }
    }

    /// <summary>
    /// Gets the squared length of this <see cref="Shift3f"/> transformation.
    /// </summary>
    public readonly float LengthSquared
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return V.LengthSquared; }
    }

    /// <summary>
    /// Gets the inverse of this <see cref="Shift3f"/> transformation.
    /// </summary>
    public readonly Shift3f Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return new(-V); }
    }

    /// <summary>
    /// Gets the reciprocal of this <see cref="Shift3f"/> transformation.
    /// </summary>
    public readonly Shift3f Reciprocal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1 / V);
    }

    #endregion

    #region Constants

    /// <summary>
    /// Gets the identity <see cref="Shift3f"/> transformation.
    /// </summary>
    public static Shift3f Identity
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 0, 0);
    }

    /// <summary>
    /// Gets a <see cref="Shift3f"/> transformation with all components set to zero.
    /// Note: Equivalent to Identity.
    /// </summary>
    public static Shift3f Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Identity;
    }

    /// <summary>
    /// Gets a <see cref="Shift3f"/> transformation with components (1, 0, 0).
    /// </summary>
    public static Shift3f XAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1, 0, 0);
    }

    /// <summary>
    /// Gets a <see cref="Shift3f"/> transformation with components (0, 1, 0).
    /// </summary>
    public static Shift3f YAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 1, 0);
    }

    /// <summary>
    /// Gets a <see cref="Shift3f"/> transformation with components (0, 0, 1).
    /// </summary>
    public static Shift3f ZAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 0, 1);
    }

    #endregion

    #region Arithmetic Operators

    /// <summary>
    /// Negates the values of a <see cref="Shift3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f operator -(Shift3f shift)
        => new(-shift.X, -shift.Y, -shift.Z);

    #region Shift / Scalar

    /// <summary>
    /// Multiplies a <see cref="Shift3f"/> transformation with a float scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f operator *(Shift3f shift, float scalar)
        => new(shift.X * scalar, shift.Y * scalar, shift.Z * scalar);

    /// <summary>
    /// Multiplies a float scalar with a <see cref="Shift3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f operator *(float scalar, Shift3f shift)
        => new(shift.X * scalar, shift.Y * scalar, shift.Z * scalar);

    /// <summary>
    /// Divides a <see cref="Shift3f"/> transformation by a float scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f operator /(Shift3f shift, float scalar)
        => new(shift.X / scalar, shift.Y / scalar, shift.Z / scalar);

    /// <summary>
    /// Divides a float scalar by a <see cref="Shift3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f operator /(float scalar, Shift3f shift)
        => new(scalar / shift.X, scalar / shift.Y, scalar / shift.Z);

    #endregion

    #region Shift / Vector Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift3f"/> transformation with a <see cref="V3f"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3f operator *(Shift3f shift, V3f vector)
        => new(vector.X + shift.X, vector.Y + shift.Y, vector.Z + shift.Z);

    #endregion

    #region Shift / Shift Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift3f"/> transformation with a <see cref="Shift2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f operator *(Shift3f a, Shift2f b)
        => new(a.X + b.X, a.Y + b.Y, a.Z);

    /// <summary>
    /// Multiplies a <see cref="Shift3f"/> transformation with a <see cref="Shift3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f operator *(Shift3f a, Shift3f b)
        => new(a.X + b.X, a.Y + b.Y, a.Z + b.Z);

    #endregion

    #region Shift / Matrix Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift3f"/> transformation (as a 3x4 matrix) with a <see cref="M33f"/> (as a 4x4 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M34f operator *(Shift3f shift, M33f matrix)
        => new(matrix, shift.V);

    /// <summary>
    /// Multiplies a <see cref="M33f"/> with a <see cref="Shift3f"/> transformation (as a 3x4 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M34f operator *(M33f matrix, Shift3f shift)
        => new(matrix, matrix * shift.V);

    /// <summary>
    /// Multiplies a <see cref="Shift3f"/> transformation (as a 4x4 matrix) with a <see cref="M44f"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M44f operator *(Shift3f s, M44f m)
        => new(
            m.M00 + s.X * m.M30, 
            m.M01 + s.X * m.M31, 
            m.M02 + s.X * m.M32, 
            m.M03 + s.X * m.M33,

            m.M10 + s.Y * m.M30, 
            m.M11 + s.Y * m.M31, 
            m.M12 + s.Y * m.M32, 
            m.M13 + s.Y * m.M33,

            m.M20 + s.Z * m.M30, 
            m.M21 + s.Z * m.M31, 
            m.M22 + s.Z * m.M32, 
            m.M23 + s.Z * m.M33,

            m.M30, m.M31, m.M32, m.M33);

    /// <summary>
    /// Multiplies a <see cref="M44f"/> with a <see cref="Shift3f"/> transformation (as a 4x4 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M44f operator *(M44f m, Shift3f s)
        => new(
            m.M00, 
            m.M01, 
            m.M02,
            s.X * m.M00 + s.Y * m.M01 + s.Z * m.M02 + m.M03,

            m.M10, 
            m.M11, 
            m.M12,
            s.X * m.M10 + s.Y * m.M11 + s.Z * m.M12 + m.M13,

            m.M20, 
            m.M21, 
            m.M22,
            s.X * m.M20 + s.Y * m.M21 + s.Z * m.M22 + m.M23,

            m.M30, 
            m.M31, 
            m.M32,
            s.X * m.M30 + s.Y * m.M31 + s.Z * m.M32 + m.M33);

    /// <summary>
    /// Multiplies a <see cref="Shift3f"/> transformation (as a 3x4 matrix) with a <see cref="M34f"/> (as a 4x4 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M34f operator *(Shift3f s, M34f m)
        => new(
            m.M00, m.M01, m.M02, m.M03 + s.X, 
            m.M10, m.M11, m.M12, m.M13 + s.Y, 
            m.M20, m.M21, m.M22, m.M23 + s.Z);

    /// <summary>
    /// Multiplies a <see cref="M34f"/> with a <see cref="Shift3f"/> transformation (as a 4x4 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M34f operator *(M34f m, Shift3f s)
        => new(
            m.M00, 
            m.M01, 
            m.M02,
            s.X * m.M00 + s.Y * m.M01 + s.Z * m.M02 + m.M03,

            m.M10, 
            m.M11, 
            m.M12,
            s.X * m.M10 + s.Y * m.M11 + s.Z * m.M12 + m.M13,

            m.M20, 
            m.M21, 
            m.M22,
            s.X * m.M20 + s.Y * m.M21 + s.Z * m.M22 + m.M23);

    #endregion

    #region Shift / Rot, Scale Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift3f"/> transformation with a <see cref="Rot3f"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Euclidean3f operator *(Shift3f a, Rot3f b)
        => new(b, a.V);

    /// <summary>
    /// Multiplies a <see cref="Shift3f"/> transformation with a <see cref="Scale3f"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Affine3f operator *(Shift3f a, Scale3f b)
        => new((M33f)b, a.V);

    #endregion

    #endregion

    #region Comparison Operators

    /// <summary>
    /// Checks whether two <see cref="Shift3f"/> transformations are equal.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Shift3f s0, Shift3f s1)
        => s0.X == s1.X && s0.Y == s1.Y && s0.Z == s1.Z;

    /// <summary>
    /// Checks whether two <see cref="Shift3f"/> transformations are different.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Shift3f s0, Shift3f s1)
        => s0.X != s1.X || s0.Y != s1.Y || s0.Z != s1.Z;

    #endregion

    #region Static Creators

    /// <summary>
    /// Creates a <see cref="Shift3f"/> transformation from a <see cref="M34f"/> matrix.
    /// The matrix must only contain translation components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f FromM34f(M34f m, float epsilon = (float)1e-6)
    {
        if (!M33f.Identity.ApproximateEquals((M33f)m, epsilon))
            throw new ArgumentException("Matrix is not a pure translation matrix.");

        return new(m.C3);
    }

    /// <summary>
    /// Creates a <see cref="Shift3f"/> transformation from a translation <see cref="M44f"/> matrix.
    /// The matrix has to be homogeneous and must not contain perspective components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f FromM44f(M44f m, float epsilon = (float)1e-6)
    {
        if (!M33f.Identity.ApproximateEquals((M33f)m, epsilon))
            throw new ArgumentException("Matrix is not a pure translation matrix.");

        if (!(m.M30.IsTiny(epsilon) && m.M31.IsTiny(epsilon) && m.M32.IsTiny(epsilon)))
            throw new ArgumentException("Matrix contains perspective components.");

        if (m.M33.IsTiny(epsilon))
            throw new ArgumentException("Matrix is not homogeneous.");

        return new(m.C3.XYZ / m.M33);
    }

    /// <summary>
    /// Creates a <see cref="Shift3f"/> transformation from a <see cref="Euclidean3f"/>.
    /// The transformation <paramref name="euclidean"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f FromEuclidean3f(Euclidean3f euclidean, float epsilon = 1e-5f)
    {
        if (!euclidean.Rot.ApproximateEquals(Rot3f.Identity, epsilon))
            throw new ArgumentException("Euclidean transformation contains rotational component");

        return new(euclidean.Trans);
    }

    /// <summary>
    /// Creates a <see cref="Shift3f"/> transformation from a <see cref="Similarity3f"/>.
    /// The transformation <paramref name="similarity"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f FromSimilarity3f(Similarity3f similarity, float epsilon = 1e-5f)
    {
        if (!similarity.Scale.ApproximateEquals(1, epsilon))
            throw new ArgumentException("Similarity transformation contains scaling component");

        if (!similarity.Rot.ApproximateEquals(Rot3f.Identity, epsilon))
            throw new ArgumentException("Similarity transformation contains rotational component");

        return new(similarity.Trans);
    }

    /// <summary>
    /// Creates a <see cref="Shift3f"/> transformation from an <see cref="Affine3f"/>.
    /// The transformation <paramref name="affine"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f FromAffine3f(Affine3f affine, float epsilon = 1e-5f)
        => FromM44f((M44f)affine, epsilon);

    /// <summary>
    /// Creates a <see cref="Shift3f"/> transformation from a <see cref="Trafo3f"/>.
    /// The transformation <paramref name="trafo"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f FromTrafo3f(Trafo3f trafo, float epsilon = 1e-5f)
        => FromM44f(trafo.Forward, epsilon);

    #endregion

    #region Conversion

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M33f(Shift3f s)
        => new(
            1, 0, s.X, 
            0, 1, s.Y,
            0, 0, 1);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M23f(Shift3f s)
        => new(
            1, 0, s.X, 
            0, 1, s.Y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M44f(Shift3f s)
        => new(
            1, 0, 0, s.X, 
            0, 1, 0, s.Y, 
            0, 0, 1, s.Z,
            0, 0, 0, 1);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M34f(Shift3f s)
        => new(
            1, 0, 0, s.X, 
            0, 1, 0, s.Y, 
            0, 0, 1, s.Z);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Euclidean3f(Shift3f s)
        => new(Rot3f.Identity, s.V);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Similarity3f(Shift3f s)
        => new(1, Rot3f.Identity, s.V);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Affine3f(Shift3f s)
        => new(M33f.Identity, s.V);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Trafo3f(Shift3f s)
        => new((M44f)s, (M44f)s.Inverse);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Shift3d(Shift3f s)
        => new((V3d)s.V);

    /// <summary>
    /// Returns all values of a <see cref="Shift3f"/> instance
    /// in a float[] array.
    /// </summary>
    public static explicit operator float[](Shift3f shift)
    {
        var array = new float[3];
        array[0] = shift.X;
        array[1] = shift.Y;
        array[2] = shift.Z;
        return array;
    }

    #endregion

    #region Indexing

    public float this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get => V[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => V[index] = value;
    }

    #endregion

    #region Overrides

    public override readonly int GetHashCode()
        => V.GetHashCode();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Equals(Shift3f other)
        => X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z);

    public override readonly bool Equals(object other)
        => (other is Shift3f o) && Equals(o);

    public override readonly string ToString()
        => string.Format(CultureInfo.InvariantCulture, "[{0}, {1}, {2}]", X, Y, Z);

    public static Shift3f Parse(string s)
    {
        var x = s.NestedBracketSplitLevelOne().ToArray();
        return new(
            float.Parse(x[0], CultureInfo.InvariantCulture), 
            float.Parse(x[1], CultureInfo.InvariantCulture), 
            float.Parse(x[2], CultureInfo.InvariantCulture)
        );
    }

    #endregion
}

public static partial class Shift
{
    #region Invert

    /// <summary>
    /// Returns the inverse of a <see cref="Shift3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3f Inverse(Shift3f shift)
        => shift.Inverse;

    /// <summary>
    /// Inverts a <see cref="Shift3f"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Invert(this ref Shift3f shift)
    {
        shift.V.X = -shift.V.X;
        shift.V.Y = -shift.V.Y;
        shift.V.Z = -shift.V.Z;
    }

    #endregion

    #region Transformations

    /// <summary>
    /// Transforms a <see cref="V3f"/> vector by a <see cref="Shift3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3f Transform(this Shift3f s, V3f v)
        => new(v.X + s.X, v.Y + s.Y, v.Z + s.Z);

    /// <summary>
    /// Transforms a <see cref="V3f"/> vector by the inverse of a <see cref="Shift3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3f InvTransform(this Shift3f s, V3f v)
        => new(v.X - s.X, v.Y - s.Y, v.Z - s.Z);

    /// <summary>
    /// Transforms a <see cref="V4f"/> vector by a <see cref="Shift3f"/> transformation.
    /// v.W is not modified.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4f Transform(this Shift3f s, V4f v)
        => new(v.X + s.X, v.Y + s.Y, v.Z + s.Z, v.W);

    /// <summary>
    /// Transforms a <see cref="V4f"/> vector by the inverse of a <see cref="Shift3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4f InvTransform(this Shift3f s, V4f v)
        => new(v.X - s.X, v.Y - s.Y, v.Z - s.Z, v.W);

    #endregion
}

public static partial class Fun
{
    #region ApproximateEquals

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Shift3f s0, Shift3f s1)
        => ApproximateEquals(s0.V, s1.V, Constant<float>.PositiveTinyValue);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Shift3f s0, Shift3f s1, float tolerance)
        => ApproximateEquals(s0.V, s1.V, tolerance);

    #endregion
}

#endregion

#region Shift2d

/// <summary>
/// A 2-dimensional translational transform with different translation values
/// in each dimension.
/// </summary>
[DataContract]
[StructLayout(LayoutKind.Sequential)]
public partial struct Shift2d : IEquatable<Shift2d>
{
    [DataMember]
    [XmlIgnore]
    public V2d V;

    #region Constructors

    /// <summary>
    /// Constructs a <see cref="Shift2d"/> transformation from 2 doubles.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift2d(double x, double y)
    {
        V = new(x, y);
    }

    /// <summary>
    /// Constructs a <see cref="Shift2d"/> from a <see cref="V2d"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift2d(V2d v)
    {
        V = v;
    }

    /// <summary>
    /// Constructs a copy of a <see cref="Shift2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift2d(Shift2d s)
    {
        V = s.V;
    }

    /// <summary>
    /// Constructs a <see cref="Shift2d"/> transformation from a <see cref="Shift2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift2d(Shift2f shift)
    {
        V = (V2d)shift.V;
    }

    /// <summary>
    /// Constructs a <see cref="Shift2d"/> transformation from a double-array.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift2d(double[] array)
    {
        V = new(array);
    }

    /// <summary>
    /// Constructs a <see cref="Shift2d"/> transformation from a double-array starting from the given index.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift2d(double[] array, int start)
    {
        V = new(array, start);
    }

    #endregion

    #region Properties

    /// <summary>
    /// Gets and sets the X coordinate.
    /// </summary>
    public double X
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.X; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.X = value; }
    }

    /// <summary>
    /// Gets and sets the Y coordinate.
    /// </summary>
    public double Y
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.Y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.Y = value; }
    }

    /// <summary>
    /// Gets the length of this <see cref="Shift2d"/> transformation.
    /// </summary>
    public readonly double Length
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return V.Length; }
    }

    /// <summary>
    /// Gets the squared length of this <see cref="Shift2d"/> transformation.
    /// </summary>
    public readonly double LengthSquared
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return V.LengthSquared; }
    }

    /// <summary>
    /// Gets the inverse of this <see cref="Shift2d"/> transformation.
    /// </summary>
    public readonly Shift2d Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return new(-V); }
    }

    /// <summary>
    /// Gets the reciprocal of this <see cref="Shift2d"/> transformation.
    /// </summary>
    public readonly Shift2d Reciprocal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1 / V);
    }

    #endregion

    #region Constants

    /// <summary>
    /// Gets the identity <see cref="Shift2d"/> transformation.
    /// </summary>
    public static Shift2d Identity
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 0);
    }

    /// <summary>
    /// Gets a <see cref="Shift2d"/> transformation with all components set to zero.
    /// Note: Equivalent to Identity.
    /// </summary>
    public static Shift2d Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Identity;
    }

    /// <summary>
    /// Gets a <see cref="Shift2d"/> transformation with components (1, 0).
    /// </summary>
    public static Shift2d XAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1, 0);
    }

    /// <summary>
    /// Gets a <see cref="Shift2d"/> transformation with components (0, 1).
    /// </summary>
    public static Shift2d YAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 1);
    }

    #endregion

    #region Arithmetic Operators

    /// <summary>
    /// Negates the values of a <see cref="Shift2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2d operator -(Shift2d shift)
        => new(-shift.X, -shift.Y);

    #region Shift / Scalar

    /// <summary>
    /// Multiplies a <see cref="Shift2d"/> transformation with a double scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2d operator *(Shift2d shift, double scalar)
        => new(shift.X * scalar, shift.Y * scalar);

    /// <summary>
    /// Multiplies a double scalar with a <see cref="Shift2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2d operator *(double scalar, Shift2d shift)
        => new(shift.X * scalar, shift.Y * scalar);

    /// <summary>
    /// Divides a <see cref="Shift2d"/> transformation by a double scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2d operator /(Shift2d shift, double scalar)
        => new(shift.X / scalar, shift.Y / scalar);

    /// <summary>
    /// Divides a double scalar by a <see cref="Shift2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2d operator /(double scalar, Shift2d shift)
        => new(scalar / shift.X, scalar / shift.Y);

    #endregion

    #region Shift / Vector Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift2d"/> transformation with a <see cref="V2d"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V2d operator *(Shift2d shift, V2d vector)
        => new(vector.X + shift.X, vector.Y + shift.Y);

    #endregion

    #region Shift / Shift Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift2d"/> transformation with a <see cref="Shift2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2d operator *(Shift2d a, Shift2d b)
        => new(a.X + b.X, a.Y + b.Y);

    /// <summary>
    /// Multiplies a <see cref="Shift2d"/> transformation with a <see cref="Shift3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d operator *(Shift2d a, Shift3d b)
        => new(a.X + b.X, a.Y + b.Y, b.Z);

    #endregion

    #region Shift / Matrix Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift2d"/> transformation (as a 2x3 matrix) with a <see cref="M22d"/> (as a 3x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M23d operator *(Shift2d shift, M22d matrix)
        => new(matrix, shift.V);

    /// <summary>
    /// Multiplies a <see cref="M22d"/> with a <see cref="Shift2d"/> transformation (as a 2x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M23d operator *(M22d matrix, Shift2d shift)
        => new(matrix, matrix * shift.V);

    /// <summary>
    /// Multiplies a <see cref="Shift2d"/> transformation (as a 3x3 matrix) with a <see cref="M33d"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M33d operator *(Shift2d s, M33d m)
        => new(
            m.M00 + s.X * m.M20, 
            m.M01 + s.X * m.M21, 
            m.M02 + s.X * m.M22,

            m.M10 + s.Y * m.M20, 
            m.M11 + s.Y * m.M21, 
            m.M12 + s.Y * m.M22,

            m.M20, m.M21, m.M22);

    /// <summary>
    /// Multiplies a <see cref="M33d"/> with a <see cref="Shift2d"/> transformation (as a 3x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M33d operator *(M33d m, Shift2d s)
        => new(
            m.M00, 
            m.M01,
            s.X * m.M00 + s.Y * m.M01 + m.M02,

            m.M10, 
            m.M11,
            s.X * m.M10 + s.Y * m.M11 + m.M12,

            m.M20, 
            m.M21,
            s.X * m.M20 + s.Y * m.M21 + m.M22);

    /// <summary>
    /// Multiplies a <see cref="Shift2d"/> transformation (as a 2x3 matrix) with a <see cref="M23d"/> (as a 3x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M23d operator *(Shift2d s, M23d m)
        => new(
            m.M00, m.M01, m.M02 + s.X, 
            m.M10, m.M11, m.M12 + s.Y);

    /// <summary>
    /// Multiplies a <see cref="M23d"/> with a <see cref="Shift2d"/> transformation (as a 3x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M23d operator *(M23d m, Shift2d s)
        => new(
            m.M00, 
            m.M01,
            s.X * m.M00 + s.Y * m.M01 + m.M02,

            m.M10, 
            m.M11,
            s.X * m.M10 + s.Y * m.M11 + m.M12);

    #endregion

    #region Shift / Rot, Scale Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift2d"/> transformation with a <see cref="Rot2d"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Euclidean2d operator *(Shift2d a, Rot2d b)
        => new(b, a.V);

    /// <summary>
    /// Multiplies a <see cref="Shift2d"/> transformation with a <see cref="Scale2d"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Affine2d operator *(Shift2d a, Scale2d b)
        => new((M22d)b, a.V);

    #endregion

    #endregion

    #region Comparison Operators

    /// <summary>
    /// Checks whether two <see cref="Shift2d"/> transformations are equal.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Shift2d s0, Shift2d s1)
        => s0.X == s1.X && s0.Y == s1.Y;

    /// <summary>
    /// Checks whether two <see cref="Shift2d"/> transformations are different.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Shift2d s0, Shift2d s1)
        => s0.X != s1.X || s0.Y != s1.Y;

    #endregion

    #region Static Creators

    /// <summary>
    /// Creates a <see cref="Shift2d"/> transformation from a <see cref="M23d"/> matrix.
    /// The matrix must only contain translation components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2d FromM23d(M23d m, double epsilon = (double)1e-6)
    {
        if (!M22d.Identity.ApproximateEquals((M22d)m, epsilon))
            throw new ArgumentException("Matrix is not a pure translation matrix.");

        return new(m.C2);
    }

    /// <summary>
    /// Creates a <see cref="Shift2d"/> transformation from a translation <see cref="M33d"/> matrix.
    /// The matrix has to be homogeneous and must not contain perspective components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2d FromM33d(M33d m, double epsilon = (double)1e-6)
    {
        if (!M22d.Identity.ApproximateEquals((M22d)m, epsilon))
            throw new ArgumentException("Matrix is not a pure translation matrix.");

        if (!(m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon)))
            throw new ArgumentException("Matrix contains perspective components.");

        if (m.M22.IsTiny(epsilon))
            throw new ArgumentException("Matrix is not homogeneous.");

        return new(m.C2.XY / m.M22);
    }

    /// <summary>
    /// Creates a <see cref="Shift2d"/> transformation from a <see cref="Euclidean2d"/>.
    /// The transformation <paramref name="euclidean"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2d FromEuclidean2d(Euclidean2d euclidean, double epsilon = 1e-12)
    {
        if (!euclidean.Rot.ApproximateEquals(Rot2d.Identity, epsilon))
            throw new ArgumentException("Euclidean transformation contains rotational component");

        return new(euclidean.Trans);
    }

    /// <summary>
    /// Creates a <see cref="Shift2d"/> transformation from a <see cref="Similarity2d"/>.
    /// The transformation <paramref name="similarity"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2d FromSimilarity2d(Similarity2d similarity, double epsilon = 1e-12)
    {
        if (!similarity.Scale.ApproximateEquals(1, epsilon))
            throw new ArgumentException("Similarity transformation contains scaling component");

        if (!similarity.Rot.ApproximateEquals(Rot2d.Identity, epsilon))
            throw new ArgumentException("Similarity transformation contains rotational component");

        return new(similarity.Trans);
    }

    /// <summary>
    /// Creates a <see cref="Shift2d"/> transformation from an <see cref="Affine2d"/>.
    /// The transformation <paramref name="affine"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2d FromAffine2d(Affine2d affine, double epsilon = 1e-12)
        => FromM33d((M33d)affine, epsilon);

    /// <summary>
    /// Creates a <see cref="Shift2d"/> transformation from a <see cref="Trafo2d"/>.
    /// The transformation <paramref name="trafo"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2d FromTrafo2d(Trafo2d trafo, double epsilon = 1e-12)
        => FromM33d(trafo.Forward, epsilon);

    #endregion

    #region Conversion

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M33d(Shift2d s)
        => new(
            1, 0, s.X, 
            0, 1, s.Y,
            0, 0, 1);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M23d(Shift2d s)
        => new(
            1, 0, s.X, 
            0, 1, s.Y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M44d(Shift2d s)
        => new(
            1, 0, 0, s.X, 
            0, 1, 0, s.Y, 
            0, 0, 1, 0,
            0, 0, 0, 1);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M34d(Shift2d s)
        => new(
            1, 0, 0, s.X, 
            0, 1, 0, s.Y, 
            0, 0, 1, 0);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Euclidean2d(Shift2d s)
        => new(Rot2d.Identity, s.V);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Similarity2d(Shift2d s)
        => new(1, Rot2d.Identity, s.V);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Affine2d(Shift2d s)
        => new(M22d.Identity, s.V);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Trafo2d(Shift2d s)
        => new((M33d)s, (M33d)s.Inverse);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Shift2f(Shift2d s)
        => new((V2f)s.V);

    /// <summary>
    /// Returns all values of a <see cref="Shift2d"/> instance
    /// in a double[] array.
    /// </summary>
    public static explicit operator double[](Shift2d shift)
    {
        var array = new double[2];
        array[0] = shift.X;
        array[1] = shift.Y;
        return array;
    }

    #endregion

    #region Indexing

    public double this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get => V[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => V[index] = value;
    }

    #endregion

    #region Overrides

    public override readonly int GetHashCode()
        => V.GetHashCode();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Equals(Shift2d other)
        => X.Equals(other.X) && Y.Equals(other.Y);

    public override readonly bool Equals(object other)
        => (other is Shift2d o) && Equals(o);

    public override readonly string ToString()
        => string.Format(CultureInfo.InvariantCulture, "[{0}, {1}]", X, Y);

    public static Shift2d Parse(string s)
    {
        var x = s.NestedBracketSplitLevelOne().ToArray();
        return new(
            double.Parse(x[0], CultureInfo.InvariantCulture), 
            double.Parse(x[1], CultureInfo.InvariantCulture)
        );
    }

    #endregion
}

public static partial class Shift
{
    #region Invert

    /// <summary>
    /// Returns the inverse of a <see cref="Shift2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift2d Inverse(Shift2d shift)
        => shift.Inverse;

    /// <summary>
    /// Inverts a <see cref="Shift2d"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Invert(this ref Shift2d shift)
    {
        shift.V.X = -shift.V.X;
        shift.V.Y = -shift.V.Y;
    }

    #endregion

    #region Transformations

    /// <summary>
    /// Transforms a <see cref="V2d"/> vector by a <see cref="Shift2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V2d Transform(this Shift2d s, V2d v)
        => new(v.X + s.X, v.Y + s.Y);

    /// <summary>
    /// Transforms a <see cref="V2d"/> vector by the inverse of a <see cref="Shift2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V2d InvTransform(this Shift2d s, V2d v)
        => new(v.X - s.X, v.Y - s.Y);

    /// <summary>
    /// Transforms a <see cref="V3d"/> vector by a <see cref="Shift2d"/> transformation.
    /// v.Z is not modified.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3d Transform(this Shift2d s, V3d v)
        => new(v.X + s.X, v.Y + s.Y, v.Z);

    /// <summary>
    /// Transforms a <see cref="V3d"/> vector by the inverse of a <see cref="Shift2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3d InvTransform(this Shift2d s, V3d v)
        => new(v.X - s.X, v.Y - s.Y, v.Z);

    /// <summary>
    /// Transforms a <see cref="V4d"/> vector by a <see cref="Shift2d"/> transformation.
    /// v.Z and v.W are not modified.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4d Transform(this Shift2d s, V4d v)
        => new(v.X + s.X, v.Y + s.Y, v.Z, v.W);

    /// <summary>
    /// Transforms a <see cref="V4d"/> vector by the inverse of a <see cref="Shift2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4d InvTransform(this Shift2d s, V4d v)
        => new(v.X - s.X, v.Y - s.Y, v.Z, v.W);

    #endregion
}

public static partial class Fun
{
    #region ApproximateEquals

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Shift2d s0, Shift2d s1)
        => ApproximateEquals(s0.V, s1.V, Constant<double>.PositiveTinyValue);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Shift2d s0, Shift2d s1, double tolerance)
        => ApproximateEquals(s0.V, s1.V, tolerance);

    #endregion
}

#endregion

#region Shift3d

/// <summary>
/// A 3-dimensional translational transform with different translation values
/// in each dimension.
/// </summary>
[DataContract]
[StructLayout(LayoutKind.Sequential)]
public partial struct Shift3d : IEquatable<Shift3d>
{
    [DataMember]
    [XmlIgnore]
    public V3d V;

    #region Constructors

    /// <summary>
    /// Constructs a <see cref="Shift3d"/> transformation from 3 doubles.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift3d(double x, double y, double z)
    {
        V = new(x, y, z);
    }

    /// <summary>
    /// Constructs a <see cref="Shift3d"/> from a <see cref="V3d"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift3d(V3d v)
    {
        V = v;
    }

    /// <summary>
    /// Constructs a copy of a <see cref="Shift3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift3d(Shift3d s)
    {
        V = s.V;
    }

    /// <summary>
    /// Constructs a <see cref="Shift3d"/> transformation from a <see cref="Shift3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift3d(Shift3f shift)
    {
        V = (V3d)shift.V;
    }

    /// <summary>
    /// Constructs a <see cref="Shift3d"/> transformation from a double-array.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift3d(double[] array)
    {
        V = new(array);
    }

    /// <summary>
    /// Constructs a <see cref="Shift3d"/> transformation from a double-array starting from the given index.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Shift3d(double[] array, int start)
    {
        V = new(array, start);
    }

    #endregion

    #region Properties

    /// <summary>
    /// Gets and sets the X coordinate.
    /// </summary>
    public double X
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.X; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.X = value; }
    }

    /// <summary>
    /// Gets and sets the Y coordinate.
    /// </summary>
    public double Y
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.Y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.Y = value; }
    }

    /// <summary>
    /// Gets and sets the Z coordinate.
    /// </summary>
    public double Z
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.Z; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.Z = value; }
    }

    /// <summary>
    /// Gets the length of this <see cref="Shift3d"/> transformation.
    /// </summary>
    public readonly double Length
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return V.Length; }
    }

    /// <summary>
    /// Gets the squared length of this <see cref="Shift3d"/> transformation.
    /// </summary>
    public readonly double LengthSquared
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return V.LengthSquared; }
    }

    /// <summary>
    /// Gets the inverse of this <see cref="Shift3d"/> transformation.
    /// </summary>
    public readonly Shift3d Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return new(-V); }
    }

    /// <summary>
    /// Gets the reciprocal of this <see cref="Shift3d"/> transformation.
    /// </summary>
    public readonly Shift3d Reciprocal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1 / V);
    }

    #endregion

    #region Constants

    /// <summary>
    /// Gets the identity <see cref="Shift3d"/> transformation.
    /// </summary>
    public static Shift3d Identity
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 0, 0);
    }

    /// <summary>
    /// Gets a <see cref="Shift3d"/> transformation with all components set to zero.
    /// Note: Equivalent to Identity.
    /// </summary>
    public static Shift3d Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => Identity;
    }

    /// <summary>
    /// Gets a <see cref="Shift3d"/> transformation with components (1, 0, 0).
    /// </summary>
    public static Shift3d XAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1, 0, 0);
    }

    /// <summary>
    /// Gets a <see cref="Shift3d"/> transformation with components (0, 1, 0).
    /// </summary>
    public static Shift3d YAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 1, 0);
    }

    /// <summary>
    /// Gets a <see cref="Shift3d"/> transformation with components (0, 0, 1).
    /// </summary>
    public static Shift3d ZAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 0, 1);
    }

    #endregion

    #region Arithmetic Operators

    /// <summary>
    /// Negates the values of a <see cref="Shift3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d operator -(Shift3d shift)
        => new(-shift.X, -shift.Y, -shift.Z);

    #region Shift / Scalar

    /// <summary>
    /// Multiplies a <see cref="Shift3d"/> transformation with a double scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d operator *(Shift3d shift, double scalar)
        => new(shift.X * scalar, shift.Y * scalar, shift.Z * scalar);

    /// <summary>
    /// Multiplies a double scalar with a <see cref="Shift3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d operator *(double scalar, Shift3d shift)
        => new(shift.X * scalar, shift.Y * scalar, shift.Z * scalar);

    /// <summary>
    /// Divides a <see cref="Shift3d"/> transformation by a double scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d operator /(Shift3d shift, double scalar)
        => new(shift.X / scalar, shift.Y / scalar, shift.Z / scalar);

    /// <summary>
    /// Divides a double scalar by a <see cref="Shift3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d operator /(double scalar, Shift3d shift)
        => new(scalar / shift.X, scalar / shift.Y, scalar / shift.Z);

    #endregion

    #region Shift / Vector Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift3d"/> transformation with a <see cref="V3d"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3d operator *(Shift3d shift, V3d vector)
        => new(vector.X + shift.X, vector.Y + shift.Y, vector.Z + shift.Z);

    #endregion

    #region Shift / Shift Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift3d"/> transformation with a <see cref="Shift2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d operator *(Shift3d a, Shift2d b)
        => new(a.X + b.X, a.Y + b.Y, a.Z);

    /// <summary>
    /// Multiplies a <see cref="Shift3d"/> transformation with a <see cref="Shift3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d operator *(Shift3d a, Shift3d b)
        => new(a.X + b.X, a.Y + b.Y, a.Z + b.Z);

    #endregion

    #region Shift / Matrix Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift3d"/> transformation (as a 3x4 matrix) with a <see cref="M33d"/> (as a 4x4 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M34d operator *(Shift3d shift, M33d matrix)
        => new(matrix, shift.V);

    /// <summary>
    /// Multiplies a <see cref="M33d"/> with a <see cref="Shift3d"/> transformation (as a 3x4 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M34d operator *(M33d matrix, Shift3d shift)
        => new(matrix, matrix * shift.V);

    /// <summary>
    /// Multiplies a <see cref="Shift3d"/> transformation (as a 4x4 matrix) with a <see cref="M44d"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M44d operator *(Shift3d s, M44d m)
        => new(
            m.M00 + s.X * m.M30, 
            m.M01 + s.X * m.M31, 
            m.M02 + s.X * m.M32, 
            m.M03 + s.X * m.M33,

            m.M10 + s.Y * m.M30, 
            m.M11 + s.Y * m.M31, 
            m.M12 + s.Y * m.M32, 
            m.M13 + s.Y * m.M33,

            m.M20 + s.Z * m.M30, 
            m.M21 + s.Z * m.M31, 
            m.M22 + s.Z * m.M32, 
            m.M23 + s.Z * m.M33,

            m.M30, m.M31, m.M32, m.M33);

    /// <summary>
    /// Multiplies a <see cref="M44d"/> with a <see cref="Shift3d"/> transformation (as a 4x4 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M44d operator *(M44d m, Shift3d s)
        => new(
            m.M00, 
            m.M01, 
            m.M02,
            s.X * m.M00 + s.Y * m.M01 + s.Z * m.M02 + m.M03,

            m.M10, 
            m.M11, 
            m.M12,
            s.X * m.M10 + s.Y * m.M11 + s.Z * m.M12 + m.M13,

            m.M20, 
            m.M21, 
            m.M22,
            s.X * m.M20 + s.Y * m.M21 + s.Z * m.M22 + m.M23,

            m.M30, 
            m.M31, 
            m.M32,
            s.X * m.M30 + s.Y * m.M31 + s.Z * m.M32 + m.M33);

    /// <summary>
    /// Multiplies a <see cref="Shift3d"/> transformation (as a 3x4 matrix) with a <see cref="M34d"/> (as a 4x4 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M34d operator *(Shift3d s, M34d m)
        => new(
            m.M00, m.M01, m.M02, m.M03 + s.X, 
            m.M10, m.M11, m.M12, m.M13 + s.Y, 
            m.M20, m.M21, m.M22, m.M23 + s.Z);

    /// <summary>
    /// Multiplies a <see cref="M34d"/> with a <see cref="Shift3d"/> transformation (as a 4x4 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M34d operator *(M34d m, Shift3d s)
        => new(
            m.M00, 
            m.M01, 
            m.M02,
            s.X * m.M00 + s.Y * m.M01 + s.Z * m.M02 + m.M03,

            m.M10, 
            m.M11, 
            m.M12,
            s.X * m.M10 + s.Y * m.M11 + s.Z * m.M12 + m.M13,

            m.M20, 
            m.M21, 
            m.M22,
            s.X * m.M20 + s.Y * m.M21 + s.Z * m.M22 + m.M23);

    #endregion

    #region Shift / Rot, Scale Multiplication

    /// <summary>
    /// Multiplies a <see cref="Shift3d"/> transformation with a <see cref="Rot3d"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Euclidean3d operator *(Shift3d a, Rot3d b)
        => new(b, a.V);

    /// <summary>
    /// Multiplies a <see cref="Shift3d"/> transformation with a <see cref="Scale3d"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Affine3d operator *(Shift3d a, Scale3d b)
        => new((M33d)b, a.V);

    #endregion

    #endregion

    #region Comparison Operators

    /// <summary>
    /// Checks whether two <see cref="Shift3d"/> transformations are equal.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Shift3d s0, Shift3d s1)
        => s0.X == s1.X && s0.Y == s1.Y && s0.Z == s1.Z;

    /// <summary>
    /// Checks whether two <see cref="Shift3d"/> transformations are different.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Shift3d s0, Shift3d s1)
        => s0.X != s1.X || s0.Y != s1.Y || s0.Z != s1.Z;

    #endregion

    #region Static Creators

    /// <summary>
    /// Creates a <see cref="Shift3d"/> transformation from a <see cref="M34d"/> matrix.
    /// The matrix must only contain translation components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d FromM34d(M34d m, double epsilon = (double)1e-6)
    {
        if (!M33d.Identity.ApproximateEquals((M33d)m, epsilon))
            throw new ArgumentException("Matrix is not a pure translation matrix.");

        return new(m.C3);
    }

    /// <summary>
    /// Creates a <see cref="Shift3d"/> transformation from a translation <see cref="M44d"/> matrix.
    /// The matrix has to be homogeneous and must not contain perspective components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d FromM44d(M44d m, double epsilon = (double)1e-6)
    {
        if (!M33d.Identity.ApproximateEquals((M33d)m, epsilon))
            throw new ArgumentException("Matrix is not a pure translation matrix.");

        if (!(m.M30.IsTiny(epsilon) && m.M31.IsTiny(epsilon) && m.M32.IsTiny(epsilon)))
            throw new ArgumentException("Matrix contains perspective components.");

        if (m.M33.IsTiny(epsilon))
            throw new ArgumentException("Matrix is not homogeneous.");

        return new(m.C3.XYZ / m.M33);
    }

    /// <summary>
    /// Creates a <see cref="Shift3d"/> transformation from a <see cref="Euclidean3d"/>.
    /// The transformation <paramref name="euclidean"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d FromEuclidean3d(Euclidean3d euclidean, double epsilon = 1e-12)
    {
        if (!euclidean.Rot.ApproximateEquals(Rot3d.Identity, epsilon))
            throw new ArgumentException("Euclidean transformation contains rotational component");

        return new(euclidean.Trans);
    }

    /// <summary>
    /// Creates a <see cref="Shift3d"/> transformation from a <see cref="Similarity3d"/>.
    /// The transformation <paramref name="similarity"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d FromSimilarity3d(Similarity3d similarity, double epsilon = 1e-12)
    {
        if (!similarity.Scale.ApproximateEquals(1, epsilon))
            throw new ArgumentException("Similarity transformation contains scaling component");

        if (!similarity.Rot.ApproximateEquals(Rot3d.Identity, epsilon))
            throw new ArgumentException("Similarity transformation contains rotational component");

        return new(similarity.Trans);
    }

    /// <summary>
    /// Creates a <see cref="Shift3d"/> transformation from an <see cref="Affine3d"/>.
    /// The transformation <paramref name="affine"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d FromAffine3d(Affine3d affine, double epsilon = 1e-12)
        => FromM44d((M44d)affine, epsilon);

    /// <summary>
    /// Creates a <see cref="Shift3d"/> transformation from a <see cref="Trafo3d"/>.
    /// The transformation <paramref name="trafo"/> must only consist of a translation.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d FromTrafo3d(Trafo3d trafo, double epsilon = 1e-12)
        => FromM44d(trafo.Forward, epsilon);

    #endregion

    #region Conversion

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M33d(Shift3d s)
        => new(
            1, 0, s.X, 
            0, 1, s.Y,
            0, 0, 1);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M23d(Shift3d s)
        => new(
            1, 0, s.X, 
            0, 1, s.Y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M44d(Shift3d s)
        => new(
            1, 0, 0, s.X, 
            0, 1, 0, s.Y, 
            0, 0, 1, s.Z,
            0, 0, 0, 1);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M34d(Shift3d s)
        => new(
            1, 0, 0, s.X, 
            0, 1, 0, s.Y, 
            0, 0, 1, s.Z);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Euclidean3d(Shift3d s)
        => new(Rot3d.Identity, s.V);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Similarity3d(Shift3d s)
        => new(1, Rot3d.Identity, s.V);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Affine3d(Shift3d s)
        => new(M33d.Identity, s.V);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Trafo3d(Shift3d s)
        => new((M44d)s, (M44d)s.Inverse);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Shift3f(Shift3d s)
        => new((V3f)s.V);

    /// <summary>
    /// Returns all values of a <see cref="Shift3d"/> instance
    /// in a double[] array.
    /// </summary>
    public static explicit operator double[](Shift3d shift)
    {
        var array = new double[3];
        array[0] = shift.X;
        array[1] = shift.Y;
        array[2] = shift.Z;
        return array;
    }

    #endregion

    #region Indexing

    public double this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get => V[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => V[index] = value;
    }

    #endregion

    #region Overrides

    public override readonly int GetHashCode()
        => V.GetHashCode();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Equals(Shift3d other)
        => X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z);

    public override readonly bool Equals(object other)
        => (other is Shift3d o) && Equals(o);

    public override readonly string ToString()
        => string.Format(CultureInfo.InvariantCulture, "[{0}, {1}, {2}]", X, Y, Z);

    public static Shift3d Parse(string s)
    {
        var x = s.NestedBracketSplitLevelOne().ToArray();
        return new(
            double.Parse(x[0], CultureInfo.InvariantCulture), 
            double.Parse(x[1], CultureInfo.InvariantCulture), 
            double.Parse(x[2], CultureInfo.InvariantCulture)
        );
    }

    #endregion
}

public static partial class Shift
{
    #region Invert

    /// <summary>
    /// Returns the inverse of a <see cref="Shift3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Shift3d Inverse(Shift3d shift)
        => shift.Inverse;

    /// <summary>
    /// Inverts a <see cref="Shift3d"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Invert(this ref Shift3d shift)
    {
        shift.V.X = -shift.V.X;
        shift.V.Y = -shift.V.Y;
        shift.V.Z = -shift.V.Z;
    }

    #endregion

    #region Transformations

    /// <summary>
    /// Transforms a <see cref="V3d"/> vector by a <see cref="Shift3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3d Transform(this Shift3d s, V3d v)
        => new(v.X + s.X, v.Y + s.Y, v.Z + s.Z);

    /// <summary>
    /// Transforms a <see cref="V3d"/> vector by the inverse of a <see cref="Shift3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3d InvTransform(this Shift3d s, V3d v)
        => new(v.X - s.X, v.Y - s.Y, v.Z - s.Z);

    /// <summary>
    /// Transforms a <see cref="V4d"/> vector by a <see cref="Shift3d"/> transformation.
    /// v.W is not modified.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4d Transform(this Shift3d s, V4d v)
        => new(v.X + s.X, v.Y + s.Y, v.Z + s.Z, v.W);

    /// <summary>
    /// Transforms a <see cref="V4d"/> vector by the inverse of a <see cref="Shift3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4d InvTransform(this Shift3d s, V4d v)
        => new(v.X - s.X, v.Y - s.Y, v.Z - s.Z, v.W);

    #endregion
}

public static partial class Fun
{
    #region ApproximateEquals

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Shift3d s0, Shift3d s1)
        => ApproximateEquals(s0.V, s1.V, Constant<double>.PositiveTinyValue);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Shift3d s0, Shift3d s1, double tolerance)
        => ApproximateEquals(s0.V, s1.V, tolerance);

    #endregion
}

#endregion

