using System;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    #region Shift2f

    /// <summary>
    /// A 2-dimensional translational transform with different translation values
    /// in each dimension.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Shift2f
    {
        [DataMember]
        public V2f V;

        #region Constructors

        /// <summary>
        /// Constructs a <see cref="Shift2f"/> transformation from 2 floats.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift2f(float x, float y)
        {
            V = new V2f(x, y);
        }

        /// <summary>
        /// Constructs a <see cref="Shift2f"/> from a <see cref="V2f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift2f(V2f v)
        {
            V = v;
        }

        /// <summary>
        /// Constructs a copy of a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift2f(Shift2f s)
        {
            V = s.V;
        }

        /// <summary>
        /// Constructs a <see cref="Shift2f"/> transformation from a float-array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift2f(float[] array)
        {
            V = new V2f(array);
        }

        /// <summary>
        /// Constructs a <see cref="Shift2f"/> transformation from a float-array starting from the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift2f(float[] array, int start)
        {
            V = new V2f(array, start);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets and sets the X coordinate.
        /// </summary>
        public float X
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.X = value; }
        }

        /// <summary>
        /// Gets and sets the Y coordinate.
        /// </summary>
        public float Y
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Y = value; }
        }

        /// <summary>
        /// Gets the length of this <see cref="Shift2f"/> transformation.
        /// </summary>
        public float Length
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Length; }
        }

        /// <summary>
        /// Gets the squared length of this <see cref="Shift2f"/> transformation.
        /// </summary>
        public float LengthSquared
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.LengthSquared; }
        }

        /// <summary>
        /// Gets the inverse of this <see cref="Shift2f"/> transformation.
        /// </summary>
        public Shift2f Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Shift2f(-V); }
        }

        /// <summary>
        /// Gets the reciprocal of this <see cref="Shift2f"/> transformation.
        /// </summary>
        public Shift2f Reciprocal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift2f(1 / V);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity <see cref="Shift2f"/> transformation.
        /// </summary>
        public static Shift2f Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift2f(0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Shift2f"/> transformation with all components set to zero.
        /// Note: Equivalent to Identity.
        /// </summary>
        public static Shift2f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Identity;
        }

        /// <summary>
        /// Gets a <see cref="Shift2f"/> transformation with components (1, 0).
        /// </summary>
        public static Shift2f XAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift2f(1, 0);
        }

        /// <summary>
        /// Gets a <see cref="Shift2f"/> transformation with components (0, 1).
        /// </summary>
        public static Shift2f YAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift2f(0, 1);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Negates the values of a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2f operator -(Shift2f shift)
        {
            return new Shift2f(-shift.X, -shift.Y);
        }

        #region Shift / Scalar

        /// <summary>
        /// Multiplies a <see cref="Shift2f"/> transformation with a float scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2f operator *(Shift2f shift, float scalar)
        {
            return new Shift2f(shift.X * scalar, shift.Y * scalar);
        }

        /// <summary>
        /// Multiplies a float scalar with a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2f operator *(float scalar, Shift2f shift)
        {
            return new Shift2f(shift.X * scalar, shift.Y * scalar);
        }

        /// <summary>
        /// Divides a <see cref="Shift2f"/> transformation by a float scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2f operator /(Shift2f shift, float scalar)
        {
            return new Shift2f(shift.X / scalar, shift.Y / scalar);
        }

        /// <summary>
        /// Divides a float scalar by a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2f operator /(float scalar, Shift2f shift)
        {
            return new Shift2f(scalar / shift.X, scalar / shift.Y);
        }

        #endregion

        #region Shift / Vector Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift2f"/> transformation with a <see cref="V2f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f operator *(Shift2f shift, V2f vector)
        {
            return new V2f(vector.X + shift.X, vector.Y + shift.Y);
        }

        #endregion

        #region Shift / Shift Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift2f"/> transformation with a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2f operator *(Shift2f a, Shift2f b)
            => new Shift2f(a.X + b.X, a.Y + b.Y);

        /// <summary>
        /// Multiplies a <see cref="Shift2f"/> transformation with a <see cref="Shift3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f operator *(Shift2f a, Shift3f b)
            => new Shift3f(a.X + b.X, a.Y + b.Y, b.Z);

        #endregion

        #region Shift / Matrix Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift2f"/> transformation (as a 2x3 matrix) with a <see cref="M22f"/> (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator *(Shift2f shift, M22f matrix)
        {
            return new M23f(matrix, shift.V);
        }

        /// <summary>
        /// Multiplies a <see cref="M22f"/> with a <see cref="Shift2f"/> transformation (as a 2x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator *(M22f matrix, Shift2f shift)
        {
            return new M23f(matrix, matrix * shift.V);
        }

        /// <summary>
        /// Multiplies a <see cref="Shift2f"/> transformation (as a 3x3 matrix) with a <see cref="M33f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator *(Shift2f s, M33f m)
        {
            return new M33f(
                m.M00 + s.X * m.M20, 
                m.M01 + s.X * m.M21, 
                m.M02 + s.X * m.M22,

                m.M10 + s.Y * m.M20, 
                m.M11 + s.Y * m.M21, 
                m.M12 + s.Y * m.M22,

                m.M20, m.M21, m.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="M33f"/> with a <see cref="Shift2f"/> transformation (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator *(M33f m, Shift2f s)
        {
            return new M33f(
                m.M00, 
                m.M01,
                s.X * m.M00 + s.Y * m.M01 + m.M02,

                m.M10, 
                m.M11,
                s.X * m.M10 + s.Y * m.M11 + m.M12,

                m.M20, 
                m.M21,
                s.X * m.M20 + s.Y * m.M21 + m.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="Shift2f"/> transformation (as a 2x3 matrix) with a <see cref="M23f"/> (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator *(Shift2f s, M23f m)
        {
            return new M23f(
                m.M00, m.M01, m.M02 + s.X, 
                m.M10, m.M11, m.M12 + s.Y);
        }

        /// <summary>
        /// Multiplies a <see cref="M23f"/> with a <see cref="Shift2f"/> transformation (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator *(M23f m, Shift2f s)
        {
            return new M23f(
                m.M00, 
                m.M01,
                s.X * m.M00 + s.Y * m.M01 + m.M02,

                m.M10, 
                m.M11,
                s.X * m.M10 + s.Y * m.M11 + m.M12);
        }

        #endregion

        #region Shift / Rot, Scale Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift2f"/> transformation with a <see cref="Rot2f"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Euclidean2f operator *(Shift2f a, Rot2f b)
            => new Euclidean2f(b, a.V);

        /// <summary>
        /// Multiplies a <see cref="Shift2f"/> transformation with a <see cref="Scale2f"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f operator *(Shift2f a, Scale2f b)
            => new Affine2f((M22f)b, a.V);

        #endregion

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Shift2f"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Shift2f s0, Shift2f s1)
            => s0.X == s1.X && s0.Y == s1.Y;

        /// <summary>
        /// Checks whether two <see cref="Shift2f"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Shift2f s0, Shift2f s1)
            => s0.X != s1.X || s0.Y != s1.Y;

        #endregion

        #region Static Creators

        /// <summary>
        /// Creates a <see cref="Shift2f"/> transformation from a translation <see cref="M23f"/> matrix.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2f FromM23f(M23f m, float epsilon = (float)1e-6)
        {
            if (!M22f.Identity.ApproximateEquals((M22f)m, epsilon))
                throw new ArgumentException("Matrix is not a pure translation matrix.");

            return new Shift2f(m.C2);
        }

        /// <summary>
        /// Creates a <see cref="Shift2f"/> transformation from a translation <see cref="M33f"/> matrix.
        /// The matrix has to be homogeneous and must not contain perspective components.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2f FromM33f(M33f m, float epsilon = (float)1e-6)
        {
            if (!M22f.Identity.ApproximateEquals((M22f)m, epsilon))
                throw new ArgumentException("Matrix is not a pure translation matrix.");

            if (!(m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon)))
                throw new ArgumentException("Matrix contains perspective components.");

            if (m.M22.IsTiny(epsilon))
                throw new ArgumentException("Matrix is not homogeneous.");

            return new Shift2f(m.C2.XY / m.M22);
        }

        /// <summary>
        /// Creates a <see cref="Shift2f"/> transformation from a <see cref="Euclidean2f"/>.
        /// The transformation <paramref name="euclidean"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2f FromEuclidean2f(Euclidean2f euclidean, float epsilon = 1e-5f)
        {
            if (!euclidean.Rot.ApproximateEquals(Rot2f.Identity, epsilon))
                throw new ArgumentException("Euclidean transformation contains rotational component");

            return new Shift2f(euclidean.Trans);
        }

        /// <summary>
        /// Creates a <see cref="Shift2f"/> transformation from a <see cref="Similarity2f"/>.
        /// The transformation <paramref name="similarity"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2f FromSimilarity2f(Similarity2f similarity, float epsilon = 1e-5f)
        {
            if (!similarity.Scale.ApproximateEquals(1, epsilon))
                throw new ArgumentException("Similarity transformation contains scaling component");

            if (!similarity.Rot.ApproximateEquals(Rot2f.Identity, epsilon))
                throw new ArgumentException("Similarity transformation contains rotational component");

            return new Shift2f(similarity.Trans);
        }

        /// <summary>
        /// Creates a <see cref="Shift2f"/> transformation from an <see cref="Affine2f"/>.
        /// The transformation <paramref name="affine"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2f FromAffine2f(Affine2f affine, float epsilon = 1e-5f)
            => FromM33f((M33f)affine, epsilon);

        /// <summary>
        /// Creates a <see cref="Shift2f"/> transformation from a <see cref="Trafo2f"/>.
        /// The transformation <paramref name="trafo"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2f FromTrafo2f(Trafo2f trafo, float epsilon = 1e-5f)
            => FromM33f(trafo.Forward, epsilon);

        #endregion

        #region Conversion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33f(Shift2f s)
        {
            return new M33f(
                1, 0, s.X, 
                0, 1, s.Y,
                0, 0, 1);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M23f(Shift2f s)
        {
            return new M23f(
                1, 0, s.X, 
                0, 1, s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44f(Shift2f s)
        {
            return new M44f(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, 0,
                0, 0, 0, 1);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M34f(Shift2f s)
        {
            return new M34f(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Euclidean2f(Shift2f s)
            => new Euclidean2f(Rot2f.Identity, s.V);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Similarity2f(Shift2f s)
            => new Similarity2f(1, Rot2f.Identity, s.V);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine2f(Shift2f s)
            => new Affine2f(M22f.Identity, s.V);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Trafo2f(Shift2f s)
            => new Trafo2f((M33f)s, (M33f)s.Inverse);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Shift2d(Shift2f s)
            => new Shift2d((V2d)s.V);

        /// <summary>
        /// Returns all values of a <see cref="Shift2f"/> instance
        /// in a float[] array.
        /// </summary>
        public static explicit operator float[](Shift2f shift)
        {
            float[] array = new float[2];
            array[0] = shift.X;
            array[1] = shift.Y;
            return array;
        }

        #endregion

        #region Indexing

        public float this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                switch (index)
                {
                    case 0: return V.X;
                    case 1: return V.Y;
                    default: throw new IndexOutOfRangeException();
                }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                switch (index)
                {
                    case 0: V.X = value; return;
                    case 1: V.Y = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return V.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is Shift2f)
            {
                Shift2f v = (Shift2f)obj;
                return X == v.X && Y == v.Y;
            }
            return false;
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}]", X, Y);
        }

        public static Shift2f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Shift2f(
                float.Parse(x[0], CultureInfo.InvariantCulture), 
                float.Parse(x[1], CultureInfo.InvariantCulture)
            );
        }

        #endregion
    }

    public static partial class Shift
    {
        #region Invert

        /// <summary>
        /// Returns the inverse of a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2f Inverse(Shift2f shift)
            => shift.Inverse;

        /// <summary>
        /// Inverts a <see cref="Shift2f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Shift2f shift)
        {
            shift.V.X = -shift.V.X;
            shift.V.Y = -shift.V.Y;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V2f"/> vector by a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f Transform(this Shift2f s, V2f v)
            => new V2f(v.X + s.X, v.Y + s.Y);

        /// <summary>
        /// Transforms a <see cref="V2f"/> vector by the inverse of a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f InvTransform(this Shift2f s, V2f v)
            => new V2f(v.X - s.X, v.Y - s.Y);

        /// <summary>
        /// Transforms a <see cref="V3f"/> vector by a <see cref="Shift2f"/> transformation.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this Shift2f s, V3f v)
            => new V3f(v.X + s.X, v.Y + s.Y, v.Z);

        /// <summary>
        /// Transforms a <see cref="V3f"/> vector by the inverse of a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f InvTransform(this Shift2f s, V3f v)
            => new V3f(v.X - s.X, v.Y - s.Y, v.Z);

        /// <summary>
        /// Transforms a <see cref="V4f"/> vector by a <see cref="Shift2f"/> transformation.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Transform(this Shift2f s, V4f v)
            => new V4f(v.X + s.X, v.Y + s.Y, v.Z, v.W);

        /// <summary>
        /// Transforms a <see cref="V4f"/> vector by the inverse of a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f InvTransform(this Shift2f s, V4f v)
            => new V4f(v.X - s.X, v.Y - s.Y, v.Z, v.W);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Shift2f s0, Shift2f s1)
        {
            return ApproximateEquals(s0.V, s1.V, Constant<float>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Shift2f s0, Shift2f s1, float tolerance)
        {
            return ApproximateEquals(s0.V, s1.V, tolerance);
        }

        #endregion
    }

    #endregion

    #region Shift3f

    /// <summary>
    /// A 3-dimensional translational transform with different translation values
    /// in each dimension.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Shift3f
    {
        [DataMember]
        public V3f V;

        #region Constructors

        /// <summary>
        /// Constructs a <see cref="Shift3f"/> transformation from 3 floats.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift3f(float x, float y, float z)
        {
            V = new V3f(x, y, z);
        }

        /// <summary>
        /// Constructs a <see cref="Shift3f"/> from a <see cref="V3f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift3f(V3f v)
        {
            V = v;
        }

        /// <summary>
        /// Constructs a copy of a <see cref="Shift3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift3f(Shift3f s)
        {
            V = s.V;
        }

        /// <summary>
        /// Constructs a <see cref="Shift3f"/> transformation from a float-array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift3f(float[] array)
        {
            V = new V3f(array);
        }

        /// <summary>
        /// Constructs a <see cref="Shift3f"/> transformation from a float-array starting from the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift3f(float[] array, int start)
        {
            V = new V3f(array, start);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets and sets the X coordinate.
        /// </summary>
        public float X
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.X = value; }
        }

        /// <summary>
        /// Gets and sets the Y coordinate.
        /// </summary>
        public float Y
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Y = value; }
        }

        /// <summary>
        /// Gets and sets the Z coordinate.
        /// </summary>
        public float Z
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Z; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Z = value; }
        }

        /// <summary>
        /// Gets the length of this <see cref="Shift3f"/> transformation.
        /// </summary>
        public float Length
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Length; }
        }

        /// <summary>
        /// Gets the squared length of this <see cref="Shift3f"/> transformation.
        /// </summary>
        public float LengthSquared
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.LengthSquared; }
        }

        /// <summary>
        /// Gets the inverse of this <see cref="Shift3f"/> transformation.
        /// </summary>
        public Shift3f Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Shift3f(-V); }
        }

        /// <summary>
        /// Gets the reciprocal of this <see cref="Shift3f"/> transformation.
        /// </summary>
        public Shift3f Reciprocal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift3f(1 / V);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity <see cref="Shift3f"/> transformation.
        /// </summary>
        public static Shift3f Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift3f(0, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Shift3f"/> transformation with all components set to zero.
        /// Note: Equivalent to Identity.
        /// </summary>
        public static Shift3f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Identity;
        }

        /// <summary>
        /// Gets a <see cref="Shift3f"/> transformation with components (1, 0, 0).
        /// </summary>
        public static Shift3f XAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift3f(1, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Shift3f"/> transformation with components (0, 1, 0).
        /// </summary>
        public static Shift3f YAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift3f(0, 1, 0);
        }

        /// <summary>
        /// Gets a <see cref="Shift3f"/> transformation with components (0, 0, 1).
        /// </summary>
        public static Shift3f ZAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift3f(0, 0, 1);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Negates the values of a <see cref="Shift3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f operator -(Shift3f shift)
        {
            return new Shift3f(-shift.X, -shift.Y, -shift.Z);
        }

        #region Shift / Scalar

        /// <summary>
        /// Multiplies a <see cref="Shift3f"/> transformation with a float scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f operator *(Shift3f shift, float scalar)
        {
            return new Shift3f(shift.X * scalar, shift.Y * scalar, shift.Z * scalar);
        }

        /// <summary>
        /// Multiplies a float scalar with a <see cref="Shift3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f operator *(float scalar, Shift3f shift)
        {
            return new Shift3f(shift.X * scalar, shift.Y * scalar, shift.Z * scalar);
        }

        /// <summary>
        /// Divides a <see cref="Shift3f"/> transformation by a float scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f operator /(Shift3f shift, float scalar)
        {
            return new Shift3f(shift.X / scalar, shift.Y / scalar, shift.Z / scalar);
        }

        /// <summary>
        /// Divides a float scalar by a <see cref="Shift3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f operator /(float scalar, Shift3f shift)
        {
            return new Shift3f(scalar / shift.X, scalar / shift.Y, scalar / shift.Z);
        }

        #endregion

        #region Shift / Vector Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift3f"/> transformation with a <see cref="V3f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f operator *(Shift3f shift, V3f vector)
        {
            return new V3f(vector.X + shift.X, vector.Y + shift.Y, vector.Z + shift.Z);
        }

        #endregion

        #region Shift / Shift Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift3f"/> transformation with a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f operator *(Shift3f a, Shift2f b)
            => new Shift3f(a.X + b.X, a.Y + b.Y, a.Z);

        /// <summary>
        /// Multiplies a <see cref="Shift3f"/> transformation with a <see cref="Shift3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f operator *(Shift3f a, Shift3f b)
            => new Shift3f(a.X + b.X, a.Y + b.Y, a.Z + b.Z);

        #endregion

        #region Shift / Matrix Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift3f"/> transformation (as a 3x4 matrix) with a <see cref="M33f"/> (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator *(Shift3f shift, M33f matrix)
        {
            return new M34f(matrix, shift.V);
        }

        /// <summary>
        /// Multiplies a <see cref="M33f"/> with a <see cref="Shift3f"/> transformation (as a 3x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator *(M33f matrix, Shift3f shift)
        {
            return new M34f(matrix, matrix * shift.V);
        }

        /// <summary>
        /// Multiplies a <see cref="Shift3f"/> transformation (as a 4x4 matrix) with a <see cref="M44f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator *(Shift3f s, M44f m)
        {
            return new M44f(
                m.M00 + s.X * m.M30, 
                m.M01 + s.X * m.M31, 
                m.M02 + s.X * m.M32, 
                m.M03 + s.X * m.M33,

                m.M10 + s.Y * m.M30, 
                m.M11 + s.Y * m.M31, 
                m.M12 + s.Y * m.M32, 
                m.M13 + s.Y * m.M33,

                m.M20 + s.Z * m.M30, 
                m.M21 + s.Z * m.M31, 
                m.M22 + s.Z * m.M32, 
                m.M23 + s.Z * m.M33,

                m.M30, m.M31, m.M32, m.M33);
        }

        /// <summary>
        /// Multiplies a <see cref="M44f"/> with a <see cref="Shift3f"/> transformation (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator *(M44f m, Shift3f s)
        {
            return new M44f(
                m.M00, 
                m.M01, 
                m.M02,
                s.X * m.M00 + s.Y * m.M01 + s.Z * m.M02 + m.M03,

                m.M10, 
                m.M11, 
                m.M12,
                s.X * m.M10 + s.Y * m.M11 + s.Z * m.M12 + m.M13,

                m.M20, 
                m.M21, 
                m.M22,
                s.X * m.M20 + s.Y * m.M21 + s.Z * m.M22 + m.M23,

                m.M30, 
                m.M31, 
                m.M32,
                s.X * m.M30 + s.Y * m.M31 + s.Z * m.M32 + m.M33);
        }

        /// <summary>
        /// Multiplies a <see cref="Shift3f"/> transformation (as a 3x4 matrix) with a <see cref="M34f"/> (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator *(Shift3f s, M34f m)
        {
            return new M34f(
                m.M00, m.M01, m.M02, m.M03 + s.X, 
                m.M10, m.M11, m.M12, m.M13 + s.Y, 
                m.M20, m.M21, m.M22, m.M23 + s.Z);
        }

        /// <summary>
        /// Multiplies a <see cref="M34f"/> with a <see cref="Shift3f"/> transformation (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator *(M34f m, Shift3f s)
        {
            return new M34f(
                m.M00, 
                m.M01, 
                m.M02,
                s.X * m.M00 + s.Y * m.M01 + s.Z * m.M02 + m.M03,

                m.M10, 
                m.M11, 
                m.M12,
                s.X * m.M10 + s.Y * m.M11 + s.Z * m.M12 + m.M13,

                m.M20, 
                m.M21, 
                m.M22,
                s.X * m.M20 + s.Y * m.M21 + s.Z * m.M22 + m.M23);
        }

        #endregion

        #region Shift / Rot, Scale Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift3f"/> transformation with a <see cref="Rot3f"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Euclidean3f operator *(Shift3f a, Rot3f b)
            => new Euclidean3f(b, a.V);

        /// <summary>
        /// Multiplies a <see cref="Shift3f"/> transformation with a <see cref="Scale3f"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f operator *(Shift3f a, Scale3f b)
            => new Affine3f((M33f)b, a.V);

        #endregion

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Shift3f"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Shift3f s0, Shift3f s1)
            => s0.X == s1.X && s0.Y == s1.Y && s0.Z == s1.Z;

        /// <summary>
        /// Checks whether two <see cref="Shift3f"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Shift3f s0, Shift3f s1)
            => s0.X != s1.X || s0.Y != s1.Y || s0.Z != s1.Z;

        #endregion

        #region Static Creators

        /// <summary>
        /// Creates a <see cref="Shift3f"/> transformation from a translation <see cref="M34f"/> matrix.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f FromM34f(M34f m, float epsilon = (float)1e-6)
        {
            if (!M33f.Identity.ApproximateEquals((M33f)m, epsilon))
                throw new ArgumentException("Matrix is not a pure translation matrix.");

            return new Shift3f(m.C3);
        }

        /// <summary>
        /// Creates a <see cref="Shift3f"/> transformation from a translation <see cref="M44f"/> matrix.
        /// The matrix has to be homogeneous and must not contain perspective components.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f FromM44f(M44f m, float epsilon = (float)1e-6)
        {
            if (!M33f.Identity.ApproximateEquals((M33f)m, epsilon))
                throw new ArgumentException("Matrix is not a pure translation matrix.");

            if (!(m.M30.IsTiny(epsilon) && m.M31.IsTiny(epsilon) && m.M32.IsTiny(epsilon)))
                throw new ArgumentException("Matrix contains perspective components.");

            if (m.M33.IsTiny(epsilon))
                throw new ArgumentException("Matrix is not homogeneous.");

            return new Shift3f(m.C3.XYZ / m.M33);
        }

        /// <summary>
        /// Creates a <see cref="Shift3f"/> transformation from a <see cref="Euclidean3f"/>.
        /// The transformation <paramref name="euclidean"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f FromEuclidean3f(Euclidean3f euclidean, float epsilon = 1e-5f)
        {
            if (!euclidean.Rot.ApproximateEquals(Rot3f.Identity, epsilon))
                throw new ArgumentException("Euclidean transformation contains rotational component");

            return new Shift3f(euclidean.Trans);
        }

        /// <summary>
        /// Creates a <see cref="Shift3f"/> transformation from a <see cref="Similarity3f"/>.
        /// The transformation <paramref name="similarity"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f FromSimilarity3f(Similarity3f similarity, float epsilon = 1e-5f)
        {
            if (!similarity.Scale.ApproximateEquals(1, epsilon))
                throw new ArgumentException("Similarity transformation contains scaling component");

            if (!similarity.Rot.ApproximateEquals(Rot3f.Identity, epsilon))
                throw new ArgumentException("Similarity transformation contains rotational component");

            return new Shift3f(similarity.Trans);
        }

        /// <summary>
        /// Creates a <see cref="Shift3f"/> transformation from an <see cref="Affine3f"/>.
        /// The transformation <paramref name="affine"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f FromAffine3f(Affine3f affine, float epsilon = 1e-5f)
            => FromM44f((M44f)affine, epsilon);

        /// <summary>
        /// Creates a <see cref="Shift3f"/> transformation from a <see cref="Trafo3f"/>.
        /// The transformation <paramref name="trafo"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f FromTrafo3f(Trafo3f trafo, float epsilon = 1e-5f)
            => FromM44f(trafo.Forward, epsilon);

        #endregion

        #region Conversion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33f(Shift3f s)
        {
            return new M33f(
                1, 0, s.X, 
                0, 1, s.Y,
                0, 0, 1);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M23f(Shift3f s)
        {
            return new M23f(
                1, 0, s.X, 
                0, 1, s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44f(Shift3f s)
        {
            return new M44f(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, s.Z,
                0, 0, 0, 1);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M34f(Shift3f s)
        {
            return new M34f(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, s.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Euclidean3f(Shift3f s)
            => new Euclidean3f(Rot3f.Identity, s.V);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Similarity3f(Shift3f s)
            => new Similarity3f(1, Rot3f.Identity, s.V);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine3f(Shift3f s)
            => new Affine3f(M33f.Identity, s.V);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Trafo3f(Shift3f s)
            => new Trafo3f((M44f)s, (M44f)s.Inverse);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Shift3d(Shift3f s)
            => new Shift3d((V3d)s.V);

        /// <summary>
        /// Returns all values of a <see cref="Shift3f"/> instance
        /// in a float[] array.
        /// </summary>
        public static explicit operator float[](Shift3f shift)
        {
            float[] array = new float[3];
            array[0] = shift.X;
            array[1] = shift.Y;
            array[2] = shift.Z;
            return array;
        }

        #endregion

        #region Indexing

        public float this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                switch (index)
                {
                    case 0: return V.X;
                    case 1: return V.Y;
                    case 2: return V.Z;
                    default: throw new IndexOutOfRangeException();
                }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                switch (index)
                {
                    case 0: V.X = value; return;
                    case 1: V.Y = value; return;
                    case 2: V.Z = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return V.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is Shift3f)
            {
                Shift3f v = (Shift3f)obj;
                return X == v.X && Y == v.Y && Z == v.Z;
            }
            return false;
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}, {2}]", X, Y, Z);
        }

        public static Shift3f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Shift3f(
                float.Parse(x[0], CultureInfo.InvariantCulture), 
                float.Parse(x[1], CultureInfo.InvariantCulture), 
                float.Parse(x[2], CultureInfo.InvariantCulture)
            );
        }

        #endregion
    }

    public static partial class Shift
    {
        #region Invert

        /// <summary>
        /// Returns the inverse of a <see cref="Shift3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3f Inverse(Shift3f shift)
            => shift.Inverse;

        /// <summary>
        /// Inverts a <see cref="Shift3f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Shift3f shift)
        {
            shift.V.X = -shift.V.X;
            shift.V.Y = -shift.V.Y;
            shift.V.Z = -shift.V.Z;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V3f"/> vector by a <see cref="Shift3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this Shift3f s, V3f v)
            => new V3f(v.X + s.X, v.Y + s.Y, v.Z + s.Z);

        /// <summary>
        /// Transforms a <see cref="V3f"/> vector by the inverse of a <see cref="Shift3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f InvTransform(this Shift3f s, V3f v)
            => new V3f(v.X - s.X, v.Y - s.Y, v.Z - s.Z);

        /// <summary>
        /// Transforms a <see cref="V4f"/> vector by a <see cref="Shift3f"/> transformation.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Transform(this Shift3f s, V4f v)
            => new V4f(v.X + s.X, v.Y + s.Y, v.Z + s.Z, v.W);

        /// <summary>
        /// Transforms a <see cref="V4f"/> vector by the inverse of a <see cref="Shift3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f InvTransform(this Shift3f s, V4f v)
            => new V4f(v.X - s.X, v.Y - s.Y, v.Z - s.Z, v.W);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Shift3f s0, Shift3f s1)
        {
            return ApproximateEquals(s0.V, s1.V, Constant<float>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Shift3f s0, Shift3f s1, float tolerance)
        {
            return ApproximateEquals(s0.V, s1.V, tolerance);
        }

        #endregion
    }

    #endregion

    #region Shift2d

    /// <summary>
    /// A 2-dimensional translational transform with different translation values
    /// in each dimension.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Shift2d
    {
        [DataMember]
        public V2d V;

        #region Constructors

        /// <summary>
        /// Constructs a <see cref="Shift2d"/> transformation from 2 doubles.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift2d(double x, double y)
        {
            V = new V2d(x, y);
        }

        /// <summary>
        /// Constructs a <see cref="Shift2d"/> from a <see cref="V2d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift2d(V2d v)
        {
            V = v;
        }

        /// <summary>
        /// Constructs a copy of a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift2d(Shift2d s)
        {
            V = s.V;
        }

        /// <summary>
        /// Constructs a <see cref="Shift2d"/> transformation from a double-array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift2d(double[] array)
        {
            V = new V2d(array);
        }

        /// <summary>
        /// Constructs a <see cref="Shift2d"/> transformation from a double-array starting from the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift2d(double[] array, int start)
        {
            V = new V2d(array, start);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets and sets the X coordinate.
        /// </summary>
        public double X
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.X = value; }
        }

        /// <summary>
        /// Gets and sets the Y coordinate.
        /// </summary>
        public double Y
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Y = value; }
        }

        /// <summary>
        /// Gets the length of this <see cref="Shift2d"/> transformation.
        /// </summary>
        public double Length
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Length; }
        }

        /// <summary>
        /// Gets the squared length of this <see cref="Shift2d"/> transformation.
        /// </summary>
        public double LengthSquared
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.LengthSquared; }
        }

        /// <summary>
        /// Gets the inverse of this <see cref="Shift2d"/> transformation.
        /// </summary>
        public Shift2d Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Shift2d(-V); }
        }

        /// <summary>
        /// Gets the reciprocal of this <see cref="Shift2d"/> transformation.
        /// </summary>
        public Shift2d Reciprocal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift2d(1 / V);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity <see cref="Shift2d"/> transformation.
        /// </summary>
        public static Shift2d Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift2d(0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Shift2d"/> transformation with all components set to zero.
        /// Note: Equivalent to Identity.
        /// </summary>
        public static Shift2d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Identity;
        }

        /// <summary>
        /// Gets a <see cref="Shift2d"/> transformation with components (1, 0).
        /// </summary>
        public static Shift2d XAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift2d(1, 0);
        }

        /// <summary>
        /// Gets a <see cref="Shift2d"/> transformation with components (0, 1).
        /// </summary>
        public static Shift2d YAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift2d(0, 1);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Negates the values of a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2d operator -(Shift2d shift)
        {
            return new Shift2d(-shift.X, -shift.Y);
        }

        #region Shift / Scalar

        /// <summary>
        /// Multiplies a <see cref="Shift2d"/> transformation with a double scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2d operator *(Shift2d shift, double scalar)
        {
            return new Shift2d(shift.X * scalar, shift.Y * scalar);
        }

        /// <summary>
        /// Multiplies a double scalar with a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2d operator *(double scalar, Shift2d shift)
        {
            return new Shift2d(shift.X * scalar, shift.Y * scalar);
        }

        /// <summary>
        /// Divides a <see cref="Shift2d"/> transformation by a double scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2d operator /(Shift2d shift, double scalar)
        {
            return new Shift2d(shift.X / scalar, shift.Y / scalar);
        }

        /// <summary>
        /// Divides a double scalar by a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2d operator /(double scalar, Shift2d shift)
        {
            return new Shift2d(scalar / shift.X, scalar / shift.Y);
        }

        #endregion

        #region Shift / Vector Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift2d"/> transformation with a <see cref="V2d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d operator *(Shift2d shift, V2d vector)
        {
            return new V2d(vector.X + shift.X, vector.Y + shift.Y);
        }

        #endregion

        #region Shift / Shift Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift2d"/> transformation with a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2d operator *(Shift2d a, Shift2d b)
            => new Shift2d(a.X + b.X, a.Y + b.Y);

        /// <summary>
        /// Multiplies a <see cref="Shift2d"/> transformation with a <see cref="Shift3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d operator *(Shift2d a, Shift3d b)
            => new Shift3d(a.X + b.X, a.Y + b.Y, b.Z);

        #endregion

        #region Shift / Matrix Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift2d"/> transformation (as a 2x3 matrix) with a <see cref="M22d"/> (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator *(Shift2d shift, M22d matrix)
        {
            return new M23d(matrix, shift.V);
        }

        /// <summary>
        /// Multiplies a <see cref="M22d"/> with a <see cref="Shift2d"/> transformation (as a 2x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator *(M22d matrix, Shift2d shift)
        {
            return new M23d(matrix, matrix * shift.V);
        }

        /// <summary>
        /// Multiplies a <see cref="Shift2d"/> transformation (as a 3x3 matrix) with a <see cref="M33d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator *(Shift2d s, M33d m)
        {
            return new M33d(
                m.M00 + s.X * m.M20, 
                m.M01 + s.X * m.M21, 
                m.M02 + s.X * m.M22,

                m.M10 + s.Y * m.M20, 
                m.M11 + s.Y * m.M21, 
                m.M12 + s.Y * m.M22,

                m.M20, m.M21, m.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="M33d"/> with a <see cref="Shift2d"/> transformation (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator *(M33d m, Shift2d s)
        {
            return new M33d(
                m.M00, 
                m.M01,
                s.X * m.M00 + s.Y * m.M01 + m.M02,

                m.M10, 
                m.M11,
                s.X * m.M10 + s.Y * m.M11 + m.M12,

                m.M20, 
                m.M21,
                s.X * m.M20 + s.Y * m.M21 + m.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="Shift2d"/> transformation (as a 2x3 matrix) with a <see cref="M23d"/> (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator *(Shift2d s, M23d m)
        {
            return new M23d(
                m.M00, m.M01, m.M02 + s.X, 
                m.M10, m.M11, m.M12 + s.Y);
        }

        /// <summary>
        /// Multiplies a <see cref="M23d"/> with a <see cref="Shift2d"/> transformation (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator *(M23d m, Shift2d s)
        {
            return new M23d(
                m.M00, 
                m.M01,
                s.X * m.M00 + s.Y * m.M01 + m.M02,

                m.M10, 
                m.M11,
                s.X * m.M10 + s.Y * m.M11 + m.M12);
        }

        #endregion

        #region Shift / Rot, Scale Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift2d"/> transformation with a <see cref="Rot2d"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Euclidean2d operator *(Shift2d a, Rot2d b)
            => new Euclidean2d(b, a.V);

        /// <summary>
        /// Multiplies a <see cref="Shift2d"/> transformation with a <see cref="Scale2d"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d operator *(Shift2d a, Scale2d b)
            => new Affine2d((M22d)b, a.V);

        #endregion

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Shift2d"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Shift2d s0, Shift2d s1)
            => s0.X == s1.X && s0.Y == s1.Y;

        /// <summary>
        /// Checks whether two <see cref="Shift2d"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Shift2d s0, Shift2d s1)
            => s0.X != s1.X || s0.Y != s1.Y;

        #endregion

        #region Static Creators

        /// <summary>
        /// Creates a <see cref="Shift2d"/> transformation from a translation <see cref="M23d"/> matrix.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2d FromM23d(M23d m, double epsilon = (double)1e-6)
        {
            if (!M22d.Identity.ApproximateEquals((M22d)m, epsilon))
                throw new ArgumentException("Matrix is not a pure translation matrix.");

            return new Shift2d(m.C2);
        }

        /// <summary>
        /// Creates a <see cref="Shift2d"/> transformation from a translation <see cref="M33d"/> matrix.
        /// The matrix has to be homogeneous and must not contain perspective components.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2d FromM33d(M33d m, double epsilon = (double)1e-6)
        {
            if (!M22d.Identity.ApproximateEquals((M22d)m, epsilon))
                throw new ArgumentException("Matrix is not a pure translation matrix.");

            if (!(m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon)))
                throw new ArgumentException("Matrix contains perspective components.");

            if (m.M22.IsTiny(epsilon))
                throw new ArgumentException("Matrix is not homogeneous.");

            return new Shift2d(m.C2.XY / m.M22);
        }

        /// <summary>
        /// Creates a <see cref="Shift2d"/> transformation from a <see cref="Euclidean2d"/>.
        /// The transformation <paramref name="euclidean"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2d FromEuclidean2d(Euclidean2d euclidean, double epsilon = 1e-12)
        {
            if (!euclidean.Rot.ApproximateEquals(Rot2d.Identity, epsilon))
                throw new ArgumentException("Euclidean transformation contains rotational component");

            return new Shift2d(euclidean.Trans);
        }

        /// <summary>
        /// Creates a <see cref="Shift2d"/> transformation from a <see cref="Similarity2d"/>.
        /// The transformation <paramref name="similarity"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2d FromSimilarity2d(Similarity2d similarity, double epsilon = 1e-12)
        {
            if (!similarity.Scale.ApproximateEquals(1, epsilon))
                throw new ArgumentException("Similarity transformation contains scaling component");

            if (!similarity.Rot.ApproximateEquals(Rot2d.Identity, epsilon))
                throw new ArgumentException("Similarity transformation contains rotational component");

            return new Shift2d(similarity.Trans);
        }

        /// <summary>
        /// Creates a <see cref="Shift2d"/> transformation from an <see cref="Affine2d"/>.
        /// The transformation <paramref name="affine"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2d FromAffine2d(Affine2d affine, double epsilon = 1e-12)
            => FromM33d((M33d)affine, epsilon);

        /// <summary>
        /// Creates a <see cref="Shift2d"/> transformation from a <see cref="Trafo2d"/>.
        /// The transformation <paramref name="trafo"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2d FromTrafo2d(Trafo2d trafo, double epsilon = 1e-12)
            => FromM33d(trafo.Forward, epsilon);

        #endregion

        #region Conversion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33d(Shift2d s)
        {
            return new M33d(
                1, 0, s.X, 
                0, 1, s.Y,
                0, 0, 1);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M23d(Shift2d s)
        {
            return new M23d(
                1, 0, s.X, 
                0, 1, s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44d(Shift2d s)
        {
            return new M44d(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, 0,
                0, 0, 0, 1);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M34d(Shift2d s)
        {
            return new M34d(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Euclidean2d(Shift2d s)
            => new Euclidean2d(Rot2d.Identity, s.V);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Similarity2d(Shift2d s)
            => new Similarity2d(1, Rot2d.Identity, s.V);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine2d(Shift2d s)
            => new Affine2d(M22d.Identity, s.V);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Trafo2d(Shift2d s)
            => new Trafo2d((M33d)s, (M33d)s.Inverse);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Shift2f(Shift2d s)
            => new Shift2f((V2f)s.V);

        /// <summary>
        /// Returns all values of a <see cref="Shift2d"/> instance
        /// in a double[] array.
        /// </summary>
        public static explicit operator double[](Shift2d shift)
        {
            double[] array = new double[2];
            array[0] = shift.X;
            array[1] = shift.Y;
            return array;
        }

        #endregion

        #region Indexing

        public double this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                switch (index)
                {
                    case 0: return V.X;
                    case 1: return V.Y;
                    default: throw new IndexOutOfRangeException();
                }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                switch (index)
                {
                    case 0: V.X = value; return;
                    case 1: V.Y = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return V.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is Shift2d)
            {
                Shift2d v = (Shift2d)obj;
                return X == v.X && Y == v.Y;
            }
            return false;
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}]", X, Y);
        }

        public static Shift2d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Shift2d(
                double.Parse(x[0], CultureInfo.InvariantCulture), 
                double.Parse(x[1], CultureInfo.InvariantCulture)
            );
        }

        #endregion
    }

    public static partial class Shift
    {
        #region Invert

        /// <summary>
        /// Returns the inverse of a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift2d Inverse(Shift2d shift)
            => shift.Inverse;

        /// <summary>
        /// Inverts a <see cref="Shift2d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Shift2d shift)
        {
            shift.V.X = -shift.V.X;
            shift.V.Y = -shift.V.Y;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V2d"/> vector by a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d Transform(this Shift2d s, V2d v)
            => new V2d(v.X + s.X, v.Y + s.Y);

        /// <summary>
        /// Transforms a <see cref="V2d"/> vector by the inverse of a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d InvTransform(this Shift2d s, V2d v)
            => new V2d(v.X - s.X, v.Y - s.Y);

        /// <summary>
        /// Transforms a <see cref="V3d"/> vector by a <see cref="Shift2d"/> transformation.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this Shift2d s, V3d v)
            => new V3d(v.X + s.X, v.Y + s.Y, v.Z);

        /// <summary>
        /// Transforms a <see cref="V3d"/> vector by the inverse of a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d InvTransform(this Shift2d s, V3d v)
            => new V3d(v.X - s.X, v.Y - s.Y, v.Z);

        /// <summary>
        /// Transforms a <see cref="V4d"/> vector by a <see cref="Shift2d"/> transformation.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Transform(this Shift2d s, V4d v)
            => new V4d(v.X + s.X, v.Y + s.Y, v.Z, v.W);

        /// <summary>
        /// Transforms a <see cref="V4d"/> vector by the inverse of a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d InvTransform(this Shift2d s, V4d v)
            => new V4d(v.X - s.X, v.Y - s.Y, v.Z, v.W);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Shift2d s0, Shift2d s1)
        {
            return ApproximateEquals(s0.V, s1.V, Constant<double>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Shift2d s0, Shift2d s1, double tolerance)
        {
            return ApproximateEquals(s0.V, s1.V, tolerance);
        }

        #endregion
    }

    #endregion

    #region Shift3d

    /// <summary>
    /// A 3-dimensional translational transform with different translation values
    /// in each dimension.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Shift3d
    {
        [DataMember]
        public V3d V;

        #region Constructors

        /// <summary>
        /// Constructs a <see cref="Shift3d"/> transformation from 3 doubles.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift3d(double x, double y, double z)
        {
            V = new V3d(x, y, z);
        }

        /// <summary>
        /// Constructs a <see cref="Shift3d"/> from a <see cref="V3d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift3d(V3d v)
        {
            V = v;
        }

        /// <summary>
        /// Constructs a copy of a <see cref="Shift3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift3d(Shift3d s)
        {
            V = s.V;
        }

        /// <summary>
        /// Constructs a <see cref="Shift3d"/> transformation from a double-array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift3d(double[] array)
        {
            V = new V3d(array);
        }

        /// <summary>
        /// Constructs a <see cref="Shift3d"/> transformation from a double-array starting from the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Shift3d(double[] array, int start)
        {
            V = new V3d(array, start);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets and sets the X coordinate.
        /// </summary>
        public double X
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.X = value; }
        }

        /// <summary>
        /// Gets and sets the Y coordinate.
        /// </summary>
        public double Y
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Y = value; }
        }

        /// <summary>
        /// Gets and sets the Z coordinate.
        /// </summary>
        public double Z
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Z; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Z = value; }
        }

        /// <summary>
        /// Gets the length of this <see cref="Shift3d"/> transformation.
        /// </summary>
        public double Length
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Length; }
        }

        /// <summary>
        /// Gets the squared length of this <see cref="Shift3d"/> transformation.
        /// </summary>
        public double LengthSquared
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.LengthSquared; }
        }

        /// <summary>
        /// Gets the inverse of this <see cref="Shift3d"/> transformation.
        /// </summary>
        public Shift3d Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new Shift3d(-V); }
        }

        /// <summary>
        /// Gets the reciprocal of this <see cref="Shift3d"/> transformation.
        /// </summary>
        public Shift3d Reciprocal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift3d(1 / V);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity <see cref="Shift3d"/> transformation.
        /// </summary>
        public static Shift3d Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift3d(0, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Shift3d"/> transformation with all components set to zero.
        /// Note: Equivalent to Identity.
        /// </summary>
        public static Shift3d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Identity;
        }

        /// <summary>
        /// Gets a <see cref="Shift3d"/> transformation with components (1, 0, 0).
        /// </summary>
        public static Shift3d XAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift3d(1, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Shift3d"/> transformation with components (0, 1, 0).
        /// </summary>
        public static Shift3d YAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift3d(0, 1, 0);
        }

        /// <summary>
        /// Gets a <see cref="Shift3d"/> transformation with components (0, 0, 1).
        /// </summary>
        public static Shift3d ZAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Shift3d(0, 0, 1);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Negates the values of a <see cref="Shift3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d operator -(Shift3d shift)
        {
            return new Shift3d(-shift.X, -shift.Y, -shift.Z);
        }

        #region Shift / Scalar

        /// <summary>
        /// Multiplies a <see cref="Shift3d"/> transformation with a double scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d operator *(Shift3d shift, double scalar)
        {
            return new Shift3d(shift.X * scalar, shift.Y * scalar, shift.Z * scalar);
        }

        /// <summary>
        /// Multiplies a double scalar with a <see cref="Shift3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d operator *(double scalar, Shift3d shift)
        {
            return new Shift3d(shift.X * scalar, shift.Y * scalar, shift.Z * scalar);
        }

        /// <summary>
        /// Divides a <see cref="Shift3d"/> transformation by a double scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d operator /(Shift3d shift, double scalar)
        {
            return new Shift3d(shift.X / scalar, shift.Y / scalar, shift.Z / scalar);
        }

        /// <summary>
        /// Divides a double scalar by a <see cref="Shift3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d operator /(double scalar, Shift3d shift)
        {
            return new Shift3d(scalar / shift.X, scalar / shift.Y, scalar / shift.Z);
        }

        #endregion

        #region Shift / Vector Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift3d"/> transformation with a <see cref="V3d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d operator *(Shift3d shift, V3d vector)
        {
            return new V3d(vector.X + shift.X, vector.Y + shift.Y, vector.Z + shift.Z);
        }

        #endregion

        #region Shift / Shift Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift3d"/> transformation with a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d operator *(Shift3d a, Shift2d b)
            => new Shift3d(a.X + b.X, a.Y + b.Y, a.Z);

        /// <summary>
        /// Multiplies a <see cref="Shift3d"/> transformation with a <see cref="Shift3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d operator *(Shift3d a, Shift3d b)
            => new Shift3d(a.X + b.X, a.Y + b.Y, a.Z + b.Z);

        #endregion

        #region Shift / Matrix Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift3d"/> transformation (as a 3x4 matrix) with a <see cref="M33d"/> (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator *(Shift3d shift, M33d matrix)
        {
            return new M34d(matrix, shift.V);
        }

        /// <summary>
        /// Multiplies a <see cref="M33d"/> with a <see cref="Shift3d"/> transformation (as a 3x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator *(M33d matrix, Shift3d shift)
        {
            return new M34d(matrix, matrix * shift.V);
        }

        /// <summary>
        /// Multiplies a <see cref="Shift3d"/> transformation (as a 4x4 matrix) with a <see cref="M44d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator *(Shift3d s, M44d m)
        {
            return new M44d(
                m.M00 + s.X * m.M30, 
                m.M01 + s.X * m.M31, 
                m.M02 + s.X * m.M32, 
                m.M03 + s.X * m.M33,

                m.M10 + s.Y * m.M30, 
                m.M11 + s.Y * m.M31, 
                m.M12 + s.Y * m.M32, 
                m.M13 + s.Y * m.M33,

                m.M20 + s.Z * m.M30, 
                m.M21 + s.Z * m.M31, 
                m.M22 + s.Z * m.M32, 
                m.M23 + s.Z * m.M33,

                m.M30, m.M31, m.M32, m.M33);
        }

        /// <summary>
        /// Multiplies a <see cref="M44d"/> with a <see cref="Shift3d"/> transformation (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator *(M44d m, Shift3d s)
        {
            return new M44d(
                m.M00, 
                m.M01, 
                m.M02,
                s.X * m.M00 + s.Y * m.M01 + s.Z * m.M02 + m.M03,

                m.M10, 
                m.M11, 
                m.M12,
                s.X * m.M10 + s.Y * m.M11 + s.Z * m.M12 + m.M13,

                m.M20, 
                m.M21, 
                m.M22,
                s.X * m.M20 + s.Y * m.M21 + s.Z * m.M22 + m.M23,

                m.M30, 
                m.M31, 
                m.M32,
                s.X * m.M30 + s.Y * m.M31 + s.Z * m.M32 + m.M33);
        }

        /// <summary>
        /// Multiplies a <see cref="Shift3d"/> transformation (as a 3x4 matrix) with a <see cref="M34d"/> (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator *(Shift3d s, M34d m)
        {
            return new M34d(
                m.M00, m.M01, m.M02, m.M03 + s.X, 
                m.M10, m.M11, m.M12, m.M13 + s.Y, 
                m.M20, m.M21, m.M22, m.M23 + s.Z);
        }

        /// <summary>
        /// Multiplies a <see cref="M34d"/> with a <see cref="Shift3d"/> transformation (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator *(M34d m, Shift3d s)
        {
            return new M34d(
                m.M00, 
                m.M01, 
                m.M02,
                s.X * m.M00 + s.Y * m.M01 + s.Z * m.M02 + m.M03,

                m.M10, 
                m.M11, 
                m.M12,
                s.X * m.M10 + s.Y * m.M11 + s.Z * m.M12 + m.M13,

                m.M20, 
                m.M21, 
                m.M22,
                s.X * m.M20 + s.Y * m.M21 + s.Z * m.M22 + m.M23);
        }

        #endregion

        #region Shift / Rot, Scale Multiplication

        /// <summary>
        /// Multiplies a <see cref="Shift3d"/> transformation with a <see cref="Rot3d"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Euclidean3d operator *(Shift3d a, Rot3d b)
            => new Euclidean3d(b, a.V);

        /// <summary>
        /// Multiplies a <see cref="Shift3d"/> transformation with a <see cref="Scale3d"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d operator *(Shift3d a, Scale3d b)
            => new Affine3d((M33d)b, a.V);

        #endregion

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Shift3d"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Shift3d s0, Shift3d s1)
            => s0.X == s1.X && s0.Y == s1.Y && s0.Z == s1.Z;

        /// <summary>
        /// Checks whether two <see cref="Shift3d"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Shift3d s0, Shift3d s1)
            => s0.X != s1.X || s0.Y != s1.Y || s0.Z != s1.Z;

        #endregion

        #region Static Creators

        /// <summary>
        /// Creates a <see cref="Shift3d"/> transformation from a translation <see cref="M34d"/> matrix.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d FromM34d(M34d m, double epsilon = (double)1e-6)
        {
            if (!M33d.Identity.ApproximateEquals((M33d)m, epsilon))
                throw new ArgumentException("Matrix is not a pure translation matrix.");

            return new Shift3d(m.C3);
        }

        /// <summary>
        /// Creates a <see cref="Shift3d"/> transformation from a translation <see cref="M44d"/> matrix.
        /// The matrix has to be homogeneous and must not contain perspective components.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d FromM44d(M44d m, double epsilon = (double)1e-6)
        {
            if (!M33d.Identity.ApproximateEquals((M33d)m, epsilon))
                throw new ArgumentException("Matrix is not a pure translation matrix.");

            if (!(m.M30.IsTiny(epsilon) && m.M31.IsTiny(epsilon) && m.M32.IsTiny(epsilon)))
                throw new ArgumentException("Matrix contains perspective components.");

            if (m.M33.IsTiny(epsilon))
                throw new ArgumentException("Matrix is not homogeneous.");

            return new Shift3d(m.C3.XYZ / m.M33);
        }

        /// <summary>
        /// Creates a <see cref="Shift3d"/> transformation from a <see cref="Euclidean3d"/>.
        /// The transformation <paramref name="euclidean"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d FromEuclidean3d(Euclidean3d euclidean, double epsilon = 1e-12)
        {
            if (!euclidean.Rot.ApproximateEquals(Rot3d.Identity, epsilon))
                throw new ArgumentException("Euclidean transformation contains rotational component");

            return new Shift3d(euclidean.Trans);
        }

        /// <summary>
        /// Creates a <see cref="Shift3d"/> transformation from a <see cref="Similarity3d"/>.
        /// The transformation <paramref name="similarity"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d FromSimilarity3d(Similarity3d similarity, double epsilon = 1e-12)
        {
            if (!similarity.Scale.ApproximateEquals(1, epsilon))
                throw new ArgumentException("Similarity transformation contains scaling component");

            if (!similarity.Rot.ApproximateEquals(Rot3d.Identity, epsilon))
                throw new ArgumentException("Similarity transformation contains rotational component");

            return new Shift3d(similarity.Trans);
        }

        /// <summary>
        /// Creates a <see cref="Shift3d"/> transformation from an <see cref="Affine3d"/>.
        /// The transformation <paramref name="affine"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d FromAffine3d(Affine3d affine, double epsilon = 1e-12)
            => FromM44d((M44d)affine, epsilon);

        /// <summary>
        /// Creates a <see cref="Shift3d"/> transformation from a <see cref="Trafo3d"/>.
        /// The transformation <paramref name="trafo"/> must only consist of a translation.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d FromTrafo3d(Trafo3d trafo, double epsilon = 1e-12)
            => FromM44d(trafo.Forward, epsilon);

        #endregion

        #region Conversion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33d(Shift3d s)
        {
            return new M33d(
                1, 0, s.X, 
                0, 1, s.Y,
                0, 0, 1);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M23d(Shift3d s)
        {
            return new M23d(
                1, 0, s.X, 
                0, 1, s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44d(Shift3d s)
        {
            return new M44d(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, s.Z,
                0, 0, 0, 1);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M34d(Shift3d s)
        {
            return new M34d(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, s.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Euclidean3d(Shift3d s)
            => new Euclidean3d(Rot3d.Identity, s.V);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Similarity3d(Shift3d s)
            => new Similarity3d(1, Rot3d.Identity, s.V);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine3d(Shift3d s)
            => new Affine3d(M33d.Identity, s.V);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Trafo3d(Shift3d s)
            => new Trafo3d((M44d)s, (M44d)s.Inverse);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Shift3f(Shift3d s)
            => new Shift3f((V3f)s.V);

        /// <summary>
        /// Returns all values of a <see cref="Shift3d"/> instance
        /// in a double[] array.
        /// </summary>
        public static explicit operator double[](Shift3d shift)
        {
            double[] array = new double[3];
            array[0] = shift.X;
            array[1] = shift.Y;
            array[2] = shift.Z;
            return array;
        }

        #endregion

        #region Indexing

        public double this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                switch (index)
                {
                    case 0: return V.X;
                    case 1: return V.Y;
                    case 2: return V.Z;
                    default: throw new IndexOutOfRangeException();
                }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                switch (index)
                {
                    case 0: V.X = value; return;
                    case 1: V.Y = value; return;
                    case 2: V.Z = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return V.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is Shift3d)
            {
                Shift3d v = (Shift3d)obj;
                return X == v.X && Y == v.Y && Z == v.Z;
            }
            return false;
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}, {2}]", X, Y, Z);
        }

        public static Shift3d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Shift3d(
                double.Parse(x[0], CultureInfo.InvariantCulture), 
                double.Parse(x[1], CultureInfo.InvariantCulture), 
                double.Parse(x[2], CultureInfo.InvariantCulture)
            );
        }

        #endregion
    }

    public static partial class Shift
    {
        #region Invert

        /// <summary>
        /// Returns the inverse of a <see cref="Shift3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Shift3d Inverse(Shift3d shift)
            => shift.Inverse;

        /// <summary>
        /// Inverts a <see cref="Shift3d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Shift3d shift)
        {
            shift.V.X = -shift.V.X;
            shift.V.Y = -shift.V.Y;
            shift.V.Z = -shift.V.Z;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V3d"/> vector by a <see cref="Shift3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this Shift3d s, V3d v)
            => new V3d(v.X + s.X, v.Y + s.Y, v.Z + s.Z);

        /// <summary>
        /// Transforms a <see cref="V3d"/> vector by the inverse of a <see cref="Shift3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d InvTransform(this Shift3d s, V3d v)
            => new V3d(v.X - s.X, v.Y - s.Y, v.Z - s.Z);

        /// <summary>
        /// Transforms a <see cref="V4d"/> vector by a <see cref="Shift3d"/> transformation.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Transform(this Shift3d s, V4d v)
            => new V4d(v.X + s.X, v.Y + s.Y, v.Z + s.Z, v.W);

        /// <summary>
        /// Transforms a <see cref="V4d"/> vector by the inverse of a <see cref="Shift3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d InvTransform(this Shift3d s, V4d v)
            => new V4d(v.X - s.X, v.Y - s.Y, v.Z - s.Z, v.W);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Shift3d s0, Shift3d s1)
        {
            return ApproximateEquals(s0.V, s1.V, Constant<double>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Shift3d s0, Shift3d s1, double tolerance)
        {
            return ApproximateEquals(s0.V, s1.V, tolerance);
        }

        #endregion
    }

    #endregion

}
