using System;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    #region Scale2f

    /// <summary>
    /// A 2-dimensional scaling transform with different scaling values
    /// in each dimension.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Scale2f
    {
        [DataMember]
        public V2f V;

        #region Constructors

        /// <summary>
        /// Constructs a <see cref="Scale2f"/> transformation from 2 floats.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2f(float sX, float sY)
        {
            V = new V2f(sX, sY);
        }

        /// <summary>
        /// Constructs a <see cref="Scale2f"/> from 2 scaling factors provided as <see cref="V2f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2f(V2f scalingFactors)
        {
            V = scalingFactors;
        }

        /// <summary>
        /// Constructs a <see cref="Scale2f"/> transformation from a uniform float value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2f(float uniform)
        {
            V = new V2f(uniform, uniform);
        }

        /// <summary>
        /// Constructs a copy of a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2f(Scale2f scale)
        {
            V = scale.V;
        }

        /// <summary>
        /// Constructs a <see cref="Scale2f"/> transformation from a float-array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2f(float[] array)
        {
            V = new V2f(array);
        }

        /// <summary>
        /// Constructs a <see cref="Scale2f"/> transformation from a float-array starting from the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2f(float[] array, int start)
        {
            V = new V2f(array, start);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets and sets the X coordinate.
        /// </summary>
        public float X
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.X = value; }
        }

        /// <summary>
        /// Gets and sets the Y coordinate.
        /// </summary>
        public float Y
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Y = value; }
        }

        /// <summary>
        /// Gets the inverse of this <see cref="Scale2f"/> transformation.
        /// </summary>
        public Scale2f Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2f(1 / X, 1 / Y);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity <see cref="Scale2f"/> transformation.
        /// </summary>
        public static Scale2f Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2f(1, 1);
        }

        /// <summary>
        /// Gets a <see cref="Scale2f"/> transformation with all components set to zero.
        /// </summary>
        public static Scale2f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2f(0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale2f"/> transformation with scaling factors (1, 0).
        /// </summary>
        public static Scale2f XAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2f(1, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale2f"/> transformation with scaling factors (0, 1).
        /// </summary>
        public static Scale2f YAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2f(0, 1);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Negates the values of a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f operator -(Scale2f scale)
        {
            return new Scale2f(-scale.X, -scale.Y);
        }

        #region Scale / Scalar

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation with a float scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f operator *(Scale2f scale, float scalar)
        {
            return new Scale2f(scale.X * scalar, scale.Y * scalar);
        }

        /// <summary>
        /// Multiplies a float scalar with a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f operator *(float scalar, Scale2f scale)
        {
            return new Scale2f(scale.X * scalar, scale.Y * scalar);
        }

        /// <summary>
        /// Divides a <see cref="Scale2f"/> transformation by a float scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f operator /(Scale2f scale, float scalar)
        {
            return new Scale2f(scale.X / scalar, scale.Y / scalar);
        }

        /// <summary>
        /// Divides a float scalar by a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f operator /(float scalar, Scale2f scale)
        {
            return new Scale2f(scalar / scale.X, scalar / scale.Y);
        }

        #endregion

        #region Scale / Vector Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation with a <see cref="V2f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f operator *(Scale2f scale, V2f vector)
        {
            return new V2f(vector.X * scale.X, vector.Y * scale.Y);
        }

        #endregion

        #region Scale / Scale Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation with a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f operator *(Scale2f a, Scale2f b)
            => new Scale2f(a.X * b.X, a.Y * b.Y);

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation with a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator *(Scale2f a, Scale3f b)
            => new Scale3f(a.X * b.X, a.Y * b.Y, b.Z);

        #endregion

        #region Scale / Matrix Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation (as a 2x2 matrix) with a <see cref="M22f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator *(Scale2f scale, M22f matrix)
        {
            return new M22f(
                scale.X * matrix.M00, scale.X * matrix.M01, 
                scale.Y * matrix.M10, scale.Y * matrix.M11);
        }

        /// <summary>
        /// Multiplies a <see cref="M22f"/> with a <see cref="Scale2f"/> transformation (as a 2x2 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator *(M22f matrix, Scale2f scale)
        {
            return new M22f(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation (as a 2x2 matrix) with a <see cref="M23f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator *(Scale2f scale, M23f matrix)
        {
            return new M23f(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation (as a 3x3 matrix) with a <see cref="M33f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator *(Scale2f scale, M33f matrix)
        {
            return new M33f(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, 
                matrix.M20, matrix.M21, matrix.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="M33f"/> with a <see cref="Scale2f"/> transformation (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator *(M33f matrix, Scale2f scale)
        {
            return new M33f(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation (as a 3x3 matrix) with a <see cref="M34f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator *(Scale2f scale, M34f matrix)
        {
            return new M34f(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
                matrix.M20, matrix.M21, matrix.M22, matrix.M23);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation (as a 4x4 matrix) with a <see cref="M44f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator *(Scale2f scale, M44f matrix)
        {
            return new M44f(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
                matrix.M20, matrix.M21, matrix.M22, matrix.M23, 
                matrix.M30, matrix.M31, matrix.M32, matrix.M33);
        }

        /// <summary>
        /// Multiplies a <see cref="M44f"/> with a <see cref="Scale2f"/> transformation (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator *(M44f matrix, Scale2f scale)
        {
            return new M44f(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02, matrix.M03, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12, matrix.M13, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22, matrix.M23, 
                matrix.M30 * scale.X, matrix.M31 * scale.Y, matrix.M32, matrix.M33);
        }

        #endregion

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Scale2f"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Scale2f s0, Scale2f s1)
            => s0.X == s1.X && s0.Y == s1.Y;

        /// <summary>
        /// Checks whether two <see cref="Scale2f"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Scale2f s0, Scale2f s1)
            => s0.X != s1.X || s0.Y != s1.Y;

        #endregion

        #region Conversion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M22f(Scale2f s)
        {
            return new M22f(
                s.X, 0  , 
                0  , s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M23f(Scale2f s)
        {
            return new M23f(
                s.X, 0  , 0  , 
                0  , s.Y, 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33f(Scale2f s)
        {
            return new M33f(
                s.X, 0  , 0  , 
                0  , s.Y, 0  , 
                0  , 0  , 1  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M34f(Scale2f s)
        {
            return new M34f(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , 1  , 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44f(Scale2f s)
        {
            return new M44f(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , 1  , 0  , 
                0  , 0  , 0  , 1  );
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine2f(Scale2f s)
            => new Affine2f((M22f)s);

        /// <summary>
        /// Returns all values of a <see cref="Scale2f"/> instance
        /// in a float[] array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator float[](Scale2f s)
            => (float[])s.V;

        #endregion

        #region Indexing

        public float this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                switch (index)
                {
                    case 0: return V.X;
                    case 1: return V.Y;
                    default: throw new IndexOutOfRangeException();
                }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                switch (index)
                {
                    case 0: V.X = value; return;
                    case 1: V.Y = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return V.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is Scale2f)
            {
                Scale2f v = (Scale2f)obj;
                return X == v.X && Y == v.Y;
            }
            return false;
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}]", X, Y);
        }

        public static Scale2f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Scale2f(
                float.Parse(x[0], CultureInfo.InvariantCulture), 
                float.Parse(x[1], CultureInfo.InvariantCulture)
            );
        }

        #endregion
    }

    public static partial class Scale
    {
        #region Invert

        /// <summary>
        /// Inverts a <see cref="Scale2f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Scale2f scale)
        {
            scale = scale.Inverse;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V2f"/> vector by a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f Transform(this Scale2f s, V2f v)
            => new V2f(v.X * s.X, v.Y * s.Y);

        /// <summary>
        /// Transforms a <see cref="V2f"/> vector by the inverse of a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f InvTransform(this Scale2f s, V2f v)
            => new V2f(v.X / s.X, v.Y / s.Y);

        /// <summary>
        /// Transforms a <see cref="V3f"/> vector by a <see cref="Scale2f"/> transformation.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this Scale2f s, V3f v)
            => new V3f(v.X * s.X, v.Y * s.Y, v.Z);

        /// <summary>
        /// Transforms a <see cref="V3f"/> vector by the inverse of a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f InvTransform(this Scale2f s, V3f v)
            => new V3f(v.X / s.X, v.Y / s.Y, v.Z);

        /// <summary>
        /// Transforms a <see cref="V4f"/> vector by a <see cref="Scale2f"/> transformation.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Transform(this Scale2f s, V4f v)
            => new V4f(v.X * s.X, v.Y * s.Y, v.Z, v.W);

        /// <summary>
        /// Transforms a <see cref="V4f"/> vector by the inverse of a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f InvTransform(this Scale2f s, V4f v)
            => new V4f(v.X / s.X, v.Y / s.Y, v.Z, v.W);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale2f s0, Scale2f s1)
        {
            return ApproximateEquals(s0.V, s1.V, Constant<float>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale2f s0, Scale2f s1, float tolerance)
        {
            return ApproximateEquals(s0.V, s1.V, tolerance);
        }

        #endregion
    }

    #endregion

    #region Scale3f

    /// <summary>
    /// A 3-dimensional scaling transform with different scaling values
    /// in each dimension.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Scale3f
    {
        [DataMember]
        public V3f V;

        #region Constructors

        /// <summary>
        /// Constructs a <see cref="Scale3f"/> transformation from 3 floats.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3f(float sX, float sY, float sZ)
        {
            V = new V3f(sX, sY, sZ);
        }

        /// <summary>
        /// Constructs a <see cref="Scale3f"/> from 3 scaling factors provided as <see cref="V3f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3f(V3f scalingFactors)
        {
            V = scalingFactors;
        }

        /// <summary>
        /// Constructs a <see cref="Scale3f"/> transformation from a uniform float value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3f(float uniform)
        {
            V = new V3f(uniform, uniform, uniform);
        }

        /// <summary>
        /// Constructs a copy of a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3f(Scale3f scale)
        {
            V = scale.V;
        }

        /// <summary>
        /// Constructs a <see cref="Scale3f"/> transformation from a float-array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3f(float[] array)
        {
            V = new V3f(array);
        }

        /// <summary>
        /// Constructs a <see cref="Scale3f"/> transformation from a float-array starting from the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3f(float[] array, int start)
        {
            V = new V3f(array, start);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets and sets the X coordinate.
        /// </summary>
        public float X
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.X = value; }
        }

        /// <summary>
        /// Gets and sets the Y coordinate.
        /// </summary>
        public float Y
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Y = value; }
        }

        /// <summary>
        /// Gets and sets the Z coordinate.
        /// </summary>
        public float Z
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Z; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Z = value; }
        }

        /// <summary>
        /// Gets the inverse of this <see cref="Scale3f"/> transformation.
        /// </summary>
        public Scale3f Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3f(1 / X, 1 / Y, 1 / Z);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity <see cref="Scale3f"/> transformation.
        /// </summary>
        public static Scale3f Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3f(1, 1, 1);
        }

        /// <summary>
        /// Gets a <see cref="Scale3f"/> transformation with all components set to zero.
        /// </summary>
        public static Scale3f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3f(0, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale3f"/> transformation with scaling factors (1, 0, 0).
        /// </summary>
        public static Scale3f XAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3f(1, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale3f"/> transformation with scaling factors (0, 1, 0).
        /// </summary>
        public static Scale3f YAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3f(0, 1, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale3f"/> transformation with scaling factors (0, 0, 1).
        /// </summary>
        public static Scale3f ZAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3f(0, 0, 1);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Negates the values of a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator -(Scale3f scale)
        {
            return new Scale3f(-scale.X, -scale.Y, -scale.Z);
        }

        #region Scale / Scalar

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation with a float scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator *(Scale3f scale, float scalar)
        {
            return new Scale3f(scale.X * scalar, scale.Y * scalar, scale.Z * scalar);
        }

        /// <summary>
        /// Multiplies a float scalar with a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator *(float scalar, Scale3f scale)
        {
            return new Scale3f(scale.X * scalar, scale.Y * scalar, scale.Z * scalar);
        }

        /// <summary>
        /// Divides a <see cref="Scale3f"/> transformation by a float scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator /(Scale3f scale, float scalar)
        {
            return new Scale3f(scale.X / scalar, scale.Y / scalar, scale.Z / scalar);
        }

        /// <summary>
        /// Divides a float scalar by a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator /(float scalar, Scale3f scale)
        {
            return new Scale3f(scalar / scale.X, scalar / scale.Y, scalar / scale.Z);
        }

        #endregion

        #region Scale / Vector Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation with a <see cref="V3f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f operator *(Scale3f scale, V3f vector)
        {
            return new V3f(vector.X * scale.X, vector.Y * scale.Y, vector.Z * scale.Z);
        }

        #endregion

        #region Scale / Scale Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation with a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator *(Scale3f a, Scale2f b)
            => new Scale3f(a.X * b.X, a.Y * b.Y, a.Z);

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation with a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator *(Scale3f a, Scale3f b)
            => new Scale3f(a.X * b.X, a.Y * b.Y, a.Z * b.Z);

        #endregion

        #region Scale / Matrix Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation (as a 2x2 matrix) with a <see cref="M22f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator *(Scale3f scale, M22f matrix)
        {
            return new M22f(
                scale.X * matrix.M00, scale.X * matrix.M01, 
                scale.Y * matrix.M10, scale.Y * matrix.M11);
        }

        /// <summary>
        /// Multiplies a <see cref="M22f"/> with a <see cref="Scale3f"/> transformation (as a 2x2 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator *(M22f matrix, Scale3f scale)
        {
            return new M22f(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation (as a 2x2 matrix) with a <see cref="M23f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator *(Scale3f scale, M23f matrix)
        {
            return new M23f(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation (as a 3x3 matrix) with a <see cref="M33f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator *(Scale3f scale, M33f matrix)
        {
            return new M33f(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, 
                scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="M33f"/> with a <see cref="Scale3f"/> transformation (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator *(M33f matrix, Scale3f scale)
        {
            return new M33f(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation (as a 3x3 matrix) with a <see cref="M34f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator *(Scale3f scale, M34f matrix)
        {
            return new M34f(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
                scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22, scale.Z * matrix.M23);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation (as a 4x4 matrix) with a <see cref="M44f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator *(Scale3f scale, M44f matrix)
        {
            return new M44f(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
                scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22, scale.Z * matrix.M23, 
                matrix.M30, matrix.M31, matrix.M32, matrix.M33);
        }

        /// <summary>
        /// Multiplies a <see cref="M44f"/> with a <see cref="Scale3f"/> transformation (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator *(M44f matrix, Scale3f scale)
        {
            return new M44f(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, matrix.M03, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, matrix.M13, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z, matrix.M23, 
                matrix.M30 * scale.X, matrix.M31 * scale.Y, matrix.M32 * scale.Z, matrix.M33);
        }

        #endregion

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Scale3f"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Scale3f s0, Scale3f s1)
            => s0.X == s1.X && s0.Y == s1.Y && s0.Z == s1.Z;

        /// <summary>
        /// Checks whether two <see cref="Scale3f"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Scale3f s0, Scale3f s1)
            => s0.X != s1.X || s0.Y != s1.Y || s0.Z != s1.Z;

        #endregion

        #region Conversion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M22f(Scale3f s)
        {
            return new M22f(
                s.X, 0  , 
                0  , s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M23f(Scale3f s)
        {
            return new M23f(
                s.X, 0  , 0  , 
                0  , s.Y, 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33f(Scale3f s)
        {
            return new M33f(
                s.X, 0  , 0  , 
                0  , s.Y, 0  , 
                0  , 0  , s.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M34f(Scale3f s)
        {
            return new M34f(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , s.Z, 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44f(Scale3f s)
        {
            return new M44f(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , s.Z, 0  , 
                0  , 0  , 0  , 1  );
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine3f(Scale3f s)
            => new Affine3f((M33f)s);

        /// <summary>
        /// Returns all values of a <see cref="Scale3f"/> instance
        /// in a float[] array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator float[](Scale3f s)
            => (float[])s.V;

        #endregion

        #region Indexing

        public float this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                switch (index)
                {
                    case 0: return V.X;
                    case 1: return V.Y;
                    case 2: return V.Z;
                    default: throw new IndexOutOfRangeException();
                }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                switch (index)
                {
                    case 0: V.X = value; return;
                    case 1: V.Y = value; return;
                    case 2: V.Z = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return V.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is Scale3f)
            {
                Scale3f v = (Scale3f)obj;
                return X == v.X && Y == v.Y && Z == v.Z;
            }
            return false;
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}, {2}]", X, Y, Z);
        }

        public static Scale3f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Scale3f(
                float.Parse(x[0], CultureInfo.InvariantCulture), 
                float.Parse(x[1], CultureInfo.InvariantCulture), 
                float.Parse(x[2], CultureInfo.InvariantCulture)
            );
        }

        #endregion
    }

    public static partial class Scale
    {
        #region Invert

        /// <summary>
        /// Inverts a <see cref="Scale3f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Scale3f scale)
        {
            scale = scale.Inverse;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V3f"/> vector by a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this Scale3f s, V3f v)
            => new V3f(v.X * s.X, v.Y * s.Y, v.Z * s.Z);

        /// <summary>
        /// Transforms a <see cref="V3f"/> vector by the inverse of a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f InvTransform(this Scale3f s, V3f v)
            => new V3f(v.X / s.X, v.Y / s.Y, v.Z / s.Z);

        /// <summary>
        /// Transforms a <see cref="V4f"/> vector by a <see cref="Scale3f"/> transformation.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Transform(this Scale3f s, V4f v)
            => new V4f(v.X * s.X, v.Y * s.Y, v.Z * s.Z, v.W);

        /// <summary>
        /// Transforms a <see cref="V4f"/> vector by the inverse of a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f InvTransform(this Scale3f s, V4f v)
            => new V4f(v.X / s.X, v.Y / s.Y, v.Z / s.Z, v.W);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale3f s0, Scale3f s1)
        {
            return ApproximateEquals(s0.V, s1.V, Constant<float>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale3f s0, Scale3f s1, float tolerance)
        {
            return ApproximateEquals(s0.V, s1.V, tolerance);
        }

        #endregion
    }

    #endregion

    #region Scale2d

    /// <summary>
    /// A 2-dimensional scaling transform with different scaling values
    /// in each dimension.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Scale2d
    {
        [DataMember]
        public V2d V;

        #region Constructors

        /// <summary>
        /// Constructs a <see cref="Scale2d"/> transformation from 2 doubles.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2d(double sX, double sY)
        {
            V = new V2d(sX, sY);
        }

        /// <summary>
        /// Constructs a <see cref="Scale2d"/> from 2 scaling factors provided as <see cref="V2d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2d(V2d scalingFactors)
        {
            V = scalingFactors;
        }

        /// <summary>
        /// Constructs a <see cref="Scale2d"/> transformation from a uniform double value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2d(double uniform)
        {
            V = new V2d(uniform, uniform);
        }

        /// <summary>
        /// Constructs a copy of a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2d(Scale2d scale)
        {
            V = scale.V;
        }

        /// <summary>
        /// Constructs a <see cref="Scale2d"/> transformation from a double-array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2d(double[] array)
        {
            V = new V2d(array);
        }

        /// <summary>
        /// Constructs a <see cref="Scale2d"/> transformation from a double-array starting from the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2d(double[] array, int start)
        {
            V = new V2d(array, start);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets and sets the X coordinate.
        /// </summary>
        public double X
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.X = value; }
        }

        /// <summary>
        /// Gets and sets the Y coordinate.
        /// </summary>
        public double Y
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Y = value; }
        }

        /// <summary>
        /// Gets the inverse of this <see cref="Scale2d"/> transformation.
        /// </summary>
        public Scale2d Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2d(1 / X, 1 / Y);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity <see cref="Scale2d"/> transformation.
        /// </summary>
        public static Scale2d Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2d(1, 1);
        }

        /// <summary>
        /// Gets a <see cref="Scale2d"/> transformation with all components set to zero.
        /// </summary>
        public static Scale2d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2d(0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale2d"/> transformation with scaling factors (1, 0).
        /// </summary>
        public static Scale2d XAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2d(1, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale2d"/> transformation with scaling factors (0, 1).
        /// </summary>
        public static Scale2d YAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2d(0, 1);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Negates the values of a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d operator -(Scale2d scale)
        {
            return new Scale2d(-scale.X, -scale.Y);
        }

        #region Scale / Scalar

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation with a double scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d operator *(Scale2d scale, double scalar)
        {
            return new Scale2d(scale.X * scalar, scale.Y * scalar);
        }

        /// <summary>
        /// Multiplies a double scalar with a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d operator *(double scalar, Scale2d scale)
        {
            return new Scale2d(scale.X * scalar, scale.Y * scalar);
        }

        /// <summary>
        /// Divides a <see cref="Scale2d"/> transformation by a double scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d operator /(Scale2d scale, double scalar)
        {
            return new Scale2d(scale.X / scalar, scale.Y / scalar);
        }

        /// <summary>
        /// Divides a double scalar by a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d operator /(double scalar, Scale2d scale)
        {
            return new Scale2d(scalar / scale.X, scalar / scale.Y);
        }

        #endregion

        #region Scale / Vector Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation with a <see cref="V2d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d operator *(Scale2d scale, V2d vector)
        {
            return new V2d(vector.X * scale.X, vector.Y * scale.Y);
        }

        #endregion

        #region Scale / Scale Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation with a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d operator *(Scale2d a, Scale2d b)
            => new Scale2d(a.X * b.X, a.Y * b.Y);

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation with a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator *(Scale2d a, Scale3d b)
            => new Scale3d(a.X * b.X, a.Y * b.Y, b.Z);

        #endregion

        #region Scale / Matrix Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation (as a 2x2 matrix) with a <see cref="M22d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator *(Scale2d scale, M22d matrix)
        {
            return new M22d(
                scale.X * matrix.M00, scale.X * matrix.M01, 
                scale.Y * matrix.M10, scale.Y * matrix.M11);
        }

        /// <summary>
        /// Multiplies a <see cref="M22d"/> with a <see cref="Scale2d"/> transformation (as a 2x2 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator *(M22d matrix, Scale2d scale)
        {
            return new M22d(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation (as a 2x2 matrix) with a <see cref="M23d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator *(Scale2d scale, M23d matrix)
        {
            return new M23d(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation (as a 3x3 matrix) with a <see cref="M33d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator *(Scale2d scale, M33d matrix)
        {
            return new M33d(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, 
                matrix.M20, matrix.M21, matrix.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="M33d"/> with a <see cref="Scale2d"/> transformation (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator *(M33d matrix, Scale2d scale)
        {
            return new M33d(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation (as a 3x3 matrix) with a <see cref="M34d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator *(Scale2d scale, M34d matrix)
        {
            return new M34d(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
                matrix.M20, matrix.M21, matrix.M22, matrix.M23);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation (as a 4x4 matrix) with a <see cref="M44d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator *(Scale2d scale, M44d matrix)
        {
            return new M44d(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
                matrix.M20, matrix.M21, matrix.M22, matrix.M23, 
                matrix.M30, matrix.M31, matrix.M32, matrix.M33);
        }

        /// <summary>
        /// Multiplies a <see cref="M44d"/> with a <see cref="Scale2d"/> transformation (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator *(M44d matrix, Scale2d scale)
        {
            return new M44d(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02, matrix.M03, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12, matrix.M13, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22, matrix.M23, 
                matrix.M30 * scale.X, matrix.M31 * scale.Y, matrix.M32, matrix.M33);
        }

        #endregion

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Scale2d"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Scale2d s0, Scale2d s1)
            => s0.X == s1.X && s0.Y == s1.Y;

        /// <summary>
        /// Checks whether two <see cref="Scale2d"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Scale2d s0, Scale2d s1)
            => s0.X != s1.X || s0.Y != s1.Y;

        #endregion

        #region Conversion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M22d(Scale2d s)
        {
            return new M22d(
                s.X, 0  , 
                0  , s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M23d(Scale2d s)
        {
            return new M23d(
                s.X, 0  , 0  , 
                0  , s.Y, 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33d(Scale2d s)
        {
            return new M33d(
                s.X, 0  , 0  , 
                0  , s.Y, 0  , 
                0  , 0  , 1  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M34d(Scale2d s)
        {
            return new M34d(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , 1  , 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44d(Scale2d s)
        {
            return new M44d(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , 1  , 0  , 
                0  , 0  , 0  , 1  );
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine2d(Scale2d s)
            => new Affine2d((M22d)s);

        /// <summary>
        /// Returns all values of a <see cref="Scale2d"/> instance
        /// in a double[] array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator double[](Scale2d s)
            => (double[])s.V;

        #endregion

        #region Indexing

        public double this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                switch (index)
                {
                    case 0: return V.X;
                    case 1: return V.Y;
                    default: throw new IndexOutOfRangeException();
                }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                switch (index)
                {
                    case 0: V.X = value; return;
                    case 1: V.Y = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return V.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is Scale2d)
            {
                Scale2d v = (Scale2d)obj;
                return X == v.X && Y == v.Y;
            }
            return false;
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}]", X, Y);
        }

        public static Scale2d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Scale2d(
                double.Parse(x[0], CultureInfo.InvariantCulture), 
                double.Parse(x[1], CultureInfo.InvariantCulture)
            );
        }

        #endregion
    }

    public static partial class Scale
    {
        #region Invert

        /// <summary>
        /// Inverts a <see cref="Scale2d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Scale2d scale)
        {
            scale = scale.Inverse;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V2d"/> vector by a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d Transform(this Scale2d s, V2d v)
            => new V2d(v.X * s.X, v.Y * s.Y);

        /// <summary>
        /// Transforms a <see cref="V2d"/> vector by the inverse of a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d InvTransform(this Scale2d s, V2d v)
            => new V2d(v.X / s.X, v.Y / s.Y);

        /// <summary>
        /// Transforms a <see cref="V3d"/> vector by a <see cref="Scale2d"/> transformation.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this Scale2d s, V3d v)
            => new V3d(v.X * s.X, v.Y * s.Y, v.Z);

        /// <summary>
        /// Transforms a <see cref="V3d"/> vector by the inverse of a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d InvTransform(this Scale2d s, V3d v)
            => new V3d(v.X / s.X, v.Y / s.Y, v.Z);

        /// <summary>
        /// Transforms a <see cref="V4d"/> vector by a <see cref="Scale2d"/> transformation.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Transform(this Scale2d s, V4d v)
            => new V4d(v.X * s.X, v.Y * s.Y, v.Z, v.W);

        /// <summary>
        /// Transforms a <see cref="V4d"/> vector by the inverse of a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d InvTransform(this Scale2d s, V4d v)
            => new V4d(v.X / s.X, v.Y / s.Y, v.Z, v.W);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale2d s0, Scale2d s1)
        {
            return ApproximateEquals(s0.V, s1.V, Constant<double>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale2d s0, Scale2d s1, double tolerance)
        {
            return ApproximateEquals(s0.V, s1.V, tolerance);
        }

        #endregion
    }

    #endregion

    #region Scale3d

    /// <summary>
    /// A 3-dimensional scaling transform with different scaling values
    /// in each dimension.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Scale3d
    {
        [DataMember]
        public V3d V;

        #region Constructors

        /// <summary>
        /// Constructs a <see cref="Scale3d"/> transformation from 3 doubles.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3d(double sX, double sY, double sZ)
        {
            V = new V3d(sX, sY, sZ);
        }

        /// <summary>
        /// Constructs a <see cref="Scale3d"/> from 3 scaling factors provided as <see cref="V3d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3d(V3d scalingFactors)
        {
            V = scalingFactors;
        }

        /// <summary>
        /// Constructs a <see cref="Scale3d"/> transformation from a uniform double value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3d(double uniform)
        {
            V = new V3d(uniform, uniform, uniform);
        }

        /// <summary>
        /// Constructs a copy of a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3d(Scale3d scale)
        {
            V = scale.V;
        }

        /// <summary>
        /// Constructs a <see cref="Scale3d"/> transformation from a double-array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3d(double[] array)
        {
            V = new V3d(array);
        }

        /// <summary>
        /// Constructs a <see cref="Scale3d"/> transformation from a double-array starting from the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3d(double[] array, int start)
        {
            V = new V3d(array, start);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets and sets the X coordinate.
        /// </summary>
        public double X
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.X = value; }
        }

        /// <summary>
        /// Gets and sets the Y coordinate.
        /// </summary>
        public double Y
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Y = value; }
        }

        /// <summary>
        /// Gets and sets the Z coordinate.
        /// </summary>
        public double Z
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Z; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Z = value; }
        }

        /// <summary>
        /// Gets the inverse of this <see cref="Scale3d"/> transformation.
        /// </summary>
        public Scale3d Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3d(1 / X, 1 / Y, 1 / Z);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity <see cref="Scale3d"/> transformation.
        /// </summary>
        public static Scale3d Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3d(1, 1, 1);
        }

        /// <summary>
        /// Gets a <see cref="Scale3d"/> transformation with all components set to zero.
        /// </summary>
        public static Scale3d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3d(0, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale3d"/> transformation with scaling factors (1, 0, 0).
        /// </summary>
        public static Scale3d XAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3d(1, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale3d"/> transformation with scaling factors (0, 1, 0).
        /// </summary>
        public static Scale3d YAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3d(0, 1, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale3d"/> transformation with scaling factors (0, 0, 1).
        /// </summary>
        public static Scale3d ZAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3d(0, 0, 1);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Negates the values of a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator -(Scale3d scale)
        {
            return new Scale3d(-scale.X, -scale.Y, -scale.Z);
        }

        #region Scale / Scalar

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation with a double scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator *(Scale3d scale, double scalar)
        {
            return new Scale3d(scale.X * scalar, scale.Y * scalar, scale.Z * scalar);
        }

        /// <summary>
        /// Multiplies a double scalar with a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator *(double scalar, Scale3d scale)
        {
            return new Scale3d(scale.X * scalar, scale.Y * scalar, scale.Z * scalar);
        }

        /// <summary>
        /// Divides a <see cref="Scale3d"/> transformation by a double scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator /(Scale3d scale, double scalar)
        {
            return new Scale3d(scale.X / scalar, scale.Y / scalar, scale.Z / scalar);
        }

        /// <summary>
        /// Divides a double scalar by a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator /(double scalar, Scale3d scale)
        {
            return new Scale3d(scalar / scale.X, scalar / scale.Y, scalar / scale.Z);
        }

        #endregion

        #region Scale / Vector Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation with a <see cref="V3d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d operator *(Scale3d scale, V3d vector)
        {
            return new V3d(vector.X * scale.X, vector.Y * scale.Y, vector.Z * scale.Z);
        }

        #endregion

        #region Scale / Scale Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation with a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator *(Scale3d a, Scale2d b)
            => new Scale3d(a.X * b.X, a.Y * b.Y, a.Z);

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation with a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator *(Scale3d a, Scale3d b)
            => new Scale3d(a.X * b.X, a.Y * b.Y, a.Z * b.Z);

        #endregion

        #region Scale / Matrix Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation (as a 2x2 matrix) with a <see cref="M22d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator *(Scale3d scale, M22d matrix)
        {
            return new M22d(
                scale.X * matrix.M00, scale.X * matrix.M01, 
                scale.Y * matrix.M10, scale.Y * matrix.M11);
        }

        /// <summary>
        /// Multiplies a <see cref="M22d"/> with a <see cref="Scale3d"/> transformation (as a 2x2 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator *(M22d matrix, Scale3d scale)
        {
            return new M22d(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation (as a 2x2 matrix) with a <see cref="M23d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator *(Scale3d scale, M23d matrix)
        {
            return new M23d(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation (as a 3x3 matrix) with a <see cref="M33d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator *(Scale3d scale, M33d matrix)
        {
            return new M33d(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, 
                scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="M33d"/> with a <see cref="Scale3d"/> transformation (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator *(M33d matrix, Scale3d scale)
        {
            return new M33d(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation (as a 3x3 matrix) with a <see cref="M34d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator *(Scale3d scale, M34d matrix)
        {
            return new M34d(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
                scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22, scale.Z * matrix.M23);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation (as a 4x4 matrix) with a <see cref="M44d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator *(Scale3d scale, M44d matrix)
        {
            return new M44d(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
                scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22, scale.Z * matrix.M23, 
                matrix.M30, matrix.M31, matrix.M32, matrix.M33);
        }

        /// <summary>
        /// Multiplies a <see cref="M44d"/> with a <see cref="Scale3d"/> transformation (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator *(M44d matrix, Scale3d scale)
        {
            return new M44d(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, matrix.M03, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, matrix.M13, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z, matrix.M23, 
                matrix.M30 * scale.X, matrix.M31 * scale.Y, matrix.M32 * scale.Z, matrix.M33);
        }

        #endregion

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Scale3d"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Scale3d s0, Scale3d s1)
            => s0.X == s1.X && s0.Y == s1.Y && s0.Z == s1.Z;

        /// <summary>
        /// Checks whether two <see cref="Scale3d"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Scale3d s0, Scale3d s1)
            => s0.X != s1.X || s0.Y != s1.Y || s0.Z != s1.Z;

        #endregion

        #region Conversion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M22d(Scale3d s)
        {
            return new M22d(
                s.X, 0  , 
                0  , s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M23d(Scale3d s)
        {
            return new M23d(
                s.X, 0  , 0  , 
                0  , s.Y, 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33d(Scale3d s)
        {
            return new M33d(
                s.X, 0  , 0  , 
                0  , s.Y, 0  , 
                0  , 0  , s.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M34d(Scale3d s)
        {
            return new M34d(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , s.Z, 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44d(Scale3d s)
        {
            return new M44d(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , s.Z, 0  , 
                0  , 0  , 0  , 1  );
        }


        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine3d(Scale3d s)
            => new Affine3d((M33d)s);

        /// <summary>
        /// Returns all values of a <see cref="Scale3d"/> instance
        /// in a double[] array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator double[](Scale3d s)
            => (double[])s.V;

        #endregion

        #region Indexing

        public double this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                switch (index)
                {
                    case 0: return V.X;
                    case 1: return V.Y;
                    case 2: return V.Z;
                    default: throw new IndexOutOfRangeException();
                }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                switch (index)
                {
                    case 0: V.X = value; return;
                    case 1: V.Y = value; return;
                    case 2: V.Z = value; return;
                    default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return V.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is Scale3d)
            {
                Scale3d v = (Scale3d)obj;
                return X == v.X && Y == v.Y && Z == v.Z;
            }
            return false;
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}, {2}]", X, Y, Z);
        }

        public static Scale3d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Scale3d(
                double.Parse(x[0], CultureInfo.InvariantCulture), 
                double.Parse(x[1], CultureInfo.InvariantCulture), 
                double.Parse(x[2], CultureInfo.InvariantCulture)
            );
        }

        #endregion
    }

    public static partial class Scale
    {
        #region Invert

        /// <summary>
        /// Inverts a <see cref="Scale3d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Scale3d scale)
        {
            scale = scale.Inverse;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V3d"/> vector by a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this Scale3d s, V3d v)
            => new V3d(v.X * s.X, v.Y * s.Y, v.Z * s.Z);

        /// <summary>
        /// Transforms a <see cref="V3d"/> vector by the inverse of a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d InvTransform(this Scale3d s, V3d v)
            => new V3d(v.X / s.X, v.Y / s.Y, v.Z / s.Z);

        /// <summary>
        /// Transforms a <see cref="V4d"/> vector by a <see cref="Scale3d"/> transformation.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Transform(this Scale3d s, V4d v)
            => new V4d(v.X * s.X, v.Y * s.Y, v.Z * s.Z, v.W);

        /// <summary>
        /// Transforms a <see cref="V4d"/> vector by the inverse of a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d InvTransform(this Scale3d s, V4d v)
            => new V4d(v.X / s.X, v.Y / s.Y, v.Z / s.Z, v.W);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale3d s0, Scale3d s1)
        {
            return ApproximateEquals(s0.V, s1.V, Constant<double>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale3d s0, Scale3d s1, double tolerance)
        {
            return ApproximateEquals(s0.V, s1.V, tolerance);
        }

        #endregion
    }

    #endregion

}
