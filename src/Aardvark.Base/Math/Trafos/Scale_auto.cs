/*
    Copyright 2006-2025. The Aardvark Platform Team.

        https://aardvark.graphics

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/
using System;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;
using System.Xml.Serialization;

namespace Aardvark.Base;

// AUTOGENERATED CODE - DO NOT CHANGE!

#region Scale2f

/// <summary>
/// A 2-dimensional scaling transform with different scaling values
/// in each dimension.
/// </summary>
[DataContract]
[StructLayout(LayoutKind.Sequential)]
public partial struct Scale2f : IEquatable<Scale2f>
{
    [DataMember]
    [XmlIgnore]
    public V2f V;

    #region Constructors

    /// <summary>
    /// Constructs a <see cref="Scale2f"/> transformation from 2 floats.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale2f(float sX, float sY)
    {
        V = new V2f(sX, sY);
    }

    /// <summary>
    /// Constructs a <see cref="Scale2f"/> from 2 scaling factors provided as <see cref="V2f"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale2f(V2f scalingFactors)
    {
        V = scalingFactors;
    }

    /// <summary>
    /// Constructs a <see cref="Scale2f"/> transformation from a uniform float value.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale2f(float uniform)
    {
        V = new V2f(uniform, uniform);
    }

    /// <summary>
    /// Constructs a copy of a <see cref="Scale2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale2f(Scale2f scale)
    {
        V = scale.V;
    }

    /// <summary>
    /// Constructs a <see cref="Scale2f"/> transformation from a <see cref="Scale2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale2f(Scale2d scale)
    {
        V = (V2f)scale.V;
    }

    /// <summary>
    /// Constructs a <see cref="Scale2f"/> transformation from a float-array.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale2f(float[] array)
    {
        V = new V2f(array);
    }

    /// <summary>
    /// Constructs a <see cref="Scale2f"/> transformation from a float-array starting from the given index.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale2f(float[] array, int start)
    {
        V = new V2f(array, start);
    }

    #endregion

    #region Properties

    /// <summary>
    /// Gets and sets the X coordinate.
    /// </summary>
    public float X
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.X; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.X = value; }
    }

    /// <summary>
    /// Gets and sets the Y coordinate.
    /// </summary>
    public float Y
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.Y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.Y = value; }
    }

    /// <summary>
    /// Gets the inverse of this <see cref="Scale2f"/> transformation.
    /// </summary>
    public readonly Scale2f Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1 / X, 1 / Y);
    }

    #endregion

    #region Constants

    /// <summary>
    /// Gets the identity <see cref="Scale2f"/> transformation.
    /// </summary>
    public static Scale2f Identity
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1, 1);
    }

    /// <summary>
    /// Gets a <see cref="Scale2f"/> transformation with all components set to zero.
    /// </summary>
    public static Scale2f Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 0);
    }

    /// <summary>
    /// Gets a <see cref="Scale2f"/> transformation with scaling factors (1, 0).
    /// </summary>
    public static Scale2f XAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1, 0);
    }

    /// <summary>
    /// Gets a <see cref="Scale2f"/> transformation with scaling factors (0, 1).
    /// </summary>
    public static Scale2f YAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 1);
    }

    #endregion

    #region Arithmetic Operators

    /// <summary>
    /// Negates the values of a <see cref="Scale2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2f operator -(Scale2f scale)
        => new(-scale.X, -scale.Y);

    #region Scale / Scalar

    /// <summary>
    /// Multiplies a <see cref="Scale2f"/> transformation with a float scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2f operator *(Scale2f scale, float scalar)
        => new(scale.X * scalar, scale.Y * scalar);

    /// <summary>
    /// Multiplies a float scalar with a <see cref="Scale2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2f operator *(float scalar, Scale2f scale)
        => new(scale.X * scalar, scale.Y * scalar);

    /// <summary>
    /// Divides a <see cref="Scale2f"/> transformation by a float scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2f operator /(Scale2f scale, float scalar)
        => new(scale.X / scalar, scale.Y / scalar);

    /// <summary>
    /// Divides a float scalar by a <see cref="Scale2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2f operator /(float scalar, Scale2f scale)
        => new(scalar / scale.X, scalar / scale.Y);

    #endregion

    #region Scale / Vector Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale2f"/> transformation with a <see cref="V2f"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V2f operator *(Scale2f scale, V2f vector)
        => new(vector.X * scale.X, vector.Y * scale.Y);

    #endregion

    #region Scale / Scale Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale2f"/> transformation with a <see cref="Scale2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2f operator *(Scale2f a, Scale2f b)
        => new(a.X * b.X, a.Y * b.Y);

    /// <summary>
    /// Multiplies a <see cref="Scale2f"/> transformation with a <see cref="Scale3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3f operator *(Scale2f a, Scale3f b)
        => new(a.X * b.X, a.Y * b.Y, b.Z);

    #endregion

    #region Scale / Matrix Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale2f"/> transformation (as a 2x2 matrix) with a <see cref="M22f"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M22f operator *(Scale2f scale, M22f matrix)
        => new(
            scale.X * matrix.M00, scale.X * matrix.M01, 
            scale.Y * matrix.M10, scale.Y * matrix.M11);

    /// <summary>
    /// Multiplies a <see cref="M22f"/> with a <see cref="Scale2f"/> transformation (as a 2x2 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M22f operator *(M22f matrix, Scale2f scale)
        => new(
            matrix.M00 * scale.X, matrix.M01 * scale.Y, 
            matrix.M10 * scale.X, matrix.M11 * scale.Y);

    /// <summary>
    /// Multiplies a <see cref="Scale2f"/> transformation (as a 2x2 matrix) with a <see cref="M23f"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M23f operator *(Scale2f scale, M23f matrix)
        => new(
            scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
            scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12);

    /// <summary>
    /// Multiplies a <see cref="M23f"/> with a <see cref="Scale2f"/> transformation (as a 3x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M23f operator *(M23f matrix, Scale2f scale)
        => new(
            matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02, 
            matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12);

    /// <summary>
    /// Multiplies a <see cref="Scale2f"/> transformation (as a 3x3 matrix) with a <see cref="M33f"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M33f operator *(Scale2f scale, M33f matrix)
        => new(
            scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
            scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, 
            matrix.M20, matrix.M21, matrix.M22);

    /// <summary>
    /// Multiplies a <see cref="M33f"/> with a <see cref="Scale2f"/> transformation (as a 3x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M33f operator *(M33f matrix, Scale2f scale)
        => new(
            matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02, 
            matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12, 
            matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22);

    #endregion

    #region Scale / Rot, Shift Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale2f"/> transformation with a <see cref="Rot2f"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Affine2f operator *(Scale2f a, Rot2f b)
        => new((M22f)a * (M22f)b);

    /// <summary>
    /// Multiplies a <see cref="Scale2f"/> transformation with a <see cref="Shift2f"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Affine2f operator *(Scale2f a, Shift2f b)
        => new((M22f)a, a * b.V);

    #endregion

    #endregion

    #region Comparison Operators

    /// <summary>
    /// Checks whether two <see cref="Scale2f"/> transformations are equal.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Scale2f s0, Scale2f s1)
        => s0.X == s1.X && s0.Y == s1.Y;

    /// <summary>
    /// Checks whether two <see cref="Scale2f"/> transformations are different.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Scale2f s0, Scale2f s1)
        => s0.X != s1.X || s0.Y != s1.Y;

    #endregion

    #region Static Creators

    /// <summary>
    /// Creates a <see cref="Scale2f"/> transformation from a <see cref="M22f"/> matrix.
    /// The matrix must only contain scaling components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2f FromM22f(M22f m, float epsilon = (float)1e-6)
    {
        if (!(Fun.IsTiny(m.C0 * V2f.OI, epsilon) && Fun.IsTiny(m.C1 * V2f.IO, epsilon)))
            throw new ArgumentException("Matrix is not a pure scaling matrix.");

        return new(m.M00, m.M11);
    }

    /// <summary>
    /// Creates a <see cref="Scale2f"/> transformation from a scaling <see cref="M33f"/> matrix.
    /// The matrix has to be homogeneous and must not contain perspective components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2f FromM33f(M33f m, float epsilon = (float)1e-6)
    {
        if (!(Fun.IsTiny(m.C0.XY * V2f.OI, epsilon) && Fun.IsTiny(m.C1.XY * V2f.IO, epsilon)))
            throw new ArgumentException("Matrix is not a pure scaling matrix.");

        if (!(m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon)))
            throw new ArgumentException("Matrix contains perspective components.");

        if (!m.C2.XY.IsTiny(epsilon))
            throw new ArgumentException("Matrix contains translational component.");

        if (m.M22.IsTiny(epsilon))
            throw new ArgumentException("Matrix is not homogeneous.");

        return new(m.M00 / m.M22, m.M11 / m.M22);
    }

    /// <summary>
    /// Creates a <see cref="Scale2f"/> transformation from a <see cref="Similarity2f"/>.
    /// The transformation <paramref name="similarity"/> must only consist of a scaling.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2f FromSimilarity2f(Similarity2f similarity, float epsilon = 1e-5f)
    {
        if (!similarity.Trans.IsTiny(epsilon))
            throw new ArgumentException("Similarity transformation contains translational component");

        if (!similarity.Rot.ApproximateEquals(Rot2f.Identity, epsilon))
            throw new ArgumentException("Similarity transformation contains rotational component");

        return new(similarity.Scale);
    }

    /// <summary>
    /// Creates a <see cref="Scale2f"/> transformation from an <see cref="Affine2f"/>.
    /// The transformation <paramref name="affine"/> must only consist of a scaling.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2f FromAffine2f(Affine2f affine, float epsilon = 1e-5f)
        => FromM33f((M33f)affine, epsilon);

    /// <summary>
    /// Creates a <see cref="Scale2f"/> transformation from a <see cref="Trafo2f"/>.
    /// The transformation <paramref name="trafo"/> must only consist of a scaling.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2f FromTrafo2f(Trafo2f trafo, float epsilon = 1e-5f)
        => FromM33f(trafo.Forward, epsilon);

    #endregion

    #region Conversion

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M22f(Scale2f s)
        => new(
            s.X, 0  , 
            0  , s.Y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M23f(Scale2f s)
        => new(
            s.X, 0  , 0  , 
            0  , s.Y, 0  );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M33f(Scale2f s)
        => new(
            s.X, 0  , 0  , 
            0  , s.Y, 0  , 
            0  , 0  , 1  );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M34f(Scale2f s)
        => new(
            s.X, 0  , 0  , 0  , 
            0  , s.Y, 0  , 0  , 
            0  , 0  , 1  , 0  );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M44f(Scale2f s)
        => new(
            s.X, 0  , 0  , 0  , 
            0  , s.Y, 0  , 0  , 
            0  , 0  , 1  , 0  , 
            0  , 0  , 0  , 1  );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Affine2f(Scale2f s)
        => new((M22f)s, V2f.Zero);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Trafo2f(Scale2f s)
        => new((M33f)s, (M33f)s.Inverse);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Scale2d(Scale2f s)
        => new((V2d)s.V);

    /// <summary>
    /// Returns all values of a <see cref="Scale2f"/> instance
    /// in a float[] array.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator float[](Scale2f s)
        => (float[])s.V;

    #endregion

    #region Indexing

    public float this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get => V[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => V[index] = value;
    }

    #endregion

    #region Overrides

    public override readonly int GetHashCode()
        => V.GetHashCode();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Equals(Scale2f other)
        => X.Equals(other.X) && Y.Equals(other.Y);

    public override readonly bool Equals(object other)
        => (other is Scale2f o) && Equals(o);

    public override readonly string ToString()
        => string.Format(CultureInfo.InvariantCulture, "[{0}, {1}]", X, Y);

    public static Scale2f Parse(string s)
    {
        var x = s.NestedBracketSplitLevelOne().ToArray();
        return new(
            float.Parse(x[0], CultureInfo.InvariantCulture), 
            float.Parse(x[1], CultureInfo.InvariantCulture)
        );
    }

    #endregion
}

public static partial class Scale
{
    #region Invert

    /// <summary>
    /// Returns the inverse of a <see cref="Scale2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2f Inverse(Scale2f scale)
        => scale.Inverse;

    /// <summary>
    /// Inverts a <see cref="Scale2f"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Invert(this ref Scale2f scale)
    {
        scale.V.X = 1 / scale.V.X;
        scale.V.Y = 1 / scale.V.Y;
    }

    #endregion

    #region Transformations

    /// <summary>
    /// Transforms a <see cref="V2f"/> vector by a <see cref="Scale2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V2f Transform(this Scale2f s, V2f v)
        => new(v.X * s.X, v.Y * s.Y);

    /// <summary>
    /// Transforms a <see cref="V2f"/> vector by the inverse of a <see cref="Scale2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V2f InvTransform(this Scale2f s, V2f v)
        => new(v.X / s.X, v.Y / s.Y);

    /// <summary>
    /// Transforms a <see cref="V3f"/> vector by a <see cref="Scale2f"/> transformation.
    /// v.Z is not modified.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3f Transform(this Scale2f s, V3f v)
        => new(v.X * s.X, v.Y * s.Y, v.Z);

    /// <summary>
    /// Transforms a <see cref="V3f"/> vector by the inverse of a <see cref="Scale2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3f InvTransform(this Scale2f s, V3f v)
        => new(v.X / s.X, v.Y / s.Y, v.Z);

    /// <summary>
    /// Transforms a <see cref="V4f"/> vector by a <see cref="Scale2f"/> transformation.
    /// v.Z and v.W are not modified.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4f Transform(this Scale2f s, V4f v)
        => new(v.X * s.X, v.Y * s.Y, v.Z, v.W);

    /// <summary>
    /// Transforms a <see cref="V4f"/> vector by the inverse of a <see cref="Scale2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4f InvTransform(this Scale2f s, V4f v)
        => new(v.X / s.X, v.Y / s.Y, v.Z, v.W);

    #endregion
}

public static partial class Fun
{
    #region ApproximateEquals

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Scale2f s0, Scale2f s1)
        => ApproximateEquals(s0.V, s1.V, Constant<float>.PositiveTinyValue);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Scale2f s0, Scale2f s1, float tolerance)
        => ApproximateEquals(s0.V, s1.V, tolerance);

    #endregion
}

#endregion

#region Scale3f

/// <summary>
/// A 3-dimensional scaling transform with different scaling values
/// in each dimension.
/// </summary>
[DataContract]
[StructLayout(LayoutKind.Sequential)]
public partial struct Scale3f : IEquatable<Scale3f>
{
    [DataMember]
    [XmlIgnore]
    public V3f V;

    #region Constructors

    /// <summary>
    /// Constructs a <see cref="Scale3f"/> transformation from 3 floats.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale3f(float sX, float sY, float sZ)
    {
        V = new V3f(sX, sY, sZ);
    }

    /// <summary>
    /// Constructs a <see cref="Scale3f"/> from 3 scaling factors provided as <see cref="V3f"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale3f(V3f scalingFactors)
    {
        V = scalingFactors;
    }

    /// <summary>
    /// Constructs a <see cref="Scale3f"/> transformation from a uniform float value.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale3f(float uniform)
    {
        V = new V3f(uniform, uniform, uniform);
    }

    /// <summary>
    /// Constructs a copy of a <see cref="Scale3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale3f(Scale3f scale)
    {
        V = scale.V;
    }

    /// <summary>
    /// Constructs a <see cref="Scale3f"/> transformation from a <see cref="Scale3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale3f(Scale3d scale)
    {
        V = (V3f)scale.V;
    }

    /// <summary>
    /// Constructs a <see cref="Scale3f"/> transformation from a float-array.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale3f(float[] array)
    {
        V = new V3f(array);
    }

    /// <summary>
    /// Constructs a <see cref="Scale3f"/> transformation from a float-array starting from the given index.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale3f(float[] array, int start)
    {
        V = new V3f(array, start);
    }

    #endregion

    #region Properties

    /// <summary>
    /// Gets and sets the X coordinate.
    /// </summary>
    public float X
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.X; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.X = value; }
    }

    /// <summary>
    /// Gets and sets the Y coordinate.
    /// </summary>
    public float Y
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.Y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.Y = value; }
    }

    /// <summary>
    /// Gets and sets the Z coordinate.
    /// </summary>
    public float Z
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.Z; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.Z = value; }
    }

    /// <summary>
    /// Gets the inverse of this <see cref="Scale3f"/> transformation.
    /// </summary>
    public readonly Scale3f Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1 / X, 1 / Y, 1 / Z);
    }

    #endregion

    #region Constants

    /// <summary>
    /// Gets the identity <see cref="Scale3f"/> transformation.
    /// </summary>
    public static Scale3f Identity
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1, 1, 1);
    }

    /// <summary>
    /// Gets a <see cref="Scale3f"/> transformation with all components set to zero.
    /// </summary>
    public static Scale3f Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 0, 0);
    }

    /// <summary>
    /// Gets a <see cref="Scale3f"/> transformation with scaling factors (1, 0, 0).
    /// </summary>
    public static Scale3f XAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1, 0, 0);
    }

    /// <summary>
    /// Gets a <see cref="Scale3f"/> transformation with scaling factors (0, 1, 0).
    /// </summary>
    public static Scale3f YAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 1, 0);
    }

    /// <summary>
    /// Gets a <see cref="Scale3f"/> transformation with scaling factors (0, 0, 1).
    /// </summary>
    public static Scale3f ZAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 0, 1);
    }

    #endregion

    #region Arithmetic Operators

    /// <summary>
    /// Negates the values of a <see cref="Scale3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3f operator -(Scale3f scale)
        => new(-scale.X, -scale.Y, -scale.Z);

    #region Scale / Scalar

    /// <summary>
    /// Multiplies a <see cref="Scale3f"/> transformation with a float scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3f operator *(Scale3f scale, float scalar)
        => new(scale.X * scalar, scale.Y * scalar, scale.Z * scalar);

    /// <summary>
    /// Multiplies a float scalar with a <see cref="Scale3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3f operator *(float scalar, Scale3f scale)
        => new(scale.X * scalar, scale.Y * scalar, scale.Z * scalar);

    /// <summary>
    /// Divides a <see cref="Scale3f"/> transformation by a float scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3f operator /(Scale3f scale, float scalar)
        => new(scale.X / scalar, scale.Y / scalar, scale.Z / scalar);

    /// <summary>
    /// Divides a float scalar by a <see cref="Scale3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3f operator /(float scalar, Scale3f scale)
        => new(scalar / scale.X, scalar / scale.Y, scalar / scale.Z);

    #endregion

    #region Scale / Vector Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale3f"/> transformation with a <see cref="V3f"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3f operator *(Scale3f scale, V3f vector)
        => new(vector.X * scale.X, vector.Y * scale.Y, vector.Z * scale.Z);

    #endregion

    #region Scale / Scale Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale3f"/> transformation with a <see cref="Scale2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3f operator *(Scale3f a, Scale2f b)
        => new(a.X * b.X, a.Y * b.Y, a.Z);

    /// <summary>
    /// Multiplies a <see cref="Scale3f"/> transformation with a <see cref="Scale3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3f operator *(Scale3f a, Scale3f b)
        => new(a.X * b.X, a.Y * b.Y, a.Z * b.Z);

    #endregion

    #region Scale / Matrix Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale3f"/> transformation (as a 3x3 matrix) with a <see cref="M33f"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M33f operator *(Scale3f scale, M33f matrix)
        => new(
            scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
            scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, 
            scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22);

    /// <summary>
    /// Multiplies a <see cref="M33f"/> with a <see cref="Scale3f"/> transformation (as a 3x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M33f operator *(M33f matrix, Scale3f scale)
        => new(
            matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, 
            matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, 
            matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z);

    /// <summary>
    /// Multiplies a <see cref="Scale3f"/> transformation (as a 3x3 matrix) with a <see cref="M34f"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M34f operator *(Scale3f scale, M34f matrix)
        => new(
            scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
            scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
            scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22, scale.Z * matrix.M23);

    /// <summary>
    /// Multiplies a <see cref="M34f"/> with a <see cref="Scale3f"/> transformation (as a 4x4 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M34f operator *(M34f matrix, Scale3f scale)
        => new(
            matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, matrix.M03, 
            matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, matrix.M13, 
            matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z, matrix.M23);

    /// <summary>
    /// Multiplies a <see cref="Scale3f"/> transformation (as a 4x4 matrix) with a <see cref="M44f"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M44f operator *(Scale3f scale, M44f matrix)
        => new(
            scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
            scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
            scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22, scale.Z * matrix.M23, 
            matrix.M30, matrix.M31, matrix.M32, matrix.M33);

    /// <summary>
    /// Multiplies a <see cref="M44f"/> with a <see cref="Scale3f"/> transformation (as a 4x4 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M44f operator *(M44f matrix, Scale3f scale)
        => new(
            matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, matrix.M03, 
            matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, matrix.M13, 
            matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z, matrix.M23, 
            matrix.M30 * scale.X, matrix.M31 * scale.Y, matrix.M32 * scale.Z, matrix.M33);

    #endregion

    #region Scale / Rot, Shift Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale3f"/> transformation with a <see cref="Rot3f"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Affine3f operator *(Scale3f a, Rot3f b)
        => new((M33f)a * (M33f)b);

    /// <summary>
    /// Multiplies a <see cref="Scale3f"/> transformation with a <see cref="Shift3f"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Affine3f operator *(Scale3f a, Shift3f b)
        => new((M33f)a, a * b.V);

    #endregion

    #endregion

    #region Comparison Operators

    /// <summary>
    /// Checks whether two <see cref="Scale3f"/> transformations are equal.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Scale3f s0, Scale3f s1)
        => s0.X == s1.X && s0.Y == s1.Y && s0.Z == s1.Z;

    /// <summary>
    /// Checks whether two <see cref="Scale3f"/> transformations are different.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Scale3f s0, Scale3f s1)
        => s0.X != s1.X || s0.Y != s1.Y || s0.Z != s1.Z;

    #endregion

    #region Static Creators

    /// <summary>
    /// Creates a <see cref="Scale3f"/> transformation from a <see cref="M33f"/> matrix.
    /// The matrix must only contain scaling components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3f FromM33f(M33f m, float epsilon = (float)1e-6)
    {
        if (!(Fun.IsTiny(m.C0 * V3f.OII, epsilon) && Fun.IsTiny(m.C1 * V3f.IOI, epsilon) && Fun.IsTiny(m.C2 * V3f.IIO, epsilon)))
            throw new ArgumentException("Matrix is not a pure scaling matrix.");

        return new(m.M00, m.M11, m.M22);
    }

    /// <summary>
    /// Creates a <see cref="Scale3f"/> transformation from a scaling <see cref="M44f"/> matrix.
    /// The matrix has to be homogeneous and must not contain perspective components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3f FromM44f(M44f m, float epsilon = (float)1e-6)
    {
        if (!(Fun.IsTiny(m.C0.XYZ * V3f.OII, epsilon) && Fun.IsTiny(m.C1.XYZ * V3f.IOI, epsilon) && Fun.IsTiny(m.C2.XYZ * V3f.IIO, epsilon)))
            throw new ArgumentException("Matrix is not a pure scaling matrix.");

        if (!(m.M30.IsTiny(epsilon) && m.M31.IsTiny(epsilon) && m.M32.IsTiny(epsilon)))
            throw new ArgumentException("Matrix contains perspective components.");

        if (!m.C3.XYZ.IsTiny(epsilon))
            throw new ArgumentException("Matrix contains translational component.");

        if (m.M33.IsTiny(epsilon))
            throw new ArgumentException("Matrix is not homogeneous.");

        return new(m.M00 / m.M33, m.M11 / m.M33, m.M22 / m.M33);
    }

    /// <summary>
    /// Creates a <see cref="Scale3f"/> transformation from a <see cref="Similarity3f"/>.
    /// The transformation <paramref name="similarity"/> must only consist of a scaling.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3f FromSimilarity3f(Similarity3f similarity, float epsilon = 1e-5f)
    {
        if (!similarity.Trans.IsTiny(epsilon))
            throw new ArgumentException("Similarity transformation contains translational component");

        if (!similarity.Rot.ApproximateEquals(Rot3f.Identity, epsilon))
            throw new ArgumentException("Similarity transformation contains rotational component");

        return new(similarity.Scale);
    }

    /// <summary>
    /// Creates a <see cref="Scale3f"/> transformation from an <see cref="Affine3f"/>.
    /// The transformation <paramref name="affine"/> must only consist of a scaling.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3f FromAffine3f(Affine3f affine, float epsilon = 1e-5f)
        => FromM44f((M44f)affine, epsilon);

    /// <summary>
    /// Creates a <see cref="Scale3f"/> transformation from a <see cref="Trafo3f"/>.
    /// The transformation <paramref name="trafo"/> must only consist of a scaling.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3f FromTrafo3f(Trafo3f trafo, float epsilon = 1e-5f)
        => FromM44f(trafo.Forward, epsilon);

    #endregion

    #region Conversion

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M22f(Scale3f s)
        => new(
            s.X, 0  , 
            0  , s.Y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M23f(Scale3f s)
        => new(
            s.X, 0  , 0  , 
            0  , s.Y, 0  );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M33f(Scale3f s)
        => new(
            s.X, 0  , 0  , 
            0  , s.Y, 0  , 
            0  , 0  , s.Z);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M34f(Scale3f s)
        => new(
            s.X, 0  , 0  , 0  , 
            0  , s.Y, 0  , 0  , 
            0  , 0  , s.Z, 0  );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M44f(Scale3f s)
        => new(
            s.X, 0  , 0  , 0  , 
            0  , s.Y, 0  , 0  , 
            0  , 0  , s.Z, 0  , 
            0  , 0  , 0  , 1  );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Affine3f(Scale3f s)
        => new((M33f)s, V3f.Zero);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Trafo3f(Scale3f s)
        => new((M44f)s, (M44f)s.Inverse);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Scale3d(Scale3f s)
        => new((V3d)s.V);

    /// <summary>
    /// Returns all values of a <see cref="Scale3f"/> instance
    /// in a float[] array.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator float[](Scale3f s)
        => (float[])s.V;

    #endregion

    #region Indexing

    public float this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get => V[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => V[index] = value;
    }

    #endregion

    #region Overrides

    public override readonly int GetHashCode()
        => V.GetHashCode();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Equals(Scale3f other)
        => X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z);

    public override readonly bool Equals(object other)
        => (other is Scale3f o) && Equals(o);

    public override readonly string ToString()
        => string.Format(CultureInfo.InvariantCulture, "[{0}, {1}, {2}]", X, Y, Z);

    public static Scale3f Parse(string s)
    {
        var x = s.NestedBracketSplitLevelOne().ToArray();
        return new(
            float.Parse(x[0], CultureInfo.InvariantCulture), 
            float.Parse(x[1], CultureInfo.InvariantCulture), 
            float.Parse(x[2], CultureInfo.InvariantCulture)
        );
    }

    #endregion
}

public static partial class Scale
{
    #region Invert

    /// <summary>
    /// Returns the inverse of a <see cref="Scale3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3f Inverse(Scale3f scale)
        => scale.Inverse;

    /// <summary>
    /// Inverts a <see cref="Scale3f"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Invert(this ref Scale3f scale)
    {
        scale.V.X = 1 / scale.V.X;
        scale.V.Y = 1 / scale.V.Y;
        scale.V.Z = 1 / scale.V.Z;
    }

    #endregion

    #region Transformations

    /// <summary>
    /// Transforms a <see cref="V3f"/> vector by a <see cref="Scale3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3f Transform(this Scale3f s, V3f v)
        => new(v.X * s.X, v.Y * s.Y, v.Z * s.Z);

    /// <summary>
    /// Transforms a <see cref="V3f"/> vector by the inverse of a <see cref="Scale3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3f InvTransform(this Scale3f s, V3f v)
        => new(v.X / s.X, v.Y / s.Y, v.Z / s.Z);

    /// <summary>
    /// Transforms a <see cref="V4f"/> vector by a <see cref="Scale3f"/> transformation.
    /// v.W is not modified.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4f Transform(this Scale3f s, V4f v)
        => new(v.X * s.X, v.Y * s.Y, v.Z * s.Z, v.W);

    /// <summary>
    /// Transforms a <see cref="V4f"/> vector by the inverse of a <see cref="Scale3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4f InvTransform(this Scale3f s, V4f v)
        => new(v.X / s.X, v.Y / s.Y, v.Z / s.Z, v.W);

    #endregion
}

public static partial class Fun
{
    #region ApproximateEquals

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Scale3f s0, Scale3f s1)
        => ApproximateEquals(s0.V, s1.V, Constant<float>.PositiveTinyValue);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Scale3f s0, Scale3f s1, float tolerance)
        => ApproximateEquals(s0.V, s1.V, tolerance);

    #endregion
}

#endregion

#region Scale2d

/// <summary>
/// A 2-dimensional scaling transform with different scaling values
/// in each dimension.
/// </summary>
[DataContract]
[StructLayout(LayoutKind.Sequential)]
public partial struct Scale2d : IEquatable<Scale2d>
{
    [DataMember]
    [XmlIgnore]
    public V2d V;

    #region Constructors

    /// <summary>
    /// Constructs a <see cref="Scale2d"/> transformation from 2 doubles.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale2d(double sX, double sY)
    {
        V = new V2d(sX, sY);
    }

    /// <summary>
    /// Constructs a <see cref="Scale2d"/> from 2 scaling factors provided as <see cref="V2d"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale2d(V2d scalingFactors)
    {
        V = scalingFactors;
    }

    /// <summary>
    /// Constructs a <see cref="Scale2d"/> transformation from a uniform double value.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale2d(double uniform)
    {
        V = new V2d(uniform, uniform);
    }

    /// <summary>
    /// Constructs a copy of a <see cref="Scale2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale2d(Scale2d scale)
    {
        V = scale.V;
    }

    /// <summary>
    /// Constructs a <see cref="Scale2d"/> transformation from a <see cref="Scale2f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale2d(Scale2f scale)
    {
        V = (V2d)scale.V;
    }

    /// <summary>
    /// Constructs a <see cref="Scale2d"/> transformation from a double-array.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale2d(double[] array)
    {
        V = new V2d(array);
    }

    /// <summary>
    /// Constructs a <see cref="Scale2d"/> transformation from a double-array starting from the given index.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale2d(double[] array, int start)
    {
        V = new V2d(array, start);
    }

    #endregion

    #region Properties

    /// <summary>
    /// Gets and sets the X coordinate.
    /// </summary>
    public double X
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.X; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.X = value; }
    }

    /// <summary>
    /// Gets and sets the Y coordinate.
    /// </summary>
    public double Y
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.Y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.Y = value; }
    }

    /// <summary>
    /// Gets the inverse of this <see cref="Scale2d"/> transformation.
    /// </summary>
    public readonly Scale2d Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1 / X, 1 / Y);
    }

    #endregion

    #region Constants

    /// <summary>
    /// Gets the identity <see cref="Scale2d"/> transformation.
    /// </summary>
    public static Scale2d Identity
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1, 1);
    }

    /// <summary>
    /// Gets a <see cref="Scale2d"/> transformation with all components set to zero.
    /// </summary>
    public static Scale2d Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 0);
    }

    /// <summary>
    /// Gets a <see cref="Scale2d"/> transformation with scaling factors (1, 0).
    /// </summary>
    public static Scale2d XAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1, 0);
    }

    /// <summary>
    /// Gets a <see cref="Scale2d"/> transformation with scaling factors (0, 1).
    /// </summary>
    public static Scale2d YAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 1);
    }

    #endregion

    #region Arithmetic Operators

    /// <summary>
    /// Negates the values of a <see cref="Scale2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2d operator -(Scale2d scale)
        => new(-scale.X, -scale.Y);

    #region Scale / Scalar

    /// <summary>
    /// Multiplies a <see cref="Scale2d"/> transformation with a double scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2d operator *(Scale2d scale, double scalar)
        => new(scale.X * scalar, scale.Y * scalar);

    /// <summary>
    /// Multiplies a double scalar with a <see cref="Scale2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2d operator *(double scalar, Scale2d scale)
        => new(scale.X * scalar, scale.Y * scalar);

    /// <summary>
    /// Divides a <see cref="Scale2d"/> transformation by a double scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2d operator /(Scale2d scale, double scalar)
        => new(scale.X / scalar, scale.Y / scalar);

    /// <summary>
    /// Divides a double scalar by a <see cref="Scale2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2d operator /(double scalar, Scale2d scale)
        => new(scalar / scale.X, scalar / scale.Y);

    #endregion

    #region Scale / Vector Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale2d"/> transformation with a <see cref="V2d"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V2d operator *(Scale2d scale, V2d vector)
        => new(vector.X * scale.X, vector.Y * scale.Y);

    #endregion

    #region Scale / Scale Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale2d"/> transformation with a <see cref="Scale2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2d operator *(Scale2d a, Scale2d b)
        => new(a.X * b.X, a.Y * b.Y);

    /// <summary>
    /// Multiplies a <see cref="Scale2d"/> transformation with a <see cref="Scale3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3d operator *(Scale2d a, Scale3d b)
        => new(a.X * b.X, a.Y * b.Y, b.Z);

    #endregion

    #region Scale / Matrix Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale2d"/> transformation (as a 2x2 matrix) with a <see cref="M22d"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M22d operator *(Scale2d scale, M22d matrix)
        => new(
            scale.X * matrix.M00, scale.X * matrix.M01, 
            scale.Y * matrix.M10, scale.Y * matrix.M11);

    /// <summary>
    /// Multiplies a <see cref="M22d"/> with a <see cref="Scale2d"/> transformation (as a 2x2 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M22d operator *(M22d matrix, Scale2d scale)
        => new(
            matrix.M00 * scale.X, matrix.M01 * scale.Y, 
            matrix.M10 * scale.X, matrix.M11 * scale.Y);

    /// <summary>
    /// Multiplies a <see cref="Scale2d"/> transformation (as a 2x2 matrix) with a <see cref="M23d"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M23d operator *(Scale2d scale, M23d matrix)
        => new(
            scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
            scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12);

    /// <summary>
    /// Multiplies a <see cref="M23d"/> with a <see cref="Scale2d"/> transformation (as a 3x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M23d operator *(M23d matrix, Scale2d scale)
        => new(
            matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02, 
            matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12);

    /// <summary>
    /// Multiplies a <see cref="Scale2d"/> transformation (as a 3x3 matrix) with a <see cref="M33d"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M33d operator *(Scale2d scale, M33d matrix)
        => new(
            scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
            scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, 
            matrix.M20, matrix.M21, matrix.M22);

    /// <summary>
    /// Multiplies a <see cref="M33d"/> with a <see cref="Scale2d"/> transformation (as a 3x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M33d operator *(M33d matrix, Scale2d scale)
        => new(
            matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02, 
            matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12, 
            matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22);

    #endregion

    #region Scale / Rot, Shift Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale2d"/> transformation with a <see cref="Rot2d"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Affine2d operator *(Scale2d a, Rot2d b)
        => new((M22d)a * (M22d)b);

    /// <summary>
    /// Multiplies a <see cref="Scale2d"/> transformation with a <see cref="Shift2d"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Affine2d operator *(Scale2d a, Shift2d b)
        => new((M22d)a, a * b.V);

    #endregion

    #endregion

    #region Comparison Operators

    /// <summary>
    /// Checks whether two <see cref="Scale2d"/> transformations are equal.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Scale2d s0, Scale2d s1)
        => s0.X == s1.X && s0.Y == s1.Y;

    /// <summary>
    /// Checks whether two <see cref="Scale2d"/> transformations are different.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Scale2d s0, Scale2d s1)
        => s0.X != s1.X || s0.Y != s1.Y;

    #endregion

    #region Static Creators

    /// <summary>
    /// Creates a <see cref="Scale2d"/> transformation from a <see cref="M22d"/> matrix.
    /// The matrix must only contain scaling components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2d FromM22d(M22d m, double epsilon = (double)1e-6)
    {
        if (!(Fun.IsTiny(m.C0 * V2d.OI, epsilon) && Fun.IsTiny(m.C1 * V2d.IO, epsilon)))
            throw new ArgumentException("Matrix is not a pure scaling matrix.");

        return new(m.M00, m.M11);
    }

    /// <summary>
    /// Creates a <see cref="Scale2d"/> transformation from a scaling <see cref="M33d"/> matrix.
    /// The matrix has to be homogeneous and must not contain perspective components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2d FromM33d(M33d m, double epsilon = (double)1e-6)
    {
        if (!(Fun.IsTiny(m.C0.XY * V2d.OI, epsilon) && Fun.IsTiny(m.C1.XY * V2d.IO, epsilon)))
            throw new ArgumentException("Matrix is not a pure scaling matrix.");

        if (!(m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon)))
            throw new ArgumentException("Matrix contains perspective components.");

        if (!m.C2.XY.IsTiny(epsilon))
            throw new ArgumentException("Matrix contains translational component.");

        if (m.M22.IsTiny(epsilon))
            throw new ArgumentException("Matrix is not homogeneous.");

        return new(m.M00 / m.M22, m.M11 / m.M22);
    }

    /// <summary>
    /// Creates a <see cref="Scale2d"/> transformation from a <see cref="Similarity2d"/>.
    /// The transformation <paramref name="similarity"/> must only consist of a scaling.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2d FromSimilarity2d(Similarity2d similarity, double epsilon = 1e-12)
    {
        if (!similarity.Trans.IsTiny(epsilon))
            throw new ArgumentException("Similarity transformation contains translational component");

        if (!similarity.Rot.ApproximateEquals(Rot2d.Identity, epsilon))
            throw new ArgumentException("Similarity transformation contains rotational component");

        return new(similarity.Scale);
    }

    /// <summary>
    /// Creates a <see cref="Scale2d"/> transformation from an <see cref="Affine2d"/>.
    /// The transformation <paramref name="affine"/> must only consist of a scaling.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2d FromAffine2d(Affine2d affine, double epsilon = 1e-12)
        => FromM33d((M33d)affine, epsilon);

    /// <summary>
    /// Creates a <see cref="Scale2d"/> transformation from a <see cref="Trafo2d"/>.
    /// The transformation <paramref name="trafo"/> must only consist of a scaling.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2d FromTrafo2d(Trafo2d trafo, double epsilon = 1e-12)
        => FromM33d(trafo.Forward, epsilon);

    #endregion

    #region Conversion

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M22d(Scale2d s)
        => new(
            s.X, 0  , 
            0  , s.Y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M23d(Scale2d s)
        => new(
            s.X, 0  , 0  , 
            0  , s.Y, 0  );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M33d(Scale2d s)
        => new(
            s.X, 0  , 0  , 
            0  , s.Y, 0  , 
            0  , 0  , 1  );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M34d(Scale2d s)
        => new(
            s.X, 0  , 0  , 0  , 
            0  , s.Y, 0  , 0  , 
            0  , 0  , 1  , 0  );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M44d(Scale2d s)
        => new(
            s.X, 0  , 0  , 0  , 
            0  , s.Y, 0  , 0  , 
            0  , 0  , 1  , 0  , 
            0  , 0  , 0  , 1  );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Affine2d(Scale2d s)
        => new((M22d)s, V2d.Zero);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Trafo2d(Scale2d s)
        => new((M33d)s, (M33d)s.Inverse);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Scale2f(Scale2d s)
        => new((V2f)s.V);

    /// <summary>
    /// Returns all values of a <see cref="Scale2d"/> instance
    /// in a double[] array.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator double[](Scale2d s)
        => (double[])s.V;

    #endregion

    #region Indexing

    public double this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get => V[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => V[index] = value;
    }

    #endregion

    #region Overrides

    public override readonly int GetHashCode()
        => V.GetHashCode();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Equals(Scale2d other)
        => X.Equals(other.X) && Y.Equals(other.Y);

    public override readonly bool Equals(object other)
        => (other is Scale2d o) && Equals(o);

    public override readonly string ToString()
        => string.Format(CultureInfo.InvariantCulture, "[{0}, {1}]", X, Y);

    public static Scale2d Parse(string s)
    {
        var x = s.NestedBracketSplitLevelOne().ToArray();
        return new(
            double.Parse(x[0], CultureInfo.InvariantCulture), 
            double.Parse(x[1], CultureInfo.InvariantCulture)
        );
    }

    #endregion
}

public static partial class Scale
{
    #region Invert

    /// <summary>
    /// Returns the inverse of a <see cref="Scale2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale2d Inverse(Scale2d scale)
        => scale.Inverse;

    /// <summary>
    /// Inverts a <see cref="Scale2d"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Invert(this ref Scale2d scale)
    {
        scale.V.X = 1 / scale.V.X;
        scale.V.Y = 1 / scale.V.Y;
    }

    #endregion

    #region Transformations

    /// <summary>
    /// Transforms a <see cref="V2d"/> vector by a <see cref="Scale2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V2d Transform(this Scale2d s, V2d v)
        => new(v.X * s.X, v.Y * s.Y);

    /// <summary>
    /// Transforms a <see cref="V2d"/> vector by the inverse of a <see cref="Scale2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V2d InvTransform(this Scale2d s, V2d v)
        => new(v.X / s.X, v.Y / s.Y);

    /// <summary>
    /// Transforms a <see cref="V3d"/> vector by a <see cref="Scale2d"/> transformation.
    /// v.Z is not modified.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3d Transform(this Scale2d s, V3d v)
        => new(v.X * s.X, v.Y * s.Y, v.Z);

    /// <summary>
    /// Transforms a <see cref="V3d"/> vector by the inverse of a <see cref="Scale2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3d InvTransform(this Scale2d s, V3d v)
        => new(v.X / s.X, v.Y / s.Y, v.Z);

    /// <summary>
    /// Transforms a <see cref="V4d"/> vector by a <see cref="Scale2d"/> transformation.
    /// v.Z and v.W are not modified.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4d Transform(this Scale2d s, V4d v)
        => new(v.X * s.X, v.Y * s.Y, v.Z, v.W);

    /// <summary>
    /// Transforms a <see cref="V4d"/> vector by the inverse of a <see cref="Scale2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4d InvTransform(this Scale2d s, V4d v)
        => new(v.X / s.X, v.Y / s.Y, v.Z, v.W);

    #endregion
}

public static partial class Fun
{
    #region ApproximateEquals

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Scale2d s0, Scale2d s1)
        => ApproximateEquals(s0.V, s1.V, Constant<double>.PositiveTinyValue);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Scale2d s0, Scale2d s1, double tolerance)
        => ApproximateEquals(s0.V, s1.V, tolerance);

    #endregion
}

#endregion

#region Scale3d

/// <summary>
/// A 3-dimensional scaling transform with different scaling values
/// in each dimension.
/// </summary>
[DataContract]
[StructLayout(LayoutKind.Sequential)]
public partial struct Scale3d : IEquatable<Scale3d>
{
    [DataMember]
    [XmlIgnore]
    public V3d V;

    #region Constructors

    /// <summary>
    /// Constructs a <see cref="Scale3d"/> transformation from 3 doubles.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale3d(double sX, double sY, double sZ)
    {
        V = new V3d(sX, sY, sZ);
    }

    /// <summary>
    /// Constructs a <see cref="Scale3d"/> from 3 scaling factors provided as <see cref="V3d"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale3d(V3d scalingFactors)
    {
        V = scalingFactors;
    }

    /// <summary>
    /// Constructs a <see cref="Scale3d"/> transformation from a uniform double value.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale3d(double uniform)
    {
        V = new V3d(uniform, uniform, uniform);
    }

    /// <summary>
    /// Constructs a copy of a <see cref="Scale3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale3d(Scale3d scale)
    {
        V = scale.V;
    }

    /// <summary>
    /// Constructs a <see cref="Scale3d"/> transformation from a <see cref="Scale3f"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale3d(Scale3f scale)
    {
        V = (V3d)scale.V;
    }

    /// <summary>
    /// Constructs a <see cref="Scale3d"/> transformation from a double-array.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale3d(double[] array)
    {
        V = new V3d(array);
    }

    /// <summary>
    /// Constructs a <see cref="Scale3d"/> transformation from a double-array starting from the given index.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Scale3d(double[] array, int start)
    {
        V = new V3d(array, start);
    }

    #endregion

    #region Properties

    /// <summary>
    /// Gets and sets the X coordinate.
    /// </summary>
    public double X
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.X; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.X = value; }
    }

    /// <summary>
    /// Gets and sets the Y coordinate.
    /// </summary>
    public double Y
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.Y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.Y = value; }
    }

    /// <summary>
    /// Gets and sets the Z coordinate.
    /// </summary>
    public double Z
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get { return V.Z; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { V.Z = value; }
    }

    /// <summary>
    /// Gets the inverse of this <see cref="Scale3d"/> transformation.
    /// </summary>
    public readonly Scale3d Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1 / X, 1 / Y, 1 / Z);
    }

    #endregion

    #region Constants

    /// <summary>
    /// Gets the identity <see cref="Scale3d"/> transformation.
    /// </summary>
    public static Scale3d Identity
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1, 1, 1);
    }

    /// <summary>
    /// Gets a <see cref="Scale3d"/> transformation with all components set to zero.
    /// </summary>
    public static Scale3d Zero
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 0, 0);
    }

    /// <summary>
    /// Gets a <see cref="Scale3d"/> transformation with scaling factors (1, 0, 0).
    /// </summary>
    public static Scale3d XAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(1, 0, 0);
    }

    /// <summary>
    /// Gets a <see cref="Scale3d"/> transformation with scaling factors (0, 1, 0).
    /// </summary>
    public static Scale3d YAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 1, 0);
    }

    /// <summary>
    /// Gets a <see cref="Scale3d"/> transformation with scaling factors (0, 0, 1).
    /// </summary>
    public static Scale3d ZAxis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => new(0, 0, 1);
    }

    #endregion

    #region Arithmetic Operators

    /// <summary>
    /// Negates the values of a <see cref="Scale3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3d operator -(Scale3d scale)
        => new(-scale.X, -scale.Y, -scale.Z);

    #region Scale / Scalar

    /// <summary>
    /// Multiplies a <see cref="Scale3d"/> transformation with a double scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3d operator *(Scale3d scale, double scalar)
        => new(scale.X * scalar, scale.Y * scalar, scale.Z * scalar);

    /// <summary>
    /// Multiplies a double scalar with a <see cref="Scale3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3d operator *(double scalar, Scale3d scale)
        => new(scale.X * scalar, scale.Y * scalar, scale.Z * scalar);

    /// <summary>
    /// Divides a <see cref="Scale3d"/> transformation by a double scalar.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3d operator /(Scale3d scale, double scalar)
        => new(scale.X / scalar, scale.Y / scalar, scale.Z / scalar);

    /// <summary>
    /// Divides a double scalar by a <see cref="Scale3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3d operator /(double scalar, Scale3d scale)
        => new(scalar / scale.X, scalar / scale.Y, scalar / scale.Z);

    #endregion

    #region Scale / Vector Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale3d"/> transformation with a <see cref="V3d"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3d operator *(Scale3d scale, V3d vector)
        => new(vector.X * scale.X, vector.Y * scale.Y, vector.Z * scale.Z);

    #endregion

    #region Scale / Scale Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale3d"/> transformation with a <see cref="Scale2d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3d operator *(Scale3d a, Scale2d b)
        => new(a.X * b.X, a.Y * b.Y, a.Z);

    /// <summary>
    /// Multiplies a <see cref="Scale3d"/> transformation with a <see cref="Scale3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3d operator *(Scale3d a, Scale3d b)
        => new(a.X * b.X, a.Y * b.Y, a.Z * b.Z);

    #endregion

    #region Scale / Matrix Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale3d"/> transformation (as a 3x3 matrix) with a <see cref="M33d"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M33d operator *(Scale3d scale, M33d matrix)
        => new(
            scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
            scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, 
            scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22);

    /// <summary>
    /// Multiplies a <see cref="M33d"/> with a <see cref="Scale3d"/> transformation (as a 3x3 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M33d operator *(M33d matrix, Scale3d scale)
        => new(
            matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, 
            matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, 
            matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z);

    /// <summary>
    /// Multiplies a <see cref="Scale3d"/> transformation (as a 3x3 matrix) with a <see cref="M34d"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M34d operator *(Scale3d scale, M34d matrix)
        => new(
            scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
            scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
            scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22, scale.Z * matrix.M23);

    /// <summary>
    /// Multiplies a <see cref="M34d"/> with a <see cref="Scale3d"/> transformation (as a 4x4 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M34d operator *(M34d matrix, Scale3d scale)
        => new(
            matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, matrix.M03, 
            matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, matrix.M13, 
            matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z, matrix.M23);

    /// <summary>
    /// Multiplies a <see cref="Scale3d"/> transformation (as a 4x4 matrix) with a <see cref="M44d"/>.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M44d operator *(Scale3d scale, M44d matrix)
        => new(
            scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
            scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
            scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22, scale.Z * matrix.M23, 
            matrix.M30, matrix.M31, matrix.M32, matrix.M33);

    /// <summary>
    /// Multiplies a <see cref="M44d"/> with a <see cref="Scale3d"/> transformation (as a 4x4 matrix).
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static M44d operator *(M44d matrix, Scale3d scale)
        => new(
            matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, matrix.M03, 
            matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, matrix.M13, 
            matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z, matrix.M23, 
            matrix.M30 * scale.X, matrix.M31 * scale.Y, matrix.M32 * scale.Z, matrix.M33);

    #endregion

    #region Scale / Rot, Shift Multiplication

    /// <summary>
    /// Multiplies a <see cref="Scale3d"/> transformation with a <see cref="Rot3d"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Affine3d operator *(Scale3d a, Rot3d b)
        => new((M33d)a * (M33d)b);

    /// <summary>
    /// Multiplies a <see cref="Scale3d"/> transformation with a <see cref="Shift3d"/> transformation.
    /// Attention: Multiplication is NOT commutative!
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Affine3d operator *(Scale3d a, Shift3d b)
        => new((M33d)a, a * b.V);

    #endregion

    #endregion

    #region Comparison Operators

    /// <summary>
    /// Checks whether two <see cref="Scale3d"/> transformations are equal.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Scale3d s0, Scale3d s1)
        => s0.X == s1.X && s0.Y == s1.Y && s0.Z == s1.Z;

    /// <summary>
    /// Checks whether two <see cref="Scale3d"/> transformations are different.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Scale3d s0, Scale3d s1)
        => s0.X != s1.X || s0.Y != s1.Y || s0.Z != s1.Z;

    #endregion

    #region Static Creators

    /// <summary>
    /// Creates a <see cref="Scale3d"/> transformation from a <see cref="M33d"/> matrix.
    /// The matrix must only contain scaling components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3d FromM33d(M33d m, double epsilon = (double)1e-6)
    {
        if (!(Fun.IsTiny(m.C0 * V3d.OII, epsilon) && Fun.IsTiny(m.C1 * V3d.IOI, epsilon) && Fun.IsTiny(m.C2 * V3d.IIO, epsilon)))
            throw new ArgumentException("Matrix is not a pure scaling matrix.");

        return new(m.M00, m.M11, m.M22);
    }

    /// <summary>
    /// Creates a <see cref="Scale3d"/> transformation from a scaling <see cref="M44d"/> matrix.
    /// The matrix has to be homogeneous and must not contain perspective components.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3d FromM44d(M44d m, double epsilon = (double)1e-6)
    {
        if (!(Fun.IsTiny(m.C0.XYZ * V3d.OII, epsilon) && Fun.IsTiny(m.C1.XYZ * V3d.IOI, epsilon) && Fun.IsTiny(m.C2.XYZ * V3d.IIO, epsilon)))
            throw new ArgumentException("Matrix is not a pure scaling matrix.");

        if (!(m.M30.IsTiny(epsilon) && m.M31.IsTiny(epsilon) && m.M32.IsTiny(epsilon)))
            throw new ArgumentException("Matrix contains perspective components.");

        if (!m.C3.XYZ.IsTiny(epsilon))
            throw new ArgumentException("Matrix contains translational component.");

        if (m.M33.IsTiny(epsilon))
            throw new ArgumentException("Matrix is not homogeneous.");

        return new(m.M00 / m.M33, m.M11 / m.M33, m.M22 / m.M33);
    }

    /// <summary>
    /// Creates a <see cref="Scale3d"/> transformation from a <see cref="Similarity3d"/>.
    /// The transformation <paramref name="similarity"/> must only consist of a scaling.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3d FromSimilarity3d(Similarity3d similarity, double epsilon = 1e-12)
    {
        if (!similarity.Trans.IsTiny(epsilon))
            throw new ArgumentException("Similarity transformation contains translational component");

        if (!similarity.Rot.ApproximateEquals(Rot3d.Identity, epsilon))
            throw new ArgumentException("Similarity transformation contains rotational component");

        return new(similarity.Scale);
    }

    /// <summary>
    /// Creates a <see cref="Scale3d"/> transformation from an <see cref="Affine3d"/>.
    /// The transformation <paramref name="affine"/> must only consist of a scaling.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3d FromAffine3d(Affine3d affine, double epsilon = 1e-12)
        => FromM44d((M44d)affine, epsilon);

    /// <summary>
    /// Creates a <see cref="Scale3d"/> transformation from a <see cref="Trafo3d"/>.
    /// The transformation <paramref name="trafo"/> must only consist of a scaling.
    /// </summary>
    /// <exception cref="ArgumentException"></exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3d FromTrafo3d(Trafo3d trafo, double epsilon = 1e-12)
        => FromM44d(trafo.Forward, epsilon);

    #endregion

    #region Conversion

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M22d(Scale3d s)
        => new(
            s.X, 0  , 
            0  , s.Y);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M23d(Scale3d s)
        => new(
            s.X, 0  , 0  , 
            0  , s.Y, 0  );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M33d(Scale3d s)
        => new(
            s.X, 0  , 0  , 
            0  , s.Y, 0  , 
            0  , 0  , s.Z);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M34d(Scale3d s)
        => new(
            s.X, 0  , 0  , 0  , 
            0  , s.Y, 0  , 0  , 
            0  , 0  , s.Z, 0  );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator M44d(Scale3d s)
        => new(
            s.X, 0  , 0  , 0  , 
            0  , s.Y, 0  , 0  , 
            0  , 0  , s.Z, 0  , 
            0  , 0  , 0  , 1  );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Affine3d(Scale3d s)
        => new((M33d)s, V3d.Zero);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Trafo3d(Scale3d s)
        => new((M44d)s, (M44d)s.Inverse);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator Scale3f(Scale3d s)
        => new((V3f)s.V);

    /// <summary>
    /// Returns all values of a <see cref="Scale3d"/> instance
    /// in a double[] array.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static explicit operator double[](Scale3d s)
        => (double[])s.V;

    #endregion

    #region Indexing

    public double this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        readonly get => V[index];

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => V[index] = value;
    }

    #endregion

    #region Overrides

    public override readonly int GetHashCode()
        => V.GetHashCode();

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly bool Equals(Scale3d other)
        => X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z);

    public override readonly bool Equals(object other)
        => (other is Scale3d o) && Equals(o);

    public override readonly string ToString()
        => string.Format(CultureInfo.InvariantCulture, "[{0}, {1}, {2}]", X, Y, Z);

    public static Scale3d Parse(string s)
    {
        var x = s.NestedBracketSplitLevelOne().ToArray();
        return new(
            double.Parse(x[0], CultureInfo.InvariantCulture), 
            double.Parse(x[1], CultureInfo.InvariantCulture), 
            double.Parse(x[2], CultureInfo.InvariantCulture)
        );
    }

    #endregion
}

public static partial class Scale
{
    #region Invert

    /// <summary>
    /// Returns the inverse of a <see cref="Scale3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Scale3d Inverse(Scale3d scale)
        => scale.Inverse;

    /// <summary>
    /// Inverts a <see cref="Scale3d"/>.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Invert(this ref Scale3d scale)
    {
        scale.V.X = 1 / scale.V.X;
        scale.V.Y = 1 / scale.V.Y;
        scale.V.Z = 1 / scale.V.Z;
    }

    #endregion

    #region Transformations

    /// <summary>
    /// Transforms a <see cref="V3d"/> vector by a <see cref="Scale3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3d Transform(this Scale3d s, V3d v)
        => new(v.X * s.X, v.Y * s.Y, v.Z * s.Z);

    /// <summary>
    /// Transforms a <see cref="V3d"/> vector by the inverse of a <see cref="Scale3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V3d InvTransform(this Scale3d s, V3d v)
        => new(v.X / s.X, v.Y / s.Y, v.Z / s.Z);

    /// <summary>
    /// Transforms a <see cref="V4d"/> vector by a <see cref="Scale3d"/> transformation.
    /// v.W is not modified.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4d Transform(this Scale3d s, V4d v)
        => new(v.X * s.X, v.Y * s.Y, v.Z * s.Z, v.W);

    /// <summary>
    /// Transforms a <see cref="V4d"/> vector by the inverse of a <see cref="Scale3d"/> transformation.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static V4d InvTransform(this Scale3d s, V4d v)
        => new(v.X / s.X, v.Y / s.Y, v.Z / s.Z, v.W);

    #endregion
}

public static partial class Fun
{
    #region ApproximateEquals

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Scale3d s0, Scale3d s1)
        => ApproximateEquals(s0.V, s1.V, Constant<double>.PositiveTinyValue);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool ApproximateEquals(this Scale3d s0, Scale3d s1, double tolerance)
        => ApproximateEquals(s0.V, s1.V, tolerance);

    #endregion
}

#endregion

