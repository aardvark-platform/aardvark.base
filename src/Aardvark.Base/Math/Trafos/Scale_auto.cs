using System;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;
using System.Xml.Serialization;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    #region Scale2f

    /// <summary>
    /// A 2-dimensional scaling transform with different scaling values
    /// in each dimension.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Scale2f : IEquatable<Scale2f>
    {
        [DataMember]
        [XmlIgnore]
        public V2f V;

        #region Constructors

        /// <summary>
        /// Constructs a <see cref="Scale2f"/> transformation from 2 floats.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2f(float sX, float sY)
        {
            V = new V2f(sX, sY);
        }

        /// <summary>
        /// Constructs a <see cref="Scale2f"/> from 2 scaling factors provided as <see cref="V2f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2f(V2f scalingFactors)
        {
            V = scalingFactors;
        }

        /// <summary>
        /// Constructs a <see cref="Scale2f"/> transformation from a uniform float value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2f(float uniform)
        {
            V = new V2f(uniform, uniform);
        }

        /// <summary>
        /// Constructs a copy of a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2f(Scale2f scale)
        {
            V = scale.V;
        }

        /// <summary>
        /// Constructs a <see cref="Scale2f"/> transformation from a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2f(Scale2d scale)
        {
            V = (V2f)scale.V;
        }

        /// <summary>
        /// Constructs a <see cref="Scale2f"/> transformation from a float-array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2f(float[] array)
        {
            V = new V2f(array);
        }

        /// <summary>
        /// Constructs a <see cref="Scale2f"/> transformation from a float-array starting from the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2f(float[] array, int start)
        {
            V = new V2f(array, start);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets and sets the X coordinate.
        /// </summary>
        public float X
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.X = value; }
        }

        /// <summary>
        /// Gets and sets the Y coordinate.
        /// </summary>
        public float Y
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Y = value; }
        }

        /// <summary>
        /// Gets the inverse of this <see cref="Scale2f"/> transformation.
        /// </summary>
        public Scale2f Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2f(1 / X, 1 / Y);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity <see cref="Scale2f"/> transformation.
        /// </summary>
        public static Scale2f Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2f(1, 1);
        }

        /// <summary>
        /// Gets a <see cref="Scale2f"/> transformation with all components set to zero.
        /// </summary>
        public static Scale2f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2f(0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale2f"/> transformation with scaling factors (1, 0).
        /// </summary>
        public static Scale2f XAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2f(1, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale2f"/> transformation with scaling factors (0, 1).
        /// </summary>
        public static Scale2f YAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2f(0, 1);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Negates the values of a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f operator -(Scale2f scale)
        {
            return new Scale2f(-scale.X, -scale.Y);
        }

        #region Scale / Scalar

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation with a float scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f operator *(Scale2f scale, float scalar)
        {
            return new Scale2f(scale.X * scalar, scale.Y * scalar);
        }

        /// <summary>
        /// Multiplies a float scalar with a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f operator *(float scalar, Scale2f scale)
        {
            return new Scale2f(scale.X * scalar, scale.Y * scalar);
        }

        /// <summary>
        /// Divides a <see cref="Scale2f"/> transformation by a float scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f operator /(Scale2f scale, float scalar)
        {
            return new Scale2f(scale.X / scalar, scale.Y / scalar);
        }

        /// <summary>
        /// Divides a float scalar by a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f operator /(float scalar, Scale2f scale)
        {
            return new Scale2f(scalar / scale.X, scalar / scale.Y);
        }

        #endregion

        #region Scale / Vector Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation with a <see cref="V2f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f operator *(Scale2f scale, V2f vector)
        {
            return new V2f(vector.X * scale.X, vector.Y * scale.Y);
        }

        #endregion

        #region Scale / Scale Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation with a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f operator *(Scale2f a, Scale2f b)
            => new Scale2f(a.X * b.X, a.Y * b.Y);

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation with a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator *(Scale2f a, Scale3f b)
            => new Scale3f(a.X * b.X, a.Y * b.Y, b.Z);

        #endregion

        #region Scale / Matrix Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation (as a 2x2 matrix) with a <see cref="M22f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator *(Scale2f scale, M22f matrix)
        {
            return new M22f(
                scale.X * matrix.M00, scale.X * matrix.M01, 
                scale.Y * matrix.M10, scale.Y * matrix.M11);
        }

        /// <summary>
        /// Multiplies a <see cref="M22f"/> with a <see cref="Scale2f"/> transformation (as a 2x2 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator *(M22f matrix, Scale2f scale)
        {
            return new M22f(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation (as a 2x2 matrix) with a <see cref="M23f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator *(Scale2f scale, M23f matrix)
        {
            return new M23f(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12);
        }

        /// <summary>
        /// Multiplies a <see cref="M23f"/> with a <see cref="Scale2f"/> transformation (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator *(M23f matrix, Scale2f scale)
        {
            return new M23f(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation (as a 3x3 matrix) with a <see cref="M33f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator *(Scale2f scale, M33f matrix)
        {
            return new M33f(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, 
                matrix.M20, matrix.M21, matrix.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="M33f"/> with a <see cref="Scale2f"/> transformation (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator *(M33f matrix, Scale2f scale)
        {
            return new M33f(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22);
        }

        #endregion

        #region Scale / Rot, Shift Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation with a <see cref="Rot2f"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f operator *(Scale2f a, Rot2f b)
            => new Affine2f((M22f)a * (M22f)b);

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> transformation with a <see cref="Shift2f"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f operator *(Scale2f a, Shift2f b)
            => new Affine2f((M22f)a, a * b.V);

        #endregion

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Scale2f"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Scale2f s0, Scale2f s1)
            => s0.X == s1.X && s0.Y == s1.Y;

        /// <summary>
        /// Checks whether two <see cref="Scale2f"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Scale2f s0, Scale2f s1)
            => s0.X != s1.X || s0.Y != s1.Y;

        #endregion

        #region Static Creators

        /// <summary>
        /// Creates a <see cref="Scale2f"/> transformation from a <see cref="M22f"/> matrix.
        /// The matrix must only contain scaling components.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f FromM22f(M22f m, float epsilon = (float)1e-6)
        {
            if (!(Fun.IsTiny(m.C0 * V2f.OI, epsilon) && Fun.IsTiny(m.C1 * V2f.IO, epsilon)))
                throw new ArgumentException("Matrix is not a pure scaling matrix.");

            return new Scale2f(m.M00, m.M11);
        }

        /// <summary>
        /// Creates a <see cref="Scale2f"/> transformation from a scaling <see cref="M33f"/> matrix.
        /// The matrix has to be homogeneous and must not contain perspective components.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f FromM33f(M33f m, float epsilon = (float)1e-6)
        {
            if (!(Fun.IsTiny(m.C0.XY * V2f.OI, epsilon) && Fun.IsTiny(m.C1.XY * V2f.IO, epsilon)))
                throw new ArgumentException("Matrix is not a pure scaling matrix.");

            if (!(m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon)))
                throw new ArgumentException("Matrix contains perspective components.");

            if (!m.C2.XY.IsTiny(epsilon))
                throw new ArgumentException("Matrix contains translational component.");

            if (m.M22.IsTiny(epsilon))
                throw new ArgumentException("Matrix is not homogeneous.");

            return new Scale2f(m.M00 / m.M22, m.M11 / m.M22);
        }

        /// <summary>
        /// Creates a <see cref="Scale2f"/> transformation from a <see cref="Similarity2f"/>.
        /// The transformation <paramref name="similarity"/> must only consist of a scaling.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f FromSimilarity2f(Similarity2f similarity, float epsilon = 1e-5f)
        {
            if (!similarity.Trans.IsTiny(epsilon))
                throw new ArgumentException("Similarity transformation contains translational component");

            if (!similarity.Rot.ApproximateEquals(Rot2f.Identity, epsilon))
                throw new ArgumentException("Similarity transformation contains rotational component");

            return new Scale2f(similarity.Scale);
        }

        /// <summary>
        /// Creates a <see cref="Scale2f"/> transformation from an <see cref="Affine2f"/>.
        /// The transformation <paramref name="affine"/> must only consist of a scaling.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f FromAffine2f(Affine2f affine, float epsilon = 1e-5f)
            => FromM33f((M33f)affine, epsilon);

        /// <summary>
        /// Creates a <see cref="Scale2f"/> transformation from a <see cref="Trafo2f"/>.
        /// The transformation <paramref name="trafo"/> must only consist of a scaling.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f FromTrafo2f(Trafo2f trafo, float epsilon = 1e-5f)
            => FromM33f(trafo.Forward, epsilon);

        #endregion

        #region Conversion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M22f(Scale2f s)
        {
            return new M22f(
                s.X, 0  , 
                0  , s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M23f(Scale2f s)
        {
            return new M23f(
                s.X, 0  , 0  , 
                0  , s.Y, 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33f(Scale2f s)
        {
            return new M33f(
                s.X, 0  , 0  , 
                0  , s.Y, 0  , 
                0  , 0  , 1  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M34f(Scale2f s)
        {
            return new M34f(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , 1  , 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44f(Scale2f s)
        {
            return new M44f(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , 1  , 0  , 
                0  , 0  , 0  , 1  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine2f(Scale2f s)
            => new Affine2f((M22f)s, V2f.Zero);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Trafo2f(Scale2f s)
            => new Trafo2f((M33f)s, (M33f)s.Inverse);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Scale2d(Scale2f s)
            => new Scale2d((V2d)s.V);

        /// <summary>
        /// Returns all values of a <see cref="Scale2f"/> instance
        /// in a float[] array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator float[](Scale2f s)
            => (float[])s.V;

        #endregion

        #region Indexing

        public float this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => V[index];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => V[index] = value;
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return V.GetHashCode();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Scale2f other)
            => X.Equals(other.X) && Y.Equals(other.Y);

        public override bool Equals(object other)
            => (other is Scale2f o) ? Equals(o) : false;

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}]", X, Y);
        }

        public static Scale2f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Scale2f(
                float.Parse(x[0], CultureInfo.InvariantCulture), 
                float.Parse(x[1], CultureInfo.InvariantCulture)
            );
        }

        #endregion
    }

    public static partial class Scale
    {
        #region Invert

        /// <summary>
        /// Returns the inverse of a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2f Inverse(Scale2f scale)
            => scale.Inverse;

        /// <summary>
        /// Inverts a <see cref="Scale2f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Scale2f scale)
        {
            scale.V.X = 1 / scale.V.X;
            scale.V.Y = 1 / scale.V.Y;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V2f"/> vector by a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f Transform(this Scale2f s, V2f v)
            => new V2f(v.X * s.X, v.Y * s.Y);

        /// <summary>
        /// Transforms a <see cref="V2f"/> vector by the inverse of a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f InvTransform(this Scale2f s, V2f v)
            => new V2f(v.X / s.X, v.Y / s.Y);

        /// <summary>
        /// Transforms a <see cref="V3f"/> vector by a <see cref="Scale2f"/> transformation.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this Scale2f s, V3f v)
            => new V3f(v.X * s.X, v.Y * s.Y, v.Z);

        /// <summary>
        /// Transforms a <see cref="V3f"/> vector by the inverse of a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f InvTransform(this Scale2f s, V3f v)
            => new V3f(v.X / s.X, v.Y / s.Y, v.Z);

        /// <summary>
        /// Transforms a <see cref="V4f"/> vector by a <see cref="Scale2f"/> transformation.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Transform(this Scale2f s, V4f v)
            => new V4f(v.X * s.X, v.Y * s.Y, v.Z, v.W);

        /// <summary>
        /// Transforms a <see cref="V4f"/> vector by the inverse of a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f InvTransform(this Scale2f s, V4f v)
            => new V4f(v.X / s.X, v.Y / s.Y, v.Z, v.W);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale2f s0, Scale2f s1)
        {
            return ApproximateEquals(s0.V, s1.V, Constant<float>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale2f s0, Scale2f s1, float tolerance)
        {
            return ApproximateEquals(s0.V, s1.V, tolerance);
        }

        #endregion
    }

    #endregion

    #region Scale3f

    /// <summary>
    /// A 3-dimensional scaling transform with different scaling values
    /// in each dimension.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Scale3f : IEquatable<Scale3f>
    {
        [DataMember]
        [XmlIgnore]
        public V3f V;

        #region Constructors

        /// <summary>
        /// Constructs a <see cref="Scale3f"/> transformation from 3 floats.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3f(float sX, float sY, float sZ)
        {
            V = new V3f(sX, sY, sZ);
        }

        /// <summary>
        /// Constructs a <see cref="Scale3f"/> from 3 scaling factors provided as <see cref="V3f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3f(V3f scalingFactors)
        {
            V = scalingFactors;
        }

        /// <summary>
        /// Constructs a <see cref="Scale3f"/> transformation from a uniform float value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3f(float uniform)
        {
            V = new V3f(uniform, uniform, uniform);
        }

        /// <summary>
        /// Constructs a copy of a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3f(Scale3f scale)
        {
            V = scale.V;
        }

        /// <summary>
        /// Constructs a <see cref="Scale3f"/> transformation from a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3f(Scale3d scale)
        {
            V = (V3f)scale.V;
        }

        /// <summary>
        /// Constructs a <see cref="Scale3f"/> transformation from a float-array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3f(float[] array)
        {
            V = new V3f(array);
        }

        /// <summary>
        /// Constructs a <see cref="Scale3f"/> transformation from a float-array starting from the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3f(float[] array, int start)
        {
            V = new V3f(array, start);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets and sets the X coordinate.
        /// </summary>
        public float X
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.X = value; }
        }

        /// <summary>
        /// Gets and sets the Y coordinate.
        /// </summary>
        public float Y
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Y = value; }
        }

        /// <summary>
        /// Gets and sets the Z coordinate.
        /// </summary>
        public float Z
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Z; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Z = value; }
        }

        /// <summary>
        /// Gets the inverse of this <see cref="Scale3f"/> transformation.
        /// </summary>
        public Scale3f Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3f(1 / X, 1 / Y, 1 / Z);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity <see cref="Scale3f"/> transformation.
        /// </summary>
        public static Scale3f Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3f(1, 1, 1);
        }

        /// <summary>
        /// Gets a <see cref="Scale3f"/> transformation with all components set to zero.
        /// </summary>
        public static Scale3f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3f(0, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale3f"/> transformation with scaling factors (1, 0, 0).
        /// </summary>
        public static Scale3f XAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3f(1, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale3f"/> transformation with scaling factors (0, 1, 0).
        /// </summary>
        public static Scale3f YAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3f(0, 1, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale3f"/> transformation with scaling factors (0, 0, 1).
        /// </summary>
        public static Scale3f ZAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3f(0, 0, 1);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Negates the values of a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator -(Scale3f scale)
        {
            return new Scale3f(-scale.X, -scale.Y, -scale.Z);
        }

        #region Scale / Scalar

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation with a float scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator *(Scale3f scale, float scalar)
        {
            return new Scale3f(scale.X * scalar, scale.Y * scalar, scale.Z * scalar);
        }

        /// <summary>
        /// Multiplies a float scalar with a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator *(float scalar, Scale3f scale)
        {
            return new Scale3f(scale.X * scalar, scale.Y * scalar, scale.Z * scalar);
        }

        /// <summary>
        /// Divides a <see cref="Scale3f"/> transformation by a float scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator /(Scale3f scale, float scalar)
        {
            return new Scale3f(scale.X / scalar, scale.Y / scalar, scale.Z / scalar);
        }

        /// <summary>
        /// Divides a float scalar by a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator /(float scalar, Scale3f scale)
        {
            return new Scale3f(scalar / scale.X, scalar / scale.Y, scalar / scale.Z);
        }

        #endregion

        #region Scale / Vector Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation with a <see cref="V3f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f operator *(Scale3f scale, V3f vector)
        {
            return new V3f(vector.X * scale.X, vector.Y * scale.Y, vector.Z * scale.Z);
        }

        #endregion

        #region Scale / Scale Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation with a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator *(Scale3f a, Scale2f b)
            => new Scale3f(a.X * b.X, a.Y * b.Y, a.Z);

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation with a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f operator *(Scale3f a, Scale3f b)
            => new Scale3f(a.X * b.X, a.Y * b.Y, a.Z * b.Z);

        #endregion

        #region Scale / Matrix Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation (as a 3x3 matrix) with a <see cref="M33f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator *(Scale3f scale, M33f matrix)
        {
            return new M33f(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, 
                scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="M33f"/> with a <see cref="Scale3f"/> transformation (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator *(M33f matrix, Scale3f scale)
        {
            return new M33f(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation (as a 3x3 matrix) with a <see cref="M34f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator *(Scale3f scale, M34f matrix)
        {
            return new M34f(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
                scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22, scale.Z * matrix.M23);
        }

        /// <summary>
        /// Multiplies a <see cref="M34f"/> with a <see cref="Scale3f"/> transformation (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator *(M34f matrix, Scale3f scale)
        {
            return new M34f(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, matrix.M03, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, matrix.M13, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z, matrix.M23);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation (as a 4x4 matrix) with a <see cref="M44f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator *(Scale3f scale, M44f matrix)
        {
            return new M44f(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
                scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22, scale.Z * matrix.M23, 
                matrix.M30, matrix.M31, matrix.M32, matrix.M33);
        }

        /// <summary>
        /// Multiplies a <see cref="M44f"/> with a <see cref="Scale3f"/> transformation (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator *(M44f matrix, Scale3f scale)
        {
            return new M44f(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, matrix.M03, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, matrix.M13, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z, matrix.M23, 
                matrix.M30 * scale.X, matrix.M31 * scale.Y, matrix.M32 * scale.Z, matrix.M33);
        }

        #endregion

        #region Scale / Rot, Shift Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation with a <see cref="Rot3f"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f operator *(Scale3f a, Rot3f b)
            => new Affine3f((M33f)a * (M33f)b);

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> transformation with a <see cref="Shift3f"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f operator *(Scale3f a, Shift3f b)
            => new Affine3f((M33f)a, a * b.V);

        #endregion

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Scale3f"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Scale3f s0, Scale3f s1)
            => s0.X == s1.X && s0.Y == s1.Y && s0.Z == s1.Z;

        /// <summary>
        /// Checks whether two <see cref="Scale3f"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Scale3f s0, Scale3f s1)
            => s0.X != s1.X || s0.Y != s1.Y || s0.Z != s1.Z;

        #endregion

        #region Static Creators

        /// <summary>
        /// Creates a <see cref="Scale3f"/> transformation from a <see cref="M33f"/> matrix.
        /// The matrix must only contain scaling components.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f FromM33f(M33f m, float epsilon = (float)1e-6)
        {
            if (!(Fun.IsTiny(m.C0 * V3f.OII, epsilon) && Fun.IsTiny(m.C1 * V3f.IOI, epsilon) && Fun.IsTiny(m.C2 * V3f.IIO, epsilon)))
                throw new ArgumentException("Matrix is not a pure scaling matrix.");

            return new Scale3f(m.M00, m.M11, m.M22);
        }

        /// <summary>
        /// Creates a <see cref="Scale3f"/> transformation from a scaling <see cref="M44f"/> matrix.
        /// The matrix has to be homogeneous and must not contain perspective components.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f FromM44f(M44f m, float epsilon = (float)1e-6)
        {
            if (!(Fun.IsTiny(m.C0.XYZ * V3f.OII, epsilon) && Fun.IsTiny(m.C1.XYZ * V3f.IOI, epsilon) && Fun.IsTiny(m.C2.XYZ * V3f.IIO, epsilon)))
                throw new ArgumentException("Matrix is not a pure scaling matrix.");

            if (!(m.M30.IsTiny(epsilon) && m.M31.IsTiny(epsilon) && m.M32.IsTiny(epsilon)))
                throw new ArgumentException("Matrix contains perspective components.");

            if (!m.C3.XYZ.IsTiny(epsilon))
                throw new ArgumentException("Matrix contains translational component.");

            if (m.M33.IsTiny(epsilon))
                throw new ArgumentException("Matrix is not homogeneous.");

            return new Scale3f(m.M00 / m.M33, m.M11 / m.M33, m.M22 / m.M33);
        }

        /// <summary>
        /// Creates a <see cref="Scale3f"/> transformation from a <see cref="Similarity3f"/>.
        /// The transformation <paramref name="similarity"/> must only consist of a scaling.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f FromSimilarity3f(Similarity3f similarity, float epsilon = 1e-5f)
        {
            if (!similarity.Trans.IsTiny(epsilon))
                throw new ArgumentException("Similarity transformation contains translational component");

            if (!similarity.Rot.ApproximateEquals(Rot3f.Identity, epsilon))
                throw new ArgumentException("Similarity transformation contains rotational component");

            return new Scale3f(similarity.Scale);
        }

        /// <summary>
        /// Creates a <see cref="Scale3f"/> transformation from an <see cref="Affine3f"/>.
        /// The transformation <paramref name="affine"/> must only consist of a scaling.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f FromAffine3f(Affine3f affine, float epsilon = 1e-5f)
            => FromM44f((M44f)affine, epsilon);

        /// <summary>
        /// Creates a <see cref="Scale3f"/> transformation from a <see cref="Trafo3f"/>.
        /// The transformation <paramref name="trafo"/> must only consist of a scaling.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f FromTrafo3f(Trafo3f trafo, float epsilon = 1e-5f)
            => FromM44f(trafo.Forward, epsilon);

        #endregion

        #region Conversion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M22f(Scale3f s)
        {
            return new M22f(
                s.X, 0  , 
                0  , s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M23f(Scale3f s)
        {
            return new M23f(
                s.X, 0  , 0  , 
                0  , s.Y, 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33f(Scale3f s)
        {
            return new M33f(
                s.X, 0  , 0  , 
                0  , s.Y, 0  , 
                0  , 0  , s.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M34f(Scale3f s)
        {
            return new M34f(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , s.Z, 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44f(Scale3f s)
        {
            return new M44f(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , s.Z, 0  , 
                0  , 0  , 0  , 1  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine3f(Scale3f s)
            => new Affine3f((M33f)s, V3f.Zero);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Trafo3f(Scale3f s)
            => new Trafo3f((M44f)s, (M44f)s.Inverse);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Scale3d(Scale3f s)
            => new Scale3d((V3d)s.V);

        /// <summary>
        /// Returns all values of a <see cref="Scale3f"/> instance
        /// in a float[] array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator float[](Scale3f s)
            => (float[])s.V;

        #endregion

        #region Indexing

        public float this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => V[index];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => V[index] = value;
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return V.GetHashCode();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Scale3f other)
            => X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z);

        public override bool Equals(object other)
            => (other is Scale3f o) ? Equals(o) : false;

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}, {2}]", X, Y, Z);
        }

        public static Scale3f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Scale3f(
                float.Parse(x[0], CultureInfo.InvariantCulture), 
                float.Parse(x[1], CultureInfo.InvariantCulture), 
                float.Parse(x[2], CultureInfo.InvariantCulture)
            );
        }

        #endregion
    }

    public static partial class Scale
    {
        #region Invert

        /// <summary>
        /// Returns the inverse of a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3f Inverse(Scale3f scale)
            => scale.Inverse;

        /// <summary>
        /// Inverts a <see cref="Scale3f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Scale3f scale)
        {
            scale.V.X = 1 / scale.V.X;
            scale.V.Y = 1 / scale.V.Y;
            scale.V.Z = 1 / scale.V.Z;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V3f"/> vector by a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this Scale3f s, V3f v)
            => new V3f(v.X * s.X, v.Y * s.Y, v.Z * s.Z);

        /// <summary>
        /// Transforms a <see cref="V3f"/> vector by the inverse of a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f InvTransform(this Scale3f s, V3f v)
            => new V3f(v.X / s.X, v.Y / s.Y, v.Z / s.Z);

        /// <summary>
        /// Transforms a <see cref="V4f"/> vector by a <see cref="Scale3f"/> transformation.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Transform(this Scale3f s, V4f v)
            => new V4f(v.X * s.X, v.Y * s.Y, v.Z * s.Z, v.W);

        /// <summary>
        /// Transforms a <see cref="V4f"/> vector by the inverse of a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f InvTransform(this Scale3f s, V4f v)
            => new V4f(v.X / s.X, v.Y / s.Y, v.Z / s.Z, v.W);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale3f s0, Scale3f s1)
        {
            return ApproximateEquals(s0.V, s1.V, Constant<float>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale3f s0, Scale3f s1, float tolerance)
        {
            return ApproximateEquals(s0.V, s1.V, tolerance);
        }

        #endregion
    }

    #endregion

    #region Scale2d

    /// <summary>
    /// A 2-dimensional scaling transform with different scaling values
    /// in each dimension.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Scale2d : IEquatable<Scale2d>
    {
        [DataMember]
        [XmlIgnore]
        public V2d V;

        #region Constructors

        /// <summary>
        /// Constructs a <see cref="Scale2d"/> transformation from 2 doubles.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2d(double sX, double sY)
        {
            V = new V2d(sX, sY);
        }

        /// <summary>
        /// Constructs a <see cref="Scale2d"/> from 2 scaling factors provided as <see cref="V2d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2d(V2d scalingFactors)
        {
            V = scalingFactors;
        }

        /// <summary>
        /// Constructs a <see cref="Scale2d"/> transformation from a uniform double value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2d(double uniform)
        {
            V = new V2d(uniform, uniform);
        }

        /// <summary>
        /// Constructs a copy of a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2d(Scale2d scale)
        {
            V = scale.V;
        }

        /// <summary>
        /// Constructs a <see cref="Scale2d"/> transformation from a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2d(Scale2f scale)
        {
            V = (V2d)scale.V;
        }

        /// <summary>
        /// Constructs a <see cref="Scale2d"/> transformation from a double-array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2d(double[] array)
        {
            V = new V2d(array);
        }

        /// <summary>
        /// Constructs a <see cref="Scale2d"/> transformation from a double-array starting from the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale2d(double[] array, int start)
        {
            V = new V2d(array, start);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets and sets the X coordinate.
        /// </summary>
        public double X
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.X = value; }
        }

        /// <summary>
        /// Gets and sets the Y coordinate.
        /// </summary>
        public double Y
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Y = value; }
        }

        /// <summary>
        /// Gets the inverse of this <see cref="Scale2d"/> transformation.
        /// </summary>
        public Scale2d Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2d(1 / X, 1 / Y);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity <see cref="Scale2d"/> transformation.
        /// </summary>
        public static Scale2d Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2d(1, 1);
        }

        /// <summary>
        /// Gets a <see cref="Scale2d"/> transformation with all components set to zero.
        /// </summary>
        public static Scale2d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2d(0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale2d"/> transformation with scaling factors (1, 0).
        /// </summary>
        public static Scale2d XAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2d(1, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale2d"/> transformation with scaling factors (0, 1).
        /// </summary>
        public static Scale2d YAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale2d(0, 1);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Negates the values of a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d operator -(Scale2d scale)
        {
            return new Scale2d(-scale.X, -scale.Y);
        }

        #region Scale / Scalar

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation with a double scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d operator *(Scale2d scale, double scalar)
        {
            return new Scale2d(scale.X * scalar, scale.Y * scalar);
        }

        /// <summary>
        /// Multiplies a double scalar with a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d operator *(double scalar, Scale2d scale)
        {
            return new Scale2d(scale.X * scalar, scale.Y * scalar);
        }

        /// <summary>
        /// Divides a <see cref="Scale2d"/> transformation by a double scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d operator /(Scale2d scale, double scalar)
        {
            return new Scale2d(scale.X / scalar, scale.Y / scalar);
        }

        /// <summary>
        /// Divides a double scalar by a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d operator /(double scalar, Scale2d scale)
        {
            return new Scale2d(scalar / scale.X, scalar / scale.Y);
        }

        #endregion

        #region Scale / Vector Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation with a <see cref="V2d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d operator *(Scale2d scale, V2d vector)
        {
            return new V2d(vector.X * scale.X, vector.Y * scale.Y);
        }

        #endregion

        #region Scale / Scale Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation with a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d operator *(Scale2d a, Scale2d b)
            => new Scale2d(a.X * b.X, a.Y * b.Y);

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation with a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator *(Scale2d a, Scale3d b)
            => new Scale3d(a.X * b.X, a.Y * b.Y, b.Z);

        #endregion

        #region Scale / Matrix Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation (as a 2x2 matrix) with a <see cref="M22d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator *(Scale2d scale, M22d matrix)
        {
            return new M22d(
                scale.X * matrix.M00, scale.X * matrix.M01, 
                scale.Y * matrix.M10, scale.Y * matrix.M11);
        }

        /// <summary>
        /// Multiplies a <see cref="M22d"/> with a <see cref="Scale2d"/> transformation (as a 2x2 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator *(M22d matrix, Scale2d scale)
        {
            return new M22d(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation (as a 2x2 matrix) with a <see cref="M23d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator *(Scale2d scale, M23d matrix)
        {
            return new M23d(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12);
        }

        /// <summary>
        /// Multiplies a <see cref="M23d"/> with a <see cref="Scale2d"/> transformation (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator *(M23d matrix, Scale2d scale)
        {
            return new M23d(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation (as a 3x3 matrix) with a <see cref="M33d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator *(Scale2d scale, M33d matrix)
        {
            return new M33d(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, 
                matrix.M20, matrix.M21, matrix.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="M33d"/> with a <see cref="Scale2d"/> transformation (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator *(M33d matrix, Scale2d scale)
        {
            return new M33d(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22);
        }

        #endregion

        #region Scale / Rot, Shift Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation with a <see cref="Rot2d"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d operator *(Scale2d a, Rot2d b)
            => new Affine2d((M22d)a * (M22d)b);

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> transformation with a <see cref="Shift2d"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d operator *(Scale2d a, Shift2d b)
            => new Affine2d((M22d)a, a * b.V);

        #endregion

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Scale2d"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Scale2d s0, Scale2d s1)
            => s0.X == s1.X && s0.Y == s1.Y;

        /// <summary>
        /// Checks whether two <see cref="Scale2d"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Scale2d s0, Scale2d s1)
            => s0.X != s1.X || s0.Y != s1.Y;

        #endregion

        #region Static Creators

        /// <summary>
        /// Creates a <see cref="Scale2d"/> transformation from a <see cref="M22d"/> matrix.
        /// The matrix must only contain scaling components.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d FromM22d(M22d m, double epsilon = (double)1e-6)
        {
            if (!(Fun.IsTiny(m.C0 * V2d.OI, epsilon) && Fun.IsTiny(m.C1 * V2d.IO, epsilon)))
                throw new ArgumentException("Matrix is not a pure scaling matrix.");

            return new Scale2d(m.M00, m.M11);
        }

        /// <summary>
        /// Creates a <see cref="Scale2d"/> transformation from a scaling <see cref="M33d"/> matrix.
        /// The matrix has to be homogeneous and must not contain perspective components.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d FromM33d(M33d m, double epsilon = (double)1e-6)
        {
            if (!(Fun.IsTiny(m.C0.XY * V2d.OI, epsilon) && Fun.IsTiny(m.C1.XY * V2d.IO, epsilon)))
                throw new ArgumentException("Matrix is not a pure scaling matrix.");

            if (!(m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon)))
                throw new ArgumentException("Matrix contains perspective components.");

            if (!m.C2.XY.IsTiny(epsilon))
                throw new ArgumentException("Matrix contains translational component.");

            if (m.M22.IsTiny(epsilon))
                throw new ArgumentException("Matrix is not homogeneous.");

            return new Scale2d(m.M00 / m.M22, m.M11 / m.M22);
        }

        /// <summary>
        /// Creates a <see cref="Scale2d"/> transformation from a <see cref="Similarity2d"/>.
        /// The transformation <paramref name="similarity"/> must only consist of a scaling.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d FromSimilarity2d(Similarity2d similarity, double epsilon = 1e-12)
        {
            if (!similarity.Trans.IsTiny(epsilon))
                throw new ArgumentException("Similarity transformation contains translational component");

            if (!similarity.Rot.ApproximateEquals(Rot2d.Identity, epsilon))
                throw new ArgumentException("Similarity transformation contains rotational component");

            return new Scale2d(similarity.Scale);
        }

        /// <summary>
        /// Creates a <see cref="Scale2d"/> transformation from an <see cref="Affine2d"/>.
        /// The transformation <paramref name="affine"/> must only consist of a scaling.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d FromAffine2d(Affine2d affine, double epsilon = 1e-12)
            => FromM33d((M33d)affine, epsilon);

        /// <summary>
        /// Creates a <see cref="Scale2d"/> transformation from a <see cref="Trafo2d"/>.
        /// The transformation <paramref name="trafo"/> must only consist of a scaling.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d FromTrafo2d(Trafo2d trafo, double epsilon = 1e-12)
            => FromM33d(trafo.Forward, epsilon);

        #endregion

        #region Conversion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M22d(Scale2d s)
        {
            return new M22d(
                s.X, 0  , 
                0  , s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M23d(Scale2d s)
        {
            return new M23d(
                s.X, 0  , 0  , 
                0  , s.Y, 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33d(Scale2d s)
        {
            return new M33d(
                s.X, 0  , 0  , 
                0  , s.Y, 0  , 
                0  , 0  , 1  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M34d(Scale2d s)
        {
            return new M34d(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , 1  , 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44d(Scale2d s)
        {
            return new M44d(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , 1  , 0  , 
                0  , 0  , 0  , 1  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine2d(Scale2d s)
            => new Affine2d((M22d)s, V2d.Zero);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Trafo2d(Scale2d s)
            => new Trafo2d((M33d)s, (M33d)s.Inverse);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Scale2f(Scale2d s)
            => new Scale2f((V2f)s.V);

        /// <summary>
        /// Returns all values of a <see cref="Scale2d"/> instance
        /// in a double[] array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator double[](Scale2d s)
            => (double[])s.V;

        #endregion

        #region Indexing

        public double this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => V[index];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => V[index] = value;
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return V.GetHashCode();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Scale2d other)
            => X.Equals(other.X) && Y.Equals(other.Y);

        public override bool Equals(object other)
            => (other is Scale2d o) ? Equals(o) : false;

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}]", X, Y);
        }

        public static Scale2d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Scale2d(
                double.Parse(x[0], CultureInfo.InvariantCulture), 
                double.Parse(x[1], CultureInfo.InvariantCulture)
            );
        }

        #endregion
    }

    public static partial class Scale
    {
        #region Invert

        /// <summary>
        /// Returns the inverse of a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale2d Inverse(Scale2d scale)
            => scale.Inverse;

        /// <summary>
        /// Inverts a <see cref="Scale2d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Scale2d scale)
        {
            scale.V.X = 1 / scale.V.X;
            scale.V.Y = 1 / scale.V.Y;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V2d"/> vector by a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d Transform(this Scale2d s, V2d v)
            => new V2d(v.X * s.X, v.Y * s.Y);

        /// <summary>
        /// Transforms a <see cref="V2d"/> vector by the inverse of a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d InvTransform(this Scale2d s, V2d v)
            => new V2d(v.X / s.X, v.Y / s.Y);

        /// <summary>
        /// Transforms a <see cref="V3d"/> vector by a <see cref="Scale2d"/> transformation.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this Scale2d s, V3d v)
            => new V3d(v.X * s.X, v.Y * s.Y, v.Z);

        /// <summary>
        /// Transforms a <see cref="V3d"/> vector by the inverse of a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d InvTransform(this Scale2d s, V3d v)
            => new V3d(v.X / s.X, v.Y / s.Y, v.Z);

        /// <summary>
        /// Transforms a <see cref="V4d"/> vector by a <see cref="Scale2d"/> transformation.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Transform(this Scale2d s, V4d v)
            => new V4d(v.X * s.X, v.Y * s.Y, v.Z, v.W);

        /// <summary>
        /// Transforms a <see cref="V4d"/> vector by the inverse of a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d InvTransform(this Scale2d s, V4d v)
            => new V4d(v.X / s.X, v.Y / s.Y, v.Z, v.W);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale2d s0, Scale2d s1)
        {
            return ApproximateEquals(s0.V, s1.V, Constant<double>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale2d s0, Scale2d s1, double tolerance)
        {
            return ApproximateEquals(s0.V, s1.V, tolerance);
        }

        #endregion
    }

    #endregion

    #region Scale3d

    /// <summary>
    /// A 3-dimensional scaling transform with different scaling values
    /// in each dimension.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Scale3d : IEquatable<Scale3d>
    {
        [DataMember]
        [XmlIgnore]
        public V3d V;

        #region Constructors

        /// <summary>
        /// Constructs a <see cref="Scale3d"/> transformation from 3 doubles.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3d(double sX, double sY, double sZ)
        {
            V = new V3d(sX, sY, sZ);
        }

        /// <summary>
        /// Constructs a <see cref="Scale3d"/> from 3 scaling factors provided as <see cref="V3d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3d(V3d scalingFactors)
        {
            V = scalingFactors;
        }

        /// <summary>
        /// Constructs a <see cref="Scale3d"/> transformation from a uniform double value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3d(double uniform)
        {
            V = new V3d(uniform, uniform, uniform);
        }

        /// <summary>
        /// Constructs a copy of a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3d(Scale3d scale)
        {
            V = scale.V;
        }

        /// <summary>
        /// Constructs a <see cref="Scale3d"/> transformation from a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3d(Scale3f scale)
        {
            V = (V3d)scale.V;
        }

        /// <summary>
        /// Constructs a <see cref="Scale3d"/> transformation from a double-array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3d(double[] array)
        {
            V = new V3d(array);
        }

        /// <summary>
        /// Constructs a <see cref="Scale3d"/> transformation from a double-array starting from the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Scale3d(double[] array, int start)
        {
            V = new V3d(array, start);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets and sets the X coordinate.
        /// </summary>
        public double X
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.X; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.X = value; }
        }

        /// <summary>
        /// Gets and sets the Y coordinate.
        /// </summary>
        public double Y
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Y; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Y = value; }
        }

        /// <summary>
        /// Gets and sets the Z coordinate.
        /// </summary>
        public double Z
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Z; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.Z = value; }
        }

        /// <summary>
        /// Gets the inverse of this <see cref="Scale3d"/> transformation.
        /// </summary>
        public Scale3d Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3d(1 / X, 1 / Y, 1 / Z);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity <see cref="Scale3d"/> transformation.
        /// </summary>
        public static Scale3d Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3d(1, 1, 1);
        }

        /// <summary>
        /// Gets a <see cref="Scale3d"/> transformation with all components set to zero.
        /// </summary>
        public static Scale3d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3d(0, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale3d"/> transformation with scaling factors (1, 0, 0).
        /// </summary>
        public static Scale3d XAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3d(1, 0, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale3d"/> transformation with scaling factors (0, 1, 0).
        /// </summary>
        public static Scale3d YAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3d(0, 1, 0);
        }

        /// <summary>
        /// Gets a <see cref="Scale3d"/> transformation with scaling factors (0, 0, 1).
        /// </summary>
        public static Scale3d ZAxis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Scale3d(0, 0, 1);
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Negates the values of a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator -(Scale3d scale)
        {
            return new Scale3d(-scale.X, -scale.Y, -scale.Z);
        }

        #region Scale / Scalar

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation with a double scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator *(Scale3d scale, double scalar)
        {
            return new Scale3d(scale.X * scalar, scale.Y * scalar, scale.Z * scalar);
        }

        /// <summary>
        /// Multiplies a double scalar with a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator *(double scalar, Scale3d scale)
        {
            return new Scale3d(scale.X * scalar, scale.Y * scalar, scale.Z * scalar);
        }

        /// <summary>
        /// Divides a <see cref="Scale3d"/> transformation by a double scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator /(Scale3d scale, double scalar)
        {
            return new Scale3d(scale.X / scalar, scale.Y / scalar, scale.Z / scalar);
        }

        /// <summary>
        /// Divides a double scalar by a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator /(double scalar, Scale3d scale)
        {
            return new Scale3d(scalar / scale.X, scalar / scale.Y, scalar / scale.Z);
        }

        #endregion

        #region Scale / Vector Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation with a <see cref="V3d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d operator *(Scale3d scale, V3d vector)
        {
            return new V3d(vector.X * scale.X, vector.Y * scale.Y, vector.Z * scale.Z);
        }

        #endregion

        #region Scale / Scale Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation with a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator *(Scale3d a, Scale2d b)
            => new Scale3d(a.X * b.X, a.Y * b.Y, a.Z);

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation with a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d operator *(Scale3d a, Scale3d b)
            => new Scale3d(a.X * b.X, a.Y * b.Y, a.Z * b.Z);

        #endregion

        #region Scale / Matrix Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation (as a 3x3 matrix) with a <see cref="M33d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator *(Scale3d scale, M33d matrix)
        {
            return new M33d(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, 
                scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="M33d"/> with a <see cref="Scale3d"/> transformation (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator *(M33d matrix, Scale3d scale)
        {
            return new M33d(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation (as a 3x3 matrix) with a <see cref="M34d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator *(Scale3d scale, M34d matrix)
        {
            return new M34d(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
                scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22, scale.Z * matrix.M23);
        }

        /// <summary>
        /// Multiplies a <see cref="M34d"/> with a <see cref="Scale3d"/> transformation (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator *(M34d matrix, Scale3d scale)
        {
            return new M34d(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, matrix.M03, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, matrix.M13, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z, matrix.M23);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation (as a 4x4 matrix) with a <see cref="M44d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator *(Scale3d scale, M44d matrix)
        {
            return new M44d(
                scale.X * matrix.M00, scale.X * matrix.M01, scale.X * matrix.M02, scale.X * matrix.M03, 
                scale.Y * matrix.M10, scale.Y * matrix.M11, scale.Y * matrix.M12, scale.Y * matrix.M13, 
                scale.Z * matrix.M20, scale.Z * matrix.M21, scale.Z * matrix.M22, scale.Z * matrix.M23, 
                matrix.M30, matrix.M31, matrix.M32, matrix.M33);
        }

        /// <summary>
        /// Multiplies a <see cref="M44d"/> with a <see cref="Scale3d"/> transformation (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator *(M44d matrix, Scale3d scale)
        {
            return new M44d(
                matrix.M00 * scale.X, matrix.M01 * scale.Y, matrix.M02 * scale.Z, matrix.M03, 
                matrix.M10 * scale.X, matrix.M11 * scale.Y, matrix.M12 * scale.Z, matrix.M13, 
                matrix.M20 * scale.X, matrix.M21 * scale.Y, matrix.M22 * scale.Z, matrix.M23, 
                matrix.M30 * scale.X, matrix.M31 * scale.Y, matrix.M32 * scale.Z, matrix.M33);
        }

        #endregion

        #region Scale / Rot, Shift Multiplication

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation with a <see cref="Rot3d"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d operator *(Scale3d a, Rot3d b)
            => new Affine3d((M33d)a * (M33d)b);

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> transformation with a <see cref="Shift3d"/> transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d operator *(Scale3d a, Shift3d b)
            => new Affine3d((M33d)a, a * b.V);

        #endregion

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Scale3d"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Scale3d s0, Scale3d s1)
            => s0.X == s1.X && s0.Y == s1.Y && s0.Z == s1.Z;

        /// <summary>
        /// Checks whether two <see cref="Scale3d"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Scale3d s0, Scale3d s1)
            => s0.X != s1.X || s0.Y != s1.Y || s0.Z != s1.Z;

        #endregion

        #region Static Creators

        /// <summary>
        /// Creates a <see cref="Scale3d"/> transformation from a <see cref="M33d"/> matrix.
        /// The matrix must only contain scaling components.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d FromM33d(M33d m, double epsilon = (double)1e-6)
        {
            if (!(Fun.IsTiny(m.C0 * V3d.OII, epsilon) && Fun.IsTiny(m.C1 * V3d.IOI, epsilon) && Fun.IsTiny(m.C2 * V3d.IIO, epsilon)))
                throw new ArgumentException("Matrix is not a pure scaling matrix.");

            return new Scale3d(m.M00, m.M11, m.M22);
        }

        /// <summary>
        /// Creates a <see cref="Scale3d"/> transformation from a scaling <see cref="M44d"/> matrix.
        /// The matrix has to be homogeneous and must not contain perspective components.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d FromM44d(M44d m, double epsilon = (double)1e-6)
        {
            if (!(Fun.IsTiny(m.C0.XYZ * V3d.OII, epsilon) && Fun.IsTiny(m.C1.XYZ * V3d.IOI, epsilon) && Fun.IsTiny(m.C2.XYZ * V3d.IIO, epsilon)))
                throw new ArgumentException("Matrix is not a pure scaling matrix.");

            if (!(m.M30.IsTiny(epsilon) && m.M31.IsTiny(epsilon) && m.M32.IsTiny(epsilon)))
                throw new ArgumentException("Matrix contains perspective components.");

            if (!m.C3.XYZ.IsTiny(epsilon))
                throw new ArgumentException("Matrix contains translational component.");

            if (m.M33.IsTiny(epsilon))
                throw new ArgumentException("Matrix is not homogeneous.");

            return new Scale3d(m.M00 / m.M33, m.M11 / m.M33, m.M22 / m.M33);
        }

        /// <summary>
        /// Creates a <see cref="Scale3d"/> transformation from a <see cref="Similarity3d"/>.
        /// The transformation <paramref name="similarity"/> must only consist of a scaling.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d FromSimilarity3d(Similarity3d similarity, double epsilon = 1e-12)
        {
            if (!similarity.Trans.IsTiny(epsilon))
                throw new ArgumentException("Similarity transformation contains translational component");

            if (!similarity.Rot.ApproximateEquals(Rot3d.Identity, epsilon))
                throw new ArgumentException("Similarity transformation contains rotational component");

            return new Scale3d(similarity.Scale);
        }

        /// <summary>
        /// Creates a <see cref="Scale3d"/> transformation from an <see cref="Affine3d"/>.
        /// The transformation <paramref name="affine"/> must only consist of a scaling.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d FromAffine3d(Affine3d affine, double epsilon = 1e-12)
            => FromM44d((M44d)affine, epsilon);

        /// <summary>
        /// Creates a <see cref="Scale3d"/> transformation from a <see cref="Trafo3d"/>.
        /// The transformation <paramref name="trafo"/> must only consist of a scaling.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d FromTrafo3d(Trafo3d trafo, double epsilon = 1e-12)
            => FromM44d(trafo.Forward, epsilon);

        #endregion

        #region Conversion

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M22d(Scale3d s)
        {
            return new M22d(
                s.X, 0  , 
                0  , s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M23d(Scale3d s)
        {
            return new M23d(
                s.X, 0  , 0  , 
                0  , s.Y, 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33d(Scale3d s)
        {
            return new M33d(
                s.X, 0  , 0  , 
                0  , s.Y, 0  , 
                0  , 0  , s.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M34d(Scale3d s)
        {
            return new M34d(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , s.Z, 0  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44d(Scale3d s)
        {
            return new M44d(
                s.X, 0  , 0  , 0  , 
                0  , s.Y, 0  , 0  , 
                0  , 0  , s.Z, 0  , 
                0  , 0  , 0  , 1  );
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine3d(Scale3d s)
            => new Affine3d((M33d)s, V3d.Zero);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Trafo3d(Scale3d s)
            => new Trafo3d((M44d)s, (M44d)s.Inverse);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Scale3f(Scale3d s)
            => new Scale3f((V3f)s.V);

        /// <summary>
        /// Returns all values of a <see cref="Scale3d"/> instance
        /// in a double[] array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator double[](Scale3d s)
            => (double[])s.V;

        #endregion

        #region Indexing

        public double this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => V[index];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => V[index] = value;
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return V.GetHashCode();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Scale3d other)
            => X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z);

        public override bool Equals(object other)
            => (other is Scale3d o) ? Equals(o) : false;

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}, {2}]", X, Y, Z);
        }

        public static Scale3d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Scale3d(
                double.Parse(x[0], CultureInfo.InvariantCulture), 
                double.Parse(x[1], CultureInfo.InvariantCulture), 
                double.Parse(x[2], CultureInfo.InvariantCulture)
            );
        }

        #endregion
    }

    public static partial class Scale
    {
        #region Invert

        /// <summary>
        /// Returns the inverse of a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Scale3d Inverse(Scale3d scale)
            => scale.Inverse;

        /// <summary>
        /// Inverts a <see cref="Scale3d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Scale3d scale)
        {
            scale.V.X = 1 / scale.V.X;
            scale.V.Y = 1 / scale.V.Y;
            scale.V.Z = 1 / scale.V.Z;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V3d"/> vector by a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this Scale3d s, V3d v)
            => new V3d(v.X * s.X, v.Y * s.Y, v.Z * s.Z);

        /// <summary>
        /// Transforms a <see cref="V3d"/> vector by the inverse of a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d InvTransform(this Scale3d s, V3d v)
            => new V3d(v.X / s.X, v.Y / s.Y, v.Z / s.Z);

        /// <summary>
        /// Transforms a <see cref="V4d"/> vector by a <see cref="Scale3d"/> transformation.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Transform(this Scale3d s, V4d v)
            => new V4d(v.X * s.X, v.Y * s.Y, v.Z * s.Z, v.W);

        /// <summary>
        /// Transforms a <see cref="V4d"/> vector by the inverse of a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d InvTransform(this Scale3d s, V4d v)
            => new V4d(v.X / s.X, v.Y / s.Y, v.Z / s.Z, v.W);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale3d s0, Scale3d s1)
        {
            return ApproximateEquals(s0.V, s1.V, Constant<double>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Scale3d s0, Scale3d s1, double tolerance)
        {
            return ApproximateEquals(s0.V, s1.V, tolerance);
        }

        #endregion
    }

    #endregion

}
