using System;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    //# Action comma = () => Out(", ");
    //# Action commaln = () => Out("," + Environment.NewLine);
    //# Action add = () => Out(" + ");
    //# Action and = () => Out(" && ");
    //# Action or = () => Out(" || ");
    //# Action andLit = () => Out(" and ");
    //# var fields = new[] {"X", "Y", "Z", "W"};
    //# var fieldsL = new[] {"x", "y", "z", "w"};
    //# foreach (var isDouble in new[] { false, true }) {
    //# for (int d = 2; d <= 3; d++) {
    //#   var d1 = d + 1;
    //#   var ftype = isDouble ? "double" : "float";
    //#   var tc = isDouble ? "d" : "f";
    //#   var type = "Shift" + d + tc;
    //#   var trafodt = "Trafo" + d + tc;
    //#   var affinedt = "Affine" + d + tc;
    //#   var euclideandt = "Euclidean" + d + tc;
    //#   var rotdt = "Rot" + d + tc;
    //#   var shiftdt = "Shift" + d + tc;
    //#   var similaritydt = "Similarity" + d + tc;
    //#   var mddt = "M" + d + d + tc;
    //#   var md1d1t = "M" + (d + 1) + (d + 1) + tc;
    //#   var mdd1t = "M" + d + (d + 1) + tc;
    //#   var vdt = "V" + d + tc;
    //#   var dfields = fields.Take(d).ToArray();
    //#   var dfieldsL = fieldsL.Take(d).ToArray();
    //#   var fd = fields[d];
    #region __type__

    /// <summary>
    /// A __d__-dimensional translational transform with different translation values
    /// in each dimension.
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct __type__
    {
        [DataMember]
        public __vdt__ V;

        #region Constructors

        /// <summary>
        /// Constructs a <see cref="__type__"/> transformation from __d__ __ftype__s.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(/*# dfieldsL.ForEach(f => { */__ftype__ __f__/*# }, comma); */)
        {
            V = new __vdt__(/*# dfieldsL.ForEach(f => { */__f__/*# }, comma); */);
        }

        /// <summary>
        /// Constructs a <see cref="__type__"/> from a <see cref="__vdt__"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(__vdt__ v)
        {
            V = v;
        }

        /// <summary>
        /// Constructs a copy of a <see cref="__type__"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(__type__ s)
        {
            V = s.V;
        }

        /// <summary>
        /// Constructs a <see cref="__type__"/> transformation from a __ftype__-array.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(__ftype__[] array)
        {
            V = new __vdt__(array);
        }

        /// <summary>
        /// Constructs a <see cref="__type__"/> transformation from a __ftype__-array starting from the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public __type__(__ftype__[] array, int start)
        {
            V = new __vdt__(array, start);
        }

        #endregion

        #region Properties

        //# dfields.ForEach(f => {
        /// <summary>
        /// Gets and sets the __f__ coordinate.
        /// </summary>
        public __ftype__ __f__
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.__f__; }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { V.__f__ = value; }
        }

        //# });
        /// <summary>
        /// Gets the length of this <see cref="__type__"/> transformation.
        /// </summary>
        public __ftype__ Length
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.Length; }
        }

        /// <summary>
        /// Gets the squared length of this <see cref="__type__"/> transformation.
        /// </summary>
        public __ftype__ LengthSquared
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return V.LengthSquared; }
        }

        /// <summary>
        /// Gets the inverse of this <see cref="__type__"/> transformation.
        /// </summary>
        public __type__ Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new __type__(-V); }
        }

        /// <summary>
        /// Gets the reciprocal of this <see cref="__type__"/> transformation.
        /// </summary>
        public __type__ Reciprocal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new __type__(1 / V);
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity <see cref="__type__"/> transformation.
        /// </summary>
        public static __type__ Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new __type__(/*# dfields.ForEach(f => { */0/*# }, comma); */);
        }

        /// <summary>
        /// Gets a <see cref="__type__"/> transformation with all components set to zero.
        /// Note: Equivalent to Identity.
        /// </summary>
        public static __type__ Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Identity;
        }

        //# dfields.ForEach((fi, i) => {
        /// <summary>
        /// Gets a <see cref="__type__"/> transformation with components (/*# dfields.ForEach((fj, j) => { var val = (i != j) ? "0" : "1"; */__val__/*# }, comma); */).
        /// </summary>
        public static __type__ __fi__Axis
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new __type__(/*# dfields.ForEach((fj, j) => { var val = (i != j) ? "0" : "1"; */__val__/*# }, comma); */);
        }

        //# });
        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Negates the values of a <see cref="__type__"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ operator -(__type__ shift)
        {
            return new __type__(/*# dfields.ForEach(f => { */-shift.__f__/*# }, comma); */);
        }

        #region Shift / Scalar

        /// <summary>
        /// Multiplies a <see cref="__type__"/> transformation with a __ftype__ scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ operator *(__type__ shift, __ftype__ scalar)
        {
            return new __type__(/*# dfields.ForEach(f => { */shift.__f__ * scalar/*# }, comma); */);
        }

        /// <summary>
        /// Multiplies a __ftype__ scalar with a <see cref="__type__"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ operator *(__ftype__ scalar, __type__ shift)
        {
            return new __type__(/*# dfields.ForEach(f => { */shift.__f__ * scalar/*# }, comma); */);
        }

        /// <summary>
        /// Divides a <see cref="__type__"/> transformation by a __ftype__ scalar.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ operator /(__type__ shift, __ftype__ scalar)
        {
            return new __type__(/*# dfields.ForEach(f => { */shift.__f__ / scalar/*# }, comma); */);
        }

        /// <summary>
        /// Divides a __ftype__ scalar by a <see cref="__type__"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ operator /(__ftype__ scalar, __type__ shift)
        {
            return new __type__(/*# dfields.ForEach(f => { */scalar / shift.__f__/*# }, comma); */);
        }

        #endregion

        #region Shift / Vector Multiplication

        /// <summary>
        /// Multiplies a <see cref="__type__"/> transformation with a <see cref="__vdt__"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __vdt__ operator *(__type__ shift, __vdt__ vector)
        {
            return new __vdt__(/*# dfields.ForEach(f => { */vector.__f__ + shift.__f__/*# }, comma); */);
        }

        #endregion

        #region Shift / Shift Multiplication

        //# for (int n = 2; n <= 3; n++) {
        //# var r = (d > n) ? d : n;
        //# var m = (d < n) ? d : n;
        //# var mfields = fields.Take(m);
        //# var rem = r - m;
        //# var ntype = "Shift" + n + tc;
        //# var rtype = "Shift" + r + tc;
        /// <summary>
        /// Multiplies a <see cref="__type__"/> transformation with a <see cref="__ntype__"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __rtype__ operator *(__type__ a, __ntype__ b)
            => new __rtype__(/*# mfields.ForEach(f => {*/a.__f__ + b.__f__/*# }, comma);
                if (r > m) {*/, /*# rem.ForEach(i => {
                var x = (d > n) ? "a" : "b";
                var f = fields[m + i]; */__x__.__f__/*#}, comma); } */);

        //# }
        #endregion

        #region Shift / Matrix Multiplication

        /// <summary>
        /// Multiplies a <see cref="__type__"/> transformation (as a __d__x__d1__ matrix) with a <see cref="__mddt__"/> (as a __d1__x__d1__ matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __mdd1t__ operator *(__type__ shift, __mddt__ matrix)
        {
            return new __mdd1t__(matrix, shift.V);
        }

        /// <summary>
        /// Multiplies a <see cref="__mddt__"/> with a <see cref="__type__"/> transformation (as a __d__x__d1__ matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __mdd1t__ operator *(__mddt__ matrix, __type__ shift)
        {
            return new __mdd1t__(matrix, matrix * shift.V);
        }

        /// <summary>
        /// Multiplies a <see cref="__type__"/> transformation (as a __d1__x__d1__ matrix) with a <see cref="__md1d1t__"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __md1d1t__ operator *(__type__ s, __md1d1t__ m)
        {
            return new __md1d1t__(/*# dfields.ForEach((fi, i) => { d1.ForEach(j => { */
                m.M__i____j__ + s.__fi__ * m.M__d____j__/*# }, comma); }, commaln);*/,

                /*# d1.ForEach(j => {*/m.M__d____j__/*# }, comma);*/);
        }

        /// <summary>
        /// Multiplies a <see cref="__md1d1t__"/> with a <see cref="__type__"/> transformation (as a __d1__x__d1__ matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __md1d1t__ operator *(__md1d1t__ m, __type__ s)
        {
            return new __md1d1t__(/*# d1.ForEach(i => { dfields.ForEach((fj, j) => { */
                m.M__i____j__/*# }, comma);*/,
                /*# dfields.ForEach((fj, j) => {
                */s.__fj__ * m.M__i____j__/*# }, add);
                */ + m.M__i____d__/*# }, commaln);*/);
        }

        /// <summary>
        /// Multiplies a <see cref="__type__"/> transformation (as a __d__x__d1__ matrix) with a <see cref="__mdd1t__"/> (as a __d1__x__d1__ matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __mdd1t__ operator *(__type__ s, __mdd1t__ m)
        {
            return new __mdd1t__(/*# dfields.ForEach((fi, i) => { */
                /*# dfields.ForEach((fj, j) => {*/m.M__i____j__/*# }, comma);*/, m.M__i____d__ + s.__fi__/*# }, comma);*/);
        }

        /// <summary>
        /// Multiplies a <see cref="__mdd1t__"/> with a <see cref="__type__"/> transformation (as a __d1__x__d1__ matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __mdd1t__ operator *(__mdd1t__ m, __type__ s)
        {
            return new __mdd1t__(/*# d.ForEach(i => { dfields.ForEach((fj, j) => { */
                m.M__i____j__/*# }, comma);*/,
                /*# dfields.ForEach((fj, j) => {
                */s.__fj__ * m.M__i____j__/*# }, add);
                */ + m.M__i____d__/*# }, commaln);*/);
        }

        #endregion

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="__type__"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(__type__ s0, __type__ s1)
            => /*# dfields.ForEach(f => {*/s0.__f__ == s1.__f__/*# }, and);*/;

        /// <summary>
        /// Checks whether two <see cref="__type__"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(__type__ s0, __type__ s1)
            => /*# dfields.ForEach(f => {*/s0.__f__ != s1.__f__/*# }, or);*/;

        #endregion

        #region Conversion

        //# for (int n = 3; n <= 4; n++) {
        //#     var m = n - 1;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M__n____n____tc__(__type__ s)
        {
            return new M__n____n____tc__(/*# fields.Take(m).ForEach((fi, i) => { */
                /*# var f = (i < d) ? "s." + fi : "0";
                   m.ForEach(j => {
                   var x = (i == j) ? "1" : "0";
                */__x__/*# }, comma);*/, __f__/*# }, comma);*/,
                /*# m.ForEach(i => { */0/*# }, comma);*/, 1);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M__m____n____tc__(__type__ s)
        {
            return new M__m____n____tc__(/*# fields.Take(m).ForEach((fi, i) => { */
                /*# var f = (i < d) ? "s." + fi : "0";
                   m.ForEach(j => {
                   var x = (i == j) ? "1" : "0";
                */__x__/*# }, comma);*/, __f__/*# }, comma);*/);
        }

        //# }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator __affinedt__(__type__ s)
            => new __affinedt__(s);

        /// <summary>
        /// Returns all values of a <see cref="__type__"/> instance
        /// in a __ftype__[] array.
        /// </summary>
        public static explicit operator __ftype__[](__type__ shift)
        {
            __ftype__[] array = new __ftype__[__d__];
            /*# dfields.ForEach((f, i) => {*/array[__i__] = shift.__f__;
            /*# });*/return array;
        }

        #endregion

        #region Indexing

        public __ftype__ this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                switch (index)
                {
                    /*# dfields.ForEach((f, i) => {*/case __i__: return V.__f__;
                    /*# });*/default: throw new IndexOutOfRangeException();
                }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                switch (index)
                {
                    /*# dfields.ForEach((f, i) => {*/case __i__: V.__f__ = value; return;
                    /*# });*/default: throw new IndexOutOfRangeException();
                }
            }
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return V.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is __type__)
            {
                __type__ v = (__type__)obj;
                return /*# dfields.ForEach(f => {*/__f__ == v.__f__/*# }, and);*/;
            }
            return false;
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[/*# d.ForEach(i => {*/{__i__}/*# }, comma);*/]", /*# dfields.ForEach(f => {*/__f__/*#}, comma);*/);
        }

        public static __type__ Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new __type__(/*# d.ForEach(i => {*/
                __ftype__.Parse(x[__i__], CultureInfo.InvariantCulture)/*# }, comma);*/
            );
        }

        #endregion
    }

    public static partial class Shift
    {
        #region Invert

        /// <summary>
        /// Returns the inverse of a <see cref="__type__"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __type__ Inverse(__type__ shift)
            => shift.Inverse;

        /// <summary>
        /// Inverts a <see cref="__type__"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref __type__ shift)
        {
            shift = shift.Inverse;
        }

        #endregion

        #region Transformations

        //# for (int n = d; n <= 4; n++) {
        //# var vec = "V" + n + tc;
        //# var rem = n - d;
        //# var constfields = fields.Skip(d).Take(rem);
        //# var isare = (rem > 1) ? "are" : "is";
        /// <summary>
        /// Transforms a <see cref="__vec__"/> vector by a <see cref="__type__"/> transformation./*# if (rem > 0) { */
        /// /*# constfields.ForEach(f => {*/v.__f__/*# }, andLit); */ __isare__ not modified./*# }*/
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __vec__ Transform(this __type__ s, __vec__ v)
            => new __vec__(/*# dfields.ForEach(f => {*/v.__f__ + s.__f__/*# }, comma);
                if (rem > 0) {*/, /*# rem.ForEach(i => {
                var f = fields[d + i]; */v.__f__/*#}, comma); } */);

        /// <summary>
        /// Transforms a <see cref="__vec__"/> vector by the inverse of a <see cref="__type__"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static __vec__ InvTransform(this __type__ s, __vec__ v)
            => new __vec__(/*# dfields.ForEach(f => {*/v.__f__ - s.__f__/*# }, comma);
                if (rem > 0) {*/, /*# rem.ForEach(i => {
                var f = fields[d + i]; */v.__f__/*#}, comma); } */);

        //# }
        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this __type__ s0, __type__ s1)
        {
            return ApproximateEquals(s0.V, s1.V, Constant<__ftype__>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this __type__ s0, __type__ s1, __ftype__ tolerance)
        {
            return ApproximateEquals(s0.V, s1.V, tolerance);
        }

        #endregion
    }

    #endregion

    //# } }
}
