using System;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Runtime.CompilerServices;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    #region Affine2f

    /// <summary>
    /// Struct to represent an affine transformation in 2-dimensional space. It consists of
    /// a linear tranformation (invertible 2x2 matrix) and a translational component (2d vector).
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public struct Affine2f : IValidity
    {
        [DataMember]
        public M22f Linear;
        [DataMember]
        public V2f Trans;

        #region Constructors

        /// <summary>
        /// Constructs a copy of an <see cref="Affine2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine2f(Affine2f affine)
        {
            Linear = affine.Linear;
            Trans = affine.Trans;
        }

        /// <summary>
        /// Constructs an affine transformation from a linear map and a translation.
        /// The matrix <paramref name="linear"/> must be invertible.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine2f(M22f linear, V2f translation)
        {
            Debug.Assert(linear.Invertible);
            Linear = linear;
            Trans = translation;
        }

        /// <summary>
        /// Constructs an affine transformation from a linear map and a translation.
        /// The matrix <paramref name="linear"/> must be invertible.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine2f(M22f linear, float tX, float tY)
        {
            Debug.Assert(linear.Invertible);
            Linear = linear;
            Trans = new V2f(tX, tY);
        }

        /// <summary>
        /// Constructs an affine transformation from a linear map.
        /// The matrix <paramref name="linear"/> must be invertible.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine2f(M22f linear)
        {
            Debug.Assert(linear.Invertible);
            Linear = linear;
            Trans = V2f.Zero;
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity transformation.
        /// </summary>
        public static Affine2f Identity
        { 
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Affine2f(M22f.Identity);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets if this affine transformation is valid, i.e. if the linear map is invertible.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Linear.Invertible;
        }

        /// <summary>
        /// Gets if this affine transformation is invalid, i.e. if the linear map is singular.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => !IsValid;
        }

        /// <summary>
        /// Gets the inverse of this affine transformation.
        /// </summary>
        public Affine2f Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var rs = new Affine2f(this);
                rs.Invert();
                return rs;
            }
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Multiplies two affine transformations.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f operator *(Affine2f a, Affine2f b)
        {
            return new Affine2f(a.Linear * b.Linear, a.Linear * b.Trans + a.Trans);
        }

        /// <summary>
        /// Transforms a <see cref="V3f"/> vector by an affine transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f operator *(Affine2f a, V3f v)
        {
            return new V3f(
                a.Linear.M00 * v.X + a.Linear.M01 * v.Y + a.Trans.X * v.Z, 
                a.Linear.M10 * v.X + a.Linear.M11 * v.Y + a.Trans.Y * v.Z, 
                v.Z);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine2f"/> (as a 3x3 matrix) and a <see cref="M33f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator *(Affine2f a, M33f m)
        {
            return new M33f(
                a.Linear.M00 * m.M00 + a.Linear.M01 * m.M10 + a.Trans.X * m.M20, 
                a.Linear.M00 * m.M01 + a.Linear.M01 * m.M11 + a.Trans.X * m.M21, 
                a.Linear.M00 * m.M02 + a.Linear.M01 * m.M12 + a.Trans.X * m.M22,

                a.Linear.M10 * m.M00 + a.Linear.M11 * m.M10 + a.Trans.Y * m.M20, 
                a.Linear.M10 * m.M01 + a.Linear.M11 * m.M11 + a.Trans.Y * m.M21, 
                a.Linear.M10 * m.M02 + a.Linear.M11 * m.M12 + a.Trans.Y * m.M22,

                m.M20, m.M21, m.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="M33f"/> and a <see cref="Affine2f"/> (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator *(M33f m, Affine2f a)
        {
            return new M33f(
                m.M00 * a.Linear.M00 + m.M01 * a.Linear.M10, 
                m.M00 * a.Linear.M01 + m.M01 * a.Linear.M11,
                m.M00 * a.Trans.X + m.M01 * a.Trans.Y + m.M02,

                m.M10 * a.Linear.M00 + m.M11 * a.Linear.M10, 
                m.M10 * a.Linear.M01 + m.M11 * a.Linear.M11,
                m.M10 * a.Trans.X + m.M11 * a.Trans.Y + m.M12,

                m.M20 * a.Linear.M00 + m.M21 * a.Linear.M10, 
                m.M20 * a.Linear.M01 + m.M21 * a.Linear.M11,
                m.M20 * a.Trans.X + m.M21 * a.Trans.Y + m.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine2f"/> (as a 2x3 matrix) and a <see cref="M22f"/> (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator *(Affine2f a, M22f m)
            => new M23f(a.Linear * m, a.Trans);

        /// <summary>
        /// Multiplies a <see cref="M22f"/> and a <see cref="Affine2f"/> (as a 2x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator *(M22f m, Affine2f a)
            => new M23f(m * a.Linear, m * a.Trans);

        /// <summary>
        /// Multiplies a <see cref="Affine2f"/> (as a 2x3 matrix) and a <see cref="M23f"/> (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator *(Affine2f a, M23f m)
        {
            return new M23f(
                a.Linear.M00 * m.M00 + a.Linear.M01 * m.M10, 
                a.Linear.M00 * m.M01 + a.Linear.M01 * m.M11,
                a.Trans.X + a.Linear.M00 * m.M02 + a.Linear.M01 * m.M12,

                a.Linear.M10 * m.M00 + a.Linear.M11 * m.M10, 
                a.Linear.M10 * m.M01 + a.Linear.M11 * m.M11,
                a.Trans.Y + a.Linear.M10 * m.M02 + a.Linear.M11 * m.M12);
        }

        /// <summary>
        /// Multiplies a <see cref="M23f"/> and a <see cref="Affine2f"/> (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator *(M23f m, Affine2f a)
        {
            return new M23f(
                m.M00 * a.Linear.M00 + m.M01 * a.Linear.M10, 
                m.M00 * a.Linear.M01 + m.M01 * a.Linear.M11,
                m.M00 * a.Trans.X + m.M01 * a.Trans.Y + m.M02,

                m.M10 * a.Linear.M00 + m.M11 * a.Linear.M10, 
                m.M10 * a.Linear.M01 + m.M11 * a.Linear.M11,
                m.M10 * a.Trans.X + m.M11 * a.Trans.Y + m.M12);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine2f"/> and a <see cref="Euclidean2f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f operator *(Affine2f a, Euclidean2f e)
            => a * (Affine2f)e;

        /// <summary>
        /// Multiplies a <see cref="Euclidean2f"/> and a <see cref="Affine2f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f operator *(Euclidean2f e, Affine2f a)
            => (Affine2f)e * a;

        /// <summary>
        /// Multiplies a <see cref="Affine2f"/> and a <see cref="Rot2f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f operator *(Affine2f a, Rot2f r)
            => new Affine2f(a.Linear * r, a.Trans);

        /// <summary>
        /// Multiplies a <see cref="Rot2f"/> and a <see cref="Affine2f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f operator *(Rot2f r, Affine2f a)
            => new Affine2f(r * a.Linear, r * a.Trans);

        /// <summary>
        /// Multiplies a <see cref="Affine2f"/> and a <see cref="Scale2f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f operator *(Affine2f a, Scale2f s)
        {
            return new Affine2f(new M22f(
                a.Linear.M00 * s.X, a.Linear.M01 * s.Y, 
                a.Linear.M10 * s.X, a.Linear.M11 * s.Y),
                a.Trans);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale2f"/> and a <see cref="Affine2f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f operator *(Scale2f s, Affine2f a)
        {
            return new Affine2f(new M22f(
                a.Linear.M00 * s.X, a.Linear.M01 * s.X, 
                a.Linear.M10 * s.Y, a.Linear.M11 * s.Y),
                a.Trans * s.V);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine2f"/> and a <see cref="Shift2f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f operator *(Affine2f a, Shift2f s)
        {
            return new Affine2f(a.Linear, a.Linear * s.V + a.Trans);
        }

        /// <summary>
        /// Multiplies a <see cref="Shift2f"/> and a <see cref="Affine2f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f operator *(Shift2f s, Affine2f a)
        {
            return new Affine2f(a.Linear, a.Trans + s.V);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine2f"/> and a <see cref="Similarity2f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f operator *(Affine2f a, Similarity2f s)
            => a * (Affine2f)s;

        /// <summary>
        /// Multiplies a <see cref="Similarity2f"/> and a <see cref="Affine2f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f operator *(Similarity2f s, Affine2f a)
            => (Affine2f)s * a;

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Affine2f"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Affine2f a0, Affine2f a1)
            => (a0.Linear == a1.Linear) && (a0.Trans == a1.Trans); 

        /// <summary>
        /// Checks whether two <see cref="Affine2f"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Affine2f a0, Affine2f a1)
            => (a0.Linear != a1.Linear) || (a0.Trans != a1.Trans);

        #endregion

        #region Static Creators

        /// <summary>
        /// Creates an affine transformation from a 2x3 matrix.
        /// The left 2x2 submatrix of <paramref name="matrix"/> must be invertible.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f FromM23f(M23f matrix, float epsilon = 1e-5f)
        {
            var linear = (M22f)matrix;
            var trans = new V2f(matrix.M02, matrix.M12);

            if (linear.Determinant.IsTiny(epsilon))
                throw new ArgumentException("Matrix must be invertible");

            return new Affine2f(linear, trans);
        }

        /// <summary>
        /// Creates an affine transformation from a 3x3 matrix.
        /// The matrix <paramref name="m"/> has to be homogeneous and must not contain perspective components and its upper left 2x2 submatrix must be invertible.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f FromM33f(M33f m, float epsilon = 1e-5f)
        {
            if (!(m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon)))
                throw new ArgumentException("Matrix contains perspective components.");

            if (m.M22.IsTiny(epsilon))
                throw new ArgumentException("Matrix is not homogeneous.");

            var linear = ((M22f)m) / m.M22;
            var trans = new V2f(m.M02, m.M12) / m.M22;

            if (linear.Determinant.IsTiny(epsilon))
                throw new ArgumentException("Matrix must be invertible");

            return new Affine2f(linear, trans);
        }

        /// <summary>
        /// Creates an affine transformation from a <see cref="Trafo2f"/>.
        /// The transformation <paramref name="trafo"/> must represent a valid affine transformation (e.g. it does not contain perspective components).
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f FromTrafo2f(Trafo2f trafo, float epsilon = 1e-5f)
            => FromM33f(trafo.Forward, epsilon);

        /// <summary>
        /// Creates an affine transformation with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f Translation(float tX, float tY)
            => new Affine2f(M22f.Identity, tX, tY);

        /// <summary>
        /// Creates an affine transformation with the translational component given a <see cref="V2f"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f Translation(V2f vector)
            => new Affine2f(M22f.Identity, vector);

        /// <summary>
        /// Creates an affine transformation with the translational component given a <see cref="Shift2f"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f Translation(Shift2f shift)
            => new Affine2f(M22f.Identity, shift.V);

        /// <summary>
        /// Creates a scaling transformation using a uniform scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f Scale(float scaleFactor)
            => new Affine2f(M22f.Scale(scaleFactor, scaleFactor));

        /// <summary>
        /// Creates a scaling transformation using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f Scale(float sX, float sY)
            => new Affine2f(M22f.Scale(sX, sY));

        /// <summary>
        /// Creates a scaling transformation using a <see cref="V2f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f Scale(V2f scaleFactors)
            => new Affine2f(M22f.Scale(scaleFactors));

        /// <summary>
        /// Creates a scaling transformation using a <see cref="Scale2f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f Scale(Scale2f scale)
            => new Affine2f(M22f.Scale(scale));

        /// <summary>
        /// Creates a rotation transformation from a <see cref="Rot2f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f Rotation(Rot2f rot)
            => new Affine2f(M22f.Rotation(rot));

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M23f(Affine2f a)
            => new M23f(a.Linear, a.Trans);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M22f(Affine2f a)
            => a.Linear;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33f(Affine2f a)
            => new M33f((M23f)a);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Trafo2f(Affine2f a)
        {
            Debug.Assert(a.Linear.Invertible);
            var t = (M33f)a;
            return new Trafo2f(t, t.Inverse);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine2d(Affine2f a)
            => new Affine2d((M22d)a.Linear, (V2d)a.Trans);

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Linear, Trans);
        }

        public override bool Equals(object other)
        {
            return (other is Affine2f) ? (this == (Affine2f)other) : false;
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}]", Linear, Trans);
        }

        public static Affine2f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Affine2f(M22f.Parse(x[0]), V2f.Parse(x[1]));
        }

        #endregion
    }

    public static partial class Affine
    {
        #region Invert

        /// <summary>
        /// Returns the inverse of an <see cref="Affine2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2f Inverse(Affine2f a)
            => a.Inverse;

        /// <summary>
        /// Inverts the given affine transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Affine2f a)
        {
            Debug.Assert(a.Linear.Invertible);
            a.Linear.Invert();
            a.Trans = -a.Linear * a.Trans;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V3f"/> by an <see cref="Affine2f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this Affine2f a, V3f v)
            => a * v;

        /// <summary>
        /// Transforms a <see cref="V2f"/> position vector (v.Z is presumed 1) by an <see cref="Affine2f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f TransformPos(this Affine2f a, V2f v)
        {
            return new V2f(
                a.Linear.M00 * v.X + a.Linear.M01 * v.Y + a.Trans.X, 
                a.Linear.M10 * v.X + a.Linear.M11 * v.Y + a.Trans.Y);
        }

        /// <summary>
        /// Transforms a <see cref="V2f"/> direction vector (v.Z is presumed 0) by an <see cref="Affine2f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f TransformDir(this Affine2f a, V2f v)
        {
            return new V2f(
                a.Linear.M00 * v.X + a.Linear.M01 * v.Y, 
                a.Linear.M10 * v.X + a.Linear.M11 * v.Y);
        }

        /// <summary>
        /// Transforms a <see cref="V3f"/> by the transpose of an <see cref="Affine2f"/> (as a 3x3 matrix).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f TransposedTransform(this Affine2f a, V3f v)
        {
            return new V3f(
                v.X * a.Linear.M00 + v.Y * a.Linear.M10, 
                v.X * a.Linear.M01 + v.Y * a.Linear.M11,
                v.X * a.Trans.X + v.Y * a.Trans.Y + v.Z);
        }

        /// <summary>
        /// Transforms a <see cref="V2f"/> by the transpose of an <see cref="Affine2f"/> (as a 3x3 matrix).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f TransposedTransform(this Affine2f a, V2f v)
        {
            return new V2f(
                v.X * a.Linear.M00 + v.Y * a.Linear.M10, 
                v.X * a.Linear.M01 + v.Y * a.Linear.M11);
        }

        /// <summary>
        /// Transforms a <see cref="V2f"/> position vector (v.Z is presumed 1) by the transpose of an <see cref="Affine2f"/> (as a 3x3 matrix).
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f TransposedTransformPosProj(this Affine2f a, V2f v)
        {
            var s = v.X * a.Trans.X + v.Y * a.Trans.Y + 1;
            return TransposedTransform(a, v) * (1 / s);
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Affine2f a0, Affine2f a1)
        {
            return ApproximateEquals(a0, a1, Constant<float>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Affine2f a0, Affine2f a1, float tolerance)
        {
            return ApproximateEquals(a0.Linear, a1.Linear, tolerance) && ApproximateEquals(a0.Trans, a1.Trans, tolerance);
        }

        #endregion
    }

    #endregion

    #region Affine3f

    /// <summary>
    /// Struct to represent an affine transformation in 3-dimensional space. It consists of
    /// a linear tranformation (invertible 3x3 matrix) and a translational component (3d vector).
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public struct Affine3f : IValidity
    {
        [DataMember]
        public M33f Linear;
        [DataMember]
        public V3f Trans;

        #region Constructors

        /// <summary>
        /// Constructs a copy of an <see cref="Affine3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine3f(Affine3f affine)
        {
            Linear = affine.Linear;
            Trans = affine.Trans;
        }

        /// <summary>
        /// Constructs an affine transformation from a linear map and a translation.
        /// The matrix <paramref name="linear"/> must be invertible.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine3f(M33f linear, V3f translation)
        {
            Debug.Assert(linear.Invertible);
            Linear = linear;
            Trans = translation;
        }

        /// <summary>
        /// Constructs an affine transformation from a linear map and a translation.
        /// The matrix <paramref name="linear"/> must be invertible.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine3f(M33f linear, float tX, float tY, float tZ)
        {
            Debug.Assert(linear.Invertible);
            Linear = linear;
            Trans = new V3f(tX, tY, tZ);
        }

        /// <summary>
        /// Constructs an affine transformation from a linear map.
        /// The matrix <paramref name="linear"/> must be invertible.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine3f(M33f linear)
        {
            Debug.Assert(linear.Invertible);
            Linear = linear;
            Trans = V3f.Zero;
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity transformation.
        /// </summary>
        public static Affine3f Identity
        { 
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Affine3f(M33f.Identity);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets if this affine transformation is valid, i.e. if the linear map is invertible.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Linear.Invertible;
        }

        /// <summary>
        /// Gets if this affine transformation is invalid, i.e. if the linear map is singular.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => !IsValid;
        }

        /// <summary>
        /// Gets the inverse of this affine transformation.
        /// </summary>
        public Affine3f Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var rs = new Affine3f(this);
                rs.Invert();
                return rs;
            }
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Multiplies two affine transformations.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f operator *(Affine3f a, Affine3f b)
        {
            return new Affine3f(a.Linear * b.Linear, a.Linear * b.Trans + a.Trans);
        }

        /// <summary>
        /// Transforms a <see cref="V4f"/> vector by an affine transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f operator *(Affine3f a, V4f v)
        {
            return new V4f(
                a.Linear.M00 * v.X + a.Linear.M01 * v.Y + a.Linear.M02 * v.Z + a.Trans.X * v.W, 
                a.Linear.M10 * v.X + a.Linear.M11 * v.Y + a.Linear.M12 * v.Z + a.Trans.Y * v.W, 
                a.Linear.M20 * v.X + a.Linear.M21 * v.Y + a.Linear.M22 * v.Z + a.Trans.Z * v.W, 
                v.W);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine3f"/> (as a 4x4 matrix) and a <see cref="M44f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator *(Affine3f a, M44f m)
        {
            return new M44f(
                a.Linear.M00 * m.M00 + a.Linear.M01 * m.M10 + a.Linear.M02 * m.M20 + a.Trans.X * m.M30, 
                a.Linear.M00 * m.M01 + a.Linear.M01 * m.M11 + a.Linear.M02 * m.M21 + a.Trans.X * m.M31, 
                a.Linear.M00 * m.M02 + a.Linear.M01 * m.M12 + a.Linear.M02 * m.M22 + a.Trans.X * m.M32, 
                a.Linear.M00 * m.M03 + a.Linear.M01 * m.M13 + a.Linear.M02 * m.M23 + a.Trans.X * m.M33,

                a.Linear.M10 * m.M00 + a.Linear.M11 * m.M10 + a.Linear.M12 * m.M20 + a.Trans.Y * m.M30, 
                a.Linear.M10 * m.M01 + a.Linear.M11 * m.M11 + a.Linear.M12 * m.M21 + a.Trans.Y * m.M31, 
                a.Linear.M10 * m.M02 + a.Linear.M11 * m.M12 + a.Linear.M12 * m.M22 + a.Trans.Y * m.M32, 
                a.Linear.M10 * m.M03 + a.Linear.M11 * m.M13 + a.Linear.M12 * m.M23 + a.Trans.Y * m.M33,

                a.Linear.M20 * m.M00 + a.Linear.M21 * m.M10 + a.Linear.M22 * m.M20 + a.Trans.Z * m.M30, 
                a.Linear.M20 * m.M01 + a.Linear.M21 * m.M11 + a.Linear.M22 * m.M21 + a.Trans.Z * m.M31, 
                a.Linear.M20 * m.M02 + a.Linear.M21 * m.M12 + a.Linear.M22 * m.M22 + a.Trans.Z * m.M32, 
                a.Linear.M20 * m.M03 + a.Linear.M21 * m.M13 + a.Linear.M22 * m.M23 + a.Trans.Z * m.M33,

                m.M30, m.M31, m.M32, m.M33);
        }

        /// <summary>
        /// Multiplies a <see cref="M44f"/> and a <see cref="Affine3f"/> (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator *(M44f m, Affine3f a)
        {
            return new M44f(
                m.M00 * a.Linear.M00 + m.M01 * a.Linear.M10 + m.M02 * a.Linear.M20, 
                m.M00 * a.Linear.M01 + m.M01 * a.Linear.M11 + m.M02 * a.Linear.M21, 
                m.M00 * a.Linear.M02 + m.M01 * a.Linear.M12 + m.M02 * a.Linear.M22,
                m.M00 * a.Trans.X + m.M01 * a.Trans.Y + m.M02 * a.Trans.Z + m.M03,

                m.M10 * a.Linear.M00 + m.M11 * a.Linear.M10 + m.M12 * a.Linear.M20, 
                m.M10 * a.Linear.M01 + m.M11 * a.Linear.M11 + m.M12 * a.Linear.M21, 
                m.M10 * a.Linear.M02 + m.M11 * a.Linear.M12 + m.M12 * a.Linear.M22,
                m.M10 * a.Trans.X + m.M11 * a.Trans.Y + m.M12 * a.Trans.Z + m.M13,

                m.M20 * a.Linear.M00 + m.M21 * a.Linear.M10 + m.M22 * a.Linear.M20, 
                m.M20 * a.Linear.M01 + m.M21 * a.Linear.M11 + m.M22 * a.Linear.M21, 
                m.M20 * a.Linear.M02 + m.M21 * a.Linear.M12 + m.M22 * a.Linear.M22,
                m.M20 * a.Trans.X + m.M21 * a.Trans.Y + m.M22 * a.Trans.Z + m.M23,

                m.M30 * a.Linear.M00 + m.M31 * a.Linear.M10 + m.M32 * a.Linear.M20, 
                m.M30 * a.Linear.M01 + m.M31 * a.Linear.M11 + m.M32 * a.Linear.M21, 
                m.M30 * a.Linear.M02 + m.M31 * a.Linear.M12 + m.M32 * a.Linear.M22,
                m.M30 * a.Trans.X + m.M31 * a.Trans.Y + m.M32 * a.Trans.Z + m.M33);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine3f"/> (as a 3x4 matrix) and a <see cref="M33f"/> (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator *(Affine3f a, M33f m)
            => new M34f(a.Linear * m, a.Trans);

        /// <summary>
        /// Multiplies a <see cref="M33f"/> and a <see cref="Affine3f"/> (as a 3x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator *(M33f m, Affine3f a)
            => new M34f(m * a.Linear, m * a.Trans);

        /// <summary>
        /// Multiplies a <see cref="Affine3f"/> (as a 3x4 matrix) and a <see cref="M34f"/> (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator *(Affine3f a, M34f m)
        {
            return new M34f(
                a.Linear.M00 * m.M00 + a.Linear.M01 * m.M10 + a.Linear.M02 * m.M20, 
                a.Linear.M00 * m.M01 + a.Linear.M01 * m.M11 + a.Linear.M02 * m.M21, 
                a.Linear.M00 * m.M02 + a.Linear.M01 * m.M12 + a.Linear.M02 * m.M22,
                a.Trans.X + a.Linear.M00 * m.M03 + a.Linear.M01 * m.M13 + a.Linear.M02 * m.M23,

                a.Linear.M10 * m.M00 + a.Linear.M11 * m.M10 + a.Linear.M12 * m.M20, 
                a.Linear.M10 * m.M01 + a.Linear.M11 * m.M11 + a.Linear.M12 * m.M21, 
                a.Linear.M10 * m.M02 + a.Linear.M11 * m.M12 + a.Linear.M12 * m.M22,
                a.Trans.Y + a.Linear.M10 * m.M03 + a.Linear.M11 * m.M13 + a.Linear.M12 * m.M23,

                a.Linear.M20 * m.M00 + a.Linear.M21 * m.M10 + a.Linear.M22 * m.M20, 
                a.Linear.M20 * m.M01 + a.Linear.M21 * m.M11 + a.Linear.M22 * m.M21, 
                a.Linear.M20 * m.M02 + a.Linear.M21 * m.M12 + a.Linear.M22 * m.M22,
                a.Trans.Z + a.Linear.M20 * m.M03 + a.Linear.M21 * m.M13 + a.Linear.M22 * m.M23);
        }

        /// <summary>
        /// Multiplies a <see cref="M34f"/> and a <see cref="Affine3f"/> (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator *(M34f m, Affine3f a)
        {
            return new M34f(
                m.M00 * a.Linear.M00 + m.M01 * a.Linear.M10 + m.M02 * a.Linear.M20, 
                m.M00 * a.Linear.M01 + m.M01 * a.Linear.M11 + m.M02 * a.Linear.M21, 
                m.M00 * a.Linear.M02 + m.M01 * a.Linear.M12 + m.M02 * a.Linear.M22,
                m.M00 * a.Trans.X + m.M01 * a.Trans.Y + m.M02 * a.Trans.Z + m.M03,

                m.M10 * a.Linear.M00 + m.M11 * a.Linear.M10 + m.M12 * a.Linear.M20, 
                m.M10 * a.Linear.M01 + m.M11 * a.Linear.M11 + m.M12 * a.Linear.M21, 
                m.M10 * a.Linear.M02 + m.M11 * a.Linear.M12 + m.M12 * a.Linear.M22,
                m.M10 * a.Trans.X + m.M11 * a.Trans.Y + m.M12 * a.Trans.Z + m.M13,

                m.M20 * a.Linear.M00 + m.M21 * a.Linear.M10 + m.M22 * a.Linear.M20, 
                m.M20 * a.Linear.M01 + m.M21 * a.Linear.M11 + m.M22 * a.Linear.M21, 
                m.M20 * a.Linear.M02 + m.M21 * a.Linear.M12 + m.M22 * a.Linear.M22,
                m.M20 * a.Trans.X + m.M21 * a.Trans.Y + m.M22 * a.Trans.Z + m.M23);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine3f"/> and a <see cref="Euclidean3f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f operator *(Affine3f a, Euclidean3f e)
            => a * (Affine3f)e;

        /// <summary>
        /// Multiplies a <see cref="Euclidean3f"/> and a <see cref="Affine3f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f operator *(Euclidean3f e, Affine3f a)
            => (Affine3f)e * a;

        /// <summary>
        /// Multiplies a <see cref="Affine3f"/> and a <see cref="Rot3f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f operator *(Affine3f a, Rot3f r)
            => new Affine3f(a.Linear * r, a.Trans);

        /// <summary>
        /// Multiplies a <see cref="Rot3f"/> and a <see cref="Affine3f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f operator *(Rot3f r, Affine3f a)
            => new Affine3f(r * a.Linear, r * a.Trans);

        /// <summary>
        /// Multiplies a <see cref="Affine3f"/> and a <see cref="Scale3f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f operator *(Affine3f a, Scale3f s)
        {
            return new Affine3f(new M33f(
                a.Linear.M00 * s.X, a.Linear.M01 * s.Y, a.Linear.M02 * s.Z, 
                a.Linear.M10 * s.X, a.Linear.M11 * s.Y, a.Linear.M12 * s.Z, 
                a.Linear.M20 * s.X, a.Linear.M21 * s.Y, a.Linear.M22 * s.Z),
                a.Trans);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale3f"/> and a <see cref="Affine3f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f operator *(Scale3f s, Affine3f a)
        {
            return new Affine3f(new M33f(
                a.Linear.M00 * s.X, a.Linear.M01 * s.X, a.Linear.M02 * s.X, 
                a.Linear.M10 * s.Y, a.Linear.M11 * s.Y, a.Linear.M12 * s.Y, 
                a.Linear.M20 * s.Z, a.Linear.M21 * s.Z, a.Linear.M22 * s.Z),
                a.Trans * s.V);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine3f"/> and a <see cref="Shift3f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f operator *(Affine3f a, Shift3f s)
        {
            return new Affine3f(a.Linear, a.Linear * s.V + a.Trans);
        }

        /// <summary>
        /// Multiplies a <see cref="Shift3f"/> and a <see cref="Affine3f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f operator *(Shift3f s, Affine3f a)
        {
            return new Affine3f(a.Linear, a.Trans + s.V);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine3f"/> and a <see cref="Similarity3f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f operator *(Affine3f a, Similarity3f s)
            => a * (Affine3f)s;

        /// <summary>
        /// Multiplies a <see cref="Similarity3f"/> and a <see cref="Affine3f"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f operator *(Similarity3f s, Affine3f a)
            => (Affine3f)s * a;

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Affine3f"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Affine3f a0, Affine3f a1)
            => (a0.Linear == a1.Linear) && (a0.Trans == a1.Trans); 

        /// <summary>
        /// Checks whether two <see cref="Affine3f"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Affine3f a0, Affine3f a1)
            => (a0.Linear != a1.Linear) || (a0.Trans != a1.Trans);

        #endregion

        #region Static Creators

        /// <summary>
        /// Creates an affine transformation from a 3x4 matrix.
        /// The left 3x3 submatrix of <paramref name="matrix"/> must be invertible.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f FromM34f(M34f matrix, float epsilon = 1e-5f)
        {
            var linear = (M33f)matrix;
            var trans = new V3f(matrix.M03, matrix.M13, matrix.M23);

            if (linear.Determinant.IsTiny(epsilon))
                throw new ArgumentException("Matrix must be invertible");

            return new Affine3f(linear, trans);
        }

        /// <summary>
        /// Creates an affine transformation from a 4x4 matrix.
        /// The matrix <paramref name="m"/> has to be homogeneous and must not contain perspective components and its upper left 3x3 submatrix must be invertible.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f FromM44f(M44f m, float epsilon = 1e-5f)
        {
            if (!(m.M30.IsTiny(epsilon) && m.M31.IsTiny(epsilon) && m.M32.IsTiny(epsilon)))
                throw new ArgumentException("Matrix contains perspective components.");

            if (m.M33.IsTiny(epsilon))
                throw new ArgumentException("Matrix is not homogeneous.");

            var linear = ((M33f)m) / m.M33;
            var trans = new V3f(m.M03, m.M13, m.M23) / m.M33;

            if (linear.Determinant.IsTiny(epsilon))
                throw new ArgumentException("Matrix must be invertible");

            return new Affine3f(linear, trans);
        }

        /// <summary>
        /// Creates an affine transformation from a <see cref="Trafo3f"/>.
        /// The transformation <paramref name="trafo"/> must represent a valid affine transformation (e.g. it does not contain perspective components).
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f FromTrafo3f(Trafo3f trafo, float epsilon = 1e-5f)
            => FromM44f(trafo.Forward, epsilon);

        /// <summary>
        /// Creates an affine transformation with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f Translation(float tX, float tY, float tZ)
            => new Affine3f(M33f.Identity, tX, tY, tZ);

        /// <summary>
        /// Creates an affine transformation with the translational component given a <see cref="V3f"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f Translation(V3f vector)
            => new Affine3f(M33f.Identity, vector);

        /// <summary>
        /// Creates an affine transformation with the translational component given a <see cref="Shift3f"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f Translation(Shift3f shift)
            => new Affine3f(M33f.Identity, shift.V);

        /// <summary>
        /// Creates a scaling transformation using a uniform scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f Scale(float scaleFactor)
            => new Affine3f(M33f.Scale(scaleFactor, scaleFactor, scaleFactor));

        /// <summary>
        /// Creates a scaling transformation using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f Scale(float sX, float sY, float sZ)
            => new Affine3f(M33f.Scale(sX, sY, sZ));

        /// <summary>
        /// Creates a scaling transformation using a <see cref="V3f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f Scale(V3f scaleFactors)
            => new Affine3f(M33f.Scale(scaleFactors));

        /// <summary>
        /// Creates a scaling transformation using a <see cref="Scale3f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f Scale(Scale3f scale)
            => new Affine3f(M33f.Scale(scale));

        /// <summary>
        /// Creates a rotation transformation from a <see cref="Rot3f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f Rotation(Rot3f rot)
            => new Affine3f(M33f.Rotation(rot));

        /// <summary>
        /// Creates a rotation transformation from an axis vector and an angle in radians.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f Rotation(V3f normalizedAxis, float angleRadians)
            => new Affine3f(M33f.Rotation(normalizedAxis, angleRadians));

        /// <summary>
        /// Creates a rotation transformation from roll (X), pitch (Y), and yaw (Z). 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f RotationEuler(float rollInRadians, float pitchInRadians, float yawInRadians)
            => new Affine3f(M33f.RotationEuler(rollInRadians, pitchInRadians, yawInRadians));

        /// <summary>
        /// Creates a rotation transformation from euler angles as a vector [roll, pitch, yaw].
        /// The rotation order is yaw (Z), pitch (Y), roll (X).
        /// <param name="rollPitchYawInRadians">[roll, pitch, yaw] in radians</param>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f RotationEuler(V3f rollPitchYawInRadians)
            => RotationEuler(rollPitchYawInRadians.X, rollPitchYawInRadians.Y, rollPitchYawInRadians.Z);

        /// <summary>
        /// Creates a rotation transformation by <paramref name="angleRadians"/> radians around the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f RotationX(float angleRadians)
            => new Affine3f(M33f.RotationX(angleRadians));

        /// <summary>
        /// Creates a rotation transformation by <paramref name="angleRadians"/> radians around the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f RotationY(float angleRadians)
            => new Affine3f(M33f.RotationY(angleRadians));

        /// <summary>
        /// Creates a rotation transformation by <paramref name="angleRadians"/> radians around the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f RotationZ(float angleRadians)
            => new Affine3f(M33f.RotationZ(angleRadians));

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M34f(Affine3f a)
            => new M34f(a.Linear, a.Trans);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33f(Affine3f a)
            => a.Linear;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44f(Affine3f a)
            => new M44f((M34f)a);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Trafo3f(Affine3f a)
        {
            Debug.Assert(a.Linear.Invertible);
            var t = (M44f)a;
            return new Trafo3f(t, t.Inverse);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine3d(Affine3f a)
            => new Affine3d((M33d)a.Linear, (V3d)a.Trans);

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Linear, Trans);
        }

        public override bool Equals(object other)
        {
            return (other is Affine3f) ? (this == (Affine3f)other) : false;
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}]", Linear, Trans);
        }

        public static Affine3f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Affine3f(M33f.Parse(x[0]), V3f.Parse(x[1]));
        }

        #endregion
    }

    public static partial class Affine
    {
        #region Invert

        /// <summary>
        /// Returns the inverse of an <see cref="Affine3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3f Inverse(Affine3f a)
            => a.Inverse;

        /// <summary>
        /// Inverts the given affine transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Affine3f a)
        {
            Debug.Assert(a.Linear.Invertible);
            a.Linear.Invert();
            a.Trans = -a.Linear * a.Trans;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V4f"/> by an <see cref="Affine3f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Transform(this Affine3f a, V4f v)
            => a * v;

        /// <summary>
        /// Transforms a <see cref="V3f"/> position vector (v.W is presumed 1) by an <see cref="Affine3f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f TransformPos(this Affine3f a, V3f v)
        {
            return new V3f(
                a.Linear.M00 * v.X + a.Linear.M01 * v.Y + a.Linear.M02 * v.Z + a.Trans.X, 
                a.Linear.M10 * v.X + a.Linear.M11 * v.Y + a.Linear.M12 * v.Z + a.Trans.Y, 
                a.Linear.M20 * v.X + a.Linear.M21 * v.Y + a.Linear.M22 * v.Z + a.Trans.Z);
        }

        /// <summary>
        /// Transforms a <see cref="V3f"/> direction vector (v.W is presumed 0) by an <see cref="Affine3f"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f TransformDir(this Affine3f a, V3f v)
        {
            return new V3f(
                a.Linear.M00 * v.X + a.Linear.M01 * v.Y + a.Linear.M02 * v.Z, 
                a.Linear.M10 * v.X + a.Linear.M11 * v.Y + a.Linear.M12 * v.Z, 
                a.Linear.M20 * v.X + a.Linear.M21 * v.Y + a.Linear.M22 * v.Z);
        }

        /// <summary>
        /// Transforms a <see cref="V4f"/> by the transpose of an <see cref="Affine3f"/> (as a 4x4 matrix).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f TransposedTransform(this Affine3f a, V4f v)
        {
            return new V4f(
                v.X * a.Linear.M00 + v.Y * a.Linear.M10 + v.Z * a.Linear.M20, 
                v.X * a.Linear.M01 + v.Y * a.Linear.M11 + v.Z * a.Linear.M21, 
                v.X * a.Linear.M02 + v.Y * a.Linear.M12 + v.Z * a.Linear.M22,
                v.X * a.Trans.X + v.Y * a.Trans.Y + v.Z * a.Trans.Z + v.W);
        }

        /// <summary>
        /// Transforms a <see cref="V3f"/> by the transpose of an <see cref="Affine3f"/> (as a 4x4 matrix).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f TransposedTransform(this Affine3f a, V3f v)
        {
            return new V3f(
                v.X * a.Linear.M00 + v.Y * a.Linear.M10 + v.Z * a.Linear.M20, 
                v.X * a.Linear.M01 + v.Y * a.Linear.M11 + v.Z * a.Linear.M21, 
                v.X * a.Linear.M02 + v.Y * a.Linear.M12 + v.Z * a.Linear.M22);
        }

        /// <summary>
        /// Transforms a <see cref="V3f"/> position vector (v.W is presumed 1) by the transpose of an <see cref="Affine3f"/> (as a 4x4 matrix).
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f TransposedTransformPosProj(this Affine3f a, V3f v)
        {
            var s = v.X * a.Trans.X + v.Y * a.Trans.Y + v.Z * a.Trans.Z + 1;
            return TransposedTransform(a, v) * (1 / s);
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Affine3f a0, Affine3f a1)
        {
            return ApproximateEquals(a0, a1, Constant<float>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Affine3f a0, Affine3f a1, float tolerance)
        {
            return ApproximateEquals(a0.Linear, a1.Linear, tolerance) && ApproximateEquals(a0.Trans, a1.Trans, tolerance);
        }

        #endregion
    }

    #endregion

    #region Affine2d

    /// <summary>
    /// Struct to represent an affine transformation in 2-dimensional space. It consists of
    /// a linear tranformation (invertible 2x2 matrix) and a translational component (2d vector).
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public struct Affine2d : IValidity
    {
        [DataMember]
        public M22d Linear;
        [DataMember]
        public V2d Trans;

        #region Constructors

        /// <summary>
        /// Constructs a copy of an <see cref="Affine2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine2d(Affine2d affine)
        {
            Linear = affine.Linear;
            Trans = affine.Trans;
        }

        /// <summary>
        /// Constructs an affine transformation from a linear map and a translation.
        /// The matrix <paramref name="linear"/> must be invertible.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine2d(M22d linear, V2d translation)
        {
            Debug.Assert(linear.Invertible);
            Linear = linear;
            Trans = translation;
        }

        /// <summary>
        /// Constructs an affine transformation from a linear map and a translation.
        /// The matrix <paramref name="linear"/> must be invertible.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine2d(M22d linear, double tX, double tY)
        {
            Debug.Assert(linear.Invertible);
            Linear = linear;
            Trans = new V2d(tX, tY);
        }

        /// <summary>
        /// Constructs an affine transformation from a linear map.
        /// The matrix <paramref name="linear"/> must be invertible.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine2d(M22d linear)
        {
            Debug.Assert(linear.Invertible);
            Linear = linear;
            Trans = V2d.Zero;
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity transformation.
        /// </summary>
        public static Affine2d Identity
        { 
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Affine2d(M22d.Identity);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets if this affine transformation is valid, i.e. if the linear map is invertible.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Linear.Invertible;
        }

        /// <summary>
        /// Gets if this affine transformation is invalid, i.e. if the linear map is singular.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => !IsValid;
        }

        /// <summary>
        /// Gets the inverse of this affine transformation.
        /// </summary>
        public Affine2d Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var rs = new Affine2d(this);
                rs.Invert();
                return rs;
            }
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Multiplies two affine transformations.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d operator *(Affine2d a, Affine2d b)
        {
            return new Affine2d(a.Linear * b.Linear, a.Linear * b.Trans + a.Trans);
        }

        /// <summary>
        /// Transforms a <see cref="V3d"/> vector by an affine transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d operator *(Affine2d a, V3d v)
        {
            return new V3d(
                a.Linear.M00 * v.X + a.Linear.M01 * v.Y + a.Trans.X * v.Z, 
                a.Linear.M10 * v.X + a.Linear.M11 * v.Y + a.Trans.Y * v.Z, 
                v.Z);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine2d"/> (as a 3x3 matrix) and a <see cref="M33d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator *(Affine2d a, M33d m)
        {
            return new M33d(
                a.Linear.M00 * m.M00 + a.Linear.M01 * m.M10 + a.Trans.X * m.M20, 
                a.Linear.M00 * m.M01 + a.Linear.M01 * m.M11 + a.Trans.X * m.M21, 
                a.Linear.M00 * m.M02 + a.Linear.M01 * m.M12 + a.Trans.X * m.M22,

                a.Linear.M10 * m.M00 + a.Linear.M11 * m.M10 + a.Trans.Y * m.M20, 
                a.Linear.M10 * m.M01 + a.Linear.M11 * m.M11 + a.Trans.Y * m.M21, 
                a.Linear.M10 * m.M02 + a.Linear.M11 * m.M12 + a.Trans.Y * m.M22,

                m.M20, m.M21, m.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="M33d"/> and a <see cref="Affine2d"/> (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator *(M33d m, Affine2d a)
        {
            return new M33d(
                m.M00 * a.Linear.M00 + m.M01 * a.Linear.M10, 
                m.M00 * a.Linear.M01 + m.M01 * a.Linear.M11,
                m.M00 * a.Trans.X + m.M01 * a.Trans.Y + m.M02,

                m.M10 * a.Linear.M00 + m.M11 * a.Linear.M10, 
                m.M10 * a.Linear.M01 + m.M11 * a.Linear.M11,
                m.M10 * a.Trans.X + m.M11 * a.Trans.Y + m.M12,

                m.M20 * a.Linear.M00 + m.M21 * a.Linear.M10, 
                m.M20 * a.Linear.M01 + m.M21 * a.Linear.M11,
                m.M20 * a.Trans.X + m.M21 * a.Trans.Y + m.M22);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine2d"/> (as a 2x3 matrix) and a <see cref="M22d"/> (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator *(Affine2d a, M22d m)
            => new M23d(a.Linear * m, a.Trans);

        /// <summary>
        /// Multiplies a <see cref="M22d"/> and a <see cref="Affine2d"/> (as a 2x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator *(M22d m, Affine2d a)
            => new M23d(m * a.Linear, m * a.Trans);

        /// <summary>
        /// Multiplies a <see cref="Affine2d"/> (as a 2x3 matrix) and a <see cref="M23d"/> (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator *(Affine2d a, M23d m)
        {
            return new M23d(
                a.Linear.M00 * m.M00 + a.Linear.M01 * m.M10, 
                a.Linear.M00 * m.M01 + a.Linear.M01 * m.M11,
                a.Trans.X + a.Linear.M00 * m.M02 + a.Linear.M01 * m.M12,

                a.Linear.M10 * m.M00 + a.Linear.M11 * m.M10, 
                a.Linear.M10 * m.M01 + a.Linear.M11 * m.M11,
                a.Trans.Y + a.Linear.M10 * m.M02 + a.Linear.M11 * m.M12);
        }

        /// <summary>
        /// Multiplies a <see cref="M23d"/> and a <see cref="Affine2d"/> (as a 3x3 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator *(M23d m, Affine2d a)
        {
            return new M23d(
                m.M00 * a.Linear.M00 + m.M01 * a.Linear.M10, 
                m.M00 * a.Linear.M01 + m.M01 * a.Linear.M11,
                m.M00 * a.Trans.X + m.M01 * a.Trans.Y + m.M02,

                m.M10 * a.Linear.M00 + m.M11 * a.Linear.M10, 
                m.M10 * a.Linear.M01 + m.M11 * a.Linear.M11,
                m.M10 * a.Trans.X + m.M11 * a.Trans.Y + m.M12);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine2d"/> and a <see cref="Euclidean2d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d operator *(Affine2d a, Euclidean2d e)
            => a * (Affine2d)e;

        /// <summary>
        /// Multiplies a <see cref="Euclidean2d"/> and a <see cref="Affine2d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d operator *(Euclidean2d e, Affine2d a)
            => (Affine2d)e * a;

        /// <summary>
        /// Multiplies a <see cref="Affine2d"/> and a <see cref="Rot2d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d operator *(Affine2d a, Rot2d r)
            => new Affine2d(a.Linear * r, a.Trans);

        /// <summary>
        /// Multiplies a <see cref="Rot2d"/> and a <see cref="Affine2d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d operator *(Rot2d r, Affine2d a)
            => new Affine2d(r * a.Linear, r * a.Trans);

        /// <summary>
        /// Multiplies a <see cref="Affine2d"/> and a <see cref="Scale2d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d operator *(Affine2d a, Scale2d s)
        {
            return new Affine2d(new M22d(
                a.Linear.M00 * s.X, a.Linear.M01 * s.Y, 
                a.Linear.M10 * s.X, a.Linear.M11 * s.Y),
                a.Trans);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale2d"/> and a <see cref="Affine2d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d operator *(Scale2d s, Affine2d a)
        {
            return new Affine2d(new M22d(
                a.Linear.M00 * s.X, a.Linear.M01 * s.X, 
                a.Linear.M10 * s.Y, a.Linear.M11 * s.Y),
                a.Trans * s.V);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine2d"/> and a <see cref="Shift2d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d operator *(Affine2d a, Shift2d s)
        {
            return new Affine2d(a.Linear, a.Linear * s.V + a.Trans);
        }

        /// <summary>
        /// Multiplies a <see cref="Shift2d"/> and a <see cref="Affine2d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d operator *(Shift2d s, Affine2d a)
        {
            return new Affine2d(a.Linear, a.Trans + s.V);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine2d"/> and a <see cref="Similarity2d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d operator *(Affine2d a, Similarity2d s)
            => a * (Affine2d)s;

        /// <summary>
        /// Multiplies a <see cref="Similarity2d"/> and a <see cref="Affine2d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d operator *(Similarity2d s, Affine2d a)
            => (Affine2d)s * a;

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Affine2d"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Affine2d a0, Affine2d a1)
            => (a0.Linear == a1.Linear) && (a0.Trans == a1.Trans); 

        /// <summary>
        /// Checks whether two <see cref="Affine2d"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Affine2d a0, Affine2d a1)
            => (a0.Linear != a1.Linear) || (a0.Trans != a1.Trans);

        #endregion

        #region Static Creators

        /// <summary>
        /// Creates an affine transformation from a 2x3 matrix.
        /// The left 2x2 submatrix of <paramref name="matrix"/> must be invertible.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d FromM23d(M23d matrix, double epsilon = 1e-12)
        {
            var linear = (M22d)matrix;
            var trans = new V2d(matrix.M02, matrix.M12);

            if (linear.Determinant.IsTiny(epsilon))
                throw new ArgumentException("Matrix must be invertible");

            return new Affine2d(linear, trans);
        }

        /// <summary>
        /// Creates an affine transformation from a 3x3 matrix.
        /// The matrix <paramref name="m"/> has to be homogeneous and must not contain perspective components and its upper left 2x2 submatrix must be invertible.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d FromM33d(M33d m, double epsilon = 1e-12)
        {
            if (!(m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon)))
                throw new ArgumentException("Matrix contains perspective components.");

            if (m.M22.IsTiny(epsilon))
                throw new ArgumentException("Matrix is not homogeneous.");

            var linear = ((M22d)m) / m.M22;
            var trans = new V2d(m.M02, m.M12) / m.M22;

            if (linear.Determinant.IsTiny(epsilon))
                throw new ArgumentException("Matrix must be invertible");

            return new Affine2d(linear, trans);
        }

        /// <summary>
        /// Creates an affine transformation from a <see cref="Trafo2d"/>.
        /// The transformation <paramref name="trafo"/> must represent a valid affine transformation (e.g. it does not contain perspective components).
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d FromTrafo2d(Trafo2d trafo, double epsilon = 1e-12)
            => FromM33d(trafo.Forward, epsilon);

        /// <summary>
        /// Creates an affine transformation with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d Translation(double tX, double tY)
            => new Affine2d(M22d.Identity, tX, tY);

        /// <summary>
        /// Creates an affine transformation with the translational component given a <see cref="V2d"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d Translation(V2d vector)
            => new Affine2d(M22d.Identity, vector);

        /// <summary>
        /// Creates an affine transformation with the translational component given a <see cref="Shift2d"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d Translation(Shift2d shift)
            => new Affine2d(M22d.Identity, shift.V);

        /// <summary>
        /// Creates a scaling transformation using a uniform scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d Scale(double scaleFactor)
            => new Affine2d(M22d.Scale(scaleFactor, scaleFactor));

        /// <summary>
        /// Creates a scaling transformation using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d Scale(double sX, double sY)
            => new Affine2d(M22d.Scale(sX, sY));

        /// <summary>
        /// Creates a scaling transformation using a <see cref="V2d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d Scale(V2d scaleFactors)
            => new Affine2d(M22d.Scale(scaleFactors));

        /// <summary>
        /// Creates a scaling transformation using a <see cref="Scale2d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d Scale(Scale2d scale)
            => new Affine2d(M22d.Scale(scale));

        /// <summary>
        /// Creates a rotation transformation from a <see cref="Rot2d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d Rotation(Rot2d rot)
            => new Affine2d(M22d.Rotation(rot));

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M23d(Affine2d a)
            => new M23d(a.Linear, a.Trans);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M22d(Affine2d a)
            => a.Linear;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33d(Affine2d a)
            => new M33d((M23d)a);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Trafo2d(Affine2d a)
        {
            Debug.Assert(a.Linear.Invertible);
            var t = (M33d)a;
            return new Trafo2d(t, t.Inverse);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine2f(Affine2d a)
            => new Affine2f((M22f)a.Linear, (V2f)a.Trans);

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Linear, Trans);
        }

        public override bool Equals(object other)
        {
            return (other is Affine2d) ? (this == (Affine2d)other) : false;
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}]", Linear, Trans);
        }

        public static Affine2d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Affine2d(M22d.Parse(x[0]), V2d.Parse(x[1]));
        }

        #endregion
    }

    public static partial class Affine
    {
        #region Invert

        /// <summary>
        /// Returns the inverse of an <see cref="Affine2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine2d Inverse(Affine2d a)
            => a.Inverse;

        /// <summary>
        /// Inverts the given affine transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Affine2d a)
        {
            Debug.Assert(a.Linear.Invertible);
            a.Linear.Invert();
            a.Trans = -a.Linear * a.Trans;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V3d"/> by an <see cref="Affine2d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this Affine2d a, V3d v)
            => a * v;

        /// <summary>
        /// Transforms a <see cref="V2d"/> position vector (v.Z is presumed 1) by an <see cref="Affine2d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d TransformPos(this Affine2d a, V2d v)
        {
            return new V2d(
                a.Linear.M00 * v.X + a.Linear.M01 * v.Y + a.Trans.X, 
                a.Linear.M10 * v.X + a.Linear.M11 * v.Y + a.Trans.Y);
        }

        /// <summary>
        /// Transforms a <see cref="V2d"/> direction vector (v.Z is presumed 0) by an <see cref="Affine2d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d TransformDir(this Affine2d a, V2d v)
        {
            return new V2d(
                a.Linear.M00 * v.X + a.Linear.M01 * v.Y, 
                a.Linear.M10 * v.X + a.Linear.M11 * v.Y);
        }

        /// <summary>
        /// Transforms a <see cref="V3d"/> by the transpose of an <see cref="Affine2d"/> (as a 3x3 matrix).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d TransposedTransform(this Affine2d a, V3d v)
        {
            return new V3d(
                v.X * a.Linear.M00 + v.Y * a.Linear.M10, 
                v.X * a.Linear.M01 + v.Y * a.Linear.M11,
                v.X * a.Trans.X + v.Y * a.Trans.Y + v.Z);
        }

        /// <summary>
        /// Transforms a <see cref="V2d"/> by the transpose of an <see cref="Affine2d"/> (as a 3x3 matrix).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d TransposedTransform(this Affine2d a, V2d v)
        {
            return new V2d(
                v.X * a.Linear.M00 + v.Y * a.Linear.M10, 
                v.X * a.Linear.M01 + v.Y * a.Linear.M11);
        }

        /// <summary>
        /// Transforms a <see cref="V2d"/> position vector (v.Z is presumed 1) by the transpose of an <see cref="Affine2d"/> (as a 3x3 matrix).
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d TransposedTransformPosProj(this Affine2d a, V2d v)
        {
            var s = v.X * a.Trans.X + v.Y * a.Trans.Y + 1;
            return TransposedTransform(a, v) * (1 / s);
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Affine2d a0, Affine2d a1)
        {
            return ApproximateEquals(a0, a1, Constant<double>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Affine2d a0, Affine2d a1, double tolerance)
        {
            return ApproximateEquals(a0.Linear, a1.Linear, tolerance) && ApproximateEquals(a0.Trans, a1.Trans, tolerance);
        }

        #endregion
    }

    #endregion

    #region Affine3d

    /// <summary>
    /// Struct to represent an affine transformation in 3-dimensional space. It consists of
    /// a linear tranformation (invertible 3x3 matrix) and a translational component (3d vector).
    /// </summary>
    [DataContract]
    [StructLayout(LayoutKind.Sequential)]
    public struct Affine3d : IValidity
    {
        [DataMember]
        public M33d Linear;
        [DataMember]
        public V3d Trans;

        #region Constructors

        /// <summary>
        /// Constructs a copy of an <see cref="Affine3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine3d(Affine3d affine)
        {
            Linear = affine.Linear;
            Trans = affine.Trans;
        }

        /// <summary>
        /// Constructs an affine transformation from a linear map and a translation.
        /// The matrix <paramref name="linear"/> must be invertible.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine3d(M33d linear, V3d translation)
        {
            Debug.Assert(linear.Invertible);
            Linear = linear;
            Trans = translation;
        }

        /// <summary>
        /// Constructs an affine transformation from a linear map and a translation.
        /// The matrix <paramref name="linear"/> must be invertible.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine3d(M33d linear, double tX, double tY, double tZ)
        {
            Debug.Assert(linear.Invertible);
            Linear = linear;
            Trans = new V3d(tX, tY, tZ);
        }

        /// <summary>
        /// Constructs an affine transformation from a linear map.
        /// The matrix <paramref name="linear"/> must be invertible.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Affine3d(M33d linear)
        {
            Debug.Assert(linear.Invertible);
            Linear = linear;
            Trans = V3d.Zero;
        }

        #endregion

        #region Constants

        /// <summary>
        /// Gets the identity transformation.
        /// </summary>
        public static Affine3d Identity
        { 
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Affine3d(M33d.Identity);
        }

        #endregion

        #region Properties

        /// <summary>
        /// Gets if this affine transformation is valid, i.e. if the linear map is invertible.
        /// </summary>
        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Linear.Invertible;
        }

        /// <summary>
        /// Gets if this affine transformation is invalid, i.e. if the linear map is singular.
        /// </summary>
        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => !IsValid;
        }

        /// <summary>
        /// Gets the inverse of this affine transformation.
        /// </summary>
        public Affine3d Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var rs = new Affine3d(this);
                rs.Invert();
                return rs;
            }
        }

        #endregion

        #region Arithmetic Operators

        /// <summary>
        /// Multiplies two affine transformations.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d operator *(Affine3d a, Affine3d b)
        {
            return new Affine3d(a.Linear * b.Linear, a.Linear * b.Trans + a.Trans);
        }

        /// <summary>
        /// Transforms a <see cref="V4d"/> vector by an affine transformation.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d operator *(Affine3d a, V4d v)
        {
            return new V4d(
                a.Linear.M00 * v.X + a.Linear.M01 * v.Y + a.Linear.M02 * v.Z + a.Trans.X * v.W, 
                a.Linear.M10 * v.X + a.Linear.M11 * v.Y + a.Linear.M12 * v.Z + a.Trans.Y * v.W, 
                a.Linear.M20 * v.X + a.Linear.M21 * v.Y + a.Linear.M22 * v.Z + a.Trans.Z * v.W, 
                v.W);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine3d"/> (as a 4x4 matrix) and a <see cref="M44d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator *(Affine3d a, M44d m)
        {
            return new M44d(
                a.Linear.M00 * m.M00 + a.Linear.M01 * m.M10 + a.Linear.M02 * m.M20 + a.Trans.X * m.M30, 
                a.Linear.M00 * m.M01 + a.Linear.M01 * m.M11 + a.Linear.M02 * m.M21 + a.Trans.X * m.M31, 
                a.Linear.M00 * m.M02 + a.Linear.M01 * m.M12 + a.Linear.M02 * m.M22 + a.Trans.X * m.M32, 
                a.Linear.M00 * m.M03 + a.Linear.M01 * m.M13 + a.Linear.M02 * m.M23 + a.Trans.X * m.M33,

                a.Linear.M10 * m.M00 + a.Linear.M11 * m.M10 + a.Linear.M12 * m.M20 + a.Trans.Y * m.M30, 
                a.Linear.M10 * m.M01 + a.Linear.M11 * m.M11 + a.Linear.M12 * m.M21 + a.Trans.Y * m.M31, 
                a.Linear.M10 * m.M02 + a.Linear.M11 * m.M12 + a.Linear.M12 * m.M22 + a.Trans.Y * m.M32, 
                a.Linear.M10 * m.M03 + a.Linear.M11 * m.M13 + a.Linear.M12 * m.M23 + a.Trans.Y * m.M33,

                a.Linear.M20 * m.M00 + a.Linear.M21 * m.M10 + a.Linear.M22 * m.M20 + a.Trans.Z * m.M30, 
                a.Linear.M20 * m.M01 + a.Linear.M21 * m.M11 + a.Linear.M22 * m.M21 + a.Trans.Z * m.M31, 
                a.Linear.M20 * m.M02 + a.Linear.M21 * m.M12 + a.Linear.M22 * m.M22 + a.Trans.Z * m.M32, 
                a.Linear.M20 * m.M03 + a.Linear.M21 * m.M13 + a.Linear.M22 * m.M23 + a.Trans.Z * m.M33,

                m.M30, m.M31, m.M32, m.M33);
        }

        /// <summary>
        /// Multiplies a <see cref="M44d"/> and a <see cref="Affine3d"/> (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator *(M44d m, Affine3d a)
        {
            return new M44d(
                m.M00 * a.Linear.M00 + m.M01 * a.Linear.M10 + m.M02 * a.Linear.M20, 
                m.M00 * a.Linear.M01 + m.M01 * a.Linear.M11 + m.M02 * a.Linear.M21, 
                m.M00 * a.Linear.M02 + m.M01 * a.Linear.M12 + m.M02 * a.Linear.M22,
                m.M00 * a.Trans.X + m.M01 * a.Trans.Y + m.M02 * a.Trans.Z + m.M03,

                m.M10 * a.Linear.M00 + m.M11 * a.Linear.M10 + m.M12 * a.Linear.M20, 
                m.M10 * a.Linear.M01 + m.M11 * a.Linear.M11 + m.M12 * a.Linear.M21, 
                m.M10 * a.Linear.M02 + m.M11 * a.Linear.M12 + m.M12 * a.Linear.M22,
                m.M10 * a.Trans.X + m.M11 * a.Trans.Y + m.M12 * a.Trans.Z + m.M13,

                m.M20 * a.Linear.M00 + m.M21 * a.Linear.M10 + m.M22 * a.Linear.M20, 
                m.M20 * a.Linear.M01 + m.M21 * a.Linear.M11 + m.M22 * a.Linear.M21, 
                m.M20 * a.Linear.M02 + m.M21 * a.Linear.M12 + m.M22 * a.Linear.M22,
                m.M20 * a.Trans.X + m.M21 * a.Trans.Y + m.M22 * a.Trans.Z + m.M23,

                m.M30 * a.Linear.M00 + m.M31 * a.Linear.M10 + m.M32 * a.Linear.M20, 
                m.M30 * a.Linear.M01 + m.M31 * a.Linear.M11 + m.M32 * a.Linear.M21, 
                m.M30 * a.Linear.M02 + m.M31 * a.Linear.M12 + m.M32 * a.Linear.M22,
                m.M30 * a.Trans.X + m.M31 * a.Trans.Y + m.M32 * a.Trans.Z + m.M33);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine3d"/> (as a 3x4 matrix) and a <see cref="M33d"/> (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator *(Affine3d a, M33d m)
            => new M34d(a.Linear * m, a.Trans);

        /// <summary>
        /// Multiplies a <see cref="M33d"/> and a <see cref="Affine3d"/> (as a 3x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator *(M33d m, Affine3d a)
            => new M34d(m * a.Linear, m * a.Trans);

        /// <summary>
        /// Multiplies a <see cref="Affine3d"/> (as a 3x4 matrix) and a <see cref="M34d"/> (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator *(Affine3d a, M34d m)
        {
            return new M34d(
                a.Linear.M00 * m.M00 + a.Linear.M01 * m.M10 + a.Linear.M02 * m.M20, 
                a.Linear.M00 * m.M01 + a.Linear.M01 * m.M11 + a.Linear.M02 * m.M21, 
                a.Linear.M00 * m.M02 + a.Linear.M01 * m.M12 + a.Linear.M02 * m.M22,
                a.Trans.X + a.Linear.M00 * m.M03 + a.Linear.M01 * m.M13 + a.Linear.M02 * m.M23,

                a.Linear.M10 * m.M00 + a.Linear.M11 * m.M10 + a.Linear.M12 * m.M20, 
                a.Linear.M10 * m.M01 + a.Linear.M11 * m.M11 + a.Linear.M12 * m.M21, 
                a.Linear.M10 * m.M02 + a.Linear.M11 * m.M12 + a.Linear.M12 * m.M22,
                a.Trans.Y + a.Linear.M10 * m.M03 + a.Linear.M11 * m.M13 + a.Linear.M12 * m.M23,

                a.Linear.M20 * m.M00 + a.Linear.M21 * m.M10 + a.Linear.M22 * m.M20, 
                a.Linear.M20 * m.M01 + a.Linear.M21 * m.M11 + a.Linear.M22 * m.M21, 
                a.Linear.M20 * m.M02 + a.Linear.M21 * m.M12 + a.Linear.M22 * m.M22,
                a.Trans.Z + a.Linear.M20 * m.M03 + a.Linear.M21 * m.M13 + a.Linear.M22 * m.M23);
        }

        /// <summary>
        /// Multiplies a <see cref="M34d"/> and a <see cref="Affine3d"/> (as a 4x4 matrix).
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator *(M34d m, Affine3d a)
        {
            return new M34d(
                m.M00 * a.Linear.M00 + m.M01 * a.Linear.M10 + m.M02 * a.Linear.M20, 
                m.M00 * a.Linear.M01 + m.M01 * a.Linear.M11 + m.M02 * a.Linear.M21, 
                m.M00 * a.Linear.M02 + m.M01 * a.Linear.M12 + m.M02 * a.Linear.M22,
                m.M00 * a.Trans.X + m.M01 * a.Trans.Y + m.M02 * a.Trans.Z + m.M03,

                m.M10 * a.Linear.M00 + m.M11 * a.Linear.M10 + m.M12 * a.Linear.M20, 
                m.M10 * a.Linear.M01 + m.M11 * a.Linear.M11 + m.M12 * a.Linear.M21, 
                m.M10 * a.Linear.M02 + m.M11 * a.Linear.M12 + m.M12 * a.Linear.M22,
                m.M10 * a.Trans.X + m.M11 * a.Trans.Y + m.M12 * a.Trans.Z + m.M13,

                m.M20 * a.Linear.M00 + m.M21 * a.Linear.M10 + m.M22 * a.Linear.M20, 
                m.M20 * a.Linear.M01 + m.M21 * a.Linear.M11 + m.M22 * a.Linear.M21, 
                m.M20 * a.Linear.M02 + m.M21 * a.Linear.M12 + m.M22 * a.Linear.M22,
                m.M20 * a.Trans.X + m.M21 * a.Trans.Y + m.M22 * a.Trans.Z + m.M23);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine3d"/> and a <see cref="Euclidean3d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d operator *(Affine3d a, Euclidean3d e)
            => a * (Affine3d)e;

        /// <summary>
        /// Multiplies a <see cref="Euclidean3d"/> and a <see cref="Affine3d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d operator *(Euclidean3d e, Affine3d a)
            => (Affine3d)e * a;

        /// <summary>
        /// Multiplies a <see cref="Affine3d"/> and a <see cref="Rot3d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d operator *(Affine3d a, Rot3d r)
            => new Affine3d(a.Linear * r, a.Trans);

        /// <summary>
        /// Multiplies a <see cref="Rot3d"/> and a <see cref="Affine3d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d operator *(Rot3d r, Affine3d a)
            => new Affine3d(r * a.Linear, r * a.Trans);

        /// <summary>
        /// Multiplies a <see cref="Affine3d"/> and a <see cref="Scale3d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d operator *(Affine3d a, Scale3d s)
        {
            return new Affine3d(new M33d(
                a.Linear.M00 * s.X, a.Linear.M01 * s.Y, a.Linear.M02 * s.Z, 
                a.Linear.M10 * s.X, a.Linear.M11 * s.Y, a.Linear.M12 * s.Z, 
                a.Linear.M20 * s.X, a.Linear.M21 * s.Y, a.Linear.M22 * s.Z),
                a.Trans);
        }

        /// <summary>
        /// Multiplies a <see cref="Scale3d"/> and a <see cref="Affine3d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d operator *(Scale3d s, Affine3d a)
        {
            return new Affine3d(new M33d(
                a.Linear.M00 * s.X, a.Linear.M01 * s.X, a.Linear.M02 * s.X, 
                a.Linear.M10 * s.Y, a.Linear.M11 * s.Y, a.Linear.M12 * s.Y, 
                a.Linear.M20 * s.Z, a.Linear.M21 * s.Z, a.Linear.M22 * s.Z),
                a.Trans * s.V);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine3d"/> and a <see cref="Shift3d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d operator *(Affine3d a, Shift3d s)
        {
            return new Affine3d(a.Linear, a.Linear * s.V + a.Trans);
        }

        /// <summary>
        /// Multiplies a <see cref="Shift3d"/> and a <see cref="Affine3d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d operator *(Shift3d s, Affine3d a)
        {
            return new Affine3d(a.Linear, a.Trans + s.V);
        }

        /// <summary>
        /// Multiplies a <see cref="Affine3d"/> and a <see cref="Similarity3d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d operator *(Affine3d a, Similarity3d s)
            => a * (Affine3d)s;

        /// <summary>
        /// Multiplies a <see cref="Similarity3d"/> and a <see cref="Affine3d"/>.
        /// Attention: Multiplication is NOT commutative!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d operator *(Similarity3d s, Affine3d a)
            => (Affine3d)s * a;

        #endregion

        #region Comparison Operators

        /// <summary>
        /// Checks whether two <see cref="Affine3d"/> transformations are equal.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Affine3d a0, Affine3d a1)
            => (a0.Linear == a1.Linear) && (a0.Trans == a1.Trans); 

        /// <summary>
        /// Checks whether two <see cref="Affine3d"/> transformations are different.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Affine3d a0, Affine3d a1)
            => (a0.Linear != a1.Linear) || (a0.Trans != a1.Trans);

        #endregion

        #region Static Creators

        /// <summary>
        /// Creates an affine transformation from a 3x4 matrix.
        /// The left 3x3 submatrix of <paramref name="matrix"/> must be invertible.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d FromM34d(M34d matrix, double epsilon = 1e-12)
        {
            var linear = (M33d)matrix;
            var trans = new V3d(matrix.M03, matrix.M13, matrix.M23);

            if (linear.Determinant.IsTiny(epsilon))
                throw new ArgumentException("Matrix must be invertible");

            return new Affine3d(linear, trans);
        }

        /// <summary>
        /// Creates an affine transformation from a 4x4 matrix.
        /// The matrix <paramref name="m"/> has to be homogeneous and must not contain perspective components and its upper left 3x3 submatrix must be invertible.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d FromM44d(M44d m, double epsilon = 1e-12)
        {
            if (!(m.M30.IsTiny(epsilon) && m.M31.IsTiny(epsilon) && m.M32.IsTiny(epsilon)))
                throw new ArgumentException("Matrix contains perspective components.");

            if (m.M33.IsTiny(epsilon))
                throw new ArgumentException("Matrix is not homogeneous.");

            var linear = ((M33d)m) / m.M33;
            var trans = new V3d(m.M03, m.M13, m.M23) / m.M33;

            if (linear.Determinant.IsTiny(epsilon))
                throw new ArgumentException("Matrix must be invertible");

            return new Affine3d(linear, trans);
        }

        /// <summary>
        /// Creates an affine transformation from a <see cref="Trafo3d"/>.
        /// The transformation <paramref name="trafo"/> must represent a valid affine transformation (e.g. it does not contain perspective components).
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d FromTrafo3d(Trafo3d trafo, double epsilon = 1e-12)
            => FromM44d(trafo.Forward, epsilon);

        /// <summary>
        /// Creates an affine transformation with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d Translation(double tX, double tY, double tZ)
            => new Affine3d(M33d.Identity, tX, tY, tZ);

        /// <summary>
        /// Creates an affine transformation with the translational component given a <see cref="V3d"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d Translation(V3d vector)
            => new Affine3d(M33d.Identity, vector);

        /// <summary>
        /// Creates an affine transformation with the translational component given a <see cref="Shift3d"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d Translation(Shift3d shift)
            => new Affine3d(M33d.Identity, shift.V);

        /// <summary>
        /// Creates a scaling transformation using a uniform scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d Scale(double scaleFactor)
            => new Affine3d(M33d.Scale(scaleFactor, scaleFactor, scaleFactor));

        /// <summary>
        /// Creates a scaling transformation using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d Scale(double sX, double sY, double sZ)
            => new Affine3d(M33d.Scale(sX, sY, sZ));

        /// <summary>
        /// Creates a scaling transformation using a <see cref="V3d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d Scale(V3d scaleFactors)
            => new Affine3d(M33d.Scale(scaleFactors));

        /// <summary>
        /// Creates a scaling transformation using a <see cref="Scale3d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d Scale(Scale3d scale)
            => new Affine3d(M33d.Scale(scale));

        /// <summary>
        /// Creates a rotation transformation from a <see cref="Rot3d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d Rotation(Rot3d rot)
            => new Affine3d(M33d.Rotation(rot));

        /// <summary>
        /// Creates a rotation transformation from an axis vector and an angle in radians.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d Rotation(V3d normalizedAxis, double angleRadians)
            => new Affine3d(M33d.Rotation(normalizedAxis, angleRadians));

        /// <summary>
        /// Creates a rotation transformation from roll (X), pitch (Y), and yaw (Z). 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d RotationEuler(double rollInRadians, double pitchInRadians, double yawInRadians)
            => new Affine3d(M33d.RotationEuler(rollInRadians, pitchInRadians, yawInRadians));

        /// <summary>
        /// Creates a rotation transformation from euler angles as a vector [roll, pitch, yaw].
        /// The rotation order is yaw (Z), pitch (Y), roll (X).
        /// <param name="rollPitchYawInRadians">[roll, pitch, yaw] in radians</param>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d RotationEuler(V3d rollPitchYawInRadians)
            => RotationEuler(rollPitchYawInRadians.X, rollPitchYawInRadians.Y, rollPitchYawInRadians.Z);

        /// <summary>
        /// Creates a rotation transformation by <paramref name="angleRadians"/> radians around the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d RotationX(double angleRadians)
            => new Affine3d(M33d.RotationX(angleRadians));

        /// <summary>
        /// Creates a rotation transformation by <paramref name="angleRadians"/> radians around the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d RotationY(double angleRadians)
            => new Affine3d(M33d.RotationY(angleRadians));

        /// <summary>
        /// Creates a rotation transformation by <paramref name="angleRadians"/> radians around the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d RotationZ(double angleRadians)
            => new Affine3d(M33d.RotationZ(angleRadians));

        #endregion

        #region Conversions

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M34d(Affine3d a)
            => new M34d(a.Linear, a.Trans);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M33d(Affine3d a)
            => a.Linear;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator M44d(Affine3d a)
            => new M44d((M34d)a);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Trafo3d(Affine3d a)
        {
            Debug.Assert(a.Linear.Invertible);
            var t = (M44d)a;
            return new Trafo3d(t, t.Inverse);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Affine3f(Affine3d a)
            => new Affine3f((M33f)a.Linear, (V3f)a.Trans);

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(Linear, Trans);
        }

        public override bool Equals(object other)
        {
            return (other is Affine3d) ? (this == (Affine3d)other) : false;
        }

        public override string ToString()
        {
            return string.Format(CultureInfo.InvariantCulture, "[{0}, {1}]", Linear, Trans);
        }

        public static Affine3d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return new Affine3d(M33d.Parse(x[0]), V3d.Parse(x[1]));
        }

        #endregion
    }

    public static partial class Affine
    {
        #region Invert

        /// <summary>
        /// Returns the inverse of an <see cref="Affine3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Affine3d Inverse(Affine3d a)
            => a.Inverse;

        /// <summary>
        /// Inverts the given affine transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Invert(this ref Affine3d a)
        {
            Debug.Assert(a.Linear.Invertible);
            a.Linear.Invert();
            a.Trans = -a.Linear * a.Trans;
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms a <see cref="V4d"/> by an <see cref="Affine3d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Transform(this Affine3d a, V4d v)
            => a * v;

        /// <summary>
        /// Transforms a <see cref="V3d"/> position vector (v.W is presumed 1) by an <see cref="Affine3d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d TransformPos(this Affine3d a, V3d v)
        {
            return new V3d(
                a.Linear.M00 * v.X + a.Linear.M01 * v.Y + a.Linear.M02 * v.Z + a.Trans.X, 
                a.Linear.M10 * v.X + a.Linear.M11 * v.Y + a.Linear.M12 * v.Z + a.Trans.Y, 
                a.Linear.M20 * v.X + a.Linear.M21 * v.Y + a.Linear.M22 * v.Z + a.Trans.Z);
        }

        /// <summary>
        /// Transforms a <see cref="V3d"/> direction vector (v.W is presumed 0) by an <see cref="Affine3d"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d TransformDir(this Affine3d a, V3d v)
        {
            return new V3d(
                a.Linear.M00 * v.X + a.Linear.M01 * v.Y + a.Linear.M02 * v.Z, 
                a.Linear.M10 * v.X + a.Linear.M11 * v.Y + a.Linear.M12 * v.Z, 
                a.Linear.M20 * v.X + a.Linear.M21 * v.Y + a.Linear.M22 * v.Z);
        }

        /// <summary>
        /// Transforms a <see cref="V4d"/> by the transpose of an <see cref="Affine3d"/> (as a 4x4 matrix).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d TransposedTransform(this Affine3d a, V4d v)
        {
            return new V4d(
                v.X * a.Linear.M00 + v.Y * a.Linear.M10 + v.Z * a.Linear.M20, 
                v.X * a.Linear.M01 + v.Y * a.Linear.M11 + v.Z * a.Linear.M21, 
                v.X * a.Linear.M02 + v.Y * a.Linear.M12 + v.Z * a.Linear.M22,
                v.X * a.Trans.X + v.Y * a.Trans.Y + v.Z * a.Trans.Z + v.W);
        }

        /// <summary>
        /// Transforms a <see cref="V3d"/> by the transpose of an <see cref="Affine3d"/> (as a 4x4 matrix).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d TransposedTransform(this Affine3d a, V3d v)
        {
            return new V3d(
                v.X * a.Linear.M00 + v.Y * a.Linear.M10 + v.Z * a.Linear.M20, 
                v.X * a.Linear.M01 + v.Y * a.Linear.M11 + v.Z * a.Linear.M21, 
                v.X * a.Linear.M02 + v.Y * a.Linear.M12 + v.Z * a.Linear.M22);
        }

        /// <summary>
        /// Transforms a <see cref="V3d"/> position vector (v.W is presumed 1) by the transpose of an <see cref="Affine3d"/> (as a 4x4 matrix).
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d TransposedTransformPosProj(this Affine3d a, V3d v)
        {
            var s = v.X * a.Trans.X + v.Y * a.Trans.Y + v.Z * a.Trans.Z + 1;
            return TransposedTransform(a, v) * (1 / s);
        }

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Affine3d a0, Affine3d a1)
        {
            return ApproximateEquals(a0, a1, Constant<double>.PositiveTinyValue);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this Affine3d a0, Affine3d a1, double tolerance)
        {
            return ApproximateEquals(a0.Linear, a1.Linear, tolerance) && ApproximateEquals(a0.Trans, a1.Trans, tolerance);
        }

        #endregion
    }

    #endregion

}