using System;
using System.ComponentModel;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Xml.Serialization;
using System.Diagnostics;

namespace Aardvark.Base
{
    // AUTOGENERATED CODE - DO NOT CHANGE!

    #region M22i

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M22i : IEquatable<M22i>, IValidity, IMatrix<double>
    {
        [DataMember]
        public int M00, M01;
        [DataMember]
        public int M10, M11;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(int value)
        {
            M00 = value; M01 = 0; 
            M10 = 0; M11 = value; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(
                int m00, int m01, 
                int m10, int m11)
        {
            M00 = m00; M01 = m01; 
            M10 = m10; M11 = m11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M10 = a[2];
            M11 = a[3];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M10 = a[start + 2];
            M11 = a[start + 3];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M23i m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M33i m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M34i m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M44i m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M22l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M23l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M33l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M34l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M44l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M22f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M23f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M33f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M34f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M44f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M22d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M23d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M33d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M34d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22i(M44d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; 
            M10 = (int)m.M10; M11 = (int)m.M11; 
        }

        #endregion

        #region Conversions

        public static explicit operator M22i(M23i m)
        {
            return new M22i {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22i(M33i m)
        {
            return new M22i {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22i(M34i m)
        {
            return new M22i {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22i(M44i m)
        {
            return new M22i {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22i(M22l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M23l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M33l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M34l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M44l m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M22f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M23f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M33f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M34f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M44f m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M22d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M23d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M33d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M34d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(M44d m)
        {
            return new M22i {
                M00 = (int)m.M00, M01 = (int)m.M01, 
                M10 = (int)m.M10, M11 = (int)m.M11, 
            };
        }

        public static explicit operator M22i(int[] a)
        {
            return new M22i(
                a[0], a[1], 
                a[2], a[3]);
        }

        public static explicit operator M22i(int[,] a)
        {
            return new M22i(
                a[0, 0], a[0, 1], 
                a[1, 0], a[1, 1]);
        }

        public static explicit operator int[](M22i m)
        {
            return new int[] {
                m.M00, m.M01, 
                m.M10, m.M11
            };
        }

        public static explicit operator int[,](M22i m)
        {
            return new int[,] {
                { m.M00, m.M01 }, 
                { m.M10, m.M11 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M10;
            array[index + 3] = M11;
        }

        public static explicit operator M22i(long[] a)
        {
            return new M22i(
                (int)a[0], (int)a[1], 
                (int)a[2], (int)a[3]);
        }

        public static explicit operator M22i(long[,] a)
        {
            return new M22i(
                (int)a[0, 0], (int)a[0, 1], 
                (int)a[1, 0], (int)a[1, 1]);
        }

        public static explicit operator long[](M22i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, 
                (long)m.M10, (long)m.M11
            };
        }

        public static explicit operator long[,](M22i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01 }, 
                { (long)m.M10, (long)m.M11 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M10;
            array[index + 3] = (long)M11;
        }

        public static explicit operator M22i(float[] a)
        {
            return new M22i(
                (int)a[0], (int)a[1], 
                (int)a[2], (int)a[3]);
        }

        public static explicit operator M22i(float[,] a)
        {
            return new M22i(
                (int)a[0, 0], (int)a[0, 1], 
                (int)a[1, 0], (int)a[1, 1]);
        }

        public static explicit operator float[](M22i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, 
                (float)m.M10, (float)m.M11
            };
        }

        public static explicit operator float[,](M22i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01 }, 
                { (float)m.M10, (float)m.M11 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M10;
            array[index + 3] = (float)M11;
        }

        public static explicit operator M22i(double[] a)
        {
            return new M22i(
                (int)a[0], (int)a[1], 
                (int)a[2], (int)a[3]);
        }

        public static explicit operator M22i(double[,] a)
        {
            return new M22i(
                (int)a[0, 0], (int)a[0, 1], 
                (int)a[1, 0], (int)a[1, 1]);
        }

        public static explicit operator double[](M22i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, 
                (double)m.M10, (double)m.M11
            };
        }

        public static explicit operator double[,](M22i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01 }, 
                { (double)m.M10, (double)m.M11 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M10;
            array[index + 3] = (double)M11;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<int, int> element_fun)
        {
            return new M22i(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M22i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<int, long> element_fun)
        {
            return new M22l(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M22l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<int, float> element_fun)
        {
            return new M22f(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M22f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<int, double> element_fun)
        {
            return new M22d(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M22d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        public int[] ToArray()
        {
            var array = new int[4];
            array[0] = M00;
            array[1] = M01;
            array[2] = M10;
            array[3] = M11;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i FromCols(V2i col0, V2i col1)
        {
            return new M22i(
                col0.X, col1.X, 
                col0.Y, col1.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i FromRows(V2i row0, V2i row1)
        {
            return new M22i(
                row0.X, row0.Y, 
                row1.X, row1.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i FromDiagonal(int value)
        {
            return new M22i(
                value, 0, 
                0, value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i FromDiagonal(int m00, int m11)
        {
            return new M22i(
                m00, 0, 
                0, m11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i FromDiagonal(V2i s)
        {
            return new M22i(
                s.X, 0, 
                0, s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i FromAntiDiagonal(int value)
        {
            return new M22i(
                 0, value, 
                 value, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i FromAntiDiagonal(int m01, int m10)
        {
            return new M22i(
                0, m01, 
                m10, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i FromAntiDiagonal(V2i s)
        {
            return new M22i(
                0, s.X, 
                s.Y, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M22i"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i Scale(int sX, int sY)
            => FromDiagonal(sX, sY);

        /// <summary>
        /// Creates a transformation <see cref="M22i"/> using a <see cref="V2i"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i Scale(V2i s)
            => FromDiagonal(s);

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i DivideByInt(M22i m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<int> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M10;
                yield return M11;
            }
        }

        public IEnumerable<V2i> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2i> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
            }
        }

        [XmlIgnore]
        public V2i R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2i( M00,  M01); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
            }
        }

        [XmlIgnore]
        public V2i R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2i( M10,  M11); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
            }
        }

        [XmlIgnore]
        public V2i C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2i( M00,  M10); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        [XmlIgnore]
        public V2i C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2i( M01,  M11); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public V2i Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2i(M00, M11);
        }

        public V2i AntiDiagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2i(M01, M10);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public int MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M10, M11);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public int MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M10, M11);
        }

        public unsafe int this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (int* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (int* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe int this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (int* ptr = &M00) { return ptr[row * 2 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (int* ptr = &M00) { ptr[row * 2 + column] = value; }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 2;
        public const int ElementCount = 2 * 2;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 2);
        }

        public static M22i Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22i(0);
        }

        public static M22i Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22i(1, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + 
                    Fun.Abs(M10) + Fun.Abs(M11);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + 
                    M10 * M10 + M11 * M11);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator -(M22i m)
        {
            return new M22i(
                -m.M00, -m.M01, 
                -m.M10, -m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator  + (M22i a, M22i b)
        {
            return new M22i(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator  + (M22i m, int s)
        {
            return new M22i(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator  + (int s, M22i m)
        {
            return new M22i(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  + (M22i a, M22l b)
        {
            return new M22l(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  + (M22i m, long s)
        {
            return new M22l(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  + (long s, M22i m)
        {
            return new M22l(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  + (M22i a, M22f b)
        {
            return new M22f(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  + (M22i m, float s)
        {
            return new M22f(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  + (float s, M22i m)
        {
            return new M22f(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  + (M22i a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  + (M22i m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  + (double s, M22i m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator  - (M22i a, M22i b)
        {
            return new M22i(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator  - (M22i m, int s)
        {
            return new M22i(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator  - (int s, M22i m)
        {
            return new M22i(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  - (M22i a, M22l b)
        {
            return new M22l(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  - (M22i m, long s)
        {
            return new M22l(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  - (long s, M22i m)
        {
            return new M22l(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  - (M22i a, M22f b)
        {
            return new M22f(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  - (M22i m, float s)
        {
            return new M22f(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  - (float s, M22i m)
        {
            return new M22f(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  - (M22i a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  - (M22i m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  - (double s, M22i m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator  % (M22i a, M22i b)
        {
            return new M22i(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator  % (M22i m, int s)
        {
            return new M22i(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator  % (int s, M22i m)
        {
            return new M22i(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  % (M22i a, M22l b)
        {
            return new M22l(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  % (M22i m, long s)
        {
            return new M22l(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  % (long s, M22i m)
        {
            return new M22l(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  % (M22i a, M22f b)
        {
            return new M22f(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  % (M22i m, float s)
        {
            return new M22f(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  % (float s, M22i m)
        {
            return new M22f(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  % (M22i a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  % (M22i m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  % (double s, M22i m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator  / (M22i a, M22i b)
        {
            return new M22i(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator  / (M22i m, int s)
        {
            return new M22i(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator  / (int s, M22i m)
        {
            return new M22i(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  / (M22i a, M22l b)
        {
            return new M22l(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  / (M22i m, long s)
        {
            return new M22l(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  / (long s, M22i m)
        {
            return new M22l(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  / (M22i a, M22f b)
        {
            return new M22f(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  / (M22i m, float s)
        {
            return new M22f(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  / (float s, M22i m)
        {
            return new M22f(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  / (M22i a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  / (M22i m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  / (double s, M22i m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator  * (M22i m, int s)
        {
            return new M22i(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator  * (int s, M22i m)
        {
            return new M22i(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  * (M22i m, long s)
        {
            return new M22l(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  * (long s, M22i m)
        {
            return new M22l(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  * (M22i m, float s)
        {
            return new M22f(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  * (float s, M22i m)
        {
            return new M22f(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  * (M22i m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  * (double s, M22i m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        #endregion

        #region Bitwise Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator ~(M22i m)
        {
            return new M22i(
                ~m.M00, ~m.M01, 
                ~m.M10, ~m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator <<(M22i a, int s)
        {
            return new M22i(
                a.M00 << s, a.M01 << s, 
                a.M10 << s, a.M11 << s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator >>(M22i a, int s)
        {
            return new M22i(
                a.M00 >> s, a.M01 >> s, 
                a.M10 >> s, a.M11 >> s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator &(M22i a, M22i b)
        {
            return new M22i(
                a.M00 & b.M00, a.M01 & b.M01, 
                a.M10 & b.M10, a.M11 & b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator &(M22i a, int s)
        {
            return new M22i(
                a.M00 & s, a.M01 & s, 
                a.M10 & s, a.M11 & s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator &(int s, M22i a)
        {
            return new M22i(
                s & a.M00, s & a.M01, 
                s & a.M10, s & a.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator |(M22i a, M22i b)
        {
            return new M22i(
                a.M00 | b.M00, a.M01 | b.M01, 
                a.M10 | b.M10, a.M11 | b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator |(M22i a, int s)
        {
            return new M22i(
                a.M00 | s, a.M01 | s, 
                a.M10 | s, a.M11 | s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator |(int s, M22i a)
        {
            return new M22i(
                s | a.M00, s | a.M01, 
                s | a.M10, s | a.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator ^(M22i a, M22i b)
        {
            return new M22i(
                a.M00 ^ b.M00, a.M01 ^ b.M01, 
                a.M10 ^ b.M10, a.M11 ^ b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator ^(M22i a, int s)
        {
            return new M22i(
                a.M00 ^ s, a.M01 ^ s, 
                a.M10 ^ s, a.M11 ^ s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i operator ^(int s, M22i a)
        {
            return new M22i(
                s ^ a.M00, s ^ a.M01, 
                s ^ a.M10, s ^ a.M11);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M22i matrix with a V2i column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i operator *(M22i m, V2i v)
        {
            return new V2i(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        /// <summary>
        /// Multiplies a V2i row vector with a M22i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i operator *(V2i v, M22i m)
        {
            return new V2i(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M22i a, M22i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M22i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M10 < s && 
                a.M11 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(int s, M22i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M10  && 
                s < a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M22i a, M22i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M22i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M10 > s && 
                a.M11 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(int s, M22i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M10  && 
                s > a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M22i a, M22i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M22i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M10 == s && 
                a.M11 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(int s, M22i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M10  && 
                s == a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M22i a, M22i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M22i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M10 <= s && 
                a.M11 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(int s, M22i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M10  && 
                s <= a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M22i a, M22i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M22i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M10 >= s && 
                a.M11 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(int s, M22i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M10  && 
                s >= a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M22i a, M22i b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M22i m, int s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(int s, M22i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01),
                        HashCode.GetCombined(M10, M11));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M22i other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && 
                M10.Equals(other.M10) && M11.Equals(other.M11);
        }

        public override bool Equals(object other)
            => (other is M22i o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M22i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M22i.FromRows(
                V2i.Parse(x[0]), 
                V2i.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M22i Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return new M22i(M11, -M10, -M01, M00);
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public int Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public int Determinant
        {
            get
            {
                return M00 * M11 - M10 * M01;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M22i Transposed
        {
            get
            {
                return new M22i {
                    
                    M00 = M00, 
                    M01 = M10, 
                    
                    M10 = M01, 
                    M11 = M11
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M22i operator *(M22i a, M22i b)
        {
            return new M22i(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M22iEqualityComparer : IEqualityComparer<M22i>
    {
        public static readonly M22iEqualityComparer Default
            = new M22iEqualityComparer();

        #region IEqualityComparer<M22i> Members

        public bool Equals(M22i v0, M22i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M22i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M22i m)
            => (m.C0.Length + m.C1.Length) / 2;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d GetScaleVector(this M22i m)
            => new V2d(m.C0.Length, m.C1.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Norm1(M22i m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M22i m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMax(M22i m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMin(M22i m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M22i m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(this M22i a, M22i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M22i a, M22i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M22i a, M22i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(this M22i a, M22i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(this M22i a, M22i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i Transform(this M22i m, V2i v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i Transform(this M22i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i Transform(this M22i m, V4i v)
        {
            return new V4i(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z, v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i TransposedTransform(this M22i m, V2i v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i TransposedTransform(this M22i m, V3i v)
        {
            return new V3i(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i TransposedTransform(this M22i m, V4i v)
        {
            return new V4i(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z, v.W);
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M22i"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static int Minor(this M22i m, int row, int column)
        {
            return m[1 - row, 1 - column];
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V2i Row(this M22i m, int index)
        {
            int* ptr = &m.M00;
            return new V2i(ptr[index * 2], ptr[index * 2 + 1]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V2i Column(this M22i m, int index)
        {
            int* ptr = &m.M00;
            return new V2i(ptr[index], ptr[index + 2]);
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Determinant(M22i m)
            => m.Determinant;

        /// <summary>
        /// Returns the transpose of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i Transposed(M22i m)
            => m.Transposed;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Transpose(this ref M22i m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
        }

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M22i"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int MinElement(M22i m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M22i"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int MaxElement(M22i m)
            => m.MaxElement;

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M22i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M22i m, int epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M22i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M22i m, int epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M22i a, M22i b, int epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M22i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M22i m, int epsilon)
            => Mat.AllTiny(m, epsilon);

        #endregion
    }

    public static class IRandomUniformM22iExtensions
    {
        #region IRandomUniform extensions for M22i

        /// <summary>
        /// Uses UniformInt() to generate the elements of an M22i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i UniformM22i(this IRandomUniform rnd)
        {
            return new M22i(
                rnd.UniformInt(), rnd.UniformInt(), 
                rnd.UniformInt(), rnd.UniformInt());
        }

        /// <summary>
        /// Uses UniformIntNonZero() to generate the elements of an M22i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i UniformM22iNonZero(this IRandomUniform rnd)
        {
            return new M22i(
                rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), 
                rnd.UniformIntNonZero(), rnd.UniformIntNonZero());
        }

        /// <summary>
        /// Uses UniformInt(int) to generate the elements of an M22i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i UniformM22i(this IRandomUniform rnd, int size)
        {
            return new M22i(
                rnd.UniformInt(size), rnd.UniformInt(size), 
                rnd.UniformInt(size), rnd.UniformInt(size));
        }

        /// <summary>
        /// Uses UniformInt(int) to generate the elements of an M22i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22i UniformM22i(this IRandomUniform rnd, M22i size)
        {
            return new M22i(
                rnd.UniformInt(size.M00), rnd.UniformInt(size.M01), 
                rnd.UniformInt(size.M10), rnd.UniformInt(size.M11));
        }

        #endregion
    }

    #endregion

    #region M22l

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M22l : IEquatable<M22l>, IValidity, IMatrix<double>
    {
        [DataMember]
        public long M00, M01;
        [DataMember]
        public long M10, M11;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(long value)
        {
            M00 = value; M01 = 0; 
            M10 = 0; M11 = value; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(
                long m00, long m01, 
                long m10, long m11)
        {
            M00 = m00; M01 = m01; 
            M10 = m10; M11 = m11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M10 = a[2];
            M11 = a[3];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M10 = a[start + 2];
            M11 = a[start + 3];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M22i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M23i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M33i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M34i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M44i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M23l m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M33l m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M34l m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M44l m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M22f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M23f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M33f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M34f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M44f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M22d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M23d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M33d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M34d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22l(M44d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; 
            M10 = (long)m.M10; M11 = (long)m.M11; 
        }

        #endregion

        #region Conversions

        public static explicit operator M22l(M22i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M23i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M33i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M34i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M44i m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M23l m)
        {
            return new M22l {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22l(M33l m)
        {
            return new M22l {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22l(M34l m)
        {
            return new M22l {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22l(M44l m)
        {
            return new M22l {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22l(M22f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M23f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M33f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M34f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M44f m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M22d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M23d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M33d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M34d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(M44d m)
        {
            return new M22l {
                M00 = (long)m.M00, M01 = (long)m.M01, 
                M10 = (long)m.M10, M11 = (long)m.M11, 
            };
        }

        public static explicit operator M22l(int[] a)
        {
            return new M22l(
                (long)a[0], (long)a[1], 
                (long)a[2], (long)a[3]);
        }

        public static explicit operator M22l(int[,] a)
        {
            return new M22l(
                (long)a[0, 0], (long)a[0, 1], 
                (long)a[1, 0], (long)a[1, 1]);
        }

        public static explicit operator int[](M22l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, 
                (int)m.M10, (int)m.M11
            };
        }

        public static explicit operator int[,](M22l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01 }, 
                { (int)m.M10, (int)m.M11 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M10;
            array[index + 3] = (int)M11;
        }

        public static explicit operator M22l(long[] a)
        {
            return new M22l(
                a[0], a[1], 
                a[2], a[3]);
        }

        public static explicit operator M22l(long[,] a)
        {
            return new M22l(
                a[0, 0], a[0, 1], 
                a[1, 0], a[1, 1]);
        }

        public static explicit operator long[](M22l m)
        {
            return new long[] {
                m.M00, m.M01, 
                m.M10, m.M11
            };
        }

        public static explicit operator long[,](M22l m)
        {
            return new long[,] {
                { m.M00, m.M01 }, 
                { m.M10, m.M11 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M10;
            array[index + 3] = M11;
        }

        public static explicit operator M22l(float[] a)
        {
            return new M22l(
                (long)a[0], (long)a[1], 
                (long)a[2], (long)a[3]);
        }

        public static explicit operator M22l(float[,] a)
        {
            return new M22l(
                (long)a[0, 0], (long)a[0, 1], 
                (long)a[1, 0], (long)a[1, 1]);
        }

        public static explicit operator float[](M22l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, 
                (float)m.M10, (float)m.M11
            };
        }

        public static explicit operator float[,](M22l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01 }, 
                { (float)m.M10, (float)m.M11 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M10;
            array[index + 3] = (float)M11;
        }

        public static explicit operator M22l(double[] a)
        {
            return new M22l(
                (long)a[0], (long)a[1], 
                (long)a[2], (long)a[3]);
        }

        public static explicit operator M22l(double[,] a)
        {
            return new M22l(
                (long)a[0, 0], (long)a[0, 1], 
                (long)a[1, 0], (long)a[1, 1]);
        }

        public static explicit operator double[](M22l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, 
                (double)m.M10, (double)m.M11
            };
        }

        public static explicit operator double[,](M22l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01 }, 
                { (double)m.M10, (double)m.M11 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M10;
            array[index + 3] = (double)M11;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<long, int> element_fun)
        {
            return new M22i(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M22i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<long, long> element_fun)
        {
            return new M22l(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M22l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<long, float> element_fun)
        {
            return new M22f(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M22f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<long, double> element_fun)
        {
            return new M22d(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M22d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        public long[] ToArray()
        {
            var array = new long[4];
            array[0] = M00;
            array[1] = M01;
            array[2] = M10;
            array[3] = M11;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l FromCols(V2l col0, V2l col1)
        {
            return new M22l(
                col0.X, col1.X, 
                col0.Y, col1.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l FromRows(V2l row0, V2l row1)
        {
            return new M22l(
                row0.X, row0.Y, 
                row1.X, row1.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l FromDiagonal(long value)
        {
            return new M22l(
                value, 0, 
                0, value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l FromDiagonal(long m00, long m11)
        {
            return new M22l(
                m00, 0, 
                0, m11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l FromDiagonal(V2l s)
        {
            return new M22l(
                s.X, 0, 
                0, s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l FromAntiDiagonal(long value)
        {
            return new M22l(
                 0, value, 
                 value, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l FromAntiDiagonal(long m01, long m10)
        {
            return new M22l(
                0, m01, 
                m10, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l FromAntiDiagonal(V2l s)
        {
            return new M22l(
                0, s.X, 
                s.Y, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M22l"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l Scale(long sX, long sY)
            => FromDiagonal(sX, sY);

        /// <summary>
        /// Creates a transformation <see cref="M22l"/> using a <see cref="V2l"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l Scale(V2l s)
            => FromDiagonal(s);

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l DivideByInt(M22l m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<long> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M10;
                yield return M11;
            }
        }

        public IEnumerable<V2l> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2l> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
            }
        }

        [XmlIgnore]
        public V2l R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2l( M00,  M01); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
            }
        }

        [XmlIgnore]
        public V2l R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2l( M10,  M11); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
            }
        }

        [XmlIgnore]
        public V2l C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2l( M00,  M10); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        [XmlIgnore]
        public V2l C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2l( M01,  M11); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public V2l Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(M00, M11);
        }

        public V2l AntiDiagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(M01, M10);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public long MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M10, M11);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public long MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M10, M11);
        }

        public unsafe long this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (long* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (long* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe long this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (long* ptr = &M00) { return ptr[row * 2 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (long* ptr = &M00) { ptr[row * 2 + column] = value; }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 2;
        public const int ElementCount = 2 * 2;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 2);
        }

        public static M22l Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22l(0);
        }

        public static M22l Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22l(1, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + 
                    Fun.Abs(M10) + Fun.Abs(M11);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + 
                    M10 * M10 + M11 * M11);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator -(M22l m)
        {
            return new M22l(
                -m.M00, -m.M01, 
                -m.M10, -m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  + (M22l a, M22l b)
        {
            return new M22l(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  + (M22l m, long s)
        {
            return new M22l(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  + (long s, M22l m)
        {
            return new M22l(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  + (M22l a, M22f b)
        {
            return new M22f(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  + (M22l m, float s)
        {
            return new M22f(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  + (float s, M22l m)
        {
            return new M22f(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  + (M22l a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  + (M22l m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  + (double s, M22l m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  - (M22l a, M22l b)
        {
            return new M22l(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  - (M22l m, long s)
        {
            return new M22l(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  - (long s, M22l m)
        {
            return new M22l(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  - (M22l a, M22f b)
        {
            return new M22f(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  - (M22l m, float s)
        {
            return new M22f(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  - (float s, M22l m)
        {
            return new M22f(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  - (M22l a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  - (M22l m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  - (double s, M22l m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  % (M22l a, M22l b)
        {
            return new M22l(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  % (M22l m, long s)
        {
            return new M22l(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  % (long s, M22l m)
        {
            return new M22l(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  % (M22l a, M22f b)
        {
            return new M22f(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  % (M22l m, float s)
        {
            return new M22f(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  % (float s, M22l m)
        {
            return new M22f(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  % (M22l a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  % (M22l m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  % (double s, M22l m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  / (M22l a, M22l b)
        {
            return new M22l(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  / (M22l m, long s)
        {
            return new M22l(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  / (long s, M22l m)
        {
            return new M22l(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  / (M22l a, M22f b)
        {
            return new M22f(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  / (M22l m, float s)
        {
            return new M22f(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  / (float s, M22l m)
        {
            return new M22f(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  / (M22l a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  / (M22l m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  / (double s, M22l m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  * (M22l m, long s)
        {
            return new M22l(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator  * (long s, M22l m)
        {
            return new M22l(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  * (M22l m, float s)
        {
            return new M22f(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  * (float s, M22l m)
        {
            return new M22f(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  * (M22l m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  * (double s, M22l m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        #endregion

        #region Bitwise Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator ~(M22l m)
        {
            return new M22l(
                ~m.M00, ~m.M01, 
                ~m.M10, ~m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator <<(M22l a, int s)
        {
            return new M22l(
                a.M00 << s, a.M01 << s, 
                a.M10 << s, a.M11 << s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator >>(M22l a, int s)
        {
            return new M22l(
                a.M00 >> s, a.M01 >> s, 
                a.M10 >> s, a.M11 >> s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator &(M22l a, M22l b)
        {
            return new M22l(
                a.M00 & b.M00, a.M01 & b.M01, 
                a.M10 & b.M10, a.M11 & b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator &(M22l a, long s)
        {
            return new M22l(
                a.M00 & s, a.M01 & s, 
                a.M10 & s, a.M11 & s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator &(long s, M22l a)
        {
            return new M22l(
                s & a.M00, s & a.M01, 
                s & a.M10, s & a.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator |(M22l a, M22l b)
        {
            return new M22l(
                a.M00 | b.M00, a.M01 | b.M01, 
                a.M10 | b.M10, a.M11 | b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator |(M22l a, long s)
        {
            return new M22l(
                a.M00 | s, a.M01 | s, 
                a.M10 | s, a.M11 | s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator |(long s, M22l a)
        {
            return new M22l(
                s | a.M00, s | a.M01, 
                s | a.M10, s | a.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator ^(M22l a, M22l b)
        {
            return new M22l(
                a.M00 ^ b.M00, a.M01 ^ b.M01, 
                a.M10 ^ b.M10, a.M11 ^ b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator ^(M22l a, long s)
        {
            return new M22l(
                a.M00 ^ s, a.M01 ^ s, 
                a.M10 ^ s, a.M11 ^ s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l operator ^(long s, M22l a)
        {
            return new M22l(
                s ^ a.M00, s ^ a.M01, 
                s ^ a.M10, s ^ a.M11);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M22l matrix with a V2l column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l operator *(M22l m, V2l v)
        {
            return new V2l(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        /// <summary>
        /// Multiplies a V2l row vector with a M22l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l operator *(V2l v, M22l m)
        {
            return new V2l(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M22l a, M22l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M22l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M10 < s && 
                a.M11 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(long s, M22l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M10  && 
                s < a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M22l a, M22l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M22l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M10 > s && 
                a.M11 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(long s, M22l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M10  && 
                s > a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M22l a, M22l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M22l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M10 == s && 
                a.M11 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(long s, M22l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M10  && 
                s == a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M22l a, M22l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M22l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M10 <= s && 
                a.M11 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(long s, M22l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M10  && 
                s <= a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M22l a, M22l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M22l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M10 >= s && 
                a.M11 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(long s, M22l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M10  && 
                s >= a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M22l a, M22l b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M22l m, long s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(long s, M22l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01),
                        HashCode.GetCombined(M10, M11));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M22l other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && 
                M10.Equals(other.M10) && M11.Equals(other.M11);
        }

        public override bool Equals(object other)
            => (other is M22l o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M22l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M22l.FromRows(
                V2l.Parse(x[0]), 
                V2l.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M22l Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return new M22l(M11, -M10, -M01, M00);
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public long Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public long Determinant
        {
            get
            {
                return M00 * M11 - M10 * M01;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M22l Transposed
        {
            get
            {
                return new M22l {
                    
                    M00 = M00, 
                    M01 = M10, 
                    
                    M10 = M01, 
                    M11 = M11
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M22l operator *(M22l a, M22l b)
        {
            return new M22l(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M22lEqualityComparer : IEqualityComparer<M22l>
    {
        public static readonly M22lEqualityComparer Default
            = new M22lEqualityComparer();

        #region IEqualityComparer<M22l> Members

        public bool Equals(M22l v0, M22l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M22l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M22l m)
            => (m.C0.Length + m.C1.Length) / 2;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d GetScaleVector(this M22l m)
            => new V2d(m.C0.Length, m.C1.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Norm1(M22l m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M22l m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMax(M22l m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMin(M22l m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M22l m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(this M22l a, M22l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M22l a, M22l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M22l a, M22l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(this M22l a, M22l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(this M22l a, M22l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l Transform(this M22l m, V2l v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l Transform(this M22l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l Transform(this M22l m, V4l v)
        {
            return new V4l(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z, v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l TransposedTransform(this M22l m, V2l v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l TransposedTransform(this M22l m, V3l v)
        {
            return new V3l(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l TransposedTransform(this M22l m, V4l v)
        {
            return new V4l(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z, v.W);
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M22l"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static long Minor(this M22l m, int row, int column)
        {
            return m[1 - row, 1 - column];
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V2l Row(this M22l m, int index)
        {
            long* ptr = &m.M00;
            return new V2l(ptr[index * 2], ptr[index * 2 + 1]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V2l Column(this M22l m, int index)
        {
            long* ptr = &m.M00;
            return new V2l(ptr[index], ptr[index + 2]);
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Determinant(M22l m)
            => m.Determinant;

        /// <summary>
        /// Returns the transpose of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l Transposed(M22l m)
            => m.Transposed;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Transpose(this ref M22l m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
        }

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M22l"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long MinElement(M22l m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M22l"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long MaxElement(M22l m)
            => m.MaxElement;

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M22l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M22l m, long epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M22l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M22l m, long epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M22l a, M22l b, long epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M22l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M22l m, long epsilon)
            => Mat.AllTiny(m, epsilon);

        #endregion
    }

    public static class IRandomUniformM22lExtensions
    {
        #region IRandomUniform extensions for M22l

        /// <summary>
        /// Uses UniformLong() to generate the elements of an M22l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l UniformM22l(this IRandomUniform rnd)
        {
            return new M22l(
                rnd.UniformLong(), rnd.UniformLong(), 
                rnd.UniformLong(), rnd.UniformLong());
        }

        /// <summary>
        /// Uses UniformLongNonZero() to generate the elements of an M22l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l UniformM22lNonZero(this IRandomUniform rnd)
        {
            return new M22l(
                rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), 
                rnd.UniformLongNonZero(), rnd.UniformLongNonZero());
        }

        /// <summary>
        /// Uses UniformLong(long) to generate the elements of an M22l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l UniformM22l(this IRandomUniform rnd, long size)
        {
            return new M22l(
                rnd.UniformLong(size), rnd.UniformLong(size), 
                rnd.UniformLong(size), rnd.UniformLong(size));
        }

        /// <summary>
        /// Uses UniformLong(long) to generate the elements of an M22l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22l UniformM22l(this IRandomUniform rnd, M22l size)
        {
            return new M22l(
                rnd.UniformLong(size.M00), rnd.UniformLong(size.M01), 
                rnd.UniformLong(size.M10), rnd.UniformLong(size.M11));
        }

        #endregion
    }

    #endregion

    #region M22f

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M22f : IEquatable<M22f>, IValidity, IMatrix<double>
    {
        [DataMember]
        public float M00, M01;
        [DataMember]
        public float M10, M11;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(float value)
        {
            M00 = value; M01 = 0; 
            M10 = 0; M11 = value; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(
                float m00, float m01, 
                float m10, float m11)
        {
            M00 = m00; M01 = m01; 
            M10 = m10; M11 = m11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M10 = a[2];
            M11 = a[3];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M10 = a[start + 2];
            M11 = a[start + 3];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M22i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M23i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M33i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M34i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M44i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M22l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M23l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M33l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M34l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M44l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M23f m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M33f m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M34f m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M44f m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M22d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M23d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M33d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M34d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22f(M44d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; 
            M10 = (float)m.M10; M11 = (float)m.M11; 
        }

        #endregion

        #region Conversions

        public static explicit operator M22f(M22i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M23i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M33i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M34i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M44i m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M22l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M23l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M33l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M34l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M44l m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M23f m)
        {
            return new M22f {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22f(M33f m)
        {
            return new M22f {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22f(M34f m)
        {
            return new M22f {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22f(M44f m)
        {
            return new M22f {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22f(M22d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M23d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M33d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M34d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(M44d m)
        {
            return new M22f {
                M00 = (float)m.M00, M01 = (float)m.M01, 
                M10 = (float)m.M10, M11 = (float)m.M11, 
            };
        }

        public static explicit operator M22f(int[] a)
        {
            return new M22f(
                (float)a[0], (float)a[1], 
                (float)a[2], (float)a[3]);
        }

        public static explicit operator M22f(int[,] a)
        {
            return new M22f(
                (float)a[0, 0], (float)a[0, 1], 
                (float)a[1, 0], (float)a[1, 1]);
        }

        public static explicit operator int[](M22f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, 
                (int)m.M10, (int)m.M11
            };
        }

        public static explicit operator int[,](M22f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01 }, 
                { (int)m.M10, (int)m.M11 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M10;
            array[index + 3] = (int)M11;
        }

        public static explicit operator M22f(long[] a)
        {
            return new M22f(
                (float)a[0], (float)a[1], 
                (float)a[2], (float)a[3]);
        }

        public static explicit operator M22f(long[,] a)
        {
            return new M22f(
                (float)a[0, 0], (float)a[0, 1], 
                (float)a[1, 0], (float)a[1, 1]);
        }

        public static explicit operator long[](M22f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, 
                (long)m.M10, (long)m.M11
            };
        }

        public static explicit operator long[,](M22f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01 }, 
                { (long)m.M10, (long)m.M11 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M10;
            array[index + 3] = (long)M11;
        }

        public static explicit operator M22f(float[] a)
        {
            return new M22f(
                a[0], a[1], 
                a[2], a[3]);
        }

        public static explicit operator M22f(float[,] a)
        {
            return new M22f(
                a[0, 0], a[0, 1], 
                a[1, 0], a[1, 1]);
        }

        public static explicit operator float[](M22f m)
        {
            return new float[] {
                m.M00, m.M01, 
                m.M10, m.M11
            };
        }

        public static explicit operator float[,](M22f m)
        {
            return new float[,] {
                { m.M00, m.M01 }, 
                { m.M10, m.M11 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M10;
            array[index + 3] = M11;
        }

        public static explicit operator M22f(double[] a)
        {
            return new M22f(
                (float)a[0], (float)a[1], 
                (float)a[2], (float)a[3]);
        }

        public static explicit operator M22f(double[,] a)
        {
            return new M22f(
                (float)a[0, 0], (float)a[0, 1], 
                (float)a[1, 0], (float)a[1, 1]);
        }

        public static explicit operator double[](M22f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, 
                (double)m.M10, (double)m.M11
            };
        }

        public static explicit operator double[,](M22f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01 }, 
                { (double)m.M10, (double)m.M11 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M10;
            array[index + 3] = (double)M11;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<float, int> element_fun)
        {
            return new M22i(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M22i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<float, long> element_fun)
        {
            return new M22l(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M22l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<float, float> element_fun)
        {
            return new M22f(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M22f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<float, double> element_fun)
        {
            return new M22d(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M22d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        public float[] ToArray()
        {
            var array = new float[4];
            array[0] = M00;
            array[1] = M01;
            array[2] = M10;
            array[3] = M11;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f FromCols(V2f col0, V2f col1)
        {
            return new M22f(
                col0.X, col1.X, 
                col0.Y, col1.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f FromRows(V2f row0, V2f row1)
        {
            return new M22f(
                row0.X, row0.Y, 
                row1.X, row1.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f FromDiagonal(float value)
        {
            return new M22f(
                value, 0, 
                0, value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f FromDiagonal(float m00, float m11)
        {
            return new M22f(
                m00, 0, 
                0, m11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f FromDiagonal(V2f s)
        {
            return new M22f(
                s.X, 0, 
                0, s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f FromAntiDiagonal(float value)
        {
            return new M22f(
                 0, value, 
                 value, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f FromAntiDiagonal(float m01, float m10)
        {
            return new M22f(
                0, m01, 
                m10, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f FromAntiDiagonal(V2f s)
        {
            return new M22f(
                0, s.X, 
                s.Y, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M22f"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f Scale(float sX, float sY)
            => FromDiagonal(sX, sY);

        /// <summary>
        /// Creates a transformation <see cref="M22f"/> using a <see cref="V2f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f Scale(V2f s)
            => FromDiagonal(s);

        /// <summary>
        /// Creates a transformation <see cref="M22f"/> from a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f Scale(Scale2f s)
        {
            return new M22f(
                s.X, 0, 
                0, s.Y);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in radians.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f Rotation(float angleInRadians)
        {
            var a = Fun.Cos(angleInRadians);
            var b = Fun.Sin(angleInRadians);

            return new M22f(
                 a, -b, 
                 b,  a);
        }

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in degrees.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f RotationInDegrees(float angleInDegrees)
            => Rotation(angleInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 2D rotation matrix from a <see cref="Rot2f"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f Rotation(Rot2f r)
            => (M22f)r;

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f DivideByInt(M22f m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<float> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M10;
                yield return M11;
            }
        }

        public IEnumerable<V2f> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2f> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
            }
        }

        [XmlIgnore]
        public V2f R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2f( M00,  M01); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
            }
        }

        [XmlIgnore]
        public V2f R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2f( M10,  M11); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
            }
        }

        [XmlIgnore]
        public V2f C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2f( M00,  M10); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        [XmlIgnore]
        public V2f C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2f( M01,  M11); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public V2f Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2f(M00, M11);
        }

        public V2f AntiDiagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2f(M01, M10);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public float MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M10, M11);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public float MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M10, M11);
        }

        public unsafe float this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (float* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (float* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe float this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (float* ptr = &M00) { return ptr[row * 2 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (float* ptr = &M00) { ptr[row * 2 + column] = value; }
            }
        }

        public bool AnyNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNaN(M00) || float.IsNaN(M01) || 
                    float.IsNaN(M10) || float.IsNaN(M11);
            }
        }

        public bool AllNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNaN(M00) && float.IsNaN(M01) && 
                    float.IsNaN(M10) && float.IsNaN(M11);
            }
        }

        public bool AnyInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsInfinity(M00) || float.IsInfinity(M01) || 
                    float.IsInfinity(M10) || float.IsInfinity(M11);
            }
        }

        public bool AllInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsInfinity(M00) && float.IsInfinity(M01) && 
                    float.IsInfinity(M10) && float.IsInfinity(M11);
            }
        }

        public bool AnyPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsPositiveInfinity(M00) || float.IsPositiveInfinity(M01) || 
                    float.IsPositiveInfinity(M10) || float.IsPositiveInfinity(M11);
            }
        }

        public bool AllPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsPositiveInfinity(M00) && float.IsPositiveInfinity(M01) && 
                    float.IsPositiveInfinity(M10) && float.IsPositiveInfinity(M11);
            }
        }

        public bool AnyNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNegativeInfinity(M00) || float.IsNegativeInfinity(M01) || 
                    float.IsNegativeInfinity(M10) || float.IsNegativeInfinity(M11);
            }
        }

        public bool AllNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNegativeInfinity(M00) && float.IsNegativeInfinity(M01) && 
                    float.IsNegativeInfinity(M10) && float.IsNegativeInfinity(M11);
            }
        }

        public bool AnyTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) || Fun.IsTiny(M01) || 
                    Fun.IsTiny(M10) || Fun.IsTiny(M11);
            }
        }

        public bool AllTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) && Fun.IsTiny(M01) && 
                    Fun.IsTiny(M10) && Fun.IsTiny(M11);
            }
        }

        /// <summary>
        /// Returns true if the absolute value of each element of the matrix is smaller than Constant&lt;float&gt;.PositiveTinyValue, false otherwise.
        /// </summary>
        public bool IsTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AllTiny;
        }

        /// <summary>
        /// Returns true if any element of the matrix is NaN, false otherwise.
        /// </summary>
        public bool IsNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyNaN;
        }

        /// <summary>
        /// Returns true if any element of the matrix is infinite (positive or negative), false otherwise.
        /// </summary>
        public bool IsInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyInfinity;
        }

        /// <summary>
        /// Returns whether all elements of the matrix are finite (i.e. not NaN and not infinity).
        /// </summary>
        public bool IsFinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => !(IsInfinity || IsNaN);
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 2;
        public const int ElementCount = 2 * 2;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 2);
        }

        public static M22f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22f(0);
        }

        public static M22f Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22f(1, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + 
                    Fun.Abs(M10) + Fun.Abs(M11);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + 
                    M10 * M10 + M11 * M11);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator -(M22f m)
        {
            return new M22f(
                -m.M00, -m.M01, 
                -m.M10, -m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  + (M22f a, M22f b)
        {
            return new M22f(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  + (M22f m, float s)
        {
            return new M22f(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  + (float s, M22f m)
        {
            return new M22f(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  + (M22f a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  + (M22f m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  + (double s, M22f m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  - (M22f a, M22f b)
        {
            return new M22f(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  - (M22f m, float s)
        {
            return new M22f(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  - (float s, M22f m)
        {
            return new M22f(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  - (M22f a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  - (M22f m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  - (double s, M22f m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  % (M22f a, M22f b)
        {
            return new M22f(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  % (M22f m, float s)
        {
            return new M22f(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  % (float s, M22f m)
        {
            return new M22f(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  % (M22f a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  % (M22f m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  % (double s, M22f m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  / (M22f a, M22f b)
        {
            return new M22f(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  / (M22f m, float s)
        {
            return new M22f(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  / (float s, M22f m)
        {
            return new M22f(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  / (M22f a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  / (M22f m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  / (double s, M22f m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  * (M22f m, float s)
        {
            return new M22f(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f operator  * (float s, M22f m)
        {
            return new M22f(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  * (M22f m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  * (double s, M22f m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M22f matrix with a V2f column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f operator *(M22f m, V2f v)
        {
            return new V2f(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        /// <summary>
        /// Multiplies a V2f row vector with a M22f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f operator *(V2f v, M22f m)
        {
            return new V2f(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M22f a, M22f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M22f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M10 < s && 
                a.M11 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(float s, M22f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M10  && 
                s < a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M22f a, M22f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M22f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M10 > s && 
                a.M11 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(float s, M22f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M10  && 
                s > a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M22f a, M22f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M22f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M10 == s && 
                a.M11 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(float s, M22f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M10  && 
                s == a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M22f a, M22f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M22f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M10 <= s && 
                a.M11 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(float s, M22f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M10  && 
                s <= a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M22f a, M22f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M22f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M10 >= s && 
                a.M11 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(float s, M22f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M10  && 
                s >= a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M22f a, M22f b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M22f m, float s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(float s, M22f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01),
                        HashCode.GetCombined(M10, M11));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M22f other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && 
                M10.Equals(other.M10) && M11.Equals(other.M11);
        }

        public override bool Equals(object other)
            => (other is M22f o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M22f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M22f.FromRows(
                V2f.Parse(x[0]), 
                V2f.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M22f Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return new M22f(M11, -M10, -M01, M00);
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public float Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public float Determinant
        {
            get
            {
                return M00 * M11 - M10 * M01;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M22f Transposed
        {
            get
            {
                return new M22f {
                    
                    M00 = M00, 
                    M01 = M10, 
                    
                    M10 = M01, 
                    M11 = M11
                };
            }
        }

        private static V2l s_luSize = new V2l(2, 2);
        private static V2l s_luDelta = new V2l(1, 2);

        /// <summary>
        /// Inverts the given matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            M22d dbl = (M22d)this;
            if(dbl.LuInvert()) 
            { 
                this = (M22f)dbl;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M22f.Zero is returned.
        /// </summary>
        public M22f LuInverse()
        {
            return (M22f)((M22d)this).LuInverse();
        }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M22f.Zero is returned.
        /// </summary>
        public M22f Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => LuInverse();
        }

        #endregion

        #region Matrix Multiplication

        public static M22f operator *(M22f a, M22f b)
        {
            return new M22f(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M22fEqualityComparer : IEqualityComparer<M22f>
    {
        public static readonly M22fEqualityComparer Default
            = new M22fEqualityComparer();

        #region IEqualityComparer<M22f> Members

        public bool Equals(M22f v0, M22f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M22f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Computes the (signed) angle in radians of a <see cref="M22f"/> rotation matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float GetRotation(this M22f m)
            => Fun.Atan2(m.M10, m.M00);

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float GetScale(this M22f m)
            => (m.C0.Length + m.C1.Length) / 2;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f GetScaleVector(this M22f m)
            => new V2f(m.C0.Length, m.C1.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm1(M22f m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm2(M22f m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMax(M22f m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMin(M22f m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm(this M22f m, float p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(this M22f a, M22f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(this M22f a, M22f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(this M22f a, M22f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(this M22f a, M22f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(this M22f a, M22f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f Transform(this M22f m, V2f v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this M22f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Transform(this M22f m, V4f v)
        {
            return new V4f(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z, v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f TransposedTransform(this M22f m, V2f v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f TransposedTransform(this M22f m, V3f v)
        {
            return new V3f(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f TransposedTransform(this M22f m, V4f v)
        {
            return new V4f(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z, v.W);
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M22f"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static float Minor(this M22f m, int row, int column)
        {
            return m[1 - row, 1 - column];
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V2f Row(this M22f m, int index)
        {
            float* ptr = &m.M00;
            return new V2f(ptr[index * 2], ptr[index * 2 + 1]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V2f Column(this M22f m, int index)
        {
            float* ptr = &m.M00;
            return new V2f(ptr[index], ptr[index + 2]);
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Determinant(M22f m)
            => m.Determinant;

        /// <summary>
        /// Returns the transpose of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f Transposed(M22f m)
            => m.Transposed;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Transpose(this ref M22f m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
        }

        /// <summary>
        /// Returns the inverse of the given matrix. If the matrix is not invertible
        /// M22f.Zero is returned.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f Inverse(M22f m)
            => m.Inverse;

        /// <summary>
        /// Inverts the given matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Invert(this ref M22f m) { return m.LuInvert(); }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M22f m, float epsilon)
        {
            return Fun.ApproximateEquals(m, M22f.Identity, epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M22f m)
            => IsIdentity(m, Constant<float>.PositiveTinyValue);

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M22f m, float epsilon)
        {
            var i = m * m.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M22f m)
            => IsOrthonormal(m, Constant<float>.PositiveTinyValue);

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M22f m, float epsilon)
        {
            var i = m * m.Transposed;
            for (int j = 0; j < 2; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M22f m)
            => IsOrthogonal(m, Constant<float>.PositiveTinyValue);

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M22f"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MinElement(M22f m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M22f"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MaxElement(M22f m)
            => m.MaxElement;

        #endregion

        #region Orthogonalization

        /// <summary>
        /// Orthogonalizes the columns of the given <see cref="M22f"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        public static void Orthogonalize(this ref M22f matrix)
        {
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
        }

        /// <summary>
        /// Orthogonalizes the columns of the given <see cref="M22f"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f Orthogonalized(this M22f matrix)
        {
            M22f m = matrix;
            Orthogonalize(ref m);
            return m;
        }

        /// <summary>
        /// Orthonormalizes the columns of the given <see cref="M22f"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        public static void Orthonormalize(this ref M22f matrix)
        {
            matrix.C0 = matrix.C0.Normalized;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 = matrix.C1.Normalized;
        }

        /// <summary>
        /// Orthonormalizes the columns of the given <see cref="M22f"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f Orthonormalized(this M22f matrix)
        {
            M22f m = matrix;
            Orthonormalize(ref m);
            return m;
        }

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M22f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M22f m, float epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M22f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M22f m, float epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon);

        #endregion

        #region Special Floating Point Value Checks

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNaN(M22f m)
            => m.AnyNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNaN(M22f m)
            => m.AllNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyInfinity(M22f m)
            => m.AnyInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllInfinity(M22f m)
            => m.AllInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyPositiveInfinity(M22f m)
            => m.AnyPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllPositiveInfinity(M22f m)
            => m.AllPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNegativeInfinity(M22f m)
            => m.AnyNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNegativeInfinity(M22f m)
            => m.AllNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(M22f m)
            => m.AnyTiny;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(M22f m)
            => m.AllTiny;

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M22f a, M22f b)
            => ApproximateEquals(a, b, Constant<float>.PositiveTinyValue);

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M22f a, M22f b, float epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M22f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M22f m, float epsilon)
            => Mat.AllTiny(m, epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M22f"/> is smaller than Constant&lt;float&gt;.PositiveTinyValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(M22f m)
            => m.IsTiny;

        #endregion

        #region Special Floating Point Value Checks

        /// <summary>
        /// Returns whether any element of the given <see cref="M22f"/> is NaN.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNaN(M22f v)
            => v.IsNaN;

        /// <summary>
        /// Returns whether any element of the given <see cref="M22f"/> is infinity (positive or negative).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInfinity(M22f v)
            => v.IsInfinity;

        /// <summary>
        /// Returns whether all elements of the given <see cref="M22f"/> are finite (i.e. not NaN and not infinity).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsFinite(M22f v)
            => v.IsFinite;

        #endregion
    }

    public static class IRandomUniformM22fExtensions
    {
        #region IRandomUniform extensions for M22f

        /// <summary>
        /// Uses UniformFloat() to generate the elements of an M22f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f UniformM22f(this IRandomUniform rnd)
        {
            return new M22f(
                rnd.UniformFloat(), rnd.UniformFloat(), 
                rnd.UniformFloat(), rnd.UniformFloat());
        }

        /// <summary>
        /// Uses UniformFloatClosed() to generate the elements of an M22f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f UniformM22fClosed(this IRandomUniform rnd)
        {
            return new M22f(
                rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), 
                rnd.UniformFloatClosed(), rnd.UniformFloatClosed());
        }

        /// <summary>
        /// Uses UniformFloatOpen() to generate the elements of an M22f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22f UniformM22fOpen(this IRandomUniform rnd)
        {
            return new M22f(
                rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), 
                rnd.UniformFloatOpen(), rnd.UniformFloatOpen());
        }

        #endregion
    }

    #endregion

    #region M22d

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M22d : IEquatable<M22d>, IValidity, IMatrix<double>
    {
        [DataMember]
        public double M00, M01;
        [DataMember]
        public double M10, M11;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(double value)
        {
            M00 = value; M01 = 0; 
            M10 = 0; M11 = value; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(
                double m00, double m01, 
                double m10, double m11)
        {
            M00 = m00; M01 = m01; 
            M10 = m10; M11 = m11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M10 = a[2];
            M11 = a[3];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M10 = a[start + 2];
            M11 = a[start + 3];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M22i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M23i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M33i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M34i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M44i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M22l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M23l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M33l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M34l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M44l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M22f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M23f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M33f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M34f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M44f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; 
            M10 = (double)m.M10; M11 = (double)m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M23d m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M33d m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M34d m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M22d(M44d m)
        {
            M00 = m.M00; M01 = m.M01; 
            M10 = m.M10; M11 = m.M11; 
        }

        #endregion

        #region Conversions

        public static explicit operator M22d(M22i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M23i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M33i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M34i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M44i m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M22l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M23l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M33l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M34l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M44l m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M22f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M23f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M33f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M34f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M44f m)
        {
            return new M22d {
                M00 = (double)m.M00, M01 = (double)m.M01, 
                M10 = (double)m.M10, M11 = (double)m.M11, 
            };
        }

        public static explicit operator M22d(M23d m)
        {
            return new M22d {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22d(M33d m)
        {
            return new M22d {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22d(M34d m)
        {
            return new M22d {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22d(M44d m)
        {
            return new M22d {
                M00 = m.M00, M01 = m.M01, 
                M10 = m.M10, M11 = m.M11, 
            };
        }

        public static explicit operator M22d(int[] a)
        {
            return new M22d(
                (double)a[0], (double)a[1], 
                (double)a[2], (double)a[3]);
        }

        public static explicit operator M22d(int[,] a)
        {
            return new M22d(
                (double)a[0, 0], (double)a[0, 1], 
                (double)a[1, 0], (double)a[1, 1]);
        }

        public static explicit operator int[](M22d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, 
                (int)m.M10, (int)m.M11
            };
        }

        public static explicit operator int[,](M22d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01 }, 
                { (int)m.M10, (int)m.M11 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M10;
            array[index + 3] = (int)M11;
        }

        public static explicit operator M22d(long[] a)
        {
            return new M22d(
                (double)a[0], (double)a[1], 
                (double)a[2], (double)a[3]);
        }

        public static explicit operator M22d(long[,] a)
        {
            return new M22d(
                (double)a[0, 0], (double)a[0, 1], 
                (double)a[1, 0], (double)a[1, 1]);
        }

        public static explicit operator long[](M22d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, 
                (long)m.M10, (long)m.M11
            };
        }

        public static explicit operator long[,](M22d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01 }, 
                { (long)m.M10, (long)m.M11 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M10;
            array[index + 3] = (long)M11;
        }

        public static explicit operator M22d(float[] a)
        {
            return new M22d(
                (double)a[0], (double)a[1], 
                (double)a[2], (double)a[3]);
        }

        public static explicit operator M22d(float[,] a)
        {
            return new M22d(
                (double)a[0, 0], (double)a[0, 1], 
                (double)a[1, 0], (double)a[1, 1]);
        }

        public static explicit operator float[](M22d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, 
                (float)m.M10, (float)m.M11
            };
        }

        public static explicit operator float[,](M22d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01 }, 
                { (float)m.M10, (float)m.M11 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M10;
            array[index + 3] = (float)M11;
        }

        public static explicit operator M22d(double[] a)
        {
            return new M22d(
                a[0], a[1], 
                a[2], a[3]);
        }

        public static explicit operator M22d(double[,] a)
        {
            return new M22d(
                a[0, 0], a[0, 1], 
                a[1, 0], a[1, 1]);
        }

        public static explicit operator double[](M22d m)
        {
            return new double[] {
                m.M00, m.M01, 
                m.M10, m.M11
            };
        }

        public static explicit operator double[,](M22d m)
        {
            return new double[,] {
                { m.M00, m.M01 }, 
                { m.M10, m.M11 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M10;
            array[index + 3] = M11;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<double, int> element_fun)
        {
            return new M22i(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M22i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<double, long> element_fun)
        {
            return new M22l(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M22l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<double, float> element_fun)
        {
            return new M22f(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M22f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<double, double> element_fun)
        {
            return new M22d(
                element_fun(M00), element_fun(M01), 
                element_fun(M10), element_fun(M11));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M22d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M22d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1));
        }

        public double[] ToArray()
        {
            var array = new double[4];
            array[0] = M00;
            array[1] = M01;
            array[2] = M10;
            array[3] = M11;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d FromCols(V2d col0, V2d col1)
        {
            return new M22d(
                col0.X, col1.X, 
                col0.Y, col1.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d FromRows(V2d row0, V2d row1)
        {
            return new M22d(
                row0.X, row0.Y, 
                row1.X, row1.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d FromDiagonal(double value)
        {
            return new M22d(
                value, 0, 
                0, value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d FromDiagonal(double m00, double m11)
        {
            return new M22d(
                m00, 0, 
                0, m11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d FromDiagonal(V2d s)
        {
            return new M22d(
                s.X, 0, 
                0, s.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d FromAntiDiagonal(double value)
        {
            return new M22d(
                 0, value, 
                 value, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d FromAntiDiagonal(double m01, double m10)
        {
            return new M22d(
                0, m01, 
                m10, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d FromAntiDiagonal(V2d s)
        {
            return new M22d(
                0, s.X, 
                s.Y, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M22d"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d Scale(double sX, double sY)
            => FromDiagonal(sX, sY);

        /// <summary>
        /// Creates a transformation <see cref="M22d"/> using a <see cref="V2d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d Scale(V2d s)
            => FromDiagonal(s);

        /// <summary>
        /// Creates a transformation <see cref="M22d"/> from a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d Scale(Scale2d s)
        {
            return new M22d(
                s.X, 0, 
                0, s.Y);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in radians.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d Rotation(double angleInRadians)
        {
            var a = Fun.Cos(angleInRadians);
            var b = Fun.Sin(angleInRadians);

            return new M22d(
                 a, -b, 
                 b,  a);
        }

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in degrees.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d RotationInDegrees(double angleInDegrees)
            => Rotation(angleInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 2D rotation matrix from a <see cref="Rot2d"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d Rotation(Rot2d r)
            => (M22d)r;

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d DivideByInt(M22d m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<double> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M10;
                yield return M11;
            }
        }

        public IEnumerable<V2d> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2d> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
            }
        }

        [XmlIgnore]
        public V2d R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2d( M00,  M01); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
            }
        }

        [XmlIgnore]
        public V2d R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2d( M10,  M11); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
            }
        }

        [XmlIgnore]
        public V2d C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2d( M00,  M10); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        [XmlIgnore]
        public V2d C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2d( M01,  M11); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        public V2d Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2d(M00, M11);
        }

        public V2d AntiDiagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2d(M01, M10);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public double MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M10, M11);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public double MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M10, M11);
        }

        public unsafe double this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (double* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (double* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe double this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (double* ptr = &M00) { return ptr[row * 2 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (double* ptr = &M00) { ptr[row * 2 + column] = value; }
            }
        }

        public bool AnyNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNaN(M00) || double.IsNaN(M01) || 
                    double.IsNaN(M10) || double.IsNaN(M11);
            }
        }

        public bool AllNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNaN(M00) && double.IsNaN(M01) && 
                    double.IsNaN(M10) && double.IsNaN(M11);
            }
        }

        public bool AnyInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsInfinity(M00) || double.IsInfinity(M01) || 
                    double.IsInfinity(M10) || double.IsInfinity(M11);
            }
        }

        public bool AllInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsInfinity(M00) && double.IsInfinity(M01) && 
                    double.IsInfinity(M10) && double.IsInfinity(M11);
            }
        }

        public bool AnyPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsPositiveInfinity(M00) || double.IsPositiveInfinity(M01) || 
                    double.IsPositiveInfinity(M10) || double.IsPositiveInfinity(M11);
            }
        }

        public bool AllPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsPositiveInfinity(M00) && double.IsPositiveInfinity(M01) && 
                    double.IsPositiveInfinity(M10) && double.IsPositiveInfinity(M11);
            }
        }

        public bool AnyNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNegativeInfinity(M00) || double.IsNegativeInfinity(M01) || 
                    double.IsNegativeInfinity(M10) || double.IsNegativeInfinity(M11);
            }
        }

        public bool AllNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNegativeInfinity(M00) && double.IsNegativeInfinity(M01) && 
                    double.IsNegativeInfinity(M10) && double.IsNegativeInfinity(M11);
            }
        }

        public bool AnyTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) || Fun.IsTiny(M01) || 
                    Fun.IsTiny(M10) || Fun.IsTiny(M11);
            }
        }

        public bool AllTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) && Fun.IsTiny(M01) && 
                    Fun.IsTiny(M10) && Fun.IsTiny(M11);
            }
        }

        /// <summary>
        /// Returns true if the absolute value of each element of the matrix is smaller than Constant&lt;double&gt;.PositiveTinyValue, false otherwise.
        /// </summary>
        public bool IsTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AllTiny;
        }

        /// <summary>
        /// Returns true if any element of the matrix is NaN, false otherwise.
        /// </summary>
        public bool IsNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyNaN;
        }

        /// <summary>
        /// Returns true if any element of the matrix is infinite (positive or negative), false otherwise.
        /// </summary>
        public bool IsInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyInfinity;
        }

        /// <summary>
        /// Returns whether all elements of the matrix are finite (i.e. not NaN and not infinity).
        /// </summary>
        public bool IsFinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => !(IsInfinity || IsNaN);
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 2;
        public const int ElementCount = 2 * 2;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 2);
        }

        public static M22d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22d(0);
        }

        public static M22d Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M22d(1, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + 
                    Fun.Abs(M10) + Fun.Abs(M11);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + 
                    M10 * M10 + M11 * M11);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator -(M22d m)
        {
            return new M22d(
                -m.M00, -m.M01, 
                -m.M10, -m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  + (M22d a, M22d b)
        {
            return new M22d(
                a.M00 + b.M00, a.M01 + b.M01, 
                a.M10 + b.M10, a.M11 + b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  + (M22d m, double s)
        {
            return new M22d(
                m.M00 + s, m.M01 + s, 
                m.M10 + s, m.M11 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  + (double s, M22d m)
        {
            return new M22d(
                s + m.M00, s + m.M01, 
                s + m.M10, s + m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  - (M22d a, M22d b)
        {
            return new M22d(
                a.M00 - b.M00, a.M01 - b.M01, 
                a.M10 - b.M10, a.M11 - b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  - (M22d m, double s)
        {
            return new M22d(
                m.M00 - s, m.M01 - s, 
                m.M10 - s, m.M11 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  - (double s, M22d m)
        {
            return new M22d(
                s - m.M00, s - m.M01, 
                s - m.M10, s - m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  % (M22d a, M22d b)
        {
            return new M22d(
                a.M00 % b.M00, a.M01 % b.M01, 
                a.M10 % b.M10, a.M11 % b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  % (M22d m, double s)
        {
            return new M22d(
                m.M00 % s, m.M01 % s, 
                m.M10 % s, m.M11 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  % (double s, M22d m)
        {
            return new M22d(
                s % m.M00, s % m.M01, 
                s % m.M10, s % m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  / (M22d a, M22d b)
        {
            return new M22d(
                a.M00 / b.M00, a.M01 / b.M01, 
                a.M10 / b.M10, a.M11 / b.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  / (M22d m, double s)
        {
            return new M22d(
                m.M00 / s, m.M01 / s, 
                m.M10 / s, m.M11 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  / (double s, M22d m)
        {
            return new M22d(
                s / m.M00, s / m.M01, 
                s / m.M10, s / m.M11);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  * (M22d m, double s)
        {
            return new M22d(
                m.M00 * s, m.M01 * s, 
                m.M10 * s, m.M11 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d operator  * (double s, M22d m)
        {
            return new M22d(
                s * m.M00, s * m.M01, 
                s * m.M10, s * m.M11);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M22d matrix with a V2d column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d operator *(M22d m, V2d v)
        {
            return new V2d(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y);
        }

        /// <summary>
        /// Multiplies a V2d row vector with a M22d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d operator *(V2d v, M22d m)
        {
            return new V2d(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M22d a, M22d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M22d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M10 < s && 
                a.M11 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(double s, M22d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M10  && 
                s < a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M22d a, M22d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M22d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M10 > s && 
                a.M11 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(double s, M22d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M10  && 
                s > a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M22d a, M22d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M22d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M10 == s && 
                a.M11 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(double s, M22d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M10  && 
                s == a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M22d a, M22d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M22d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M10 <= s && 
                a.M11 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(double s, M22d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M10  && 
                s <= a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M22d a, M22d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M22d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M10 >= s && 
                a.M11 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(double s, M22d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M10  && 
                s >= a.M11 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M22d a, M22d b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M22d m, double s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(double s, M22d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01),
                        HashCode.GetCombined(M10, M11));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M22d other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && 
                M10.Equals(other.M10) && M11.Equals(other.M11);
        }

        public override bool Equals(object other)
            => (other is M22d o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M22d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M22d.FromRows(
                V2d.Parse(x[0]), 
                V2d.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M22d Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return new M22d(M11, -M10, -M01, M00);
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public double Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public double Determinant
        {
            get
            {
                return M00 * M11 - M10 * M01;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M22d Transposed
        {
            get
            {
                return new M22d {
                    
                    M00 = M00, 
                    M01 = M10, 
                    
                    M10 = M01, 
                    M11 = M11
                };
            }
        }

        private static V2l s_luSize = new V2l(2, 2);
        private static V2l s_luDelta = new V2l(1, 2);

        /// <summary>
        /// Inverts the given matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public unsafe bool LuInvert()
        {
            fixed (M22d* self = &this)
            {
                var lu = this;
                V2i perm;
                if (NumericExtensions.LuFactorize((double*)&lu, 0, 1, 2, (int*)&perm, 2))
                {
                    NumericExtensions.LuInverse((double*)&lu, 0, 1, 2, (int*)&perm, (double*)self, 0, 1, 2, 2);
                    return true;
                }
                return false;
            }
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M22d.Zero is returned.
        /// </summary>
        public unsafe M22d LuInverse()
        {
            var lu = this;
            M22d res;
            V2i perm;
            if (NumericExtensions.LuFactorize((double*)&lu, 0, 1, 2, (int*)&perm, 2))
            {
                NumericExtensions.LuInverse((double*)&lu, 0, 1, 2, (int*)&perm, (double*)&res, 0, 1, 2, 2);
                return res;
            }
            return M22d.Zero;
        }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M22d.Zero is returned.
        /// </summary>
        public M22d Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => LuInverse();
        }

        #endregion

        #region Matrix Multiplication

        public static M22d operator *(M22d a, M22d b)
        {
            return new M22d(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M22dEqualityComparer : IEqualityComparer<M22d>
    {
        public static readonly M22dEqualityComparer Default
            = new M22dEqualityComparer();

        #region IEqualityComparer<M22d> Members

        public bool Equals(M22d v0, M22d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M22d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Computes the (signed) angle in radians of a <see cref="M22d"/> rotation matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetRotation(this M22d m)
            => Fun.Atan2(m.M10, m.M00);

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M22d m)
            => (m.C0.Length + m.C1.Length) / 2;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d GetScaleVector(this M22d m)
            => new V2d(m.C0.Length, m.C1.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm1(M22d m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M22d m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMax(M22d m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMin(M22d m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M22d m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(this M22d a, M22d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M22d a, M22d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M22d a, M22d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(this M22d a, M22d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(this M22d a, M22d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d Transform(this M22d m, V2d v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this M22d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Transform(this M22d m, V4d v)
        {
            return new V4d(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y,
                v.Z, v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d TransposedTransform(this M22d m, V2d v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d TransposedTransform(this M22d m, V3d v)
        {
            return new V3d(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.Z and v.W are not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d TransposedTransform(this M22d m, V4d v)
        {
            return new V4d(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11,
                v.Z, v.W);
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M22d"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static double Minor(this M22d m, int row, int column)
        {
            return m[1 - row, 1 - column];
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V2d Row(this M22d m, int index)
        {
            double* ptr = &m.M00;
            return new V2d(ptr[index * 2], ptr[index * 2 + 1]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V2d Column(this M22d m, int index)
        {
            double* ptr = &m.M00;
            return new V2d(ptr[index], ptr[index + 2]);
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Determinant(M22d m)
            => m.Determinant;

        /// <summary>
        /// Returns the transpose of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d Transposed(M22d m)
            => m.Transposed;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Transpose(this ref M22d m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
        }

        /// <summary>
        /// Returns the inverse of the given matrix. If the matrix is not invertible
        /// M22d.Zero is returned.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d Inverse(M22d m)
            => m.Inverse;

        /// <summary>
        /// Inverts the given matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Invert(this ref M22d m) { return m.LuInvert(); }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M22d m, double epsilon)
        {
            return Fun.ApproximateEquals(m, M22d.Identity, epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M22d m)
            => IsIdentity(m, Constant<double>.PositiveTinyValue);

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M22d m, double epsilon)
        {
            var i = m * m.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M22d m)
            => IsOrthonormal(m, Constant<double>.PositiveTinyValue);

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M22d m, double epsilon)
        {
            var i = m * m.Transposed;
            for (int j = 0; j < 2; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M22d m)
            => IsOrthogonal(m, Constant<double>.PositiveTinyValue);

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M22d"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double MinElement(M22d m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M22d"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double MaxElement(M22d m)
            => m.MaxElement;

        #endregion

        #region Orthogonalization

        /// <summary>
        /// Orthogonalizes the columns of the given <see cref="M22d"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        public static void Orthogonalize(this ref M22d matrix)
        {
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
        }

        /// <summary>
        /// Orthogonalizes the columns of the given <see cref="M22d"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d Orthogonalized(this M22d matrix)
        {
            M22d m = matrix;
            Orthogonalize(ref m);
            return m;
        }

        /// <summary>
        /// Orthonormalizes the columns of the given <see cref="M22d"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        public static void Orthonormalize(this ref M22d matrix)
        {
            matrix.C0 = matrix.C0.Normalized;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 = matrix.C1.Normalized;
        }

        /// <summary>
        /// Orthonormalizes the columns of the given <see cref="M22d"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d Orthonormalized(this M22d matrix)
        {
            M22d m = matrix;
            Orthonormalize(ref m);
            return m;
        }

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M22d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M22d m, double epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M22d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M22d m, double epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon);

        #endregion

        #region Special Floating Point Value Checks

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNaN(M22d m)
            => m.AnyNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNaN(M22d m)
            => m.AllNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyInfinity(M22d m)
            => m.AnyInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllInfinity(M22d m)
            => m.AllInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyPositiveInfinity(M22d m)
            => m.AnyPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllPositiveInfinity(M22d m)
            => m.AllPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNegativeInfinity(M22d m)
            => m.AnyNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNegativeInfinity(M22d m)
            => m.AllNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(M22d m)
            => m.AnyTiny;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(M22d m)
            => m.AllTiny;

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M22d a, M22d b)
            => ApproximateEquals(a, b, Constant<double>.PositiveTinyValue);

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M22d a, M22d b, double epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M22d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M22d m, double epsilon)
            => Mat.AllTiny(m, epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M22d"/> is smaller than Constant&lt;double&gt;.PositiveTinyValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(M22d m)
            => m.IsTiny;

        #endregion

        #region Special Floating Point Value Checks

        /// <summary>
        /// Returns whether any element of the given <see cref="M22d"/> is NaN.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNaN(M22d v)
            => v.IsNaN;

        /// <summary>
        /// Returns whether any element of the given <see cref="M22d"/> is infinity (positive or negative).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInfinity(M22d v)
            => v.IsInfinity;

        /// <summary>
        /// Returns whether all elements of the given <see cref="M22d"/> are finite (i.e. not NaN and not infinity).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsFinite(M22d v)
            => v.IsFinite;

        #endregion
    }

    public static class IRandomUniformM22dExtensions
    {
        #region IRandomUniform extensions for M22d

        /// <summary>
        /// Uses UniformDouble() to generate the elements of an M22d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d UniformM22d(this IRandomUniform rnd)
        {
            return new M22d(
                rnd.UniformDouble(), rnd.UniformDouble(), 
                rnd.UniformDouble(), rnd.UniformDouble());
        }

        /// <summary>
        /// Uses UniformDoubleClosed() to generate the elements of an M22d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d UniformM22dClosed(this IRandomUniform rnd)
        {
            return new M22d(
                rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), 
                rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed());
        }

        /// <summary>
        /// Uses UniformDoubleOpen() to generate the elements of an M22d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d UniformM22dOpen(this IRandomUniform rnd)
        {
            return new M22d(
                rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), 
                rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen());
        }

        /// <summary>
        /// Uses UniformDoubleFull() to generate the elements of an M22d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d UniformM22dFull(this IRandomUniform rnd)
        {
            return new M22d(
                rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), 
                rnd.UniformDoubleFull(), rnd.UniformDoubleFull());
        }

        /// <summary>
        /// Uses UniformDoubleFullClosed() to generate the elements of an M22d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d UniformM22dFullClosed(this IRandomUniform rnd)
        {
            return new M22d(
                rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), 
                rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed());
        }

        /// <summary>
        /// Uses UniformDoubleFullOpen() to generate the elements of an M22d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M22d UniformM22dFullOpen(this IRandomUniform rnd)
        {
            return new M22d(
                rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), 
                rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen());
        }

        #endregion
    }

    #endregion

    #region M23i

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M23i : IEquatable<M23i>, IValidity, IMatrix<double>
    {
        [DataMember]
        public int M00, M01, M02;
        [DataMember]
        public int M10, M11, M12;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(int value)
        {
            M00 = value; M01 = 0; M02 = 0; 
            M10 = 0; M11 = value; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(
                int m00, int m01, int m02, 
                int m10, int m11, int m12)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M22i m, V2i v)
        {
            M00 = m.M00; M01 = m.M01; M02 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = v.Y; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M22i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M33i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M34i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M44i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M22l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M23l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M33l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M34l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M44l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M22f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M23f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M33f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M34f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M44f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M22d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M23d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M33d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M34d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23i(M44d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
        }

        #endregion

        #region Conversions

        public static explicit operator M23i(M22i m)
        {
            return new M23i {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23i(M33i m)
        {
            return new M23i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23i(M34i m)
        {
            return new M23i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23i(M44i m)
        {
            return new M23i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23i(M22l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23i(M23l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M33l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M34l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M44l m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M22f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23i(M23f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M33f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M34f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M44f m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M22d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23i(M23d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M33d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M34d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(M44d m)
        {
            return new M23i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
            };
        }

        public static explicit operator M23i(int[] a)
        {
            return new M23i(
                a[0], a[1], a[2], 
                a[3], a[4], a[5]);
        }

        public static explicit operator M23i(int[,] a)
        {
            return new M23i(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2]);
        }

        public static explicit operator int[](M23i m)
        {
            return new int[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12
            };
        }

        public static explicit operator int[,](M23i m)
        {
            return new int[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
        }

        public static explicit operator M23i(long[] a)
        {
            return new M23i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5]);
        }

        public static explicit operator M23i(long[,] a)
        {
            return new M23i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2]);
        }

        public static explicit operator long[](M23i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12
            };
        }

        public static explicit operator long[,](M23i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
        }

        public static explicit operator M23i(float[] a)
        {
            return new M23i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5]);
        }

        public static explicit operator M23i(float[,] a)
        {
            return new M23i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2]);
        }

        public static explicit operator float[](M23i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12
            };
        }

        public static explicit operator float[,](M23i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
        }

        public static explicit operator M23i(double[] a)
        {
            return new M23i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5]);
        }

        public static explicit operator M23i(double[,] a)
        {
            return new M23i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2]);
        }

        public static explicit operator double[](M23i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12
            };
        }

        public static explicit operator double[,](M23i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<int, int> element_fun)
        {
            return new M23i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M23i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<int, long> element_fun)
        {
            return new M23l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M23l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<int, float> element_fun)
        {
            return new M23f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M23f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<int, double> element_fun)
        {
            return new M23d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M23d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        public int[] ToArray()
        {
            var array = new int[6];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i FromCols(V2i col0, V2i col1, V2i col2)
        {
            return new M23i(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i FromRows(V3i row0, V3i row1)
        {
            return new M23i(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i FromDiagonal(int value)
        {
            return new M23i(
                value, 0, 0, 
                0, value, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i FromDiagonal(int m00, int m11)
        {
            return new M23i(
                m00, 0, 0, 
                0, m11, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i FromDiagonal(V2i s)
        {
            return new M23i(
                s.X, 0, 0, 
                0, s.Y, 0);
        }

        #region Scale

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M23i"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i Translation(int tX, int tY)
        {
            return new M23i(
                1, 0, tX, 
                0, 1, tY);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23i"/> with the translational component given by a <see cref="V2i"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i Translation(V2i t)
        {
            return new M23i(
                1, 0, t.X, 
                0, 1, t.Y);
        }

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i DivideByInt(M23i m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<int> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
            }
        }

        public IEnumerable<V3i> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2i> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        [XmlIgnore]
        public V3i R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3i( M00,  M01,  M02); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        [XmlIgnore]
        public V3i R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3i( M10,  M11,  M12); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        [XmlIgnore]
        public V2i C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2i( M00,  M10); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        [XmlIgnore]
        public V2i C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2i( M01,  M11); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        [XmlIgnore]
        public V2i C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2i( M02,  M12); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
            }
        }

        public V2i Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2i(M00, M11);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public int MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M10, M11, M12);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public int MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M10, M11, M12);
        }

        public unsafe int this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (int* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (int* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe int this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (int* ptr = &M00) { return ptr[row * 3 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (int* ptr = &M00) { ptr[row * 3 + column] = value; }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 3;
        public const int ElementCount = 2 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 3);
        }

        public static M23i Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M23i(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator -(M23i m)
        {
            return new M23i(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator  + (M23i a, M23i b)
        {
            return new M23i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator  + (M23i m, int s)
        {
            return new M23i(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator  + (int s, M23i m)
        {
            return new M23i(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  + (M23i a, M23l b)
        {
            return new M23l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  + (M23i m, long s)
        {
            return new M23l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  + (long s, M23i m)
        {
            return new M23l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  + (M23i a, M23f b)
        {
            return new M23f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  + (M23i m, float s)
        {
            return new M23f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  + (float s, M23i m)
        {
            return new M23f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  + (M23i a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  + (M23i m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  + (double s, M23i m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator  - (M23i a, M23i b)
        {
            return new M23i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator  - (M23i m, int s)
        {
            return new M23i(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator  - (int s, M23i m)
        {
            return new M23i(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  - (M23i a, M23l b)
        {
            return new M23l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  - (M23i m, long s)
        {
            return new M23l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  - (long s, M23i m)
        {
            return new M23l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  - (M23i a, M23f b)
        {
            return new M23f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  - (M23i m, float s)
        {
            return new M23f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  - (float s, M23i m)
        {
            return new M23f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  - (M23i a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  - (M23i m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  - (double s, M23i m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator  % (M23i a, M23i b)
        {
            return new M23i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator  % (M23i m, int s)
        {
            return new M23i(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator  % (int s, M23i m)
        {
            return new M23i(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  % (M23i a, M23l b)
        {
            return new M23l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  % (M23i m, long s)
        {
            return new M23l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  % (long s, M23i m)
        {
            return new M23l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  % (M23i a, M23f b)
        {
            return new M23f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  % (M23i m, float s)
        {
            return new M23f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  % (float s, M23i m)
        {
            return new M23f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  % (M23i a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  % (M23i m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  % (double s, M23i m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator  / (M23i a, M23i b)
        {
            return new M23i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator  / (M23i m, int s)
        {
            return new M23i(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator  / (int s, M23i m)
        {
            return new M23i(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  / (M23i a, M23l b)
        {
            return new M23l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  / (M23i m, long s)
        {
            return new M23l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  / (long s, M23i m)
        {
            return new M23l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  / (M23i a, M23f b)
        {
            return new M23f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  / (M23i m, float s)
        {
            return new M23f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  / (float s, M23i m)
        {
            return new M23f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  / (M23i a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  / (M23i m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  / (double s, M23i m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator  * (M23i m, int s)
        {
            return new M23i(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator  * (int s, M23i m)
        {
            return new M23i(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  * (M23i m, long s)
        {
            return new M23l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  * (long s, M23i m)
        {
            return new M23l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  * (M23i m, float s)
        {
            return new M23f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  * (float s, M23i m)
        {
            return new M23f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  * (M23i m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  * (double s, M23i m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        #endregion

        #region Bitwise Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator ~(M23i m)
        {
            return new M23i(
                ~m.M00, ~m.M01, ~m.M02, 
                ~m.M10, ~m.M11, ~m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator <<(M23i a, int s)
        {
            return new M23i(
                a.M00 << s, a.M01 << s, a.M02 << s, 
                a.M10 << s, a.M11 << s, a.M12 << s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator >>(M23i a, int s)
        {
            return new M23i(
                a.M00 >> s, a.M01 >> s, a.M02 >> s, 
                a.M10 >> s, a.M11 >> s, a.M12 >> s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator &(M23i a, M23i b)
        {
            return new M23i(
                a.M00 & b.M00, a.M01 & b.M01, a.M02 & b.M02, 
                a.M10 & b.M10, a.M11 & b.M11, a.M12 & b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator &(M23i a, int s)
        {
            return new M23i(
                a.M00 & s, a.M01 & s, a.M02 & s, 
                a.M10 & s, a.M11 & s, a.M12 & s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator &(int s, M23i a)
        {
            return new M23i(
                s & a.M00, s & a.M01, s & a.M02, 
                s & a.M10, s & a.M11, s & a.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator |(M23i a, M23i b)
        {
            return new M23i(
                a.M00 | b.M00, a.M01 | b.M01, a.M02 | b.M02, 
                a.M10 | b.M10, a.M11 | b.M11, a.M12 | b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator |(M23i a, int s)
        {
            return new M23i(
                a.M00 | s, a.M01 | s, a.M02 | s, 
                a.M10 | s, a.M11 | s, a.M12 | s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator |(int s, M23i a)
        {
            return new M23i(
                s | a.M00, s | a.M01, s | a.M02, 
                s | a.M10, s | a.M11, s | a.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator ^(M23i a, M23i b)
        {
            return new M23i(
                a.M00 ^ b.M00, a.M01 ^ b.M01, a.M02 ^ b.M02, 
                a.M10 ^ b.M10, a.M11 ^ b.M11, a.M12 ^ b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator ^(M23i a, int s)
        {
            return new M23i(
                a.M00 ^ s, a.M01 ^ s, a.M02 ^ s, 
                a.M10 ^ s, a.M11 ^ s, a.M12 ^ s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i operator ^(int s, M23i a)
        {
            return new M23i(
                s ^ a.M00, s ^ a.M01, s ^ a.M02, 
                s ^ a.M10, s ^ a.M11, s ^ a.M12);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M23i matrix with a V3i column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i operator *(M23i m, V3i v)
        {
            return new V2i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        /// <summary>
        /// Multiplies a V2i row vector with a M23i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i operator *(V2i v, M23i m)
        {
            return new V3i(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11, 
                v.X * m.M02 + v.Y * m.M12);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M23i a, M23i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M23i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(int s, M23i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M23i a, M23i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M23i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(int s, M23i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M23i a, M23i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M23i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(int s, M23i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M23i a, M23i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M23i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(int s, M23i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M23i a, M23i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M23i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(int s, M23i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M23i a, M23i b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M23i m, int s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(int s, M23i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02),
                        HashCode.GetCombined(M10, M11, M12));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M23i other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12);
        }

        public override bool Equals(object other)
            => (other is M23i o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M23i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M23i.FromRows(
                V3i.Parse(x[0]), 
                V3i.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M23i operator *(M22i a, M23i b)
        {
            return new M23i(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23i operator *(M23i a, M33i b)
        {
            return new M23i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M23iEqualityComparer : IEqualityComparer<M23i>
    {
        public static readonly M23iEqualityComparer Default
            = new M23iEqualityComparer();

        #region IEqualityComparer<M23i> Members

        public bool Equals(M23i v0, M23i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M23i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M23i m)
            => (m.C0.Length + m.C1.Length) / 2;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d GetScaleVector(this M23i m)
            => new V2d(m.C0.Length, m.C1.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Norm1(M23i m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M23i m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMax(M23i m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMin(M23i m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M23i m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(this M23i a, M23i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M23i a, M23i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M23i a, M23i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(this M23i a, M23i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(this M23i a, M23i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2i Transform(this M23i m, V3i v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i Transform(this M23i m, V4i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i TransposedTransform(this M23i m, V2i v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2i TransformDir(this M23i m, V2i v)
        {
            return new V2i(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// </summary>
        public static V2i TransformPos(this M23i m, V2i p)
        {
            return new V2i(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Multiplies two <see cref="M23i"/> matrices as 3x3 matrices.
        /// </summary>
        public static M23i MultiplyAffine(this M23i a, M23i b)
        {
            return new M23i(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12
            );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3i Row(this M23i m, int index)
        {
            int* ptr = &m.M00;
            return new V3i(ptr[index * 3], ptr[index * 3 + 1], ptr[index * 3 + 2]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V2i Column(this M23i m, int index)
        {
            int* ptr = &m.M00;
            return new V2i(ptr[index], ptr[index + 3]);
        }

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M23i"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int MinElement(M23i m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M23i"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int MaxElement(M23i m)
            => m.MaxElement;

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M23i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M23i m, int epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M23i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M23i m, int epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M23i a, M23i b, int epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M23i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M23i m, int epsilon)
            => Mat.AllTiny(m, epsilon);

        #endregion
    }

    public static class IRandomUniformM23iExtensions
    {
        #region IRandomUniform extensions for M23i

        /// <summary>
        /// Uses UniformInt() to generate the elements of an M23i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i UniformM23i(this IRandomUniform rnd)
        {
            return new M23i(
                rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), 
                rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt());
        }

        /// <summary>
        /// Uses UniformIntNonZero() to generate the elements of an M23i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i UniformM23iNonZero(this IRandomUniform rnd)
        {
            return new M23i(
                rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), 
                rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero());
        }

        /// <summary>
        /// Uses UniformInt(int) to generate the elements of an M23i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i UniformM23i(this IRandomUniform rnd, int size)
        {
            return new M23i(
                rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), 
                rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size));
        }

        /// <summary>
        /// Uses UniformInt(int) to generate the elements of an M23i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23i UniformM23i(this IRandomUniform rnd, M23i size)
        {
            return new M23i(
                rnd.UniformInt(size.M00), rnd.UniformInt(size.M01), rnd.UniformInt(size.M02), 
                rnd.UniformInt(size.M10), rnd.UniformInt(size.M11), rnd.UniformInt(size.M12));
        }

        #endregion
    }

    #endregion

    #region M23l

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M23l : IEquatable<M23l>, IValidity, IMatrix<double>
    {
        [DataMember]
        public long M00, M01, M02;
        [DataMember]
        public long M10, M11, M12;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(long value)
        {
            M00 = value; M01 = 0; M02 = 0; 
            M10 = 0; M11 = value; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(
                long m00, long m01, long m02, 
                long m10, long m11, long m12)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M22l m, V2l v)
        {
            M00 = m.M00; M01 = m.M01; M02 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = v.Y; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M22i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M23i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M33i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M34i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M44i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M22l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M33l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M34l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M44l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M22f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M23f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M33f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M34f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M44f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M22d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M23d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M33d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M34d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23l(M44d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
        }

        #endregion

        #region Conversions

        public static explicit operator M23l(M22i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23l(M23i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M33i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M34i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M44i m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M22l m)
        {
            return new M23l {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23l(M33l m)
        {
            return new M23l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23l(M34l m)
        {
            return new M23l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23l(M44l m)
        {
            return new M23l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23l(M22f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23l(M23f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M33f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M34f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M44f m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M22d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23l(M23d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M33d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M34d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(M44d m)
        {
            return new M23l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
            };
        }

        public static explicit operator M23l(int[] a)
        {
            return new M23l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5]);
        }

        public static explicit operator M23l(int[,] a)
        {
            return new M23l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2]);
        }

        public static explicit operator int[](M23l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12
            };
        }

        public static explicit operator int[,](M23l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
        }

        public static explicit operator M23l(long[] a)
        {
            return new M23l(
                a[0], a[1], a[2], 
                a[3], a[4], a[5]);
        }

        public static explicit operator M23l(long[,] a)
        {
            return new M23l(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2]);
        }

        public static explicit operator long[](M23l m)
        {
            return new long[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12
            };
        }

        public static explicit operator long[,](M23l m)
        {
            return new long[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
        }

        public static explicit operator M23l(float[] a)
        {
            return new M23l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5]);
        }

        public static explicit operator M23l(float[,] a)
        {
            return new M23l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2]);
        }

        public static explicit operator float[](M23l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12
            };
        }

        public static explicit operator float[,](M23l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
        }

        public static explicit operator M23l(double[] a)
        {
            return new M23l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5]);
        }

        public static explicit operator M23l(double[,] a)
        {
            return new M23l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2]);
        }

        public static explicit operator double[](M23l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12
            };
        }

        public static explicit operator double[,](M23l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<long, int> element_fun)
        {
            return new M23i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M23i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<long, long> element_fun)
        {
            return new M23l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M23l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<long, float> element_fun)
        {
            return new M23f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M23f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<long, double> element_fun)
        {
            return new M23d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M23d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        public long[] ToArray()
        {
            var array = new long[6];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l FromCols(V2l col0, V2l col1, V2l col2)
        {
            return new M23l(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l FromRows(V3l row0, V3l row1)
        {
            return new M23l(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l FromDiagonal(long value)
        {
            return new M23l(
                value, 0, 0, 
                0, value, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l FromDiagonal(long m00, long m11)
        {
            return new M23l(
                m00, 0, 0, 
                0, m11, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l FromDiagonal(V2l s)
        {
            return new M23l(
                s.X, 0, 0, 
                0, s.Y, 0);
        }

        #region Scale

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M23l"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l Translation(long tX, long tY)
        {
            return new M23l(
                1, 0, tX, 
                0, 1, tY);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23l"/> with the translational component given by a <see cref="V2l"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l Translation(V2l t)
        {
            return new M23l(
                1, 0, t.X, 
                0, 1, t.Y);
        }

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l DivideByInt(M23l m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<long> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
            }
        }

        public IEnumerable<V3l> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2l> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        [XmlIgnore]
        public V3l R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3l( M00,  M01,  M02); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        [XmlIgnore]
        public V3l R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3l( M10,  M11,  M12); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        [XmlIgnore]
        public V2l C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2l( M00,  M10); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        [XmlIgnore]
        public V2l C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2l( M01,  M11); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        [XmlIgnore]
        public V2l C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2l( M02,  M12); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
            }
        }

        public V2l Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(M00, M11);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public long MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M10, M11, M12);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public long MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M10, M11, M12);
        }

        public unsafe long this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (long* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (long* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe long this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (long* ptr = &M00) { return ptr[row * 3 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (long* ptr = &M00) { ptr[row * 3 + column] = value; }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 3;
        public const int ElementCount = 2 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 3);
        }

        public static M23l Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M23l(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator -(M23l m)
        {
            return new M23l(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  + (M23l a, M23l b)
        {
            return new M23l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  + (M23l m, long s)
        {
            return new M23l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  + (long s, M23l m)
        {
            return new M23l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  + (M23l a, M23f b)
        {
            return new M23f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  + (M23l m, float s)
        {
            return new M23f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  + (float s, M23l m)
        {
            return new M23f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  + (M23l a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  + (M23l m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  + (double s, M23l m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  - (M23l a, M23l b)
        {
            return new M23l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  - (M23l m, long s)
        {
            return new M23l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  - (long s, M23l m)
        {
            return new M23l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  - (M23l a, M23f b)
        {
            return new M23f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  - (M23l m, float s)
        {
            return new M23f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  - (float s, M23l m)
        {
            return new M23f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  - (M23l a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  - (M23l m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  - (double s, M23l m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  % (M23l a, M23l b)
        {
            return new M23l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  % (M23l m, long s)
        {
            return new M23l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  % (long s, M23l m)
        {
            return new M23l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  % (M23l a, M23f b)
        {
            return new M23f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  % (M23l m, float s)
        {
            return new M23f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  % (float s, M23l m)
        {
            return new M23f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  % (M23l a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  % (M23l m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  % (double s, M23l m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  / (M23l a, M23l b)
        {
            return new M23l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  / (M23l m, long s)
        {
            return new M23l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  / (long s, M23l m)
        {
            return new M23l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  / (M23l a, M23f b)
        {
            return new M23f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  / (M23l m, float s)
        {
            return new M23f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  / (float s, M23l m)
        {
            return new M23f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  / (M23l a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  / (M23l m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  / (double s, M23l m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  * (M23l m, long s)
        {
            return new M23l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator  * (long s, M23l m)
        {
            return new M23l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  * (M23l m, float s)
        {
            return new M23f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  * (float s, M23l m)
        {
            return new M23f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  * (M23l m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  * (double s, M23l m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        #endregion

        #region Bitwise Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator ~(M23l m)
        {
            return new M23l(
                ~m.M00, ~m.M01, ~m.M02, 
                ~m.M10, ~m.M11, ~m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator <<(M23l a, int s)
        {
            return new M23l(
                a.M00 << s, a.M01 << s, a.M02 << s, 
                a.M10 << s, a.M11 << s, a.M12 << s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator >>(M23l a, int s)
        {
            return new M23l(
                a.M00 >> s, a.M01 >> s, a.M02 >> s, 
                a.M10 >> s, a.M11 >> s, a.M12 >> s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator &(M23l a, M23l b)
        {
            return new M23l(
                a.M00 & b.M00, a.M01 & b.M01, a.M02 & b.M02, 
                a.M10 & b.M10, a.M11 & b.M11, a.M12 & b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator &(M23l a, long s)
        {
            return new M23l(
                a.M00 & s, a.M01 & s, a.M02 & s, 
                a.M10 & s, a.M11 & s, a.M12 & s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator &(long s, M23l a)
        {
            return new M23l(
                s & a.M00, s & a.M01, s & a.M02, 
                s & a.M10, s & a.M11, s & a.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator |(M23l a, M23l b)
        {
            return new M23l(
                a.M00 | b.M00, a.M01 | b.M01, a.M02 | b.M02, 
                a.M10 | b.M10, a.M11 | b.M11, a.M12 | b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator |(M23l a, long s)
        {
            return new M23l(
                a.M00 | s, a.M01 | s, a.M02 | s, 
                a.M10 | s, a.M11 | s, a.M12 | s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator |(long s, M23l a)
        {
            return new M23l(
                s | a.M00, s | a.M01, s | a.M02, 
                s | a.M10, s | a.M11, s | a.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator ^(M23l a, M23l b)
        {
            return new M23l(
                a.M00 ^ b.M00, a.M01 ^ b.M01, a.M02 ^ b.M02, 
                a.M10 ^ b.M10, a.M11 ^ b.M11, a.M12 ^ b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator ^(M23l a, long s)
        {
            return new M23l(
                a.M00 ^ s, a.M01 ^ s, a.M02 ^ s, 
                a.M10 ^ s, a.M11 ^ s, a.M12 ^ s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l operator ^(long s, M23l a)
        {
            return new M23l(
                s ^ a.M00, s ^ a.M01, s ^ a.M02, 
                s ^ a.M10, s ^ a.M11, s ^ a.M12);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M23l matrix with a V3l column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l operator *(M23l m, V3l v)
        {
            return new V2l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        /// <summary>
        /// Multiplies a V2l row vector with a M23l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l operator *(V2l v, M23l m)
        {
            return new V3l(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11, 
                v.X * m.M02 + v.Y * m.M12);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M23l a, M23l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M23l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(long s, M23l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M23l a, M23l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M23l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(long s, M23l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M23l a, M23l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M23l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(long s, M23l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M23l a, M23l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M23l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(long s, M23l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M23l a, M23l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M23l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(long s, M23l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M23l a, M23l b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M23l m, long s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(long s, M23l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02),
                        HashCode.GetCombined(M10, M11, M12));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M23l other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12);
        }

        public override bool Equals(object other)
            => (other is M23l o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M23l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M23l.FromRows(
                V3l.Parse(x[0]), 
                V3l.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M23l operator *(M22l a, M23l b)
        {
            return new M23l(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23l operator *(M23l a, M33l b)
        {
            return new M23l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M23lEqualityComparer : IEqualityComparer<M23l>
    {
        public static readonly M23lEqualityComparer Default
            = new M23lEqualityComparer();

        #region IEqualityComparer<M23l> Members

        public bool Equals(M23l v0, M23l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M23l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M23l m)
            => (m.C0.Length + m.C1.Length) / 2;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d GetScaleVector(this M23l m)
            => new V2d(m.C0.Length, m.C1.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Norm1(M23l m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M23l m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMax(M23l m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMin(M23l m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M23l m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(this M23l a, M23l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M23l a, M23l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M23l a, M23l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(this M23l a, M23l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(this M23l a, M23l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2l Transform(this M23l m, V3l v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l Transform(this M23l m, V4l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l TransposedTransform(this M23l m, V2l v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2l TransformDir(this M23l m, V2l v)
        {
            return new V2l(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// </summary>
        public static V2l TransformPos(this M23l m, V2l p)
        {
            return new V2l(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Multiplies two <see cref="M23l"/> matrices as 3x3 matrices.
        /// </summary>
        public static M23l MultiplyAffine(this M23l a, M23l b)
        {
            return new M23l(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12
            );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3l Row(this M23l m, int index)
        {
            long* ptr = &m.M00;
            return new V3l(ptr[index * 3], ptr[index * 3 + 1], ptr[index * 3 + 2]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V2l Column(this M23l m, int index)
        {
            long* ptr = &m.M00;
            return new V2l(ptr[index], ptr[index + 3]);
        }

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M23l"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long MinElement(M23l m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M23l"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long MaxElement(M23l m)
            => m.MaxElement;

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M23l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M23l m, long epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M23l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M23l m, long epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M23l a, M23l b, long epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M23l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M23l m, long epsilon)
            => Mat.AllTiny(m, epsilon);

        #endregion
    }

    public static class IRandomUniformM23lExtensions
    {
        #region IRandomUniform extensions for M23l

        /// <summary>
        /// Uses UniformLong() to generate the elements of an M23l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l UniformM23l(this IRandomUniform rnd)
        {
            return new M23l(
                rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), 
                rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong());
        }

        /// <summary>
        /// Uses UniformLongNonZero() to generate the elements of an M23l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l UniformM23lNonZero(this IRandomUniform rnd)
        {
            return new M23l(
                rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), 
                rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero());
        }

        /// <summary>
        /// Uses UniformLong(long) to generate the elements of an M23l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l UniformM23l(this IRandomUniform rnd, long size)
        {
            return new M23l(
                rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), 
                rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size));
        }

        /// <summary>
        /// Uses UniformLong(long) to generate the elements of an M23l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23l UniformM23l(this IRandomUniform rnd, M23l size)
        {
            return new M23l(
                rnd.UniformLong(size.M00), rnd.UniformLong(size.M01), rnd.UniformLong(size.M02), 
                rnd.UniformLong(size.M10), rnd.UniformLong(size.M11), rnd.UniformLong(size.M12));
        }

        #endregion
    }

    #endregion

    #region M23f

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M23f : IEquatable<M23f>, IValidity, IMatrix<double>
    {
        [DataMember]
        public float M00, M01, M02;
        [DataMember]
        public float M10, M11, M12;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(float value)
        {
            M00 = value; M01 = 0; M02 = 0; 
            M10 = 0; M11 = value; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(
                float m00, float m01, float m02, 
                float m10, float m11, float m12)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M22f m, V2f v)
        {
            M00 = m.M00; M01 = m.M01; M02 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = v.Y; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M22i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M23i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M33i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M34i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M44i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M22l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M23l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M33l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M34l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M44l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M22f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M33f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M34f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M44f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M22d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M23d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M33d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M34d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23f(M44d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
        }

        #endregion

        #region Conversions

        public static explicit operator M23f(M22i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23f(M23i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M33i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M34i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M44i m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M22l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23f(M23l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M33l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M34l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M44l m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M22f m)
        {
            return new M23f {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23f(M33f m)
        {
            return new M23f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23f(M34f m)
        {
            return new M23f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23f(M44f m)
        {
            return new M23f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23f(M22d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23f(M23d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M33d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M34d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(M44d m)
        {
            return new M23f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
            };
        }

        public static explicit operator M23f(int[] a)
        {
            return new M23f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5]);
        }

        public static explicit operator M23f(int[,] a)
        {
            return new M23f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2]);
        }

        public static explicit operator int[](M23f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12
            };
        }

        public static explicit operator int[,](M23f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
        }

        public static explicit operator M23f(long[] a)
        {
            return new M23f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5]);
        }

        public static explicit operator M23f(long[,] a)
        {
            return new M23f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2]);
        }

        public static explicit operator long[](M23f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12
            };
        }

        public static explicit operator long[,](M23f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
        }

        public static explicit operator M23f(float[] a)
        {
            return new M23f(
                a[0], a[1], a[2], 
                a[3], a[4], a[5]);
        }

        public static explicit operator M23f(float[,] a)
        {
            return new M23f(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2]);
        }

        public static explicit operator float[](M23f m)
        {
            return new float[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12
            };
        }

        public static explicit operator float[,](M23f m)
        {
            return new float[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
        }

        public static explicit operator M23f(double[] a)
        {
            return new M23f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5]);
        }

        public static explicit operator M23f(double[,] a)
        {
            return new M23f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2]);
        }

        public static explicit operator double[](M23f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12
            };
        }

        public static explicit operator double[,](M23f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<float, int> element_fun)
        {
            return new M23i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M23i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<float, long> element_fun)
        {
            return new M23l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M23l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<float, float> element_fun)
        {
            return new M23f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M23f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<float, double> element_fun)
        {
            return new M23d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M23d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        public float[] ToArray()
        {
            var array = new float[6];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f FromCols(V2f col0, V2f col1, V2f col2)
        {
            return new M23f(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f FromRows(V3f row0, V3f row1)
        {
            return new M23f(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f FromDiagonal(float value)
        {
            return new M23f(
                value, 0, 0, 
                0, value, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f FromDiagonal(float m00, float m11)
        {
            return new M23f(
                m00, 0, 0, 
                0, m11, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f FromDiagonal(V2f s)
        {
            return new M23f(
                s.X, 0, 0, 
                0, s.Y, 0);
        }

        #region Scale

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M23f"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f Translation(float tX, float tY)
        {
            return new M23f(
                1, 0, tX, 
                0, 1, tY);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23f"/> with the translational component given by a <see cref="V2f"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f Translation(V2f t)
        {
            return new M23f(
                1, 0, t.X, 
                0, 1, t.Y);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23f"/> from a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f Translation(Shift2f s)
        {
            return new M23f(
                1, 0, s.X, 
                0, 1, s.Y);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in radians.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f Rotation(float angleInRadians)
        {
            var a = Fun.Cos(angleInRadians);
            var b = Fun.Sin(angleInRadians);

            return new M23f(
                 a, -b,  0, 
                 b,  a,  0);
        }

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in degrees.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f RotationInDegrees(float angleInDegrees)
            => Rotation(angleInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 2D rotation matrix from a <see cref="Rot2f"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f Rotation(Rot2f r)
            => (M23f)r;

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f DivideByInt(M23f m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<float> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
            }
        }

        public IEnumerable<V3f> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2f> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        [XmlIgnore]
        public V3f R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3f( M00,  M01,  M02); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        [XmlIgnore]
        public V3f R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3f( M10,  M11,  M12); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        [XmlIgnore]
        public V2f C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2f( M00,  M10); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        [XmlIgnore]
        public V2f C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2f( M01,  M11); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        [XmlIgnore]
        public V2f C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2f( M02,  M12); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
            }
        }

        public V2f Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2f(M00, M11);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public float MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M10, M11, M12);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public float MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M10, M11, M12);
        }

        public unsafe float this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (float* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (float* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe float this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (float* ptr = &M00) { return ptr[row * 3 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (float* ptr = &M00) { ptr[row * 3 + column] = value; }
            }
        }

        public bool AnyNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNaN(M00) || float.IsNaN(M01) || float.IsNaN(M02) || 
                    float.IsNaN(M10) || float.IsNaN(M11) || float.IsNaN(M12);
            }
        }

        public bool AllNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNaN(M00) && float.IsNaN(M01) && float.IsNaN(M02) && 
                    float.IsNaN(M10) && float.IsNaN(M11) && float.IsNaN(M12);
            }
        }

        public bool AnyInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsInfinity(M00) || float.IsInfinity(M01) || float.IsInfinity(M02) || 
                    float.IsInfinity(M10) || float.IsInfinity(M11) || float.IsInfinity(M12);
            }
        }

        public bool AllInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsInfinity(M00) && float.IsInfinity(M01) && float.IsInfinity(M02) && 
                    float.IsInfinity(M10) && float.IsInfinity(M11) && float.IsInfinity(M12);
            }
        }

        public bool AnyPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsPositiveInfinity(M00) || float.IsPositiveInfinity(M01) || float.IsPositiveInfinity(M02) || 
                    float.IsPositiveInfinity(M10) || float.IsPositiveInfinity(M11) || float.IsPositiveInfinity(M12);
            }
        }

        public bool AllPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsPositiveInfinity(M00) && float.IsPositiveInfinity(M01) && float.IsPositiveInfinity(M02) && 
                    float.IsPositiveInfinity(M10) && float.IsPositiveInfinity(M11) && float.IsPositiveInfinity(M12);
            }
        }

        public bool AnyNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNegativeInfinity(M00) || float.IsNegativeInfinity(M01) || float.IsNegativeInfinity(M02) || 
                    float.IsNegativeInfinity(M10) || float.IsNegativeInfinity(M11) || float.IsNegativeInfinity(M12);
            }
        }

        public bool AllNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNegativeInfinity(M00) && float.IsNegativeInfinity(M01) && float.IsNegativeInfinity(M02) && 
                    float.IsNegativeInfinity(M10) && float.IsNegativeInfinity(M11) && float.IsNegativeInfinity(M12);
            }
        }

        public bool AnyTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) || Fun.IsTiny(M01) || Fun.IsTiny(M02) || 
                    Fun.IsTiny(M10) || Fun.IsTiny(M11) || Fun.IsTiny(M12);
            }
        }

        public bool AllTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) && Fun.IsTiny(M01) && Fun.IsTiny(M02) && 
                    Fun.IsTiny(M10) && Fun.IsTiny(M11) && Fun.IsTiny(M12);
            }
        }

        /// <summary>
        /// Returns true if the absolute value of each element of the matrix is smaller than Constant&lt;float&gt;.PositiveTinyValue, false otherwise.
        /// </summary>
        public bool IsTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AllTiny;
        }

        /// <summary>
        /// Returns true if any element of the matrix is NaN, false otherwise.
        /// </summary>
        public bool IsNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyNaN;
        }

        /// <summary>
        /// Returns true if any element of the matrix is infinite (positive or negative), false otherwise.
        /// </summary>
        public bool IsInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyInfinity;
        }

        /// <summary>
        /// Returns whether all elements of the matrix are finite (i.e. not NaN and not infinity).
        /// </summary>
        public bool IsFinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => !(IsInfinity || IsNaN);
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 3;
        public const int ElementCount = 2 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 3);
        }

        public static M23f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M23f(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator -(M23f m)
        {
            return new M23f(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  + (M23f a, M23f b)
        {
            return new M23f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  + (M23f m, float s)
        {
            return new M23f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  + (float s, M23f m)
        {
            return new M23f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  + (M23f a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  + (M23f m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  + (double s, M23f m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  - (M23f a, M23f b)
        {
            return new M23f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  - (M23f m, float s)
        {
            return new M23f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  - (float s, M23f m)
        {
            return new M23f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  - (M23f a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  - (M23f m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  - (double s, M23f m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  % (M23f a, M23f b)
        {
            return new M23f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  % (M23f m, float s)
        {
            return new M23f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  % (float s, M23f m)
        {
            return new M23f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  % (M23f a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  % (M23f m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  % (double s, M23f m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  / (M23f a, M23f b)
        {
            return new M23f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  / (M23f m, float s)
        {
            return new M23f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  / (float s, M23f m)
        {
            return new M23f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  / (M23f a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  / (M23f m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  / (double s, M23f m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  * (M23f m, float s)
        {
            return new M23f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f operator  * (float s, M23f m)
        {
            return new M23f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  * (M23f m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  * (double s, M23f m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M23f matrix with a V3f column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f operator *(M23f m, V3f v)
        {
            return new V2f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        /// <summary>
        /// Multiplies a V2f row vector with a M23f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f operator *(V2f v, M23f m)
        {
            return new V3f(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11, 
                v.X * m.M02 + v.Y * m.M12);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M23f a, M23f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M23f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(float s, M23f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M23f a, M23f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M23f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(float s, M23f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M23f a, M23f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M23f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(float s, M23f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M23f a, M23f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M23f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(float s, M23f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M23f a, M23f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M23f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(float s, M23f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M23f a, M23f b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M23f m, float s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(float s, M23f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02),
                        HashCode.GetCombined(M10, M11, M12));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M23f other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12);
        }

        public override bool Equals(object other)
            => (other is M23f o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M23f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M23f.FromRows(
                V3f.Parse(x[0]), 
                V3f.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M23f operator *(M22f a, M23f b)
        {
            return new M23f(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23f operator *(M23f a, M33f b)
        {
            return new M23f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M23fEqualityComparer : IEqualityComparer<M23f>
    {
        public static readonly M23fEqualityComparer Default
            = new M23fEqualityComparer();

        #region IEqualityComparer<M23f> Members

        public bool Equals(M23f v0, M23f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M23f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Computes the (signed) angle in radians of a <see cref="M23f"/> rotation matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float GetRotation(this M23f m)
            => Fun.Atan2(m.M10, m.M00);

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float GetScale(this M23f m)
            => (m.C0.Length + m.C1.Length) / 2;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f GetScaleVector(this M23f m)
            => new V2f(m.C0.Length, m.C1.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm1(M23f m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm2(M23f m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMax(M23f m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMin(M23f m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm(this M23f m, float p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(this M23f a, M23f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(this M23f a, M23f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(this M23f a, M23f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(this M23f a, M23f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(this M23f a, M23f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f Transform(this M23f m, V3f v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this M23f m, V4f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f TransposedTransform(this M23f m, V2f v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2f TransformDir(this M23f m, V2f v)
        {
            return new V2f(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// </summary>
        public static V2f TransformPos(this M23f m, V2f p)
        {
            return new V2f(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Multiplies two <see cref="M23f"/> matrices as 3x3 matrices.
        /// </summary>
        public static M23f MultiplyAffine(this M23f a, M23f b)
        {
            return new M23f(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12
            );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3f Row(this M23f m, int index)
        {
            float* ptr = &m.M00;
            return new V3f(ptr[index * 3], ptr[index * 3 + 1], ptr[index * 3 + 2]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V2f Column(this M23f m, int index)
        {
            float* ptr = &m.M00;
            return new V2f(ptr[index], ptr[index + 3]);
        }

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M23f"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MinElement(M23f m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M23f"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MaxElement(M23f m)
            => m.MaxElement;

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M23f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M23f m, float epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M23f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M23f m, float epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon);

        #endregion

        #region Special Floating Point Value Checks

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNaN(M23f m)
            => m.AnyNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNaN(M23f m)
            => m.AllNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyInfinity(M23f m)
            => m.AnyInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllInfinity(M23f m)
            => m.AllInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyPositiveInfinity(M23f m)
            => m.AnyPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllPositiveInfinity(M23f m)
            => m.AllPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNegativeInfinity(M23f m)
            => m.AnyNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNegativeInfinity(M23f m)
            => m.AllNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(M23f m)
            => m.AnyTiny;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(M23f m)
            => m.AllTiny;

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M23f a, M23f b)
            => ApproximateEquals(a, b, Constant<float>.PositiveTinyValue);

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M23f a, M23f b, float epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M23f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M23f m, float epsilon)
            => Mat.AllTiny(m, epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M23f"/> is smaller than Constant&lt;float&gt;.PositiveTinyValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(M23f m)
            => m.IsTiny;

        #endregion

        #region Special Floating Point Value Checks

        /// <summary>
        /// Returns whether any element of the given <see cref="M23f"/> is NaN.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNaN(M23f v)
            => v.IsNaN;

        /// <summary>
        /// Returns whether any element of the given <see cref="M23f"/> is infinity (positive or negative).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInfinity(M23f v)
            => v.IsInfinity;

        /// <summary>
        /// Returns whether all elements of the given <see cref="M23f"/> are finite (i.e. not NaN and not infinity).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsFinite(M23f v)
            => v.IsFinite;

        #endregion
    }

    public static class IRandomUniformM23fExtensions
    {
        #region IRandomUniform extensions for M23f

        /// <summary>
        /// Uses UniformFloat() to generate the elements of an M23f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f UniformM23f(this IRandomUniform rnd)
        {
            return new M23f(
                rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), 
                rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat());
        }

        /// <summary>
        /// Uses UniformFloatClosed() to generate the elements of an M23f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f UniformM23fClosed(this IRandomUniform rnd)
        {
            return new M23f(
                rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), 
                rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed());
        }

        /// <summary>
        /// Uses UniformFloatOpen() to generate the elements of an M23f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23f UniformM23fOpen(this IRandomUniform rnd)
        {
            return new M23f(
                rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), 
                rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen());
        }

        #endregion
    }

    #endregion

    #region M23d

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M23d : IEquatable<M23d>, IValidity, IMatrix<double>
    {
        [DataMember]
        public double M00, M01, M02;
        [DataMember]
        public double M10, M11, M12;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(double value)
        {
            M00 = value; M01 = 0; M02 = 0; 
            M10 = 0; M11 = value; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(
                double m00, double m01, double m02, 
                double m10, double m11, double m12)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M22d m, V2d v)
        {
            M00 = m.M00; M01 = m.M01; M02 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = v.Y; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M22i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M23i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M33i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M34i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M44i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M22l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M23l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M33l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M34l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M44l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M22f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M23f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M33f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M34f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M44f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M22d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M33d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M34d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M23d(M44d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
        }

        #endregion

        #region Conversions

        public static explicit operator M23d(M22i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23d(M23i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M33i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M34i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M44i m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M22l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23d(M23l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M33l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M34l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M44l m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M22f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23d(M23f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M33f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M34f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M44f m)
        {
            return new M23d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
            };
        }

        public static explicit operator M23d(M22d m)
        {
            return new M23d {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
            };
        }

        public static explicit operator M23d(M33d m)
        {
            return new M23d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23d(M34d m)
        {
            return new M23d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23d(M44d m)
        {
            return new M23d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
            };
        }

        public static explicit operator M23d(int[] a)
        {
            return new M23d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5]);
        }

        public static explicit operator M23d(int[,] a)
        {
            return new M23d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2]);
        }

        public static explicit operator int[](M23d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12
            };
        }

        public static explicit operator int[,](M23d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
        }

        public static explicit operator M23d(long[] a)
        {
            return new M23d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5]);
        }

        public static explicit operator M23d(long[,] a)
        {
            return new M23d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2]);
        }

        public static explicit operator long[](M23d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12
            };
        }

        public static explicit operator long[,](M23d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
        }

        public static explicit operator M23d(float[] a)
        {
            return new M23d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5]);
        }

        public static explicit operator M23d(float[,] a)
        {
            return new M23d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2]);
        }

        public static explicit operator float[](M23d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12
            };
        }

        public static explicit operator float[,](M23d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
        }

        public static explicit operator M23d(double[] a)
        {
            return new M23d(
                a[0], a[1], a[2], 
                a[3], a[4], a[5]);
        }

        public static explicit operator M23d(double[,] a)
        {
            return new M23d(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2]);
        }

        public static explicit operator double[](M23d m)
        {
            return new double[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12
            };
        }

        public static explicit operator double[,](M23d m)
        {
            return new double[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<double, int> element_fun)
        {
            return new M23i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M23i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<double, long> element_fun)
        {
            return new M23l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M23l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<double, float> element_fun)
        {
            return new M23f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M23f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<double, double> element_fun)
        {
            return new M23d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M23d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M23d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2));
        }

        public double[] ToArray()
        {
            var array = new double[6];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d FromCols(V2d col0, V2d col1, V2d col2)
        {
            return new M23d(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d FromRows(V3d row0, V3d row1)
        {
            return new M23d(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d FromDiagonal(double value)
        {
            return new M23d(
                value, 0, 0, 
                0, value, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d FromDiagonal(double m00, double m11)
        {
            return new M23d(
                m00, 0, 0, 
                0, m11, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d FromDiagonal(V2d s)
        {
            return new M23d(
                s.X, 0, 0, 
                0, s.Y, 0);
        }

        #region Scale

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M23d"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d Translation(double tX, double tY)
        {
            return new M23d(
                1, 0, tX, 
                0, 1, tY);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23d"/> with the translational component given by a <see cref="V2d"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d Translation(V2d t)
        {
            return new M23d(
                1, 0, t.X, 
                0, 1, t.Y);
        }

        /// <summary>
        /// Creates a transformation <see cref="M23d"/> from a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d Translation(Shift2d s)
        {
            return new M23d(
                1, 0, s.X, 
                0, 1, s.Y);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in radians.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d Rotation(double angleInRadians)
        {
            var a = Fun.Cos(angleInRadians);
            var b = Fun.Sin(angleInRadians);

            return new M23d(
                 a, -b,  0, 
                 b,  a,  0);
        }

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in degrees.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d RotationInDegrees(double angleInDegrees)
            => Rotation(angleInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 2D rotation matrix from a <see cref="Rot2d"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d Rotation(Rot2d r)
            => (M23d)r;

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d DivideByInt(M23d m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<double> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
            }
        }

        public IEnumerable<V3d> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
            }
        }

        public IEnumerable<V2d> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        [XmlIgnore]
        public V3d R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3d( M00,  M01,  M02); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        [XmlIgnore]
        public V3d R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3d( M10,  M11,  M12); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        [XmlIgnore]
        public V2d C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2d( M00,  M10); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
            }
        }

        [XmlIgnore]
        public V2d C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2d( M01,  M11); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
            }
        }

        [XmlIgnore]
        public V2d C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V2d( M02,  M12); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
            }
        }

        public V2d Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2d(M00, M11);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public double MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M10, M11, M12);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public double MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M10, M11, M12);
        }

        public unsafe double this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (double* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (double* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe double this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (double* ptr = &M00) { return ptr[row * 3 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (double* ptr = &M00) { ptr[row * 3 + column] = value; }
            }
        }

        public bool AnyNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNaN(M00) || double.IsNaN(M01) || double.IsNaN(M02) || 
                    double.IsNaN(M10) || double.IsNaN(M11) || double.IsNaN(M12);
            }
        }

        public bool AllNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNaN(M00) && double.IsNaN(M01) && double.IsNaN(M02) && 
                    double.IsNaN(M10) && double.IsNaN(M11) && double.IsNaN(M12);
            }
        }

        public bool AnyInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsInfinity(M00) || double.IsInfinity(M01) || double.IsInfinity(M02) || 
                    double.IsInfinity(M10) || double.IsInfinity(M11) || double.IsInfinity(M12);
            }
        }

        public bool AllInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsInfinity(M00) && double.IsInfinity(M01) && double.IsInfinity(M02) && 
                    double.IsInfinity(M10) && double.IsInfinity(M11) && double.IsInfinity(M12);
            }
        }

        public bool AnyPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsPositiveInfinity(M00) || double.IsPositiveInfinity(M01) || double.IsPositiveInfinity(M02) || 
                    double.IsPositiveInfinity(M10) || double.IsPositiveInfinity(M11) || double.IsPositiveInfinity(M12);
            }
        }

        public bool AllPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsPositiveInfinity(M00) && double.IsPositiveInfinity(M01) && double.IsPositiveInfinity(M02) && 
                    double.IsPositiveInfinity(M10) && double.IsPositiveInfinity(M11) && double.IsPositiveInfinity(M12);
            }
        }

        public bool AnyNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNegativeInfinity(M00) || double.IsNegativeInfinity(M01) || double.IsNegativeInfinity(M02) || 
                    double.IsNegativeInfinity(M10) || double.IsNegativeInfinity(M11) || double.IsNegativeInfinity(M12);
            }
        }

        public bool AllNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNegativeInfinity(M00) && double.IsNegativeInfinity(M01) && double.IsNegativeInfinity(M02) && 
                    double.IsNegativeInfinity(M10) && double.IsNegativeInfinity(M11) && double.IsNegativeInfinity(M12);
            }
        }

        public bool AnyTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) || Fun.IsTiny(M01) || Fun.IsTiny(M02) || 
                    Fun.IsTiny(M10) || Fun.IsTiny(M11) || Fun.IsTiny(M12);
            }
        }

        public bool AllTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) && Fun.IsTiny(M01) && Fun.IsTiny(M02) && 
                    Fun.IsTiny(M10) && Fun.IsTiny(M11) && Fun.IsTiny(M12);
            }
        }

        /// <summary>
        /// Returns true if the absolute value of each element of the matrix is smaller than Constant&lt;double&gt;.PositiveTinyValue, false otherwise.
        /// </summary>
        public bool IsTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AllTiny;
        }

        /// <summary>
        /// Returns true if any element of the matrix is NaN, false otherwise.
        /// </summary>
        public bool IsNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyNaN;
        }

        /// <summary>
        /// Returns true if any element of the matrix is infinite (positive or negative), false otherwise.
        /// </summary>
        public bool IsInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyInfinity;
        }

        /// <summary>
        /// Returns whether all elements of the matrix are finite (i.e. not NaN and not infinity).
        /// </summary>
        public bool IsFinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => !(IsInfinity || IsNaN);
        }

        #endregion

        #region Constants

        public const int RowCount = 2;
        public const int ColumnCount = 3;
        public const int ElementCount = 2 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(2, 3);
        }

        public static M23d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M23d(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator -(M23d m)
        {
            return new M23d(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  + (M23d a, M23d b)
        {
            return new M23d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  + (M23d m, double s)
        {
            return new M23d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  + (double s, M23d m)
        {
            return new M23d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  - (M23d a, M23d b)
        {
            return new M23d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  - (M23d m, double s)
        {
            return new M23d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  - (double s, M23d m)
        {
            return new M23d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  % (M23d a, M23d b)
        {
            return new M23d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  % (M23d m, double s)
        {
            return new M23d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  % (double s, M23d m)
        {
            return new M23d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  / (M23d a, M23d b)
        {
            return new M23d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  / (M23d m, double s)
        {
            return new M23d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  / (double s, M23d m)
        {
            return new M23d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  * (M23d m, double s)
        {
            return new M23d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d operator  * (double s, M23d m)
        {
            return new M23d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M23d matrix with a V3d column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d operator *(M23d m, V3d v)
        {
            return new V2d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z);
        }

        /// <summary>
        /// Multiplies a V2d row vector with a M23d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d operator *(V2d v, M23d m)
        {
            return new V3d(
                v.X * m.M00 + v.Y * m.M10, 
                v.X * m.M01 + v.Y * m.M11, 
                v.X * m.M02 + v.Y * m.M12);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M23d a, M23d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M23d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(double s, M23d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M23d a, M23d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M23d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(double s, M23d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M23d a, M23d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M23d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(double s, M23d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M23d a, M23d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M23d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(double s, M23d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M23d a, M23d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M23d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(double s, M23d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M23d a, M23d b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M23d m, double s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(double s, M23d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02),
                        HashCode.GetCombined(M10, M11, M12));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M23d other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12);
        }

        public override bool Equals(object other)
            => (other is M23d o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M23d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M23d.FromRows(
                V3d.Parse(x[0]), 
                V3d.Parse(x[1])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M23d operator *(M22d a, M23d b)
        {
            return new M23d(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12
             );
        }

        public static M23d operator *(M23d a, M33d b)
        {
            return new M23d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M23dEqualityComparer : IEqualityComparer<M23d>
    {
        public static readonly M23dEqualityComparer Default
            = new M23dEqualityComparer();

        #region IEqualityComparer<M23d> Members

        public bool Equals(M23d v0, M23d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M23d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Computes the (signed) angle in radians of a <see cref="M23d"/> rotation matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetRotation(this M23d m)
            => Fun.Atan2(m.M10, m.M00);

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M23d m)
            => (m.C0.Length + m.C1.Length) / 2;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d GetScaleVector(this M23d m)
            => new V2d(m.C0.Length, m.C1.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm1(M23d m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M23d m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMax(M23d m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMin(M23d m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M23d m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(this M23d a, M23d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M23d a, M23d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M23d a, M23d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(this M23d a, M23d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(this M23d a, M23d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d Transform(this M23d m, V3d v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this M23d m, V4d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d TransposedTransform(this M23d m, V2d v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2d TransformDir(this M23d m, V2d v)
        {
            return new V2d(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// </summary>
        public static V2d TransformPos(this M23d m, V2d p)
        {
            return new V2d(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Multiplies two <see cref="M23d"/> matrices as 3x3 matrices.
        /// </summary>
        public static M23d MultiplyAffine(this M23d a, M23d b)
        {
            return new M23d(
                a.M00 * b.M00 + a.M01 * b.M10, 
                a.M00 * b.M01 + a.M01 * b.M11, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02, 
                a.M10 * b.M00 + a.M11 * b.M10, 
                a.M10 * b.M01 + a.M11 * b.M11, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12
            );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3d Row(this M23d m, int index)
        {
            double* ptr = &m.M00;
            return new V3d(ptr[index * 3], ptr[index * 3 + 1], ptr[index * 3 + 2]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V2d Column(this M23d m, int index)
        {
            double* ptr = &m.M00;
            return new V2d(ptr[index], ptr[index + 3]);
        }

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M23d"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double MinElement(M23d m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M23d"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double MaxElement(M23d m)
            => m.MaxElement;

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M23d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M23d m, double epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M23d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M23d m, double epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon);

        #endregion

        #region Special Floating Point Value Checks

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNaN(M23d m)
            => m.AnyNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNaN(M23d m)
            => m.AllNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyInfinity(M23d m)
            => m.AnyInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllInfinity(M23d m)
            => m.AllInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyPositiveInfinity(M23d m)
            => m.AnyPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllPositiveInfinity(M23d m)
            => m.AllPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNegativeInfinity(M23d m)
            => m.AnyNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNegativeInfinity(M23d m)
            => m.AllNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(M23d m)
            => m.AnyTiny;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(M23d m)
            => m.AllTiny;

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M23d a, M23d b)
            => ApproximateEquals(a, b, Constant<double>.PositiveTinyValue);

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M23d a, M23d b, double epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M23d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M23d m, double epsilon)
            => Mat.AllTiny(m, epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M23d"/> is smaller than Constant&lt;double&gt;.PositiveTinyValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(M23d m)
            => m.IsTiny;

        #endregion

        #region Special Floating Point Value Checks

        /// <summary>
        /// Returns whether any element of the given <see cref="M23d"/> is NaN.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNaN(M23d v)
            => v.IsNaN;

        /// <summary>
        /// Returns whether any element of the given <see cref="M23d"/> is infinity (positive or negative).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInfinity(M23d v)
            => v.IsInfinity;

        /// <summary>
        /// Returns whether all elements of the given <see cref="M23d"/> are finite (i.e. not NaN and not infinity).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsFinite(M23d v)
            => v.IsFinite;

        #endregion
    }

    public static class IRandomUniformM23dExtensions
    {
        #region IRandomUniform extensions for M23d

        /// <summary>
        /// Uses UniformDouble() to generate the elements of an M23d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d UniformM23d(this IRandomUniform rnd)
        {
            return new M23d(
                rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), 
                rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble());
        }

        /// <summary>
        /// Uses UniformDoubleClosed() to generate the elements of an M23d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d UniformM23dClosed(this IRandomUniform rnd)
        {
            return new M23d(
                rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), 
                rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed());
        }

        /// <summary>
        /// Uses UniformDoubleOpen() to generate the elements of an M23d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d UniformM23dOpen(this IRandomUniform rnd)
        {
            return new M23d(
                rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), 
                rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen());
        }

        /// <summary>
        /// Uses UniformDoubleFull() to generate the elements of an M23d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d UniformM23dFull(this IRandomUniform rnd)
        {
            return new M23d(
                rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), 
                rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull());
        }

        /// <summary>
        /// Uses UniformDoubleFullClosed() to generate the elements of an M23d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d UniformM23dFullClosed(this IRandomUniform rnd)
        {
            return new M23d(
                rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), 
                rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed());
        }

        /// <summary>
        /// Uses UniformDoubleFullOpen() to generate the elements of an M23d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M23d UniformM23dFullOpen(this IRandomUniform rnd)
        {
            return new M23d(
                rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), 
                rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen());
        }

        #endregion
    }

    #endregion

    #region M33i

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M33i : IEquatable<M33i>, IValidity, IMatrix<double>
    {
        [DataMember]
        public int M00, M01, M02;
        [DataMember]
        public int M10, M11, M12;
        [DataMember]
        public int M20, M21, M22;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(int value)
        {
            M00 = value; M01 = 0; M02 = 0; 
            M10 = 0; M11 = value; M12 = 0; 
            M20 = 0; M21 = 0; M22 = value; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(
                int m00, int m01, int m02, 
                int m10, int m11, int m12, 
                int m20, int m21, int m22)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
            M20 = m20; M21 = m21; M22 = m22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
            M20 = a[6];
            M21 = a[7];
            M22 = a[8];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
            M20 = a[start + 6];
            M21 = a[start + 7];
            M22 = a[start + 8];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M22i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M23i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M34i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M44i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M22l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M23l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M33l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M34l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M44l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M22f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M23f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M33f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M34f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M44f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M22d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M23d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M33d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M34d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33i(M44d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; 
        }

        #endregion

        #region Conversions

        public static explicit operator M33i(M22i m)
        {
            return new M33i {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M23i m)
        {
            return new M33i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M34i m)
        {
            return new M33i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33i(M44i m)
        {
            return new M33i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33i(M22l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M23l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M33l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M34l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M44l m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M22f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M23f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M33f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M34f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M44f m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M22d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M23d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33i(M33d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M34d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(M44d m)
        {
            return new M33i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, 
            };
        }

        public static explicit operator M33i(int[] a)
        {
            return new M33i(
                a[0], a[1], a[2], 
                a[3], a[4], a[5], 
                a[6], a[7], a[8]);
        }

        public static explicit operator M33i(int[,] a)
        {
            return new M33i(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2], 
                a[2, 0], a[2, 1], a[2, 2]);
        }

        public static explicit operator int[](M33i m)
        {
            return new int[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12, 
                m.M20, m.M21, m.M22
            };
        }

        public static explicit operator int[,](M33i m)
        {
            return new int[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }, 
                { m.M20, m.M21, m.M22 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
            array[index + 6] = M20;
            array[index + 7] = M21;
            array[index + 8] = M22;
        }

        public static explicit operator M33i(long[] a)
        {
            return new M33i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5], 
                (int)a[6], (int)a[7], (int)a[8]);
        }

        public static explicit operator M33i(long[,] a)
        {
            return new M33i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2]);
        }

        public static explicit operator long[](M33i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12, 
                (long)m.M20, (long)m.M21, (long)m.M22
            };
        }

        public static explicit operator long[,](M33i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
            array[index + 6] = (long)M20;
            array[index + 7] = (long)M21;
            array[index + 8] = (long)M22;
        }

        public static explicit operator M33i(float[] a)
        {
            return new M33i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5], 
                (int)a[6], (int)a[7], (int)a[8]);
        }

        public static explicit operator M33i(float[,] a)
        {
            return new M33i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2]);
        }

        public static explicit operator float[](M33i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12, 
                (float)m.M20, (float)m.M21, (float)m.M22
            };
        }

        public static explicit operator float[,](M33i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
            array[index + 6] = (float)M20;
            array[index + 7] = (float)M21;
            array[index + 8] = (float)M22;
        }

        public static explicit operator M33i(double[] a)
        {
            return new M33i(
                (int)a[0], (int)a[1], (int)a[2], 
                (int)a[3], (int)a[4], (int)a[5], 
                (int)a[6], (int)a[7], (int)a[8]);
        }

        public static explicit operator M33i(double[,] a)
        {
            return new M33i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2]);
        }

        public static explicit operator double[](M33i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12, 
                (double)m.M20, (double)m.M21, (double)m.M22
            };
        }

        public static explicit operator double[,](M33i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
            array[index + 6] = (double)M20;
            array[index + 7] = (double)M21;
            array[index + 8] = (double)M22;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<int, int> element_fun)
        {
            return new M33i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M33i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<int, long> element_fun)
        {
            return new M33l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M33l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<int, float> element_fun)
        {
            return new M33f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M33f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<int, double> element_fun)
        {
            return new M33d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M33d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M22i UpperLeftM22()
        {
            return (M22i)this;
        }

        public int[] ToArray()
        {
            var array = new int[9];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            array[6] = M20;
            array[7] = M21;
            array[8] = M22;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i FromCols(V3i col0, V3i col1, V3i col2)
        {
            return new M33i(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y, 
                col0.Z, col1.Z, col2.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i FromRows(V3i row0, V3i row1, V3i row2)
        {
            return new M33i(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z, 
                row2.X, row2.Y, row2.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i FromDiagonal(int value)
        {
            return new M33i(
                value, 0, 0, 
                0, value, 0, 
                0, 0, value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i FromDiagonal(int m00, int m11, int m22)
        {
            return new M33i(
                m00, 0, 0, 
                0, m11, 0, 
                0, 0, m22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i FromDiagonal(V3i s)
        {
            return new M33i(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, s.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i FromAntiDiagonal(int value)
        {
            return new M33i(
                 0, 0, value, 
                 0, value, 0, 
                 value, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i FromAntiDiagonal(int m02, int m11, int m20)
        {
            return new M33i(
                0, 0, m02, 
                0, m11, 0, 
                m20, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i FromAntiDiagonal(V3i s)
        {
            return new M33i(
                0, 0, s.X, 
                0, s.Y, 0, 
                s.Z, 0, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M33i"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i Scale(int sX, int sY, int sZ)
            => FromDiagonal(sX, sY, sZ);

        /// <summary>
        /// Creates a transformation <see cref="M33i"/> using a <see cref="V3i"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i Scale(V3i s)
            => FromDiagonal(s);

        /// <summary>
        /// Creates a homogenous transformation <see cref="M33i"/> using a uniform scale.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i Scale(int s)
        {
            return new M33i(
                s, 0, 0, 
                0, s, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33i"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i Scale(int sX, int sY)
        {
            return new M33i(
                sX, 0, 0, 
                0, sY, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33i"/> using a <see cref="V2i"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i Scale(V2i s)
        {
            return new M33i(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, 1);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M33i"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i Translation(int tX, int tY)
        {
            return new M33i(
                1, 0, tX, 
                0, 1, tY, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33i"/> with the translational component given by a <see cref="V2i"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i Translation(V2i t)
        {
            return new M33i(
                1, 0, t.X, 
                0, 1, t.Y, 
                0, 0, 1);
        }

        #endregion

        #region Shearing

        /// <summary>
        /// Creates a shear transformation matrix along the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i ShearXY(int factorX, int factorY)
        {
            return new M33i(
                1, 0, factorX, 
                0, 1, factorY, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i ShearXZ(int factorX, int factorZ)
        {
            return new M33i(
                1, factorX, 0, 
                0, 1, 0, 
                0, factorZ, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i ShearYZ(int factorY, int factorZ)
        {
            return new M33i(
                1, 0, 0, 
                factorY, 1, 0, 
                factorZ, 0, 1);
        }

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i DivideByInt(M33i m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<int> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M20;
                yield return M21;
                yield return M22;
            }
        }

        public IEnumerable<V3i> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3i> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        [XmlIgnore]
        public V3i R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3i( M00,  M01,  M02); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        [XmlIgnore]
        public V3i R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3i( M10,  M11,  M12); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        [XmlIgnore]
        public V3i R2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3i( M20,  M21,  M22); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
            }
        }

        [XmlIgnore]
        public V3i C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3i( M00,  M10,  M20); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        [XmlIgnore]
        public V3i C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3i( M01,  M11,  M21); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        [XmlIgnore]
        public V3i C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3i( M02,  M12,  M22); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public V3i Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V3i(M00, M11, M22);
        }

        public V3i AntiDiagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V3i(M02, M11, M20);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public int MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M10, M11, M12, M20, M21, M22);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public int MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M10, M11, M12, M20, M21, M22);
        }

        public unsafe int this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (int* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (int* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe int this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (int* ptr = &M00) { return ptr[row * 3 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (int* ptr = &M00) { ptr[row * 3 + column] = value; }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 3;
        public const int ElementCount = 3 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 3);
        }

        public static M33i Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33i(0);
        }

        public static M33i Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33i(1, 0, 0, 0, 1, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + 
                    M20 * M20 + M21 * M21 + M22 * M22);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator -(M33i m)
        {
            return new M33i(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12, 
                -m.M20, -m.M21, -m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator  + (M33i a, M33i b)
        {
            return new M33i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator  + (M33i m, int s)
        {
            return new M33i(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator  + (int s, M33i m)
        {
            return new M33i(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  + (M33i a, M33l b)
        {
            return new M33l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  + (M33i m, long s)
        {
            return new M33l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  + (long s, M33i m)
        {
            return new M33l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  + (M33i a, M33f b)
        {
            return new M33f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  + (M33i m, float s)
        {
            return new M33f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  + (float s, M33i m)
        {
            return new M33f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  + (M33i a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  + (M33i m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  + (double s, M33i m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator  - (M33i a, M33i b)
        {
            return new M33i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator  - (M33i m, int s)
        {
            return new M33i(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator  - (int s, M33i m)
        {
            return new M33i(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  - (M33i a, M33l b)
        {
            return new M33l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  - (M33i m, long s)
        {
            return new M33l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  - (long s, M33i m)
        {
            return new M33l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  - (M33i a, M33f b)
        {
            return new M33f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  - (M33i m, float s)
        {
            return new M33f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  - (float s, M33i m)
        {
            return new M33f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  - (M33i a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  - (M33i m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  - (double s, M33i m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator  % (M33i a, M33i b)
        {
            return new M33i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator  % (M33i m, int s)
        {
            return new M33i(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator  % (int s, M33i m)
        {
            return new M33i(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  % (M33i a, M33l b)
        {
            return new M33l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  % (M33i m, long s)
        {
            return new M33l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  % (long s, M33i m)
        {
            return new M33l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  % (M33i a, M33f b)
        {
            return new M33f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  % (M33i m, float s)
        {
            return new M33f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  % (float s, M33i m)
        {
            return new M33f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  % (M33i a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  % (M33i m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  % (double s, M33i m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator  / (M33i a, M33i b)
        {
            return new M33i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator  / (M33i m, int s)
        {
            return new M33i(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator  / (int s, M33i m)
        {
            return new M33i(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  / (M33i a, M33l b)
        {
            return new M33l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  / (M33i m, long s)
        {
            return new M33l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  / (long s, M33i m)
        {
            return new M33l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  / (M33i a, M33f b)
        {
            return new M33f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  / (M33i m, float s)
        {
            return new M33f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  / (float s, M33i m)
        {
            return new M33f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  / (M33i a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  / (M33i m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  / (double s, M33i m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator  * (M33i m, int s)
        {
            return new M33i(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator  * (int s, M33i m)
        {
            return new M33i(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  * (M33i m, long s)
        {
            return new M33l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  * (long s, M33i m)
        {
            return new M33l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  * (M33i m, float s)
        {
            return new M33f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  * (float s, M33i m)
        {
            return new M33f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  * (M33i m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  * (double s, M33i m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        #endregion

        #region Bitwise Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator ~(M33i m)
        {
            return new M33i(
                ~m.M00, ~m.M01, ~m.M02, 
                ~m.M10, ~m.M11, ~m.M12, 
                ~m.M20, ~m.M21, ~m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator <<(M33i a, int s)
        {
            return new M33i(
                a.M00 << s, a.M01 << s, a.M02 << s, 
                a.M10 << s, a.M11 << s, a.M12 << s, 
                a.M20 << s, a.M21 << s, a.M22 << s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator >>(M33i a, int s)
        {
            return new M33i(
                a.M00 >> s, a.M01 >> s, a.M02 >> s, 
                a.M10 >> s, a.M11 >> s, a.M12 >> s, 
                a.M20 >> s, a.M21 >> s, a.M22 >> s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator &(M33i a, M33i b)
        {
            return new M33i(
                a.M00 & b.M00, a.M01 & b.M01, a.M02 & b.M02, 
                a.M10 & b.M10, a.M11 & b.M11, a.M12 & b.M12, 
                a.M20 & b.M20, a.M21 & b.M21, a.M22 & b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator &(M33i a, int s)
        {
            return new M33i(
                a.M00 & s, a.M01 & s, a.M02 & s, 
                a.M10 & s, a.M11 & s, a.M12 & s, 
                a.M20 & s, a.M21 & s, a.M22 & s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator &(int s, M33i a)
        {
            return new M33i(
                s & a.M00, s & a.M01, s & a.M02, 
                s & a.M10, s & a.M11, s & a.M12, 
                s & a.M20, s & a.M21, s & a.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator |(M33i a, M33i b)
        {
            return new M33i(
                a.M00 | b.M00, a.M01 | b.M01, a.M02 | b.M02, 
                a.M10 | b.M10, a.M11 | b.M11, a.M12 | b.M12, 
                a.M20 | b.M20, a.M21 | b.M21, a.M22 | b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator |(M33i a, int s)
        {
            return new M33i(
                a.M00 | s, a.M01 | s, a.M02 | s, 
                a.M10 | s, a.M11 | s, a.M12 | s, 
                a.M20 | s, a.M21 | s, a.M22 | s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator |(int s, M33i a)
        {
            return new M33i(
                s | a.M00, s | a.M01, s | a.M02, 
                s | a.M10, s | a.M11, s | a.M12, 
                s | a.M20, s | a.M21, s | a.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator ^(M33i a, M33i b)
        {
            return new M33i(
                a.M00 ^ b.M00, a.M01 ^ b.M01, a.M02 ^ b.M02, 
                a.M10 ^ b.M10, a.M11 ^ b.M11, a.M12 ^ b.M12, 
                a.M20 ^ b.M20, a.M21 ^ b.M21, a.M22 ^ b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator ^(M33i a, int s)
        {
            return new M33i(
                a.M00 ^ s, a.M01 ^ s, a.M02 ^ s, 
                a.M10 ^ s, a.M11 ^ s, a.M12 ^ s, 
                a.M20 ^ s, a.M21 ^ s, a.M22 ^ s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i operator ^(int s, M33i a)
        {
            return new M33i(
                s ^ a.M00, s ^ a.M01, s ^ a.M02, 
                s ^ a.M10, s ^ a.M11, s ^ a.M12, 
                s ^ a.M20, s ^ a.M21, s ^ a.M22);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M33i matrix with a V3i column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i operator *(M33i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        /// <summary>
        /// Multiplies a V3i row vector with a M33i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i operator *(V3i v, M33i m)
        {
            return new V3i(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M33i a, M33i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M33i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(int s, M33i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M33i a, M33i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M33i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(int s, M33i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M33i a, M33i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M33i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(int s, M33i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M33i a, M33i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M33i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(int s, M33i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M33i a, M33i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M33i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(int s, M33i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M33i a, M33i b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M33i m, int s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(int s, M33i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02),
                        HashCode.GetCombined(M10, M11, M12),
                        HashCode.GetCombined(M20, M21, M22));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M33i other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12) && 
                M20.Equals(other.M20) && M21.Equals(other.M21) && M22.Equals(other.M22);
        }

        public override bool Equals(object other)
            => (other is M33i o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M33i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M33i.FromRows(
                V3i.Parse(x[0]), 
                V3i.Parse(x[1]), 
                V3i.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M33i Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M33i result = new M33i();
                for (int row = 0; row < 3; row++)
                {
                    for (int col = 0; col < 3; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public int Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public int Determinant
        {
            get
            {
                if (M10 == 0 && M20 == 0 && M21 == 0)
                {
                    return M00 * M11 * M22;
                }
                return
                M00 * M11 * M22 - M00 * M12 * M21 +
                M01 * M12 * M20 - M01 * M10 * M22 +
                M02 * M10 * M21 - M02 * M11 * M20;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M33i Transposed
        {
            get
            {
                return new M33i {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M33i operator *(M33i a, M33i b)
        {
            return new M33i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M33iEqualityComparer : IEqualityComparer<M33i>
    {
        public static readonly M33iEqualityComparer Default
            = new M33iEqualityComparer();

        #region IEqualityComparer<M33i> Members

        public bool Equals(M33i v0, M33i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M33i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M33i m)
            => (m.C0.Length + m.C1.Length + m.C2.Length) / 3;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetScaleVector(this M33i m)
            => new V3d(m.C0.Length, m.C1.Length, m.C2.Length);

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of 2D basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale2(this M33i m)
            => (m.C0.XY.Length + m.C1.XY.Length) / 2;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the 2D basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d GetScaleVector2(this M33i m)
            => new V2d(m.C0.XY.Length, m.C1.XY.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Norm1(M33i m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M33i m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMax(M33i m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMin(M33i m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M33i m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(this M33i a, M33i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M33i a, M33i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M33i a, M33i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(this M33i a, M33i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(this M33i a, M33i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i Transform(this M33i m, V3i v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i Transform(this M33i m, V4i v)
        {
            return new V4i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i TransposedTransform(this M33i m, V3i v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i TransposedTransform(this M33i m, V4i v)
        {
            return new V4i(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22,
                v.W);
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2i TransformDir(this M33i m, V2i v)
        {
            return new V2i(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2i TransformPos(this M33i m, V2i p)
        {
            return new V2i(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2i TransformPosProj(this M33i m, V2i p)
        {
            int s = m.M20 * p.X + m.M21 * p.Y + m.M22;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3i TransformPosProjFull(this M33i m, V2i p)
        {
            return new V3i(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12, 
                m.M20 * p.X + m.M21 * p.Y + m.M22
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V2i TransposedTransformDir(this M33i m, V2i v)
        {
            return new V2i(
                m.M00 * v.X + m.M10 * v.Y, 
                m.M01 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2i TransposedTransformPos(this M33i m, V2i p)
        {
            return new V2i(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2i TransposedTransformProj(this M33i m, V2i p)
        {
            var s = m.M02 * p.X + m.M12 * p.Y + m.M22;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3i TransposedTransformProjFull(this M33i m, V2i p)
        {
            return new V3i(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21, 
                m.M02 * p.X + m.M12 * p.Y + m.M22
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M33i"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M22i Minor(this M33i m, int row, int column)
        {
            M22i rs = new M22i();

            for (int k = 0; k < 4; k++)
            {
                var i = k / 2;
                var j = k % 2;
                var ii = (i < row) ? i : i + 1;
                var jj = (j < column) ? j : j + 1;

                rs[k] = m[ii * 3 + jj];
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3i Row(this M33i m, int index)
        {
            int* ptr = &m.M00;
            return new V3i(ptr[index * 3], ptr[index * 3 + 1], ptr[index * 3 + 2]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3i Column(this M33i m, int index)
        {
            int* ptr = &m.M00;
            return new V3i(ptr[index], ptr[index + 3], ptr[index + 6]);
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Determinant(M33i m)
            => m.Determinant;

        /// <summary>
        /// Returns the transpose of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i Transposed(M33i m)
            => m.Transposed;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Transpose(this ref M33i m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
        }

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M33i"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int MinElement(M33i m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M33i"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int MaxElement(M33i m)
            => m.MaxElement;

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M33i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M33i m, int epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon) || m.M20.IsTiny(epsilon) || m.M21.IsTiny(epsilon) || m.M22.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M33i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M33i m, int epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon) && m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon) && m.M22.IsTiny(epsilon);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M33i a, M33i b, int epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M33i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M33i m, int epsilon)
            => Mat.AllTiny(m, epsilon);

        #endregion
    }

    public static class IRandomUniformM33iExtensions
    {
        #region IRandomUniform extensions for M33i

        /// <summary>
        /// Uses UniformInt() to generate the elements of an M33i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i UniformM33i(this IRandomUniform rnd)
        {
            return new M33i(
                rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), 
                rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), 
                rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt());
        }

        /// <summary>
        /// Uses UniformIntNonZero() to generate the elements of an M33i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i UniformM33iNonZero(this IRandomUniform rnd)
        {
            return new M33i(
                rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), 
                rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), 
                rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero());
        }

        /// <summary>
        /// Uses UniformInt(int) to generate the elements of an M33i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i UniformM33i(this IRandomUniform rnd, int size)
        {
            return new M33i(
                rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), 
                rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), 
                rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size));
        }

        /// <summary>
        /// Uses UniformInt(int) to generate the elements of an M33i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33i UniformM33i(this IRandomUniform rnd, M33i size)
        {
            return new M33i(
                rnd.UniformInt(size.M00), rnd.UniformInt(size.M01), rnd.UniformInt(size.M02), 
                rnd.UniformInt(size.M10), rnd.UniformInt(size.M11), rnd.UniformInt(size.M12), 
                rnd.UniformInt(size.M20), rnd.UniformInt(size.M21), rnd.UniformInt(size.M22));
        }

        #endregion
    }

    #endregion

    #region M33l

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M33l : IEquatable<M33l>, IValidity, IMatrix<double>
    {
        [DataMember]
        public long M00, M01, M02;
        [DataMember]
        public long M10, M11, M12;
        [DataMember]
        public long M20, M21, M22;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(long value)
        {
            M00 = value; M01 = 0; M02 = 0; 
            M10 = 0; M11 = value; M12 = 0; 
            M20 = 0; M21 = 0; M22 = value; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(
                long m00, long m01, long m02, 
                long m10, long m11, long m12, 
                long m20, long m21, long m22)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
            M20 = m20; M21 = m21; M22 = m22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
            M20 = a[6];
            M21 = a[7];
            M22 = a[8];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
            M20 = a[start + 6];
            M21 = a[start + 7];
            M22 = a[start + 8];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M22i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M23i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M33i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M34i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M44i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M22l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M23l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M34l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M44l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M22f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M23f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M33f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M34f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M44f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M22d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M23d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M33d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M34d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33l(M44d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; 
        }

        #endregion

        #region Conversions

        public static explicit operator M33l(M22i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M23i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M33i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M34i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M44i m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M22l m)
        {
            return new M33l {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M23l m)
        {
            return new M33l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M34l m)
        {
            return new M33l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33l(M44l m)
        {
            return new M33l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33l(M22f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M23f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M33f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M34f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M44f m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M22d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M23d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33l(M33d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M34d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(M44d m)
        {
            return new M33l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, 
            };
        }

        public static explicit operator M33l(int[] a)
        {
            return new M33l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5], 
                (long)a[6], (long)a[7], (long)a[8]);
        }

        public static explicit operator M33l(int[,] a)
        {
            return new M33l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2]);
        }

        public static explicit operator int[](M33l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12, 
                (int)m.M20, (int)m.M21, (int)m.M22
            };
        }

        public static explicit operator int[,](M33l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
            array[index + 6] = (int)M20;
            array[index + 7] = (int)M21;
            array[index + 8] = (int)M22;
        }

        public static explicit operator M33l(long[] a)
        {
            return new M33l(
                a[0], a[1], a[2], 
                a[3], a[4], a[5], 
                a[6], a[7], a[8]);
        }

        public static explicit operator M33l(long[,] a)
        {
            return new M33l(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2], 
                a[2, 0], a[2, 1], a[2, 2]);
        }

        public static explicit operator long[](M33l m)
        {
            return new long[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12, 
                m.M20, m.M21, m.M22
            };
        }

        public static explicit operator long[,](M33l m)
        {
            return new long[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }, 
                { m.M20, m.M21, m.M22 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
            array[index + 6] = M20;
            array[index + 7] = M21;
            array[index + 8] = M22;
        }

        public static explicit operator M33l(float[] a)
        {
            return new M33l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5], 
                (long)a[6], (long)a[7], (long)a[8]);
        }

        public static explicit operator M33l(float[,] a)
        {
            return new M33l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2]);
        }

        public static explicit operator float[](M33l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12, 
                (float)m.M20, (float)m.M21, (float)m.M22
            };
        }

        public static explicit operator float[,](M33l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
            array[index + 6] = (float)M20;
            array[index + 7] = (float)M21;
            array[index + 8] = (float)M22;
        }

        public static explicit operator M33l(double[] a)
        {
            return new M33l(
                (long)a[0], (long)a[1], (long)a[2], 
                (long)a[3], (long)a[4], (long)a[5], 
                (long)a[6], (long)a[7], (long)a[8]);
        }

        public static explicit operator M33l(double[,] a)
        {
            return new M33l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2]);
        }

        public static explicit operator double[](M33l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12, 
                (double)m.M20, (double)m.M21, (double)m.M22
            };
        }

        public static explicit operator double[,](M33l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
            array[index + 6] = (double)M20;
            array[index + 7] = (double)M21;
            array[index + 8] = (double)M22;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<long, int> element_fun)
        {
            return new M33i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M33i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<long, long> element_fun)
        {
            return new M33l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M33l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<long, float> element_fun)
        {
            return new M33f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M33f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<long, double> element_fun)
        {
            return new M33d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M33d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M22l UpperLeftM22()
        {
            return (M22l)this;
        }

        public long[] ToArray()
        {
            var array = new long[9];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            array[6] = M20;
            array[7] = M21;
            array[8] = M22;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l FromCols(V3l col0, V3l col1, V3l col2)
        {
            return new M33l(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y, 
                col0.Z, col1.Z, col2.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l FromRows(V3l row0, V3l row1, V3l row2)
        {
            return new M33l(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z, 
                row2.X, row2.Y, row2.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l FromDiagonal(long value)
        {
            return new M33l(
                value, 0, 0, 
                0, value, 0, 
                0, 0, value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l FromDiagonal(long m00, long m11, long m22)
        {
            return new M33l(
                m00, 0, 0, 
                0, m11, 0, 
                0, 0, m22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l FromDiagonal(V3l s)
        {
            return new M33l(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, s.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l FromAntiDiagonal(long value)
        {
            return new M33l(
                 0, 0, value, 
                 0, value, 0, 
                 value, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l FromAntiDiagonal(long m02, long m11, long m20)
        {
            return new M33l(
                0, 0, m02, 
                0, m11, 0, 
                m20, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l FromAntiDiagonal(V3l s)
        {
            return new M33l(
                0, 0, s.X, 
                0, s.Y, 0, 
                s.Z, 0, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M33l"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l Scale(long sX, long sY, long sZ)
            => FromDiagonal(sX, sY, sZ);

        /// <summary>
        /// Creates a transformation <see cref="M33l"/> using a <see cref="V3l"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l Scale(V3l s)
            => FromDiagonal(s);

        /// <summary>
        /// Creates a homogenous transformation <see cref="M33l"/> using a uniform scale.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l Scale(long s)
        {
            return new M33l(
                s, 0, 0, 
                0, s, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33l"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l Scale(long sX, long sY)
        {
            return new M33l(
                sX, 0, 0, 
                0, sY, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33l"/> using a <see cref="V2l"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l Scale(V2l s)
        {
            return new M33l(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, 1);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M33l"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l Translation(long tX, long tY)
        {
            return new M33l(
                1, 0, tX, 
                0, 1, tY, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33l"/> with the translational component given by a <see cref="V2l"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l Translation(V2l t)
        {
            return new M33l(
                1, 0, t.X, 
                0, 1, t.Y, 
                0, 0, 1);
        }

        #endregion

        #region Shearing

        /// <summary>
        /// Creates a shear transformation matrix along the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l ShearXY(long factorX, long factorY)
        {
            return new M33l(
                1, 0, factorX, 
                0, 1, factorY, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l ShearXZ(long factorX, long factorZ)
        {
            return new M33l(
                1, factorX, 0, 
                0, 1, 0, 
                0, factorZ, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l ShearYZ(long factorY, long factorZ)
        {
            return new M33l(
                1, 0, 0, 
                factorY, 1, 0, 
                factorZ, 0, 1);
        }

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l DivideByInt(M33l m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<long> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M20;
                yield return M21;
                yield return M22;
            }
        }

        public IEnumerable<V3l> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3l> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        [XmlIgnore]
        public V3l R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3l( M00,  M01,  M02); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        [XmlIgnore]
        public V3l R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3l( M10,  M11,  M12); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        [XmlIgnore]
        public V3l R2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3l( M20,  M21,  M22); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
            }
        }

        [XmlIgnore]
        public V3l C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3l( M00,  M10,  M20); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        [XmlIgnore]
        public V3l C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3l( M01,  M11,  M21); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        [XmlIgnore]
        public V3l C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3l( M02,  M12,  M22); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public V3l Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V3l(M00, M11, M22);
        }

        public V3l AntiDiagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V3l(M02, M11, M20);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public long MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M10, M11, M12, M20, M21, M22);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public long MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M10, M11, M12, M20, M21, M22);
        }

        public unsafe long this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (long* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (long* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe long this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (long* ptr = &M00) { return ptr[row * 3 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (long* ptr = &M00) { ptr[row * 3 + column] = value; }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 3;
        public const int ElementCount = 3 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 3);
        }

        public static M33l Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33l(0);
        }

        public static M33l Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33l(1, 0, 0, 0, 1, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + 
                    M20 * M20 + M21 * M21 + M22 * M22);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator -(M33l m)
        {
            return new M33l(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12, 
                -m.M20, -m.M21, -m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  + (M33l a, M33l b)
        {
            return new M33l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  + (M33l m, long s)
        {
            return new M33l(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  + (long s, M33l m)
        {
            return new M33l(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  + (M33l a, M33f b)
        {
            return new M33f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  + (M33l m, float s)
        {
            return new M33f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  + (float s, M33l m)
        {
            return new M33f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  + (M33l a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  + (M33l m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  + (double s, M33l m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  - (M33l a, M33l b)
        {
            return new M33l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  - (M33l m, long s)
        {
            return new M33l(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  - (long s, M33l m)
        {
            return new M33l(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  - (M33l a, M33f b)
        {
            return new M33f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  - (M33l m, float s)
        {
            return new M33f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  - (float s, M33l m)
        {
            return new M33f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  - (M33l a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  - (M33l m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  - (double s, M33l m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  % (M33l a, M33l b)
        {
            return new M33l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  % (M33l m, long s)
        {
            return new M33l(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  % (long s, M33l m)
        {
            return new M33l(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  % (M33l a, M33f b)
        {
            return new M33f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  % (M33l m, float s)
        {
            return new M33f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  % (float s, M33l m)
        {
            return new M33f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  % (M33l a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  % (M33l m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  % (double s, M33l m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  / (M33l a, M33l b)
        {
            return new M33l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  / (M33l m, long s)
        {
            return new M33l(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  / (long s, M33l m)
        {
            return new M33l(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  / (M33l a, M33f b)
        {
            return new M33f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  / (M33l m, float s)
        {
            return new M33f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  / (float s, M33l m)
        {
            return new M33f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  / (M33l a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  / (M33l m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  / (double s, M33l m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  * (M33l m, long s)
        {
            return new M33l(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator  * (long s, M33l m)
        {
            return new M33l(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  * (M33l m, float s)
        {
            return new M33f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  * (float s, M33l m)
        {
            return new M33f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  * (M33l m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  * (double s, M33l m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        #endregion

        #region Bitwise Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator ~(M33l m)
        {
            return new M33l(
                ~m.M00, ~m.M01, ~m.M02, 
                ~m.M10, ~m.M11, ~m.M12, 
                ~m.M20, ~m.M21, ~m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator <<(M33l a, int s)
        {
            return new M33l(
                a.M00 << s, a.M01 << s, a.M02 << s, 
                a.M10 << s, a.M11 << s, a.M12 << s, 
                a.M20 << s, a.M21 << s, a.M22 << s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator >>(M33l a, int s)
        {
            return new M33l(
                a.M00 >> s, a.M01 >> s, a.M02 >> s, 
                a.M10 >> s, a.M11 >> s, a.M12 >> s, 
                a.M20 >> s, a.M21 >> s, a.M22 >> s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator &(M33l a, M33l b)
        {
            return new M33l(
                a.M00 & b.M00, a.M01 & b.M01, a.M02 & b.M02, 
                a.M10 & b.M10, a.M11 & b.M11, a.M12 & b.M12, 
                a.M20 & b.M20, a.M21 & b.M21, a.M22 & b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator &(M33l a, long s)
        {
            return new M33l(
                a.M00 & s, a.M01 & s, a.M02 & s, 
                a.M10 & s, a.M11 & s, a.M12 & s, 
                a.M20 & s, a.M21 & s, a.M22 & s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator &(long s, M33l a)
        {
            return new M33l(
                s & a.M00, s & a.M01, s & a.M02, 
                s & a.M10, s & a.M11, s & a.M12, 
                s & a.M20, s & a.M21, s & a.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator |(M33l a, M33l b)
        {
            return new M33l(
                a.M00 | b.M00, a.M01 | b.M01, a.M02 | b.M02, 
                a.M10 | b.M10, a.M11 | b.M11, a.M12 | b.M12, 
                a.M20 | b.M20, a.M21 | b.M21, a.M22 | b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator |(M33l a, long s)
        {
            return new M33l(
                a.M00 | s, a.M01 | s, a.M02 | s, 
                a.M10 | s, a.M11 | s, a.M12 | s, 
                a.M20 | s, a.M21 | s, a.M22 | s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator |(long s, M33l a)
        {
            return new M33l(
                s | a.M00, s | a.M01, s | a.M02, 
                s | a.M10, s | a.M11, s | a.M12, 
                s | a.M20, s | a.M21, s | a.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator ^(M33l a, M33l b)
        {
            return new M33l(
                a.M00 ^ b.M00, a.M01 ^ b.M01, a.M02 ^ b.M02, 
                a.M10 ^ b.M10, a.M11 ^ b.M11, a.M12 ^ b.M12, 
                a.M20 ^ b.M20, a.M21 ^ b.M21, a.M22 ^ b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator ^(M33l a, long s)
        {
            return new M33l(
                a.M00 ^ s, a.M01 ^ s, a.M02 ^ s, 
                a.M10 ^ s, a.M11 ^ s, a.M12 ^ s, 
                a.M20 ^ s, a.M21 ^ s, a.M22 ^ s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l operator ^(long s, M33l a)
        {
            return new M33l(
                s ^ a.M00, s ^ a.M01, s ^ a.M02, 
                s ^ a.M10, s ^ a.M11, s ^ a.M12, 
                s ^ a.M20, s ^ a.M21, s ^ a.M22);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M33l matrix with a V3l column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l operator *(M33l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        /// <summary>
        /// Multiplies a V3l row vector with a M33l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l operator *(V3l v, M33l m)
        {
            return new V3l(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M33l a, M33l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M33l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(long s, M33l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M33l a, M33l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M33l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(long s, M33l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M33l a, M33l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M33l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(long s, M33l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M33l a, M33l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M33l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(long s, M33l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M33l a, M33l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M33l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(long s, M33l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M33l a, M33l b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M33l m, long s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(long s, M33l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02),
                        HashCode.GetCombined(M10, M11, M12),
                        HashCode.GetCombined(M20, M21, M22));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M33l other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12) && 
                M20.Equals(other.M20) && M21.Equals(other.M21) && M22.Equals(other.M22);
        }

        public override bool Equals(object other)
            => (other is M33l o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M33l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M33l.FromRows(
                V3l.Parse(x[0]), 
                V3l.Parse(x[1]), 
                V3l.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M33l Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M33l result = new M33l();
                for (int row = 0; row < 3; row++)
                {
                    for (int col = 0; col < 3; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public long Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public long Determinant
        {
            get
            {
                if (M10 == 0 && M20 == 0 && M21 == 0)
                {
                    return M00 * M11 * M22;
                }
                return
                M00 * M11 * M22 - M00 * M12 * M21 +
                M01 * M12 * M20 - M01 * M10 * M22 +
                M02 * M10 * M21 - M02 * M11 * M20;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M33l Transposed
        {
            get
            {
                return new M33l {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M33l operator *(M33l a, M33l b)
        {
            return new M33l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M33lEqualityComparer : IEqualityComparer<M33l>
    {
        public static readonly M33lEqualityComparer Default
            = new M33lEqualityComparer();

        #region IEqualityComparer<M33l> Members

        public bool Equals(M33l v0, M33l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M33l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M33l m)
            => (m.C0.Length + m.C1.Length + m.C2.Length) / 3;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetScaleVector(this M33l m)
            => new V3d(m.C0.Length, m.C1.Length, m.C2.Length);

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of 2D basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale2(this M33l m)
            => (m.C0.XY.Length + m.C1.XY.Length) / 2;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the 2D basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d GetScaleVector2(this M33l m)
            => new V2d(m.C0.XY.Length, m.C1.XY.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Norm1(M33l m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M33l m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMax(M33l m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMin(M33l m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M33l m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(this M33l a, M33l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M33l a, M33l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M33l a, M33l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(this M33l a, M33l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(this M33l a, M33l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l Transform(this M33l m, V3l v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l Transform(this M33l m, V4l v)
        {
            return new V4l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l TransposedTransform(this M33l m, V3l v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l TransposedTransform(this M33l m, V4l v)
        {
            return new V4l(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22,
                v.W);
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2l TransformDir(this M33l m, V2l v)
        {
            return new V2l(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2l TransformPos(this M33l m, V2l p)
        {
            return new V2l(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2l TransformPosProj(this M33l m, V2l p)
        {
            long s = m.M20 * p.X + m.M21 * p.Y + m.M22;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3l TransformPosProjFull(this M33l m, V2l p)
        {
            return new V3l(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12, 
                m.M20 * p.X + m.M21 * p.Y + m.M22
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V2l TransposedTransformDir(this M33l m, V2l v)
        {
            return new V2l(
                m.M00 * v.X + m.M10 * v.Y, 
                m.M01 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2l TransposedTransformPos(this M33l m, V2l p)
        {
            return new V2l(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2l TransposedTransformProj(this M33l m, V2l p)
        {
            var s = m.M02 * p.X + m.M12 * p.Y + m.M22;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3l TransposedTransformProjFull(this M33l m, V2l p)
        {
            return new V3l(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21, 
                m.M02 * p.X + m.M12 * p.Y + m.M22
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M33l"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M22l Minor(this M33l m, int row, int column)
        {
            M22l rs = new M22l();

            for (int k = 0; k < 4; k++)
            {
                var i = k / 2;
                var j = k % 2;
                var ii = (i < row) ? i : i + 1;
                var jj = (j < column) ? j : j + 1;

                rs[k] = m[ii * 3 + jj];
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3l Row(this M33l m, int index)
        {
            long* ptr = &m.M00;
            return new V3l(ptr[index * 3], ptr[index * 3 + 1], ptr[index * 3 + 2]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3l Column(this M33l m, int index)
        {
            long* ptr = &m.M00;
            return new V3l(ptr[index], ptr[index + 3], ptr[index + 6]);
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Determinant(M33l m)
            => m.Determinant;

        /// <summary>
        /// Returns the transpose of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l Transposed(M33l m)
            => m.Transposed;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Transpose(this ref M33l m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
        }

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M33l"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long MinElement(M33l m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M33l"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long MaxElement(M33l m)
            => m.MaxElement;

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M33l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M33l m, long epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon) || m.M20.IsTiny(epsilon) || m.M21.IsTiny(epsilon) || m.M22.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M33l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M33l m, long epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon) && m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon) && m.M22.IsTiny(epsilon);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M33l a, M33l b, long epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M33l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M33l m, long epsilon)
            => Mat.AllTiny(m, epsilon);

        #endregion
    }

    public static class IRandomUniformM33lExtensions
    {
        #region IRandomUniform extensions for M33l

        /// <summary>
        /// Uses UniformLong() to generate the elements of an M33l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l UniformM33l(this IRandomUniform rnd)
        {
            return new M33l(
                rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), 
                rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), 
                rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong());
        }

        /// <summary>
        /// Uses UniformLongNonZero() to generate the elements of an M33l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l UniformM33lNonZero(this IRandomUniform rnd)
        {
            return new M33l(
                rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), 
                rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), 
                rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero());
        }

        /// <summary>
        /// Uses UniformLong(long) to generate the elements of an M33l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l UniformM33l(this IRandomUniform rnd, long size)
        {
            return new M33l(
                rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), 
                rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), 
                rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size));
        }

        /// <summary>
        /// Uses UniformLong(long) to generate the elements of an M33l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33l UniformM33l(this IRandomUniform rnd, M33l size)
        {
            return new M33l(
                rnd.UniformLong(size.M00), rnd.UniformLong(size.M01), rnd.UniformLong(size.M02), 
                rnd.UniformLong(size.M10), rnd.UniformLong(size.M11), rnd.UniformLong(size.M12), 
                rnd.UniformLong(size.M20), rnd.UniformLong(size.M21), rnd.UniformLong(size.M22));
        }

        #endregion
    }

    #endregion

    #region M33f

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M33f : IEquatable<M33f>, IValidity, IMatrix<double>
    {
        [DataMember]
        public float M00, M01, M02;
        [DataMember]
        public float M10, M11, M12;
        [DataMember]
        public float M20, M21, M22;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(float value)
        {
            M00 = value; M01 = 0; M02 = 0; 
            M10 = 0; M11 = value; M12 = 0; 
            M20 = 0; M21 = 0; M22 = value; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(
                float m00, float m01, float m02, 
                float m10, float m11, float m12, 
                float m20, float m21, float m22)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
            M20 = m20; M21 = m21; M22 = m22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
            M20 = a[6];
            M21 = a[7];
            M22 = a[8];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
            M20 = a[start + 6];
            M21 = a[start + 7];
            M22 = a[start + 8];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M22i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M23i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M33i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M34i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M44i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M22l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M23l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M33l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M34l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M44l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M22f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M23f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M34f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M44f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M22d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M23d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M33d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M34d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33f(M44d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; 
        }

        #endregion

        #region Conversions

        public static explicit operator M33f(M22i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M23i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M33i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M34i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M44i m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M22l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M23l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M33l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M34l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M44l m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M22f m)
        {
            return new M33f {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M23f m)
        {
            return new M33f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M34f m)
        {
            return new M33f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33f(M44f m)
        {
            return new M33f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33f(M22d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M23d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33f(M33d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M34d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(M44d m)
        {
            return new M33f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, 
            };
        }

        public static explicit operator M33f(int[] a)
        {
            return new M33f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5], 
                (float)a[6], (float)a[7], (float)a[8]);
        }

        public static explicit operator M33f(int[,] a)
        {
            return new M33f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2]);
        }

        public static explicit operator int[](M33f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12, 
                (int)m.M20, (int)m.M21, (int)m.M22
            };
        }

        public static explicit operator int[,](M33f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
            array[index + 6] = (int)M20;
            array[index + 7] = (int)M21;
            array[index + 8] = (int)M22;
        }

        public static explicit operator M33f(long[] a)
        {
            return new M33f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5], 
                (float)a[6], (float)a[7], (float)a[8]);
        }

        public static explicit operator M33f(long[,] a)
        {
            return new M33f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2]);
        }

        public static explicit operator long[](M33f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12, 
                (long)m.M20, (long)m.M21, (long)m.M22
            };
        }

        public static explicit operator long[,](M33f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
            array[index + 6] = (long)M20;
            array[index + 7] = (long)M21;
            array[index + 8] = (long)M22;
        }

        public static explicit operator M33f(float[] a)
        {
            return new M33f(
                a[0], a[1], a[2], 
                a[3], a[4], a[5], 
                a[6], a[7], a[8]);
        }

        public static explicit operator M33f(float[,] a)
        {
            return new M33f(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2], 
                a[2, 0], a[2, 1], a[2, 2]);
        }

        public static explicit operator float[](M33f m)
        {
            return new float[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12, 
                m.M20, m.M21, m.M22
            };
        }

        public static explicit operator float[,](M33f m)
        {
            return new float[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }, 
                { m.M20, m.M21, m.M22 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
            array[index + 6] = M20;
            array[index + 7] = M21;
            array[index + 8] = M22;
        }

        public static explicit operator M33f(double[] a)
        {
            return new M33f(
                (float)a[0], (float)a[1], (float)a[2], 
                (float)a[3], (float)a[4], (float)a[5], 
                (float)a[6], (float)a[7], (float)a[8]);
        }

        public static explicit operator M33f(double[,] a)
        {
            return new M33f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2]);
        }

        public static explicit operator double[](M33f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, 
                (double)m.M10, (double)m.M11, (double)m.M12, 
                (double)m.M20, (double)m.M21, (double)m.M22
            };
        }

        public static explicit operator double[,](M33f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M10;
            array[index + 4] = (double)M11;
            array[index + 5] = (double)M12;
            array[index + 6] = (double)M20;
            array[index + 7] = (double)M21;
            array[index + 8] = (double)M22;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<float, int> element_fun)
        {
            return new M33i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M33i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<float, long> element_fun)
        {
            return new M33l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M33l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<float, float> element_fun)
        {
            return new M33f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M33f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<float, double> element_fun)
        {
            return new M33d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M33d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M22f UpperLeftM22()
        {
            return (M22f)this;
        }

        public float[] ToArray()
        {
            var array = new float[9];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            array[6] = M20;
            array[7] = M21;
            array[8] = M22;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f FromCols(V3f col0, V3f col1, V3f col2)
        {
            return new M33f(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y, 
                col0.Z, col1.Z, col2.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f FromRows(V3f row0, V3f row1, V3f row2)
        {
            return new M33f(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z, 
                row2.X, row2.Y, row2.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f FromDiagonal(float value)
        {
            return new M33f(
                value, 0, 0, 
                0, value, 0, 
                0, 0, value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f FromDiagonal(float m00, float m11, float m22)
        {
            return new M33f(
                m00, 0, 0, 
                0, m11, 0, 
                0, 0, m22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f FromDiagonal(V3f s)
        {
            return new M33f(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, s.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f FromAntiDiagonal(float value)
        {
            return new M33f(
                 0, 0, value, 
                 0, value, 0, 
                 value, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f FromAntiDiagonal(float m02, float m11, float m20)
        {
            return new M33f(
                0, 0, m02, 
                0, m11, 0, 
                m20, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f FromAntiDiagonal(V3f s)
        {
            return new M33f(
                0, 0, s.X, 
                0, s.Y, 0, 
                s.Z, 0, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Scale(float sX, float sY, float sZ)
            => FromDiagonal(sX, sY, sZ);

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> using a <see cref="V3f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Scale(V3f s)
            => FromDiagonal(s);

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> from a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Scale(Scale3f s)
        {
            return new M33f(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, s.Z);
        }

        /// <summary>
        /// Creates a homogenous transformation <see cref="M33f"/> using a uniform scale.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Scale(float s)
        {
            return new M33f(
                s, 0, 0, 
                0, s, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Scale(float sX, float sY)
        {
            return new M33f(
                sX, 0, 0, 
                0, sY, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> using a <see cref="V2f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Scale(V2f s)
        {
            return new M33f(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a scaling transformation <see cref="M33f"/> from a <see cref="Scale2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Scale(Scale2f s)
        {
            return new M33f(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, 1);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Translation(float tX, float tY)
        {
            return new M33f(
                1, 0, tX, 
                0, 1, tY, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> with the translational component given by a <see cref="V2f"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Translation(V2f t)
        {
            return new M33f(
                1, 0, t.X, 
                0, 1, t.Y, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33f"/> from a <see cref="Shift2f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Translation(Shift2f s)
        {
            return new M33f(
                1, 0, s.X, 
                0, 1, s.Y, 
                0, 0, 1);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in radians.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Rotation(float angleInRadians)
        {
            var a = Fun.Cos(angleInRadians);
            var b = Fun.Sin(angleInRadians);

            return new M33f(
                 a, -b,  0, 
                 b,  a,  0, 
                 0,  0,  1);
        }

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in degrees.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotationInDegrees(float angleInDegrees)
            => Rotation(angleInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix from a <see cref="Rot3f"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Rotation(Rot3f r)
            => (M33f)r;

        /// <summary>
        /// Creates a 2D rotation matrix from a <see cref="Rot2f"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Rotation(Rot2f r)
            => (M33f)r;

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in radians.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Rotation(V3f normalizedAxis, float angleInRadians)
        {
            Debug.Assert(normalizedAxis.LengthSquared.ApproximateEquals(1));
            return (M33f)(Rot3f.Rotation(normalizedAxis, angleInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in degrees.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotationInDegrees(V3f normalizedAxis, float angleInDegrees)
            => Rotation(normalizedAxis, angleInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) in radians. 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotationEuler(float rollInRadians, float pitchInRadians, float yawInRadians)
        {
            return (M33f)(Rot3f.RotationEuler(rollInRadians, pitchInRadians, yawInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) in degrees. 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotationEulerInDegrees(float rollInDegrees, float pitchInDegrees, float yawInDegrees)
            => RotationEuler(
                rollInDegrees.RadiansFromDegrees(),
                pitchInDegrees.RadiansFromDegrees(), 
                yawInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) vector in radians.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotationEuler(V3f rollPitchYawInRadians)
            => RotationEuler(
                rollPitchYawInRadians.X,
                rollPitchYawInRadians.Y,
                rollPitchYawInRadians.Z);

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) vector in degrees.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotationEulerInDegrees(V3f rollPitchYawInDegrees)
            => RotationEulerInDegrees(
                rollPitchYawInDegrees.X,
                rollPitchYawInDegrees.Y,
                rollPitchYawInDegrees.Z);

        /// <summary>
        /// Creates a 3D rotation matrix which rotates one vector into another.
        /// The input vectors have to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotateInto(V3f from, V3f into)
        {
            Debug.Assert(from.LengthSquared.ApproximateEquals(1));
            Debug.Assert(into.LengthSquared.ApproximateEquals(1));
            return (M33f)(Rot3f.RotateInto(from, into));
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotationX(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M33f(
                 1,  0,  0, 
                 0,  a, -b, 
                 0,  b,  a);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotationXInDegrees(float angleDegrees)
            => RotationX(angleDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotationY(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M33f(
                 a,  0,  b, 
                 0,  1,  0, 
                -b,  0,  a);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotationYInDegrees(float angleDegrees)
            => RotationY(angleDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotationZ(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M33f(
                 a, -b,  0, 
                 b,  a,  0, 
                 0,  0,  1);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f RotationZInDegrees(float angleDegrees)
            => RotationZ(angleDegrees.RadiansFromDegrees());

        #endregion

        #region Shearing

        /// <summary>
        /// Creates a shear transformation matrix along the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f ShearXY(float factorX, float factorY)
        {
            return new M33f(
                1, 0, factorX, 
                0, 1, factorY, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f ShearXZ(float factorX, float factorZ)
        {
            return new M33f(
                1, factorX, 0, 
                0, 1, 0, 
                0, factorZ, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f ShearYZ(float factorY, float factorZ)
        {
            return new M33f(
                1, 0, 0, 
                factorY, 1, 0, 
                factorZ, 0, 1);
        }

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f DivideByInt(M33f m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<float> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M20;
                yield return M21;
                yield return M22;
            }
        }

        public IEnumerable<V3f> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3f> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        [XmlIgnore]
        public V3f R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3f( M00,  M01,  M02); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        [XmlIgnore]
        public V3f R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3f( M10,  M11,  M12); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        [XmlIgnore]
        public V3f R2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3f( M20,  M21,  M22); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
            }
        }

        [XmlIgnore]
        public V3f C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3f( M00,  M10,  M20); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        [XmlIgnore]
        public V3f C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3f( M01,  M11,  M21); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        [XmlIgnore]
        public V3f C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3f( M02,  M12,  M22); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public V3f Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V3f(M00, M11, M22);
        }

        public V3f AntiDiagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V3f(M02, M11, M20);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public float MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M10, M11, M12, M20, M21, M22);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public float MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M10, M11, M12, M20, M21, M22);
        }

        public unsafe float this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (float* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (float* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe float this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (float* ptr = &M00) { return ptr[row * 3 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (float* ptr = &M00) { ptr[row * 3 + column] = value; }
            }
        }

        public bool AnyNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNaN(M00) || float.IsNaN(M01) || float.IsNaN(M02) || 
                    float.IsNaN(M10) || float.IsNaN(M11) || float.IsNaN(M12) || 
                    float.IsNaN(M20) || float.IsNaN(M21) || float.IsNaN(M22);
            }
        }

        public bool AllNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNaN(M00) && float.IsNaN(M01) && float.IsNaN(M02) && 
                    float.IsNaN(M10) && float.IsNaN(M11) && float.IsNaN(M12) && 
                    float.IsNaN(M20) && float.IsNaN(M21) && float.IsNaN(M22);
            }
        }

        public bool AnyInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsInfinity(M00) || float.IsInfinity(M01) || float.IsInfinity(M02) || 
                    float.IsInfinity(M10) || float.IsInfinity(M11) || float.IsInfinity(M12) || 
                    float.IsInfinity(M20) || float.IsInfinity(M21) || float.IsInfinity(M22);
            }
        }

        public bool AllInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsInfinity(M00) && float.IsInfinity(M01) && float.IsInfinity(M02) && 
                    float.IsInfinity(M10) && float.IsInfinity(M11) && float.IsInfinity(M12) && 
                    float.IsInfinity(M20) && float.IsInfinity(M21) && float.IsInfinity(M22);
            }
        }

        public bool AnyPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsPositiveInfinity(M00) || float.IsPositiveInfinity(M01) || float.IsPositiveInfinity(M02) || 
                    float.IsPositiveInfinity(M10) || float.IsPositiveInfinity(M11) || float.IsPositiveInfinity(M12) || 
                    float.IsPositiveInfinity(M20) || float.IsPositiveInfinity(M21) || float.IsPositiveInfinity(M22);
            }
        }

        public bool AllPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsPositiveInfinity(M00) && float.IsPositiveInfinity(M01) && float.IsPositiveInfinity(M02) && 
                    float.IsPositiveInfinity(M10) && float.IsPositiveInfinity(M11) && float.IsPositiveInfinity(M12) && 
                    float.IsPositiveInfinity(M20) && float.IsPositiveInfinity(M21) && float.IsPositiveInfinity(M22);
            }
        }

        public bool AnyNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNegativeInfinity(M00) || float.IsNegativeInfinity(M01) || float.IsNegativeInfinity(M02) || 
                    float.IsNegativeInfinity(M10) || float.IsNegativeInfinity(M11) || float.IsNegativeInfinity(M12) || 
                    float.IsNegativeInfinity(M20) || float.IsNegativeInfinity(M21) || float.IsNegativeInfinity(M22);
            }
        }

        public bool AllNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNegativeInfinity(M00) && float.IsNegativeInfinity(M01) && float.IsNegativeInfinity(M02) && 
                    float.IsNegativeInfinity(M10) && float.IsNegativeInfinity(M11) && float.IsNegativeInfinity(M12) && 
                    float.IsNegativeInfinity(M20) && float.IsNegativeInfinity(M21) && float.IsNegativeInfinity(M22);
            }
        }

        public bool AnyTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) || Fun.IsTiny(M01) || Fun.IsTiny(M02) || 
                    Fun.IsTiny(M10) || Fun.IsTiny(M11) || Fun.IsTiny(M12) || 
                    Fun.IsTiny(M20) || Fun.IsTiny(M21) || Fun.IsTiny(M22);
            }
        }

        public bool AllTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) && Fun.IsTiny(M01) && Fun.IsTiny(M02) && 
                    Fun.IsTiny(M10) && Fun.IsTiny(M11) && Fun.IsTiny(M12) && 
                    Fun.IsTiny(M20) && Fun.IsTiny(M21) && Fun.IsTiny(M22);
            }
        }

        /// <summary>
        /// Returns true if the absolute value of each element of the matrix is smaller than Constant&lt;float&gt;.PositiveTinyValue, false otherwise.
        /// </summary>
        public bool IsTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AllTiny;
        }

        /// <summary>
        /// Returns true if any element of the matrix is NaN, false otherwise.
        /// </summary>
        public bool IsNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyNaN;
        }

        /// <summary>
        /// Returns true if any element of the matrix is infinite (positive or negative), false otherwise.
        /// </summary>
        public bool IsInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyInfinity;
        }

        /// <summary>
        /// Returns whether all elements of the matrix are finite (i.e. not NaN and not infinity).
        /// </summary>
        public bool IsFinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => !(IsInfinity || IsNaN);
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 3;
        public const int ElementCount = 3 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 3);
        }

        public static M33f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33f(0);
        }

        public static M33f Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33f(1, 0, 0, 0, 1, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + 
                    M20 * M20 + M21 * M21 + M22 * M22);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator -(M33f m)
        {
            return new M33f(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12, 
                -m.M20, -m.M21, -m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  + (M33f a, M33f b)
        {
            return new M33f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  + (M33f m, float s)
        {
            return new M33f(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  + (float s, M33f m)
        {
            return new M33f(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  + (M33f a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  + (M33f m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  + (double s, M33f m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  - (M33f a, M33f b)
        {
            return new M33f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  - (M33f m, float s)
        {
            return new M33f(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  - (float s, M33f m)
        {
            return new M33f(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  - (M33f a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  - (M33f m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  - (double s, M33f m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  % (M33f a, M33f b)
        {
            return new M33f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  % (M33f m, float s)
        {
            return new M33f(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  % (float s, M33f m)
        {
            return new M33f(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  % (M33f a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  % (M33f m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  % (double s, M33f m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  / (M33f a, M33f b)
        {
            return new M33f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  / (M33f m, float s)
        {
            return new M33f(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  / (float s, M33f m)
        {
            return new M33f(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  / (M33f a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  / (M33f m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  / (double s, M33f m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  * (M33f m, float s)
        {
            return new M33f(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f operator  * (float s, M33f m)
        {
            return new M33f(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  * (M33f m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  * (double s, M33f m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M33f matrix with a V3f column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f operator *(M33f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        /// <summary>
        /// Multiplies a V3f row vector with a M33f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f operator *(V3f v, M33f m)
        {
            return new V3f(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M33f a, M33f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M33f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(float s, M33f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M33f a, M33f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M33f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(float s, M33f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M33f a, M33f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M33f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(float s, M33f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M33f a, M33f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M33f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(float s, M33f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M33f a, M33f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M33f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(float s, M33f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M33f a, M33f b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M33f m, float s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(float s, M33f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02),
                        HashCode.GetCombined(M10, M11, M12),
                        HashCode.GetCombined(M20, M21, M22));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M33f other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12) && 
                M20.Equals(other.M20) && M21.Equals(other.M21) && M22.Equals(other.M22);
        }

        public override bool Equals(object other)
            => (other is M33f o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M33f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M33f.FromRows(
                V3f.Parse(x[0]), 
                V3f.Parse(x[1]), 
                V3f.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M33f Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M33f result = new M33f();
                for (int row = 0; row < 3; row++)
                {
                    for (int col = 0; col < 3; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public float Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public float Determinant
        {
            get
            {
                if (M10 == 0 && M20 == 0 && M21 == 0)
                {
                    return M00 * M11 * M22;
                }
                return
                M00 * M11 * M22 - M00 * M12 * M21 +
                M01 * M12 * M20 - M01 * M10 * M22 +
                M02 * M10 * M21 - M02 * M11 * M20;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M33f Transposed
        {
            get
            {
                return new M33f {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22
                };
            }
        }

        private static V2l s_luSize = new V2l(3, 3);
        private static V2l s_luDelta = new V2l(1, 3);

        /// <summary>
        /// Inverts the given matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            M33d dbl = (M33d)this;
            if(dbl.LuInvert()) 
            { 
                this = (M33f)dbl;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M33f.Zero is returned.
        /// </summary>
        public M33f LuInverse()
        {
            return (M33f)((M33d)this).LuInverse();
        }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M33f.Zero is returned.
        /// </summary>
        public M33f Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => LuInverse();
        }

        #endregion

        #region Matrix Multiplication

        public static M33f operator *(M33f a, M33f b)
        {
            return new M33f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M33fEqualityComparer : IEqualityComparer<M33f>
    {
        public static readonly M33fEqualityComparer Default
            = new M33fEqualityComparer();

        #region IEqualityComparer<M33f> Members

        public bool Equals(M33f v0, M33f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M33f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float GetScale(this M33f m)
            => (m.C0.Length + m.C1.Length + m.C2.Length) / 3;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f GetScaleVector(this M33f m)
            => new V3f(m.C0.Length, m.C1.Length, m.C2.Length);

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of 2D basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float GetScale2(this M33f m)
            => (m.C0.XY.Length + m.C1.XY.Length) / 2;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the 2D basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2f GetScaleVector2(this M33f m)
            => new V2f(m.C0.XY.Length, m.C1.XY.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm1(M33f m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm2(M33f m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMax(M33f m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMin(M33f m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm(this M33f m, float p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(this M33f a, M33f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(this M33f a, M33f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(this M33f a, M33f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(this M33f a, M33f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(this M33f a, M33f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this M33f m, V3f v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Transform(this M33f m, V4f v)
        {
            return new V4f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f TransposedTransform(this M33f m, V3f v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f TransposedTransform(this M33f m, V4f v)
        {
            return new V4f(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22,
                v.W);
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2f TransformDir(this M33f m, V2f v)
        {
            return new V2f(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2f TransformPos(this M33f m, V2f p)
        {
            return new V2f(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2f TransformPosProj(this M33f m, V2f p)
        {
            float s = m.M20 * p.X + m.M21 * p.Y + m.M22;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3f TransformPosProjFull(this M33f m, V2f p)
        {
            return new V3f(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12, 
                m.M20 * p.X + m.M21 * p.Y + m.M22
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V2f TransposedTransformDir(this M33f m, V2f v)
        {
            return new V2f(
                m.M00 * v.X + m.M10 * v.Y, 
                m.M01 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2f TransposedTransformPos(this M33f m, V2f p)
        {
            return new V2f(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2f TransposedTransformProj(this M33f m, V2f p)
        {
            var s = m.M02 * p.X + m.M12 * p.Y + m.M22;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3f TransposedTransformProjFull(this M33f m, V2f p)
        {
            return new V3f(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21, 
                m.M02 * p.X + m.M12 * p.Y + m.M22
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M33f"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M22f Minor(this M33f m, int row, int column)
        {
            M22f rs = new M22f();

            for (int k = 0; k < 4; k++)
            {
                var i = k / 2;
                var j = k % 2;
                var ii = (i < row) ? i : i + 1;
                var jj = (j < column) ? j : j + 1;

                rs[k] = m[ii * 3 + jj];
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3f Row(this M33f m, int index)
        {
            float* ptr = &m.M00;
            return new V3f(ptr[index * 3], ptr[index * 3 + 1], ptr[index * 3 + 2]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3f Column(this M33f m, int index)
        {
            float* ptr = &m.M00;
            return new V3f(ptr[index], ptr[index + 3], ptr[index + 6]);
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Determinant(M33f m)
            => m.Determinant;

        /// <summary>
        /// Returns the transpose of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Transposed(M33f m)
            => m.Transposed;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Transpose(this ref M33f m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
        }

        /// <summary>
        /// Returns the inverse of the given matrix. If the matrix is not invertible
        /// M33f.Zero is returned.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Inverse(M33f m)
            => m.Inverse;

        /// <summary>
        /// Inverts the given matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Invert(this ref M33f m) { return m.LuInvert(); }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M33f m, float epsilon)
        {
            return Fun.ApproximateEquals(m, M33f.Identity, epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M33f m)
            => IsIdentity(m, Constant<float>.PositiveTinyValue);

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M33f m, float epsilon)
        {
            var i = m * m.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M33f m)
            => IsOrthonormal(m, Constant<float>.PositiveTinyValue);

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M33f m, float epsilon)
        {
            var i = m * m.Transposed;
            for (int j = 0; j < 3; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M33f m)
            => IsOrthogonal(m, Constant<float>.PositiveTinyValue);

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M33f"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MinElement(M33f m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M33f"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MaxElement(M33f m)
            => m.MaxElement;

        #endregion

        #region Orthogonalization

        /// <summary>
        /// Orthogonalizes the columns of the given <see cref="M33f"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        public static void Orthogonalize(this ref M33f matrix)
        {
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
        }

        /// <summary>
        /// Orthogonalizes the columns of the given <see cref="M33f"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Orthogonalized(this M33f matrix)
        {
            M33f m = matrix;
            Orthogonalize(ref m);
            return m;
        }

        /// <summary>
        /// Orthonormalizes the columns of the given <see cref="M33f"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        public static void Orthonormalize(this ref M33f matrix)
        {
            matrix.C0 = matrix.C0.Normalized;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 = matrix.C1.Normalized;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C2 = matrix.C2.Normalized;
        }

        /// <summary>
        /// Orthonormalizes the columns of the given <see cref="M33f"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f Orthonormalized(this M33f matrix)
        {
            M33f m = matrix;
            Orthonormalize(ref m);
            return m;
        }

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M33f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M33f m, float epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon) || m.M20.IsTiny(epsilon) || m.M21.IsTiny(epsilon) || m.M22.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M33f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M33f m, float epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon) && m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon) && m.M22.IsTiny(epsilon);

        #endregion

        #region Special Floating Point Value Checks

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNaN(M33f m)
            => m.AnyNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNaN(M33f m)
            => m.AllNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyInfinity(M33f m)
            => m.AnyInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllInfinity(M33f m)
            => m.AllInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyPositiveInfinity(M33f m)
            => m.AnyPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllPositiveInfinity(M33f m)
            => m.AllPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNegativeInfinity(M33f m)
            => m.AnyNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNegativeInfinity(M33f m)
            => m.AllNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(M33f m)
            => m.AnyTiny;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(M33f m)
            => m.AllTiny;

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M33f a, M33f b)
            => ApproximateEquals(a, b, Constant<float>.PositiveTinyValue);

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M33f a, M33f b, float epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M33f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M33f m, float epsilon)
            => Mat.AllTiny(m, epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M33f"/> is smaller than Constant&lt;float&gt;.PositiveTinyValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(M33f m)
            => m.IsTiny;

        #endregion

        #region Special Floating Point Value Checks

        /// <summary>
        /// Returns whether any element of the given <see cref="M33f"/> is NaN.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNaN(M33f v)
            => v.IsNaN;

        /// <summary>
        /// Returns whether any element of the given <see cref="M33f"/> is infinity (positive or negative).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInfinity(M33f v)
            => v.IsInfinity;

        /// <summary>
        /// Returns whether all elements of the given <see cref="M33f"/> are finite (i.e. not NaN and not infinity).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsFinite(M33f v)
            => v.IsFinite;

        #endregion
    }

    public static class IRandomUniformM33fExtensions
    {
        #region IRandomUniform extensions for M33f

        /// <summary>
        /// Uses UniformFloat() to generate the elements of an M33f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f UniformM33f(this IRandomUniform rnd)
        {
            return new M33f(
                rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), 
                rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), 
                rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat());
        }

        /// <summary>
        /// Uses UniformFloatClosed() to generate the elements of an M33f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f UniformM33fClosed(this IRandomUniform rnd)
        {
            return new M33f(
                rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), 
                rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), 
                rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed());
        }

        /// <summary>
        /// Uses UniformFloatOpen() to generate the elements of an M33f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33f UniformM33fOpen(this IRandomUniform rnd)
        {
            return new M33f(
                rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), 
                rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), 
                rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen());
        }

        #endregion
    }

    #endregion

    #region M33d

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M33d : IEquatable<M33d>, IValidity, IMatrix<double>
    {
        [DataMember]
        public double M00, M01, M02;
        [DataMember]
        public double M10, M11, M12;
        [DataMember]
        public double M20, M21, M22;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(double value)
        {
            M00 = value; M01 = 0; M02 = 0; 
            M10 = 0; M11 = value; M12 = 0; 
            M20 = 0; M21 = 0; M22 = value; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(
                double m00, double m01, double m02, 
                double m10, double m11, double m12, 
                double m20, double m21, double m22)
        {
            M00 = m00; M01 = m01; M02 = m02; 
            M10 = m10; M11 = m11; M12 = m12; 
            M20 = m20; M21 = m21; M22 = m22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M10 = a[3];
            M11 = a[4];
            M12 = a[5];
            M20 = a[6];
            M21 = a[7];
            M22 = a[8];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M10 = a[start + 3];
            M11 = a[start + 4];
            M12 = a[start + 5];
            M20 = a[start + 6];
            M21 = a[start + 7];
            M22 = a[start + 8];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M22i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M23i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M33i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M34i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M44i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M22l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M23l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M33l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M34l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M44l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M22f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M23f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M33f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M34f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M44f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M22d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M23d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = 0; M21 = 0; M22 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M34d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M33d(M44d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; 
        }

        #endregion

        #region Conversions

        public static explicit operator M33d(M22i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M23i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M33i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M34i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M44i m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M22l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M23l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M33l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M34l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M44l m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M22f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M23f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M33f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M34f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M44f m)
        {
            return new M33d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, 
            };
        }

        public static explicit operator M33d(M22d m)
        {
            return new M33d {
                M00 = m.M00, M01 = m.M01, M02 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M23d m)
        {
            return new M33d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = 0, M21 = 0, M22 = 1, 
            };
        }

        public static explicit operator M33d(M34d m)
        {
            return new M33d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33d(M44d m)
        {
            return new M33d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, 
            };
        }

        public static explicit operator M33d(int[] a)
        {
            return new M33d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5], 
                (double)a[6], (double)a[7], (double)a[8]);
        }

        public static explicit operator M33d(int[,] a)
        {
            return new M33d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2]);
        }

        public static explicit operator int[](M33d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, 
                (int)m.M10, (int)m.M11, (int)m.M12, 
                (int)m.M20, (int)m.M21, (int)m.M22
            };
        }

        public static explicit operator int[,](M33d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M10;
            array[index + 4] = (int)M11;
            array[index + 5] = (int)M12;
            array[index + 6] = (int)M20;
            array[index + 7] = (int)M21;
            array[index + 8] = (int)M22;
        }

        public static explicit operator M33d(long[] a)
        {
            return new M33d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5], 
                (double)a[6], (double)a[7], (double)a[8]);
        }

        public static explicit operator M33d(long[,] a)
        {
            return new M33d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2]);
        }

        public static explicit operator long[](M33d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, 
                (long)m.M10, (long)m.M11, (long)m.M12, 
                (long)m.M20, (long)m.M21, (long)m.M22
            };
        }

        public static explicit operator long[,](M33d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M10;
            array[index + 4] = (long)M11;
            array[index + 5] = (long)M12;
            array[index + 6] = (long)M20;
            array[index + 7] = (long)M21;
            array[index + 8] = (long)M22;
        }

        public static explicit operator M33d(float[] a)
        {
            return new M33d(
                (double)a[0], (double)a[1], (double)a[2], 
                (double)a[3], (double)a[4], (double)a[5], 
                (double)a[6], (double)a[7], (double)a[8]);
        }

        public static explicit operator M33d(float[,] a)
        {
            return new M33d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2]);
        }

        public static explicit operator float[](M33d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, 
                (float)m.M10, (float)m.M11, (float)m.M12, 
                (float)m.M20, (float)m.M21, (float)m.M22
            };
        }

        public static explicit operator float[,](M33d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M10;
            array[index + 4] = (float)M11;
            array[index + 5] = (float)M12;
            array[index + 6] = (float)M20;
            array[index + 7] = (float)M21;
            array[index + 8] = (float)M22;
        }

        public static explicit operator M33d(double[] a)
        {
            return new M33d(
                a[0], a[1], a[2], 
                a[3], a[4], a[5], 
                a[6], a[7], a[8]);
        }

        public static explicit operator M33d(double[,] a)
        {
            return new M33d(
                a[0, 0], a[0, 1], a[0, 2], 
                a[1, 0], a[1, 1], a[1, 2], 
                a[2, 0], a[2, 1], a[2, 2]);
        }

        public static explicit operator double[](M33d m)
        {
            return new double[] {
                m.M00, m.M01, m.M02, 
                m.M10, m.M11, m.M12, 
                m.M20, m.M21, m.M22
            };
        }

        public static explicit operator double[,](M33d m)
        {
            return new double[,] {
                { m.M00, m.M01, m.M02 }, 
                { m.M10, m.M11, m.M12 }, 
                { m.M20, m.M21, m.M22 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M10;
            array[index + 4] = M11;
            array[index + 5] = M12;
            array[index + 6] = M20;
            array[index + 7] = M21;
            array[index + 8] = M22;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<double, int> element_fun)
        {
            return new M33i(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M33i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<double, long> element_fun)
        {
            return new M33l(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M33l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<double, float> element_fun)
        {
            return new M33f(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M33f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<double, double> element_fun)
        {
            return new M33d(
                element_fun(M00), element_fun(M01), element_fun(M02), 
                element_fun(M10), element_fun(M11), element_fun(M12), 
                element_fun(M20), element_fun(M21), element_fun(M22));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M33d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M33d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M22d UpperLeftM22()
        {
            return (M22d)this;
        }

        public double[] ToArray()
        {
            var array = new double[9];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M10;
            array[4] = M11;
            array[5] = M12;
            array[6] = M20;
            array[7] = M21;
            array[8] = M22;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d FromCols(V3d col0, V3d col1, V3d col2)
        {
            return new M33d(
                col0.X, col1.X, col2.X, 
                col0.Y, col1.Y, col2.Y, 
                col0.Z, col1.Z, col2.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d FromRows(V3d row0, V3d row1, V3d row2)
        {
            return new M33d(
                row0.X, row0.Y, row0.Z, 
                row1.X, row1.Y, row1.Z, 
                row2.X, row2.Y, row2.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d FromDiagonal(double value)
        {
            return new M33d(
                value, 0, 0, 
                0, value, 0, 
                0, 0, value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d FromDiagonal(double m00, double m11, double m22)
        {
            return new M33d(
                m00, 0, 0, 
                0, m11, 0, 
                0, 0, m22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d FromDiagonal(V3d s)
        {
            return new M33d(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, s.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d FromAntiDiagonal(double value)
        {
            return new M33d(
                 0, 0, value, 
                 0, value, 0, 
                 value, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d FromAntiDiagonal(double m02, double m11, double m20)
        {
            return new M33d(
                0, 0, m02, 
                0, m11, 0, 
                m20, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d FromAntiDiagonal(V3d s)
        {
            return new M33d(
                0, 0, s.X, 
                0, s.Y, 0, 
                s.Z, 0, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Scale(double sX, double sY, double sZ)
            => FromDiagonal(sX, sY, sZ);

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> using a <see cref="V3d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Scale(V3d s)
            => FromDiagonal(s);

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> from a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Scale(Scale3d s)
        {
            return new M33d(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, s.Z);
        }

        /// <summary>
        /// Creates a homogenous transformation <see cref="M33d"/> using a uniform scale.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Scale(double s)
        {
            return new M33d(
                s, 0, 0, 
                0, s, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> using 2 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Scale(double sX, double sY)
        {
            return new M33d(
                sX, 0, 0, 
                0, sY, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> using a <see cref="V2d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Scale(V2d s)
        {
            return new M33d(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a scaling transformation <see cref="M33d"/> from a <see cref="Scale2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Scale(Scale2d s)
        {
            return new M33d(
                s.X, 0, 0, 
                0, s.Y, 0, 
                0, 0, 1);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> with the translational component given by 2 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Translation(double tX, double tY)
        {
            return new M33d(
                1, 0, tX, 
                0, 1, tY, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> with the translational component given by a <see cref="V2d"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Translation(V2d t)
        {
            return new M33d(
                1, 0, t.X, 
                0, 1, t.Y, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M33d"/> from a <see cref="Shift2d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Translation(Shift2d s)
        {
            return new M33d(
                1, 0, s.X, 
                0, 1, s.Y, 
                0, 0, 1);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in radians.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Rotation(double angleInRadians)
        {
            var a = Fun.Cos(angleInRadians);
            var b = Fun.Sin(angleInRadians);

            return new M33d(
                 a, -b,  0, 
                 b,  a,  0, 
                 0,  0,  1);
        }

        /// <summary>
        /// Creates a 2D rotation matrix with the specified angle in degrees.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotationInDegrees(double angleInDegrees)
            => Rotation(angleInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix from a <see cref="Rot3d"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Rotation(Rot3d r)
            => (M33d)r;

        /// <summary>
        /// Creates a 2D rotation matrix from a <see cref="Rot2d"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Rotation(Rot2d r)
            => (M33d)r;

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in radians.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Rotation(V3d normalizedAxis, double angleInRadians)
        {
            Debug.Assert(normalizedAxis.LengthSquared.ApproximateEquals(1));
            return (M33d)(Rot3d.Rotation(normalizedAxis, angleInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in degrees.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotationInDegrees(V3d normalizedAxis, double angleInDegrees)
            => Rotation(normalizedAxis, angleInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) in radians. 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotationEuler(double rollInRadians, double pitchInRadians, double yawInRadians)
        {
            return (M33d)(Rot3d.RotationEuler(rollInRadians, pitchInRadians, yawInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) in degrees. 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotationEulerInDegrees(double rollInDegrees, double pitchInDegrees, double yawInDegrees)
            => RotationEuler(
                rollInDegrees.RadiansFromDegrees(),
                pitchInDegrees.RadiansFromDegrees(), 
                yawInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) vector in radians.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotationEuler(V3d rollPitchYawInRadians)
            => RotationEuler(
                rollPitchYawInRadians.X,
                rollPitchYawInRadians.Y,
                rollPitchYawInRadians.Z);

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) vector in degrees.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotationEulerInDegrees(V3d rollPitchYawInDegrees)
            => RotationEulerInDegrees(
                rollPitchYawInDegrees.X,
                rollPitchYawInDegrees.Y,
                rollPitchYawInDegrees.Z);

        /// <summary>
        /// Creates a 3D rotation matrix which rotates one vector into another.
        /// The input vectors have to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotateInto(V3d from, V3d into)
        {
            Debug.Assert(from.LengthSquared.ApproximateEquals(1));
            Debug.Assert(into.LengthSquared.ApproximateEquals(1));
            return (M33d)(Rot3d.RotateInto(from, into));
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotationX(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M33d(
                 1,  0,  0, 
                 0,  a, -b, 
                 0,  b,  a);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotationXInDegrees(double angleDegrees)
            => RotationX(angleDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotationY(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M33d(
                 a,  0,  b, 
                 0,  1,  0, 
                -b,  0,  a);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotationYInDegrees(double angleDegrees)
            => RotationY(angleDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotationZ(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M33d(
                 a, -b,  0, 
                 b,  a,  0, 
                 0,  0,  1);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d RotationZInDegrees(double angleDegrees)
            => RotationZ(angleDegrees.RadiansFromDegrees());

        #endregion

        #region Shearing

        /// <summary>
        /// Creates a shear transformation matrix along the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d ShearXY(double factorX, double factorY)
        {
            return new M33d(
                1, 0, factorX, 
                0, 1, factorY, 
                0, 0, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d ShearXZ(double factorX, double factorZ)
        {
            return new M33d(
                1, factorX, 0, 
                0, 1, 0, 
                0, factorZ, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d ShearYZ(double factorY, double factorZ)
        {
            return new M33d(
                1, 0, 0, 
                factorY, 1, 0, 
                factorZ, 0, 1);
        }

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d DivideByInt(M33d m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<double> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M20;
                yield return M21;
                yield return M22;
            }
        }

        public IEnumerable<V3d> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3d> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
            }
        }

        [XmlIgnore]
        public V3d R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3d( M00,  M01,  M02); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
            }
        }

        [XmlIgnore]
        public V3d R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3d( M10,  M11,  M12); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
            }
        }

        [XmlIgnore]
        public V3d R2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3d( M20,  M21,  M22); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
            }
        }

        [XmlIgnore]
        public V3d C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3d( M00,  M10,  M20); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        [XmlIgnore]
        public V3d C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3d( M01,  M11,  M21); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        [XmlIgnore]
        public V3d C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3d( M02,  M12,  M22); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        public V3d Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V3d(M00, M11, M22);
        }

        public V3d AntiDiagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V3d(M02, M11, M20);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public double MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M10, M11, M12, M20, M21, M22);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public double MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M10, M11, M12, M20, M21, M22);
        }

        public unsafe double this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (double* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (double* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe double this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (double* ptr = &M00) { return ptr[row * 3 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (double* ptr = &M00) { ptr[row * 3 + column] = value; }
            }
        }

        public bool AnyNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNaN(M00) || double.IsNaN(M01) || double.IsNaN(M02) || 
                    double.IsNaN(M10) || double.IsNaN(M11) || double.IsNaN(M12) || 
                    double.IsNaN(M20) || double.IsNaN(M21) || double.IsNaN(M22);
            }
        }

        public bool AllNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNaN(M00) && double.IsNaN(M01) && double.IsNaN(M02) && 
                    double.IsNaN(M10) && double.IsNaN(M11) && double.IsNaN(M12) && 
                    double.IsNaN(M20) && double.IsNaN(M21) && double.IsNaN(M22);
            }
        }

        public bool AnyInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsInfinity(M00) || double.IsInfinity(M01) || double.IsInfinity(M02) || 
                    double.IsInfinity(M10) || double.IsInfinity(M11) || double.IsInfinity(M12) || 
                    double.IsInfinity(M20) || double.IsInfinity(M21) || double.IsInfinity(M22);
            }
        }

        public bool AllInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsInfinity(M00) && double.IsInfinity(M01) && double.IsInfinity(M02) && 
                    double.IsInfinity(M10) && double.IsInfinity(M11) && double.IsInfinity(M12) && 
                    double.IsInfinity(M20) && double.IsInfinity(M21) && double.IsInfinity(M22);
            }
        }

        public bool AnyPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsPositiveInfinity(M00) || double.IsPositiveInfinity(M01) || double.IsPositiveInfinity(M02) || 
                    double.IsPositiveInfinity(M10) || double.IsPositiveInfinity(M11) || double.IsPositiveInfinity(M12) || 
                    double.IsPositiveInfinity(M20) || double.IsPositiveInfinity(M21) || double.IsPositiveInfinity(M22);
            }
        }

        public bool AllPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsPositiveInfinity(M00) && double.IsPositiveInfinity(M01) && double.IsPositiveInfinity(M02) && 
                    double.IsPositiveInfinity(M10) && double.IsPositiveInfinity(M11) && double.IsPositiveInfinity(M12) && 
                    double.IsPositiveInfinity(M20) && double.IsPositiveInfinity(M21) && double.IsPositiveInfinity(M22);
            }
        }

        public bool AnyNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNegativeInfinity(M00) || double.IsNegativeInfinity(M01) || double.IsNegativeInfinity(M02) || 
                    double.IsNegativeInfinity(M10) || double.IsNegativeInfinity(M11) || double.IsNegativeInfinity(M12) || 
                    double.IsNegativeInfinity(M20) || double.IsNegativeInfinity(M21) || double.IsNegativeInfinity(M22);
            }
        }

        public bool AllNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNegativeInfinity(M00) && double.IsNegativeInfinity(M01) && double.IsNegativeInfinity(M02) && 
                    double.IsNegativeInfinity(M10) && double.IsNegativeInfinity(M11) && double.IsNegativeInfinity(M12) && 
                    double.IsNegativeInfinity(M20) && double.IsNegativeInfinity(M21) && double.IsNegativeInfinity(M22);
            }
        }

        public bool AnyTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) || Fun.IsTiny(M01) || Fun.IsTiny(M02) || 
                    Fun.IsTiny(M10) || Fun.IsTiny(M11) || Fun.IsTiny(M12) || 
                    Fun.IsTiny(M20) || Fun.IsTiny(M21) || Fun.IsTiny(M22);
            }
        }

        public bool AllTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) && Fun.IsTiny(M01) && Fun.IsTiny(M02) && 
                    Fun.IsTiny(M10) && Fun.IsTiny(M11) && Fun.IsTiny(M12) && 
                    Fun.IsTiny(M20) && Fun.IsTiny(M21) && Fun.IsTiny(M22);
            }
        }

        /// <summary>
        /// Returns true if the absolute value of each element of the matrix is smaller than Constant&lt;double&gt;.PositiveTinyValue, false otherwise.
        /// </summary>
        public bool IsTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AllTiny;
        }

        /// <summary>
        /// Returns true if any element of the matrix is NaN, false otherwise.
        /// </summary>
        public bool IsNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyNaN;
        }

        /// <summary>
        /// Returns true if any element of the matrix is infinite (positive or negative), false otherwise.
        /// </summary>
        public bool IsInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyInfinity;
        }

        /// <summary>
        /// Returns whether all elements of the matrix are finite (i.e. not NaN and not infinity).
        /// </summary>
        public bool IsFinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => !(IsInfinity || IsNaN);
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 3;
        public const int ElementCount = 3 * 3;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 3);
        }

        public static M33d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33d(0);
        }

        public static M33d Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M33d(1, 0, 0, 0, 1, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + 
                    M20 * M20 + M21 * M21 + M22 * M22);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator -(M33d m)
        {
            return new M33d(
                -m.M00, -m.M01, -m.M02, 
                -m.M10, -m.M11, -m.M12, 
                -m.M20, -m.M21, -m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  + (M33d a, M33d b)
        {
            return new M33d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  + (M33d m, double s)
        {
            return new M33d(
                m.M00 + s, m.M01 + s, m.M02 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  + (double s, M33d m)
        {
            return new M33d(
                s + m.M00, s + m.M01, s + m.M02, 
                s + m.M10, s + m.M11, s + m.M12, 
                s + m.M20, s + m.M21, s + m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  - (M33d a, M33d b)
        {
            return new M33d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  - (M33d m, double s)
        {
            return new M33d(
                m.M00 - s, m.M01 - s, m.M02 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  - (double s, M33d m)
        {
            return new M33d(
                s - m.M00, s - m.M01, s - m.M02, 
                s - m.M10, s - m.M11, s - m.M12, 
                s - m.M20, s - m.M21, s - m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  % (M33d a, M33d b)
        {
            return new M33d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  % (M33d m, double s)
        {
            return new M33d(
                m.M00 % s, m.M01 % s, m.M02 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  % (double s, M33d m)
        {
            return new M33d(
                s % m.M00, s % m.M01, s % m.M02, 
                s % m.M10, s % m.M11, s % m.M12, 
                s % m.M20, s % m.M21, s % m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  / (M33d a, M33d b)
        {
            return new M33d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  / (M33d m, double s)
        {
            return new M33d(
                m.M00 / s, m.M01 / s, m.M02 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  / (double s, M33d m)
        {
            return new M33d(
                s / m.M00, s / m.M01, s / m.M02, 
                s / m.M10, s / m.M11, s / m.M12, 
                s / m.M20, s / m.M21, s / m.M22);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  * (M33d m, double s)
        {
            return new M33d(
                m.M00 * s, m.M01 * s, m.M02 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d operator  * (double s, M33d m)
        {
            return new M33d(
                s * m.M00, s * m.M01, s * m.M02, 
                s * m.M10, s * m.M11, s * m.M12, 
                s * m.M20, s * m.M21, s * m.M22);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M33d matrix with a V3d column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d operator *(M33d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z);
        }

        /// <summary>
        /// Multiplies a V3d row vector with a M33d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d operator *(V3d v, M33d m)
        {
            return new V3d(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M33d a, M33d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M33d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(double s, M33d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M33d a, M33d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M33d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(double s, M33d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M33d a, M33d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M33d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(double s, M33d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M33d a, M33d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M33d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(double s, M33d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M33d a, M33d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M33d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(double s, M33d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M33d a, M33d b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M33d m, double s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(double s, M33d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02),
                        HashCode.GetCombined(M10, M11, M12),
                        HashCode.GetCombined(M20, M21, M22));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M33d other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12) && 
                M20.Equals(other.M20) && M21.Equals(other.M21) && M22.Equals(other.M22);
        }

        public override bool Equals(object other)
            => (other is M33d o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M33d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M33d.FromRows(
                V3d.Parse(x[0]), 
                V3d.Parse(x[1]), 
                V3d.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M33d Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M33d result = new M33d();
                for (int row = 0; row < 3; row++)
                {
                    for (int col = 0; col < 3; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public double Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public double Determinant
        {
            get
            {
                if (M10 == 0 && M20 == 0 && M21 == 0)
                {
                    return M00 * M11 * M22;
                }
                return
                M00 * M11 * M22 - M00 * M12 * M21 +
                M01 * M12 * M20 - M01 * M10 * M22 +
                M02 * M10 * M21 - M02 * M11 * M20;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M33d Transposed
        {
            get
            {
                return new M33d {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22
                };
            }
        }

        private static V2l s_luSize = new V2l(3, 3);
        private static V2l s_luDelta = new V2l(1, 3);

        /// <summary>
        /// Inverts the given matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public unsafe bool LuInvert()
        {
            fixed (M33d* self = &this)
            {
                var lu = this;
                V3i perm;
                if (NumericExtensions.LuFactorize((double*)&lu, 0, 1, 3, (int*)&perm, 3))
                {
                    NumericExtensions.LuInverse((double*)&lu, 0, 1, 3, (int*)&perm, (double*)self, 0, 1, 3, 3);
                    return true;
                }
                return false;
            }
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M33d.Zero is returned.
        /// </summary>
        public unsafe M33d LuInverse()
        {
            var lu = this;
            M33d res;
            V3i perm;
            if (NumericExtensions.LuFactorize((double*)&lu, 0, 1, 3, (int*)&perm, 3))
            {
                NumericExtensions.LuInverse((double*)&lu, 0, 1, 3, (int*)&perm, (double*)&res, 0, 1, 3, 3);
                return res;
            }
            return M33d.Zero;
        }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M33d.Zero is returned.
        /// </summary>
        public M33d Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => LuInverse();
        }

        #endregion

        #region Matrix Multiplication

        public static M33d operator *(M33d a, M33d b)
        {
            return new M33d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M33dEqualityComparer : IEqualityComparer<M33d>
    {
        public static readonly M33dEqualityComparer Default
            = new M33dEqualityComparer();

        #region IEqualityComparer<M33d> Members

        public bool Equals(M33d v0, M33d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M33d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M33d m)
            => (m.C0.Length + m.C1.Length + m.C2.Length) / 3;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetScaleVector(this M33d m)
            => new V3d(m.C0.Length, m.C1.Length, m.C2.Length);

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of 2D basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale2(this M33d m)
            => (m.C0.XY.Length + m.C1.XY.Length) / 2;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the 2D basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V2d GetScaleVector2(this M33d m)
            => new V2d(m.C0.XY.Length, m.C1.XY.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm1(M33d m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M33d m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMax(M33d m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMin(M33d m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M33d m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(this M33d a, M33d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M33d a, M33d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M33d a, M33d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(this M33d a, M33d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(this M33d a, M33d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this M33d m, V3d v)
            => m * v;

        /// <summary>
        /// Transforms vector v by matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Transform(this M33d m, V4d v)
        {
            return new V4d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z,
                v.W);
        }

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d TransposedTransform(this M33d m, V3d v)
            => v * m;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// v.W is not modified.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d TransposedTransform(this M33d m, V4d v)
        {
            return new V4d(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22,
                v.W);
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by matrix m.
        /// </summary>
        public static V2d TransformDir(this M33d m, V2d v)
        {
            return new V2d(
                m.M00 * v.X + m.M01 * v.Y, 
                m.M10 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2d TransformPos(this M33d m, V2d p)
        {
            return new V2d(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12
                );
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2d TransformPosProj(this M33d m, V2d p)
        {
            double s = m.M20 * p.X + m.M21 * p.Y + m.M22;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.Z is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V3d TransformPosProjFull(this M33d m, V2d p)
        {
            return new V3d(
                m.M00 * p.X + m.M01 * p.Y + m.M02, 
                m.M10 * p.X + m.M11 * p.Y + m.M12, 
                m.M20 * p.X + m.M21 * p.Y + m.M22
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.Z is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V2d TransposedTransformDir(this M33d m, V2d v)
        {
            return new V2d(
                m.M00 * v.X + m.M10 * v.Y, 
                m.M01 * v.X + m.M11 * v.Y
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V2d TransposedTransformPos(this M33d m, V2d p)
        {
            return new V2d(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21
                );
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V2d TransposedTransformProj(this M33d m, V2d p)
        {
            var s = m.M02 * p.X + m.M12 * p.Y + m.M22;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.Z is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3d TransposedTransformProjFull(this M33d m, V2d p)
        {
            return new V3d(
                m.M00 * p.X + m.M10 * p.Y + m.M20, 
                m.M01 * p.X + m.M11 * p.Y + m.M21, 
                m.M02 * p.X + m.M12 * p.Y + m.M22
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M33d"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M22d Minor(this M33d m, int row, int column)
        {
            M22d rs = new M22d();

            for (int k = 0; k < 4; k++)
            {
                var i = k / 2;
                var j = k % 2;
                var ii = (i < row) ? i : i + 1;
                var jj = (j < column) ? j : j + 1;

                rs[k] = m[ii * 3 + jj];
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3d Row(this M33d m, int index)
        {
            double* ptr = &m.M00;
            return new V3d(ptr[index * 3], ptr[index * 3 + 1], ptr[index * 3 + 2]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3d Column(this M33d m, int index)
        {
            double* ptr = &m.M00;
            return new V3d(ptr[index], ptr[index + 3], ptr[index + 6]);
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Determinant(M33d m)
            => m.Determinant;

        /// <summary>
        /// Returns the transpose of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Transposed(M33d m)
            => m.Transposed;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Transpose(this ref M33d m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
        }

        /// <summary>
        /// Returns the inverse of the given matrix. If the matrix is not invertible
        /// M33d.Zero is returned.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Inverse(M33d m)
            => m.Inverse;

        /// <summary>
        /// Inverts the given matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Invert(this ref M33d m) { return m.LuInvert(); }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M33d m, double epsilon)
        {
            return Fun.ApproximateEquals(m, M33d.Identity, epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M33d m)
            => IsIdentity(m, Constant<double>.PositiveTinyValue);

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M33d m, double epsilon)
        {
            var i = m * m.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M33d m)
            => IsOrthonormal(m, Constant<double>.PositiveTinyValue);

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M33d m, double epsilon)
        {
            var i = m * m.Transposed;
            for (int j = 0; j < 3; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M33d m)
            => IsOrthogonal(m, Constant<double>.PositiveTinyValue);

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M33d"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double MinElement(M33d m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M33d"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double MaxElement(M33d m)
            => m.MaxElement;

        #endregion

        #region Orthogonalization

        /// <summary>
        /// Orthogonalizes the columns of the given <see cref="M33d"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        public static void Orthogonalize(this ref M33d matrix)
        {
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
        }

        /// <summary>
        /// Orthogonalizes the columns of the given <see cref="M33d"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Orthogonalized(this M33d matrix)
        {
            M33d m = matrix;
            Orthogonalize(ref m);
            return m;
        }

        /// <summary>
        /// Orthonormalizes the columns of the given <see cref="M33d"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        public static void Orthonormalize(this ref M33d matrix)
        {
            matrix.C0 = matrix.C0.Normalized;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 = matrix.C1.Normalized;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C2 = matrix.C2.Normalized;
        }

        /// <summary>
        /// Orthonormalizes the columns of the given <see cref="M33d"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d Orthonormalized(this M33d matrix)
        {
            M33d m = matrix;
            Orthonormalize(ref m);
            return m;
        }

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M33d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M33d m, double epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon) || m.M20.IsTiny(epsilon) || m.M21.IsTiny(epsilon) || m.M22.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M33d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M33d m, double epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon) && m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon) && m.M22.IsTiny(epsilon);

        #endregion

        #region Special Floating Point Value Checks

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNaN(M33d m)
            => m.AnyNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNaN(M33d m)
            => m.AllNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyInfinity(M33d m)
            => m.AnyInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllInfinity(M33d m)
            => m.AllInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyPositiveInfinity(M33d m)
            => m.AnyPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllPositiveInfinity(M33d m)
            => m.AllPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNegativeInfinity(M33d m)
            => m.AnyNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNegativeInfinity(M33d m)
            => m.AllNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(M33d m)
            => m.AnyTiny;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(M33d m)
            => m.AllTiny;

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M33d a, M33d b)
            => ApproximateEquals(a, b, Constant<double>.PositiveTinyValue);

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M33d a, M33d b, double epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M33d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M33d m, double epsilon)
            => Mat.AllTiny(m, epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M33d"/> is smaller than Constant&lt;double&gt;.PositiveTinyValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(M33d m)
            => m.IsTiny;

        #endregion

        #region Special Floating Point Value Checks

        /// <summary>
        /// Returns whether any element of the given <see cref="M33d"/> is NaN.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNaN(M33d v)
            => v.IsNaN;

        /// <summary>
        /// Returns whether any element of the given <see cref="M33d"/> is infinity (positive or negative).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInfinity(M33d v)
            => v.IsInfinity;

        /// <summary>
        /// Returns whether all elements of the given <see cref="M33d"/> are finite (i.e. not NaN and not infinity).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsFinite(M33d v)
            => v.IsFinite;

        #endregion
    }

    public static class IRandomUniformM33dExtensions
    {
        #region IRandomUniform extensions for M33d

        /// <summary>
        /// Uses UniformDouble() to generate the elements of an M33d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d UniformM33d(this IRandomUniform rnd)
        {
            return new M33d(
                rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), 
                rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), 
                rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble());
        }

        /// <summary>
        /// Uses UniformDoubleClosed() to generate the elements of an M33d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d UniformM33dClosed(this IRandomUniform rnd)
        {
            return new M33d(
                rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), 
                rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), 
                rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed());
        }

        /// <summary>
        /// Uses UniformDoubleOpen() to generate the elements of an M33d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d UniformM33dOpen(this IRandomUniform rnd)
        {
            return new M33d(
                rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), 
                rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), 
                rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen());
        }

        /// <summary>
        /// Uses UniformDoubleFull() to generate the elements of an M33d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d UniformM33dFull(this IRandomUniform rnd)
        {
            return new M33d(
                rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), 
                rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), 
                rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull());
        }

        /// <summary>
        /// Uses UniformDoubleFullClosed() to generate the elements of an M33d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d UniformM33dFullClosed(this IRandomUniform rnd)
        {
            return new M33d(
                rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), 
                rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), 
                rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed());
        }

        /// <summary>
        /// Uses UniformDoubleFullOpen() to generate the elements of an M33d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M33d UniformM33dFullOpen(this IRandomUniform rnd)
        {
            return new M33d(
                rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), 
                rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), 
                rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen());
        }

        #endregion
    }

    #endregion

    #region M34i

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M34i : IEquatable<M34i>, IValidity, IMatrix<double>
    {
        [DataMember]
        public int M00, M01, M02, M03;
        [DataMember]
        public int M10, M11, M12, M13;
        [DataMember]
        public int M20, M21, M22, M23;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(int value)
        {
            M00 = value; M01 = 0; M02 = 0; M03 = 0; 
            M10 = 0; M11 = value; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = value; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(
                int m00, int m01, int m02, int m03, 
                int m10, int m11, int m12, int m13, 
                int m20, int m21, int m22, int m23)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M33i m, V3i v)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = v.Y; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = v.Z; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M22i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M23i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M33i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M44i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M22l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M23l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M33l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M34l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M44l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M22f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M23f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M33f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M34f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M44f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M22d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M23d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M33d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M34d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34i(M44d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
        }

        #endregion

        #region Conversions

        public static explicit operator M34i(M22i m)
        {
            return new M34i {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M23i m)
        {
            return new M34i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M33i m)
        {
            return new M34i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34i(M44i m)
        {
            return new M34i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
            };
        }

        public static explicit operator M34i(M22l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M23l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M33l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34i(M34l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M44l m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M22f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M23f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M33f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34i(M34f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M44f m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M22d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M23d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34i(M33d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34i(M34d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(M44d m)
        {
            return new M34i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
            };
        }

        public static explicit operator M34i(int[] a)
        {
            return new M34i(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11]);
        }

        public static explicit operator M34i(int[,] a)
        {
            return new M34i(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3]);
        }

        public static explicit operator int[](M34i m)
        {
            return new int[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23
            };
        }

        public static explicit operator int[,](M34i m)
        {
            return new int[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
        }

        public static explicit operator M34i(long[] a)
        {
            return new M34i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11]);
        }

        public static explicit operator M34i(long[,] a)
        {
            return new M34i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3]);
        }

        public static explicit operator long[](M34i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23
            };
        }

        public static explicit operator long[,](M34i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
        }

        public static explicit operator M34i(float[] a)
        {
            return new M34i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11]);
        }

        public static explicit operator M34i(float[,] a)
        {
            return new M34i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3]);
        }

        public static explicit operator float[](M34i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23
            };
        }

        public static explicit operator float[,](M34i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
        }

        public static explicit operator M34i(double[] a)
        {
            return new M34i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11]);
        }

        public static explicit operator M34i(double[,] a)
        {
            return new M34i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3]);
        }

        public static explicit operator double[](M34i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23
            };
        }

        public static explicit operator double[,](M34i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<int, int> element_fun)
        {
            return new M34i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M34i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<int, long> element_fun)
        {
            return new M34l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M34l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<int, float> element_fun)
        {
            return new M34f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M34f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<int, double> element_fun)
        {
            return new M34d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M34d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        public int[] ToArray()
        {
            var array = new int[12];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i FromCols(V3i col0, V3i col1, V3i col2, V3i col3)
        {
            return new M34i(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i FromRows(V4i row0, V4i row1, V4i row2)
        {
            return new M34i(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i FromDiagonal(int value)
        {
            return new M34i(
                value, 0, 0, 0, 
                0, value, 0, 0, 
                0, 0, value, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i FromDiagonal(int m00, int m11, int m22)
        {
            return new M34i(
                m00, 0, 0, 0, 
                0, m11, 0, 0, 
                0, 0, m22, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i FromDiagonal(V3i s)
        {
            return new M34i(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a homogenous transformation <see cref="M34i"/> using a uniform scale.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i Scale(int s)
        {
            return new M34i(
                s, 0, 0, 0, 
                0, s, 0, 0, 
                0, 0, s, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34i"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i Scale(int sX, int sY, int sZ)
        {
            return new M34i(
                sX, 0, 0, 0, 
                0, sY, 0, 0, 
                0, 0, sZ, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34i"/> using a <see cref="V3i"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i Scale(V3i s)
        {
            return new M34i(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M34i"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i Translation(int tX, int tY, int tZ)
        {
            return new M34i(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34i"/> with the translational component given by a <see cref="V3i"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i Translation(V3i t)
        {
            return new M34i(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z);
        }

        #endregion

        #region Shearing

        /// <summary>
        /// Creates a shear transformation matrix along the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i ShearXY(int factorX, int factorY)
        {
            return new M34i(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i ShearXZ(int factorX, int factorZ)
        {
            return new M34i(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i ShearYZ(int factorY, int factorZ)
        {
            return new M34i(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0);
        }

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i DivideByInt(M34i m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<int> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
            }
        }

        public IEnumerable<V4i> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3i> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        [XmlIgnore]
        public V4i R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4i( M00,  M01,  M02,  M03); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        [XmlIgnore]
        public V4i R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4i( M10,  M11,  M12,  M13); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        [XmlIgnore]
        public V4i R2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4i( M20,  M21,  M22,  M23); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        [XmlIgnore]
        public V3i C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3i( M00,  M10,  M20); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        [XmlIgnore]
        public V3i C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3i( M01,  M11,  M21); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        [XmlIgnore]
        public V3i C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3i( M02,  M12,  M22); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        [XmlIgnore]
        public V3i C3
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3i( M03,  M13,  M23); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
            }
        }

        public V3i Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V3i(M00, M11, M22);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public int MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public int MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23);
        }

        public unsafe int this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (int* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (int* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe int this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (int* ptr = &M00) { return ptr[row * 4 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (int* ptr = &M00) { ptr[row * 4 + column] = value; }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 4;
        public const int ElementCount = 3 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 4);
        }

        public static M34i Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M34i(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator -(M34i m)
        {
            return new M34i(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator  + (M34i a, M34i b)
        {
            return new M34i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator  + (M34i m, int s)
        {
            return new M34i(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator  + (int s, M34i m)
        {
            return new M34i(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  + (M34i a, M34l b)
        {
            return new M34l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  + (M34i m, long s)
        {
            return new M34l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  + (long s, M34i m)
        {
            return new M34l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  + (M34i a, M34f b)
        {
            return new M34f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  + (M34i m, float s)
        {
            return new M34f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  + (float s, M34i m)
        {
            return new M34f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  + (M34i a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  + (M34i m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  + (double s, M34i m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator  - (M34i a, M34i b)
        {
            return new M34i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator  - (M34i m, int s)
        {
            return new M34i(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator  - (int s, M34i m)
        {
            return new M34i(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  - (M34i a, M34l b)
        {
            return new M34l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  - (M34i m, long s)
        {
            return new M34l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  - (long s, M34i m)
        {
            return new M34l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  - (M34i a, M34f b)
        {
            return new M34f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  - (M34i m, float s)
        {
            return new M34f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  - (float s, M34i m)
        {
            return new M34f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  - (M34i a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  - (M34i m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  - (double s, M34i m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator  % (M34i a, M34i b)
        {
            return new M34i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator  % (M34i m, int s)
        {
            return new M34i(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator  % (int s, M34i m)
        {
            return new M34i(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  % (M34i a, M34l b)
        {
            return new M34l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  % (M34i m, long s)
        {
            return new M34l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  % (long s, M34i m)
        {
            return new M34l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  % (M34i a, M34f b)
        {
            return new M34f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  % (M34i m, float s)
        {
            return new M34f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  % (float s, M34i m)
        {
            return new M34f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  % (M34i a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  % (M34i m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  % (double s, M34i m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator  / (M34i a, M34i b)
        {
            return new M34i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator  / (M34i m, int s)
        {
            return new M34i(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator  / (int s, M34i m)
        {
            return new M34i(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  / (M34i a, M34l b)
        {
            return new M34l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  / (M34i m, long s)
        {
            return new M34l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  / (long s, M34i m)
        {
            return new M34l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  / (M34i a, M34f b)
        {
            return new M34f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  / (M34i m, float s)
        {
            return new M34f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  / (float s, M34i m)
        {
            return new M34f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  / (M34i a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  / (M34i m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  / (double s, M34i m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator  * (M34i m, int s)
        {
            return new M34i(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator  * (int s, M34i m)
        {
            return new M34i(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  * (M34i m, long s)
        {
            return new M34l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  * (long s, M34i m)
        {
            return new M34l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  * (M34i m, float s)
        {
            return new M34f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  * (float s, M34i m)
        {
            return new M34f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  * (M34i m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  * (double s, M34i m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        #endregion

        #region Bitwise Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator ~(M34i m)
        {
            return new M34i(
                ~m.M00, ~m.M01, ~m.M02, ~m.M03, 
                ~m.M10, ~m.M11, ~m.M12, ~m.M13, 
                ~m.M20, ~m.M21, ~m.M22, ~m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator <<(M34i a, int s)
        {
            return new M34i(
                a.M00 << s, a.M01 << s, a.M02 << s, a.M03 << s, 
                a.M10 << s, a.M11 << s, a.M12 << s, a.M13 << s, 
                a.M20 << s, a.M21 << s, a.M22 << s, a.M23 << s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator >>(M34i a, int s)
        {
            return new M34i(
                a.M00 >> s, a.M01 >> s, a.M02 >> s, a.M03 >> s, 
                a.M10 >> s, a.M11 >> s, a.M12 >> s, a.M13 >> s, 
                a.M20 >> s, a.M21 >> s, a.M22 >> s, a.M23 >> s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator &(M34i a, M34i b)
        {
            return new M34i(
                a.M00 & b.M00, a.M01 & b.M01, a.M02 & b.M02, a.M03 & b.M03, 
                a.M10 & b.M10, a.M11 & b.M11, a.M12 & b.M12, a.M13 & b.M13, 
                a.M20 & b.M20, a.M21 & b.M21, a.M22 & b.M22, a.M23 & b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator &(M34i a, int s)
        {
            return new M34i(
                a.M00 & s, a.M01 & s, a.M02 & s, a.M03 & s, 
                a.M10 & s, a.M11 & s, a.M12 & s, a.M13 & s, 
                a.M20 & s, a.M21 & s, a.M22 & s, a.M23 & s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator &(int s, M34i a)
        {
            return new M34i(
                s & a.M00, s & a.M01, s & a.M02, s & a.M03, 
                s & a.M10, s & a.M11, s & a.M12, s & a.M13, 
                s & a.M20, s & a.M21, s & a.M22, s & a.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator |(M34i a, M34i b)
        {
            return new M34i(
                a.M00 | b.M00, a.M01 | b.M01, a.M02 | b.M02, a.M03 | b.M03, 
                a.M10 | b.M10, a.M11 | b.M11, a.M12 | b.M12, a.M13 | b.M13, 
                a.M20 | b.M20, a.M21 | b.M21, a.M22 | b.M22, a.M23 | b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator |(M34i a, int s)
        {
            return new M34i(
                a.M00 | s, a.M01 | s, a.M02 | s, a.M03 | s, 
                a.M10 | s, a.M11 | s, a.M12 | s, a.M13 | s, 
                a.M20 | s, a.M21 | s, a.M22 | s, a.M23 | s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator |(int s, M34i a)
        {
            return new M34i(
                s | a.M00, s | a.M01, s | a.M02, s | a.M03, 
                s | a.M10, s | a.M11, s | a.M12, s | a.M13, 
                s | a.M20, s | a.M21, s | a.M22, s | a.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator ^(M34i a, M34i b)
        {
            return new M34i(
                a.M00 ^ b.M00, a.M01 ^ b.M01, a.M02 ^ b.M02, a.M03 ^ b.M03, 
                a.M10 ^ b.M10, a.M11 ^ b.M11, a.M12 ^ b.M12, a.M13 ^ b.M13, 
                a.M20 ^ b.M20, a.M21 ^ b.M21, a.M22 ^ b.M22, a.M23 ^ b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator ^(M34i a, int s)
        {
            return new M34i(
                a.M00 ^ s, a.M01 ^ s, a.M02 ^ s, a.M03 ^ s, 
                a.M10 ^ s, a.M11 ^ s, a.M12 ^ s, a.M13 ^ s, 
                a.M20 ^ s, a.M21 ^ s, a.M22 ^ s, a.M23 ^ s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i operator ^(int s, M34i a)
        {
            return new M34i(
                s ^ a.M00, s ^ a.M01, s ^ a.M02, s ^ a.M03, 
                s ^ a.M10, s ^ a.M11, s ^ a.M12, s ^ a.M13, 
                s ^ a.M20, s ^ a.M21, s ^ a.M22, s ^ a.M23);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M34i matrix with a V4i column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i operator *(M34i m, V4i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        /// <summary>
        /// Multiplies a V3i row vector with a M34i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i operator *(V3i v, M34i m)
        {
            return new V4i(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M34i a, M34i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M34i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(int s, M34i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M34i a, M34i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M34i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(int s, M34i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M34i a, M34i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M34i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(int s, M34i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M34i a, M34i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M34i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(int s, M34i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M34i a, M34i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M34i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(int s, M34i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M34i a, M34i b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M34i m, int s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(int s, M34i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02, M03),
                        HashCode.GetCombined(M10, M11, M12, M13),
                        HashCode.GetCombined(M20, M21, M22, M23));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M34i other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && M03.Equals(other.M03) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12) && M13.Equals(other.M13) && 
                M20.Equals(other.M20) && M21.Equals(other.M21) && M22.Equals(other.M22) && M23.Equals(other.M23);
        }

        public override bool Equals(object other)
            => (other is M34i o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M34i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M34i.FromRows(
                V4i.Parse(x[0]), 
                V4i.Parse(x[1]), 
                V4i.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M34i operator *(M33i a, M34i b)
        {
            return new M34i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34i operator *(M34i a, M44i b)
        {
            return new M34i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M34iEqualityComparer : IEqualityComparer<M34i>
    {
        public static readonly M34iEqualityComparer Default
            = new M34iEqualityComparer();

        #region IEqualityComparer<M34i> Members

        public bool Equals(M34i v0, M34i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M34i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M34i m)
            => (m.C0.Length + m.C1.Length + m.C2.Length) / 3;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetScaleVector(this M34i m)
            => new V3d(m.C0.Length, m.C1.Length, m.C2.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Norm1(M34i m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M34i m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMax(M34i m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMin(M34i m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M34i m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(this M34i a, M34i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M34i a, M34i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M34i a, M34i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(this M34i a, M34i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(this M34i a, M34i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3i Transform(this M34i m, V4i v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i TransposedTransform(this M34i m, V3i v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3i TransformDir(this M34i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// </summary>
        public static V3i TransformPos(this M34i m, V3i p)
        {
            return new V3i(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Multiplies two <see cref="M34i"/> matrices as 4x4 matrices.
        /// </summary>
        public static M34i MultiplyAffine(this M34i a, M34i b)
        {
            return new M34i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23
            );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V4i Row(this M34i m, int index)
        {
            int* ptr = &m.M00;
            return new V4i(ptr[index * 4], ptr[index * 4 + 1], ptr[index * 4 + 2], ptr[index * 4 + 3]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3i Column(this M34i m, int index)
        {
            int* ptr = &m.M00;
            return new V3i(ptr[index], ptr[index + 4], ptr[index + 8]);
        }

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M34i"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int MinElement(M34i m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M34i"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int MaxElement(M34i m)
            => m.MaxElement;

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M34i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M34i m, int epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M03.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon) || m.M13.IsTiny(epsilon) || m.M20.IsTiny(epsilon) || m.M21.IsTiny(epsilon) || m.M22.IsTiny(epsilon) || m.M23.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M34i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M34i m, int epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M03.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon) && m.M13.IsTiny(epsilon) && m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon) && m.M22.IsTiny(epsilon) && m.M23.IsTiny(epsilon);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M34i a, M34i b, int epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M34i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M34i m, int epsilon)
            => Mat.AllTiny(m, epsilon);

        #endregion
    }

    public static class IRandomUniformM34iExtensions
    {
        #region IRandomUniform extensions for M34i

        /// <summary>
        /// Uses UniformInt() to generate the elements of an M34i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i UniformM34i(this IRandomUniform rnd)
        {
            return new M34i(
                rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), 
                rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), 
                rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt());
        }

        /// <summary>
        /// Uses UniformIntNonZero() to generate the elements of an M34i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i UniformM34iNonZero(this IRandomUniform rnd)
        {
            return new M34i(
                rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), 
                rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), 
                rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero());
        }

        /// <summary>
        /// Uses UniformInt(int) to generate the elements of an M34i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i UniformM34i(this IRandomUniform rnd, int size)
        {
            return new M34i(
                rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), 
                rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), 
                rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size));
        }

        /// <summary>
        /// Uses UniformInt(int) to generate the elements of an M34i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34i UniformM34i(this IRandomUniform rnd, M34i size)
        {
            return new M34i(
                rnd.UniformInt(size.M00), rnd.UniformInt(size.M01), rnd.UniformInt(size.M02), rnd.UniformInt(size.M03), 
                rnd.UniformInt(size.M10), rnd.UniformInt(size.M11), rnd.UniformInt(size.M12), rnd.UniformInt(size.M13), 
                rnd.UniformInt(size.M20), rnd.UniformInt(size.M21), rnd.UniformInt(size.M22), rnd.UniformInt(size.M23));
        }

        #endregion
    }

    #endregion

    #region M34l

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M34l : IEquatable<M34l>, IValidity, IMatrix<double>
    {
        [DataMember]
        public long M00, M01, M02, M03;
        [DataMember]
        public long M10, M11, M12, M13;
        [DataMember]
        public long M20, M21, M22, M23;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(long value)
        {
            M00 = value; M01 = 0; M02 = 0; M03 = 0; 
            M10 = 0; M11 = value; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = value; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(
                long m00, long m01, long m02, long m03, 
                long m10, long m11, long m12, long m13, 
                long m20, long m21, long m22, long m23)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M33l m, V3l v)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = v.Y; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = v.Z; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M22i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M23i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M33i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M34i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M44i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M22l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M23l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M33l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M44l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M22f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M23f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M33f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M34f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M44f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M22d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M23d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M33d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M34d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34l(M44d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
        }

        #endregion

        #region Conversions

        public static explicit operator M34l(M22i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M23i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M33i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34l(M34i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M44i m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M22l m)
        {
            return new M34l {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M23l m)
        {
            return new M34l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M33l m)
        {
            return new M34l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34l(M44l m)
        {
            return new M34l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
            };
        }

        public static explicit operator M34l(M22f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M23f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M33f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34l(M34f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M44f m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M22d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M23d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34l(M33d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34l(M34d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(M44d m)
        {
            return new M34l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
            };
        }

        public static explicit operator M34l(int[] a)
        {
            return new M34l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11]);
        }

        public static explicit operator M34l(int[,] a)
        {
            return new M34l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3]);
        }

        public static explicit operator int[](M34l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23
            };
        }

        public static explicit operator int[,](M34l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
        }

        public static explicit operator M34l(long[] a)
        {
            return new M34l(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11]);
        }

        public static explicit operator M34l(long[,] a)
        {
            return new M34l(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3]);
        }

        public static explicit operator long[](M34l m)
        {
            return new long[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23
            };
        }

        public static explicit operator long[,](M34l m)
        {
            return new long[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
        }

        public static explicit operator M34l(float[] a)
        {
            return new M34l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11]);
        }

        public static explicit operator M34l(float[,] a)
        {
            return new M34l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3]);
        }

        public static explicit operator float[](M34l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23
            };
        }

        public static explicit operator float[,](M34l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
        }

        public static explicit operator M34l(double[] a)
        {
            return new M34l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11]);
        }

        public static explicit operator M34l(double[,] a)
        {
            return new M34l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3]);
        }

        public static explicit operator double[](M34l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23
            };
        }

        public static explicit operator double[,](M34l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<long, int> element_fun)
        {
            return new M34i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M34i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<long, long> element_fun)
        {
            return new M34l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M34l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<long, float> element_fun)
        {
            return new M34f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M34f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<long, double> element_fun)
        {
            return new M34d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M34d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        public long[] ToArray()
        {
            var array = new long[12];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l FromCols(V3l col0, V3l col1, V3l col2, V3l col3)
        {
            return new M34l(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l FromRows(V4l row0, V4l row1, V4l row2)
        {
            return new M34l(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l FromDiagonal(long value)
        {
            return new M34l(
                value, 0, 0, 0, 
                0, value, 0, 0, 
                0, 0, value, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l FromDiagonal(long m00, long m11, long m22)
        {
            return new M34l(
                m00, 0, 0, 0, 
                0, m11, 0, 0, 
                0, 0, m22, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l FromDiagonal(V3l s)
        {
            return new M34l(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a homogenous transformation <see cref="M34l"/> using a uniform scale.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l Scale(long s)
        {
            return new M34l(
                s, 0, 0, 0, 
                0, s, 0, 0, 
                0, 0, s, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34l"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l Scale(long sX, long sY, long sZ)
        {
            return new M34l(
                sX, 0, 0, 0, 
                0, sY, 0, 0, 
                0, 0, sZ, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34l"/> using a <see cref="V3l"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l Scale(V3l s)
        {
            return new M34l(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M34l"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l Translation(long tX, long tY, long tZ)
        {
            return new M34l(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34l"/> with the translational component given by a <see cref="V3l"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l Translation(V3l t)
        {
            return new M34l(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z);
        }

        #endregion

        #region Shearing

        /// <summary>
        /// Creates a shear transformation matrix along the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l ShearXY(long factorX, long factorY)
        {
            return new M34l(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l ShearXZ(long factorX, long factorZ)
        {
            return new M34l(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l ShearYZ(long factorY, long factorZ)
        {
            return new M34l(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0);
        }

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l DivideByInt(M34l m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<long> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
            }
        }

        public IEnumerable<V4l> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3l> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        [XmlIgnore]
        public V4l R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4l( M00,  M01,  M02,  M03); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        [XmlIgnore]
        public V4l R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4l( M10,  M11,  M12,  M13); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        [XmlIgnore]
        public V4l R2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4l( M20,  M21,  M22,  M23); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        [XmlIgnore]
        public V3l C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3l( M00,  M10,  M20); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        [XmlIgnore]
        public V3l C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3l( M01,  M11,  M21); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        [XmlIgnore]
        public V3l C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3l( M02,  M12,  M22); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        [XmlIgnore]
        public V3l C3
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3l( M03,  M13,  M23); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
            }
        }

        public V3l Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V3l(M00, M11, M22);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public long MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public long MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23);
        }

        public unsafe long this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (long* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (long* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe long this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (long* ptr = &M00) { return ptr[row * 4 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (long* ptr = &M00) { ptr[row * 4 + column] = value; }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 4;
        public const int ElementCount = 3 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 4);
        }

        public static M34l Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M34l(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator -(M34l m)
        {
            return new M34l(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  + (M34l a, M34l b)
        {
            return new M34l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  + (M34l m, long s)
        {
            return new M34l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  + (long s, M34l m)
        {
            return new M34l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  + (M34l a, M34f b)
        {
            return new M34f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  + (M34l m, float s)
        {
            return new M34f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  + (float s, M34l m)
        {
            return new M34f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  + (M34l a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  + (M34l m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  + (double s, M34l m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  - (M34l a, M34l b)
        {
            return new M34l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  - (M34l m, long s)
        {
            return new M34l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  - (long s, M34l m)
        {
            return new M34l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  - (M34l a, M34f b)
        {
            return new M34f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  - (M34l m, float s)
        {
            return new M34f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  - (float s, M34l m)
        {
            return new M34f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  - (M34l a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  - (M34l m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  - (double s, M34l m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  % (M34l a, M34l b)
        {
            return new M34l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  % (M34l m, long s)
        {
            return new M34l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  % (long s, M34l m)
        {
            return new M34l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  % (M34l a, M34f b)
        {
            return new M34f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  % (M34l m, float s)
        {
            return new M34f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  % (float s, M34l m)
        {
            return new M34f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  % (M34l a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  % (M34l m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  % (double s, M34l m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  / (M34l a, M34l b)
        {
            return new M34l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  / (M34l m, long s)
        {
            return new M34l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  / (long s, M34l m)
        {
            return new M34l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  / (M34l a, M34f b)
        {
            return new M34f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  / (M34l m, float s)
        {
            return new M34f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  / (float s, M34l m)
        {
            return new M34f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  / (M34l a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  / (M34l m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  / (double s, M34l m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  * (M34l m, long s)
        {
            return new M34l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator  * (long s, M34l m)
        {
            return new M34l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  * (M34l m, float s)
        {
            return new M34f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  * (float s, M34l m)
        {
            return new M34f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  * (M34l m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  * (double s, M34l m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        #endregion

        #region Bitwise Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator ~(M34l m)
        {
            return new M34l(
                ~m.M00, ~m.M01, ~m.M02, ~m.M03, 
                ~m.M10, ~m.M11, ~m.M12, ~m.M13, 
                ~m.M20, ~m.M21, ~m.M22, ~m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator <<(M34l a, int s)
        {
            return new M34l(
                a.M00 << s, a.M01 << s, a.M02 << s, a.M03 << s, 
                a.M10 << s, a.M11 << s, a.M12 << s, a.M13 << s, 
                a.M20 << s, a.M21 << s, a.M22 << s, a.M23 << s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator >>(M34l a, int s)
        {
            return new M34l(
                a.M00 >> s, a.M01 >> s, a.M02 >> s, a.M03 >> s, 
                a.M10 >> s, a.M11 >> s, a.M12 >> s, a.M13 >> s, 
                a.M20 >> s, a.M21 >> s, a.M22 >> s, a.M23 >> s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator &(M34l a, M34l b)
        {
            return new M34l(
                a.M00 & b.M00, a.M01 & b.M01, a.M02 & b.M02, a.M03 & b.M03, 
                a.M10 & b.M10, a.M11 & b.M11, a.M12 & b.M12, a.M13 & b.M13, 
                a.M20 & b.M20, a.M21 & b.M21, a.M22 & b.M22, a.M23 & b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator &(M34l a, long s)
        {
            return new M34l(
                a.M00 & s, a.M01 & s, a.M02 & s, a.M03 & s, 
                a.M10 & s, a.M11 & s, a.M12 & s, a.M13 & s, 
                a.M20 & s, a.M21 & s, a.M22 & s, a.M23 & s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator &(long s, M34l a)
        {
            return new M34l(
                s & a.M00, s & a.M01, s & a.M02, s & a.M03, 
                s & a.M10, s & a.M11, s & a.M12, s & a.M13, 
                s & a.M20, s & a.M21, s & a.M22, s & a.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator |(M34l a, M34l b)
        {
            return new M34l(
                a.M00 | b.M00, a.M01 | b.M01, a.M02 | b.M02, a.M03 | b.M03, 
                a.M10 | b.M10, a.M11 | b.M11, a.M12 | b.M12, a.M13 | b.M13, 
                a.M20 | b.M20, a.M21 | b.M21, a.M22 | b.M22, a.M23 | b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator |(M34l a, long s)
        {
            return new M34l(
                a.M00 | s, a.M01 | s, a.M02 | s, a.M03 | s, 
                a.M10 | s, a.M11 | s, a.M12 | s, a.M13 | s, 
                a.M20 | s, a.M21 | s, a.M22 | s, a.M23 | s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator |(long s, M34l a)
        {
            return new M34l(
                s | a.M00, s | a.M01, s | a.M02, s | a.M03, 
                s | a.M10, s | a.M11, s | a.M12, s | a.M13, 
                s | a.M20, s | a.M21, s | a.M22, s | a.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator ^(M34l a, M34l b)
        {
            return new M34l(
                a.M00 ^ b.M00, a.M01 ^ b.M01, a.M02 ^ b.M02, a.M03 ^ b.M03, 
                a.M10 ^ b.M10, a.M11 ^ b.M11, a.M12 ^ b.M12, a.M13 ^ b.M13, 
                a.M20 ^ b.M20, a.M21 ^ b.M21, a.M22 ^ b.M22, a.M23 ^ b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator ^(M34l a, long s)
        {
            return new M34l(
                a.M00 ^ s, a.M01 ^ s, a.M02 ^ s, a.M03 ^ s, 
                a.M10 ^ s, a.M11 ^ s, a.M12 ^ s, a.M13 ^ s, 
                a.M20 ^ s, a.M21 ^ s, a.M22 ^ s, a.M23 ^ s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l operator ^(long s, M34l a)
        {
            return new M34l(
                s ^ a.M00, s ^ a.M01, s ^ a.M02, s ^ a.M03, 
                s ^ a.M10, s ^ a.M11, s ^ a.M12, s ^ a.M13, 
                s ^ a.M20, s ^ a.M21, s ^ a.M22, s ^ a.M23);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M34l matrix with a V4l column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l operator *(M34l m, V4l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        /// <summary>
        /// Multiplies a V3l row vector with a M34l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l operator *(V3l v, M34l m)
        {
            return new V4l(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M34l a, M34l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M34l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(long s, M34l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M34l a, M34l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M34l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(long s, M34l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M34l a, M34l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M34l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(long s, M34l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M34l a, M34l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M34l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(long s, M34l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M34l a, M34l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M34l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(long s, M34l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M34l a, M34l b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M34l m, long s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(long s, M34l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02, M03),
                        HashCode.GetCombined(M10, M11, M12, M13),
                        HashCode.GetCombined(M20, M21, M22, M23));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M34l other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && M03.Equals(other.M03) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12) && M13.Equals(other.M13) && 
                M20.Equals(other.M20) && M21.Equals(other.M21) && M22.Equals(other.M22) && M23.Equals(other.M23);
        }

        public override bool Equals(object other)
            => (other is M34l o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M34l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M34l.FromRows(
                V4l.Parse(x[0]), 
                V4l.Parse(x[1]), 
                V4l.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M34l operator *(M33l a, M34l b)
        {
            return new M34l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34l operator *(M34l a, M44l b)
        {
            return new M34l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M34lEqualityComparer : IEqualityComparer<M34l>
    {
        public static readonly M34lEqualityComparer Default
            = new M34lEqualityComparer();

        #region IEqualityComparer<M34l> Members

        public bool Equals(M34l v0, M34l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M34l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M34l m)
            => (m.C0.Length + m.C1.Length + m.C2.Length) / 3;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetScaleVector(this M34l m)
            => new V3d(m.C0.Length, m.C1.Length, m.C2.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Norm1(M34l m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M34l m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMax(M34l m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMin(M34l m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M34l m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(this M34l a, M34l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M34l a, M34l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M34l a, M34l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(this M34l a, M34l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(this M34l a, M34l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3l Transform(this M34l m, V4l v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l TransposedTransform(this M34l m, V3l v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3l TransformDir(this M34l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// </summary>
        public static V3l TransformPos(this M34l m, V3l p)
        {
            return new V3l(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Multiplies two <see cref="M34l"/> matrices as 4x4 matrices.
        /// </summary>
        public static M34l MultiplyAffine(this M34l a, M34l b)
        {
            return new M34l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23
            );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V4l Row(this M34l m, int index)
        {
            long* ptr = &m.M00;
            return new V4l(ptr[index * 4], ptr[index * 4 + 1], ptr[index * 4 + 2], ptr[index * 4 + 3]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3l Column(this M34l m, int index)
        {
            long* ptr = &m.M00;
            return new V3l(ptr[index], ptr[index + 4], ptr[index + 8]);
        }

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M34l"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long MinElement(M34l m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M34l"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long MaxElement(M34l m)
            => m.MaxElement;

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M34l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M34l m, long epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M03.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon) || m.M13.IsTiny(epsilon) || m.M20.IsTiny(epsilon) || m.M21.IsTiny(epsilon) || m.M22.IsTiny(epsilon) || m.M23.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M34l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M34l m, long epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M03.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon) && m.M13.IsTiny(epsilon) && m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon) && m.M22.IsTiny(epsilon) && m.M23.IsTiny(epsilon);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M34l a, M34l b, long epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M34l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M34l m, long epsilon)
            => Mat.AllTiny(m, epsilon);

        #endregion
    }

    public static class IRandomUniformM34lExtensions
    {
        #region IRandomUniform extensions for M34l

        /// <summary>
        /// Uses UniformLong() to generate the elements of an M34l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l UniformM34l(this IRandomUniform rnd)
        {
            return new M34l(
                rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), 
                rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), 
                rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong());
        }

        /// <summary>
        /// Uses UniformLongNonZero() to generate the elements of an M34l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l UniformM34lNonZero(this IRandomUniform rnd)
        {
            return new M34l(
                rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), 
                rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), 
                rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero());
        }

        /// <summary>
        /// Uses UniformLong(long) to generate the elements of an M34l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l UniformM34l(this IRandomUniform rnd, long size)
        {
            return new M34l(
                rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), 
                rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), 
                rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size));
        }

        /// <summary>
        /// Uses UniformLong(long) to generate the elements of an M34l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34l UniformM34l(this IRandomUniform rnd, M34l size)
        {
            return new M34l(
                rnd.UniformLong(size.M00), rnd.UniformLong(size.M01), rnd.UniformLong(size.M02), rnd.UniformLong(size.M03), 
                rnd.UniformLong(size.M10), rnd.UniformLong(size.M11), rnd.UniformLong(size.M12), rnd.UniformLong(size.M13), 
                rnd.UniformLong(size.M20), rnd.UniformLong(size.M21), rnd.UniformLong(size.M22), rnd.UniformLong(size.M23));
        }

        #endregion
    }

    #endregion

    #region M34f

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M34f : IEquatable<M34f>, IValidity, IMatrix<double>
    {
        [DataMember]
        public float M00, M01, M02, M03;
        [DataMember]
        public float M10, M11, M12, M13;
        [DataMember]
        public float M20, M21, M22, M23;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(float value)
        {
            M00 = value; M01 = 0; M02 = 0; M03 = 0; 
            M10 = 0; M11 = value; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = value; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(
                float m00, float m01, float m02, float m03, 
                float m10, float m11, float m12, float m13, 
                float m20, float m21, float m22, float m23)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M33f m, V3f v)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = v.Y; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = v.Z; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M22i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M23i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M33i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M34i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M44i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M22l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M23l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M33l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M34l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M44l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M22f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M23f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M33f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M44f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M22d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M23d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M33d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M34d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34f(M44d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
        }

        #endregion

        #region Conversions

        public static explicit operator M34f(M22i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M23i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M33i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34f(M34i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M44i m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M22l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M23l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M33l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34f(M34l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M44l m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M22f m)
        {
            return new M34f {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M23f m)
        {
            return new M34f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M33f m)
        {
            return new M34f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34f(M44f m)
        {
            return new M34f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
            };
        }

        public static explicit operator M34f(M22d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M23d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34f(M33d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34f(M34d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(M44d m)
        {
            return new M34f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
            };
        }

        public static explicit operator M34f(int[] a)
        {
            return new M34f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11]);
        }

        public static explicit operator M34f(int[,] a)
        {
            return new M34f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3]);
        }

        public static explicit operator int[](M34f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23
            };
        }

        public static explicit operator int[,](M34f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
        }

        public static explicit operator M34f(long[] a)
        {
            return new M34f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11]);
        }

        public static explicit operator M34f(long[,] a)
        {
            return new M34f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3]);
        }

        public static explicit operator long[](M34f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23
            };
        }

        public static explicit operator long[,](M34f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
        }

        public static explicit operator M34f(float[] a)
        {
            return new M34f(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11]);
        }

        public static explicit operator M34f(float[,] a)
        {
            return new M34f(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3]);
        }

        public static explicit operator float[](M34f m)
        {
            return new float[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23
            };
        }

        public static explicit operator float[,](M34f m)
        {
            return new float[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
        }

        public static explicit operator M34f(double[] a)
        {
            return new M34f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11]);
        }

        public static explicit operator M34f(double[,] a)
        {
            return new M34f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3]);
        }

        public static explicit operator double[](M34f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23
            };
        }

        public static explicit operator double[,](M34f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<float, int> element_fun)
        {
            return new M34i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M34i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<float, long> element_fun)
        {
            return new M34l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M34l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<float, float> element_fun)
        {
            return new M34f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M34f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<float, double> element_fun)
        {
            return new M34d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M34d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        public float[] ToArray()
        {
            var array = new float[12];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f FromCols(V3f col0, V3f col1, V3f col2, V3f col3)
        {
            return new M34f(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f FromRows(V4f row0, V4f row1, V4f row2)
        {
            return new M34f(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f FromDiagonal(float value)
        {
            return new M34f(
                value, 0, 0, 0, 
                0, value, 0, 0, 
                0, 0, value, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f FromDiagonal(float m00, float m11, float m22)
        {
            return new M34f(
                m00, 0, 0, 0, 
                0, m11, 0, 0, 
                0, 0, m22, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f FromDiagonal(V3f s)
        {
            return new M34f(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a homogenous transformation <see cref="M34f"/> using a uniform scale.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Scale(float s)
        {
            return new M34f(
                s, 0, 0, 0, 
                0, s, 0, 0, 
                0, 0, s, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34f"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Scale(float sX, float sY, float sZ)
        {
            return new M34f(
                sX, 0, 0, 0, 
                0, sY, 0, 0, 
                0, 0, sZ, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34f"/> using a <see cref="V3f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Scale(V3f s)
        {
            return new M34f(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        /// <summary>
        /// Creates a scaling transformation <see cref="M34f"/> from a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Scale(Scale3f s)
        {
            return new M34f(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M34f"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Translation(float tX, float tY, float tZ)
        {
            return new M34f(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34f"/> with the translational component given by a <see cref="V3f"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Translation(V3f t)
        {
            return new M34f(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34f"/> from a <see cref="Shift3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Translation(Shift3f s)
        {
            return new M34f(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, s.Z);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in radians.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f Rotation(V3f normalizedAxis, float angleInRadians)
        {
            Debug.Assert(normalizedAxis.LengthSquared.ApproximateEquals(1));
            return (M34f)(Rot3f.Rotation(normalizedAxis, angleInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in degrees.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f RotationInDegrees(V3f normalizedAxis, float angleInDegrees)
            => Rotation(normalizedAxis, angleInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) in radians. 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f RotationEuler(float rollInRadians, float pitchInRadians, float yawInRadians)
        {
            return (M34f)(Rot3f.RotationEuler(rollInRadians, pitchInRadians, yawInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) in degrees. 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f RotationEulerInDegrees(float rollInDegrees, float pitchInDegrees, float yawInDegrees)
            => RotationEuler(
                rollInDegrees.RadiansFromDegrees(),
                pitchInDegrees.RadiansFromDegrees(), 
                yawInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) vector in radians.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f RotationEuler(V3f rollPitchYawInRadians)
            => RotationEuler(
                rollPitchYawInRadians.X,
                rollPitchYawInRadians.Y,
                rollPitchYawInRadians.Z);

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) vector in degrees.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f RotationEulerInDegrees(V3f rollPitchYawInDegrees)
            => RotationEulerInDegrees(
                rollPitchYawInDegrees.X,
                rollPitchYawInDegrees.Y,
                rollPitchYawInDegrees.Z);

        /// <summary>
        /// Creates a 3D rotation matrix which rotates one vector into another.
        /// The input vectors have to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f RotateInto(V3f from, V3f into)
        {
            Debug.Assert(from.LengthSquared.ApproximateEquals(1));
            Debug.Assert(into.LengthSquared.ApproximateEquals(1));
            return (M34f)(Rot3f.RotateInto(from, into));
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f RotationX(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M34f(
                 1,  0,  0,  0, 
                 0,  a, -b,  0, 
                 0,  b,  a,  0);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f RotationXInDegrees(float angleDegrees)
            => RotationX(angleDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f RotationY(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M34f(
                 a,  0,  b,  0, 
                 0,  1,  0,  0, 
                -b,  0,  a,  0);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f RotationYInDegrees(float angleDegrees)
            => RotationY(angleDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f RotationZ(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M34f(
                 a, -b,  0,  0, 
                 b,  a,  0,  0, 
                 0,  0,  1,  0);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f RotationZInDegrees(float angleDegrees)
            => RotationZ(angleDegrees.RadiansFromDegrees());

        #endregion

        #region Shearing

        /// <summary>
        /// Creates a shear transformation matrix along the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f ShearXY(float factorX, float factorY)
        {
            return new M34f(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f ShearXZ(float factorX, float factorZ)
        {
            return new M34f(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f ShearYZ(float factorY, float factorZ)
        {
            return new M34f(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0);
        }

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f DivideByInt(M34f m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<float> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
            }
        }

        public IEnumerable<V4f> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3f> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        [XmlIgnore]
        public V4f R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4f( M00,  M01,  M02,  M03); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        [XmlIgnore]
        public V4f R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4f( M10,  M11,  M12,  M13); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        [XmlIgnore]
        public V4f R2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4f( M20,  M21,  M22,  M23); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        [XmlIgnore]
        public V3f C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3f( M00,  M10,  M20); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        [XmlIgnore]
        public V3f C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3f( M01,  M11,  M21); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        [XmlIgnore]
        public V3f C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3f( M02,  M12,  M22); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        [XmlIgnore]
        public V3f C3
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3f( M03,  M13,  M23); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
            }
        }

        public V3f Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V3f(M00, M11, M22);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public float MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public float MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23);
        }

        public unsafe float this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (float* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (float* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe float this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (float* ptr = &M00) { return ptr[row * 4 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (float* ptr = &M00) { ptr[row * 4 + column] = value; }
            }
        }

        public bool AnyNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNaN(M00) || float.IsNaN(M01) || float.IsNaN(M02) || float.IsNaN(M03) || 
                    float.IsNaN(M10) || float.IsNaN(M11) || float.IsNaN(M12) || float.IsNaN(M13) || 
                    float.IsNaN(M20) || float.IsNaN(M21) || float.IsNaN(M22) || float.IsNaN(M23);
            }
        }

        public bool AllNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNaN(M00) && float.IsNaN(M01) && float.IsNaN(M02) && float.IsNaN(M03) && 
                    float.IsNaN(M10) && float.IsNaN(M11) && float.IsNaN(M12) && float.IsNaN(M13) && 
                    float.IsNaN(M20) && float.IsNaN(M21) && float.IsNaN(M22) && float.IsNaN(M23);
            }
        }

        public bool AnyInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsInfinity(M00) || float.IsInfinity(M01) || float.IsInfinity(M02) || float.IsInfinity(M03) || 
                    float.IsInfinity(M10) || float.IsInfinity(M11) || float.IsInfinity(M12) || float.IsInfinity(M13) || 
                    float.IsInfinity(M20) || float.IsInfinity(M21) || float.IsInfinity(M22) || float.IsInfinity(M23);
            }
        }

        public bool AllInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsInfinity(M00) && float.IsInfinity(M01) && float.IsInfinity(M02) && float.IsInfinity(M03) && 
                    float.IsInfinity(M10) && float.IsInfinity(M11) && float.IsInfinity(M12) && float.IsInfinity(M13) && 
                    float.IsInfinity(M20) && float.IsInfinity(M21) && float.IsInfinity(M22) && float.IsInfinity(M23);
            }
        }

        public bool AnyPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsPositiveInfinity(M00) || float.IsPositiveInfinity(M01) || float.IsPositiveInfinity(M02) || float.IsPositiveInfinity(M03) || 
                    float.IsPositiveInfinity(M10) || float.IsPositiveInfinity(M11) || float.IsPositiveInfinity(M12) || float.IsPositiveInfinity(M13) || 
                    float.IsPositiveInfinity(M20) || float.IsPositiveInfinity(M21) || float.IsPositiveInfinity(M22) || float.IsPositiveInfinity(M23);
            }
        }

        public bool AllPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsPositiveInfinity(M00) && float.IsPositiveInfinity(M01) && float.IsPositiveInfinity(M02) && float.IsPositiveInfinity(M03) && 
                    float.IsPositiveInfinity(M10) && float.IsPositiveInfinity(M11) && float.IsPositiveInfinity(M12) && float.IsPositiveInfinity(M13) && 
                    float.IsPositiveInfinity(M20) && float.IsPositiveInfinity(M21) && float.IsPositiveInfinity(M22) && float.IsPositiveInfinity(M23);
            }
        }

        public bool AnyNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNegativeInfinity(M00) || float.IsNegativeInfinity(M01) || float.IsNegativeInfinity(M02) || float.IsNegativeInfinity(M03) || 
                    float.IsNegativeInfinity(M10) || float.IsNegativeInfinity(M11) || float.IsNegativeInfinity(M12) || float.IsNegativeInfinity(M13) || 
                    float.IsNegativeInfinity(M20) || float.IsNegativeInfinity(M21) || float.IsNegativeInfinity(M22) || float.IsNegativeInfinity(M23);
            }
        }

        public bool AllNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNegativeInfinity(M00) && float.IsNegativeInfinity(M01) && float.IsNegativeInfinity(M02) && float.IsNegativeInfinity(M03) && 
                    float.IsNegativeInfinity(M10) && float.IsNegativeInfinity(M11) && float.IsNegativeInfinity(M12) && float.IsNegativeInfinity(M13) && 
                    float.IsNegativeInfinity(M20) && float.IsNegativeInfinity(M21) && float.IsNegativeInfinity(M22) && float.IsNegativeInfinity(M23);
            }
        }

        public bool AnyTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) || Fun.IsTiny(M01) || Fun.IsTiny(M02) || Fun.IsTiny(M03) || 
                    Fun.IsTiny(M10) || Fun.IsTiny(M11) || Fun.IsTiny(M12) || Fun.IsTiny(M13) || 
                    Fun.IsTiny(M20) || Fun.IsTiny(M21) || Fun.IsTiny(M22) || Fun.IsTiny(M23);
            }
        }

        public bool AllTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) && Fun.IsTiny(M01) && Fun.IsTiny(M02) && Fun.IsTiny(M03) && 
                    Fun.IsTiny(M10) && Fun.IsTiny(M11) && Fun.IsTiny(M12) && Fun.IsTiny(M13) && 
                    Fun.IsTiny(M20) && Fun.IsTiny(M21) && Fun.IsTiny(M22) && Fun.IsTiny(M23);
            }
        }

        /// <summary>
        /// Returns true if the absolute value of each element of the matrix is smaller than Constant&lt;float&gt;.PositiveTinyValue, false otherwise.
        /// </summary>
        public bool IsTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AllTiny;
        }

        /// <summary>
        /// Returns true if any element of the matrix is NaN, false otherwise.
        /// </summary>
        public bool IsNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyNaN;
        }

        /// <summary>
        /// Returns true if any element of the matrix is infinite (positive or negative), false otherwise.
        /// </summary>
        public bool IsInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyInfinity;
        }

        /// <summary>
        /// Returns whether all elements of the matrix are finite (i.e. not NaN and not infinity).
        /// </summary>
        public bool IsFinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => !(IsInfinity || IsNaN);
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 4;
        public const int ElementCount = 3 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 4);
        }

        public static M34f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M34f(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator -(M34f m)
        {
            return new M34f(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  + (M34f a, M34f b)
        {
            return new M34f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  + (M34f m, float s)
        {
            return new M34f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  + (float s, M34f m)
        {
            return new M34f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  + (M34f a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  + (M34f m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  + (double s, M34f m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  - (M34f a, M34f b)
        {
            return new M34f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  - (M34f m, float s)
        {
            return new M34f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  - (float s, M34f m)
        {
            return new M34f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  - (M34f a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  - (M34f m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  - (double s, M34f m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  % (M34f a, M34f b)
        {
            return new M34f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  % (M34f m, float s)
        {
            return new M34f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  % (float s, M34f m)
        {
            return new M34f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  % (M34f a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  % (M34f m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  % (double s, M34f m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  / (M34f a, M34f b)
        {
            return new M34f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  / (M34f m, float s)
        {
            return new M34f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  / (float s, M34f m)
        {
            return new M34f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  / (M34f a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  / (M34f m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  / (double s, M34f m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  * (M34f m, float s)
        {
            return new M34f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f operator  * (float s, M34f m)
        {
            return new M34f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  * (M34f m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  * (double s, M34f m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M34f matrix with a V4f column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f operator *(M34f m, V4f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        /// <summary>
        /// Multiplies a V3f row vector with a M34f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f operator *(V3f v, M34f m)
        {
            return new V4f(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M34f a, M34f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M34f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(float s, M34f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M34f a, M34f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M34f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(float s, M34f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M34f a, M34f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M34f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(float s, M34f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M34f a, M34f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M34f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(float s, M34f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M34f a, M34f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M34f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(float s, M34f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M34f a, M34f b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M34f m, float s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(float s, M34f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02, M03),
                        HashCode.GetCombined(M10, M11, M12, M13),
                        HashCode.GetCombined(M20, M21, M22, M23));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M34f other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && M03.Equals(other.M03) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12) && M13.Equals(other.M13) && 
                M20.Equals(other.M20) && M21.Equals(other.M21) && M22.Equals(other.M22) && M23.Equals(other.M23);
        }

        public override bool Equals(object other)
            => (other is M34f o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M34f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M34f.FromRows(
                V4f.Parse(x[0]), 
                V4f.Parse(x[1]), 
                V4f.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M34f operator *(M33f a, M34f b)
        {
            return new M34f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34f operator *(M34f a, M44f b)
        {
            return new M34f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M34fEqualityComparer : IEqualityComparer<M34f>
    {
        public static readonly M34fEqualityComparer Default
            = new M34fEqualityComparer();

        #region IEqualityComparer<M34f> Members

        public bool Equals(M34f v0, M34f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M34f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float GetScale(this M34f m)
            => (m.C0.Length + m.C1.Length + m.C2.Length) / 3;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f GetScaleVector(this M34f m)
            => new V3f(m.C0.Length, m.C1.Length, m.C2.Length);

        /// <summary>
        /// Extracts the forward vector from the given view transformation matrix.
        /// NOTE: A left-handed coordinates system transformation is expected, 
        /// where the view-space z-axis points in forward direction.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f GetViewDirectionLH(this M34f m)
            => m.R2.XYZ.Normalized;

        /// <summary>
        /// Extracts the forward vector from the given view transformation matrix.
        /// NOTE: A right-handed coordinates system transformation is expected, where 
        /// the view-space z-axis points opposit the forward vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f GetViewDirectionRH(this M34f m)
            => -m.R2.XYZ.Normalized;

        /// <summary>
        /// Extracts the translation component of the given transformation matrix, which when given 
        /// a model transformation represents the model origin in world position.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f GetModelOrigin(this M34f m)
            => m.C3;

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm1(M34f m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm2(M34f m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMax(M34f m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMin(M34f m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm(this M34f m, float p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(this M34f a, M34f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(this M34f a, M34f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(this M34f a, M34f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(this M34f a, M34f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(this M34f a, M34f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f Transform(this M34f m, V4f v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f TransposedTransform(this M34f m, V3f v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3f TransformDir(this M34f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// </summary>
        public static V3f TransformPos(this M34f m, V3f p)
        {
            return new V3f(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Multiplies two <see cref="M34f"/> matrices as 4x4 matrices.
        /// </summary>
        public static M34f MultiplyAffine(this M34f a, M34f b)
        {
            return new M34f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23
            );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V4f Row(this M34f m, int index)
        {
            float* ptr = &m.M00;
            return new V4f(ptr[index * 4], ptr[index * 4 + 1], ptr[index * 4 + 2], ptr[index * 4 + 3]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3f Column(this M34f m, int index)
        {
            float* ptr = &m.M00;
            return new V3f(ptr[index], ptr[index + 4], ptr[index + 8]);
        }

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M34f"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MinElement(M34f m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M34f"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MaxElement(M34f m)
            => m.MaxElement;

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M34f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M34f m, float epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M03.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon) || m.M13.IsTiny(epsilon) || m.M20.IsTiny(epsilon) || m.M21.IsTiny(epsilon) || m.M22.IsTiny(epsilon) || m.M23.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M34f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M34f m, float epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M03.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon) && m.M13.IsTiny(epsilon) && m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon) && m.M22.IsTiny(epsilon) && m.M23.IsTiny(epsilon);

        #endregion

        #region Special Floating Point Value Checks

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNaN(M34f m)
            => m.AnyNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNaN(M34f m)
            => m.AllNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyInfinity(M34f m)
            => m.AnyInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllInfinity(M34f m)
            => m.AllInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyPositiveInfinity(M34f m)
            => m.AnyPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllPositiveInfinity(M34f m)
            => m.AllPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNegativeInfinity(M34f m)
            => m.AnyNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNegativeInfinity(M34f m)
            => m.AllNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(M34f m)
            => m.AnyTiny;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(M34f m)
            => m.AllTiny;

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M34f a, M34f b)
            => ApproximateEquals(a, b, Constant<float>.PositiveTinyValue);

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M34f a, M34f b, float epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M34f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M34f m, float epsilon)
            => Mat.AllTiny(m, epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M34f"/> is smaller than Constant&lt;float&gt;.PositiveTinyValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(M34f m)
            => m.IsTiny;

        #endregion

        #region Special Floating Point Value Checks

        /// <summary>
        /// Returns whether any element of the given <see cref="M34f"/> is NaN.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNaN(M34f v)
            => v.IsNaN;

        /// <summary>
        /// Returns whether any element of the given <see cref="M34f"/> is infinity (positive or negative).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInfinity(M34f v)
            => v.IsInfinity;

        /// <summary>
        /// Returns whether all elements of the given <see cref="M34f"/> are finite (i.e. not NaN and not infinity).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsFinite(M34f v)
            => v.IsFinite;

        #endregion
    }

    public static class IRandomUniformM34fExtensions
    {
        #region IRandomUniform extensions for M34f

        /// <summary>
        /// Uses UniformFloat() to generate the elements of an M34f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f UniformM34f(this IRandomUniform rnd)
        {
            return new M34f(
                rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), 
                rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), 
                rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat());
        }

        /// <summary>
        /// Uses UniformFloatClosed() to generate the elements of an M34f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f UniformM34fClosed(this IRandomUniform rnd)
        {
            return new M34f(
                rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), 
                rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), 
                rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed());
        }

        /// <summary>
        /// Uses UniformFloatOpen() to generate the elements of an M34f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34f UniformM34fOpen(this IRandomUniform rnd)
        {
            return new M34f(
                rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), 
                rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), 
                rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen());
        }

        #endregion
    }

    #endregion

    #region M34d

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M34d : IEquatable<M34d>, IValidity, IMatrix<double>
    {
        [DataMember]
        public double M00, M01, M02, M03;
        [DataMember]
        public double M10, M11, M12, M13;
        [DataMember]
        public double M20, M21, M22, M23;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(double value)
        {
            M00 = value; M01 = 0; M02 = 0; M03 = 0; 
            M10 = 0; M11 = value; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = value; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(
                double m00, double m01, double m02, double m03, 
                double m10, double m11, double m12, double m13, 
                double m20, double m21, double m22, double m23)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M33d m, V3d v)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = v.X; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = v.Y; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = v.Z; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M22i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M23i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M33i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M34i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M44i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M22l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M23l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M33l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M34l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M44l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M22f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M23f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M33f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M34f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M44f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M22d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M23d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M33d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M34d(M44d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
        }

        #endregion

        #region Conversions

        public static explicit operator M34d(M22i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M23i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M33i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34d(M34i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M44i m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M22l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M23l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M33l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34d(M34l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M44l m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M22f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M23f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M33f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34d(M34f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M44f m)
        {
            return new M34d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
            };
        }

        public static explicit operator M34d(M22d m)
        {
            return new M34d {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M23d m)
        {
            return new M34d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
            };
        }

        public static explicit operator M34d(M33d m)
        {
            return new M34d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
            };
        }

        public static explicit operator M34d(M44d m)
        {
            return new M34d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
            };
        }

        public static explicit operator M34d(int[] a)
        {
            return new M34d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11]);
        }

        public static explicit operator M34d(int[,] a)
        {
            return new M34d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3]);
        }

        public static explicit operator int[](M34d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23
            };
        }

        public static explicit operator int[,](M34d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
        }

        public static explicit operator M34d(long[] a)
        {
            return new M34d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11]);
        }

        public static explicit operator M34d(long[,] a)
        {
            return new M34d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3]);
        }

        public static explicit operator long[](M34d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23
            };
        }

        public static explicit operator long[,](M34d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
        }

        public static explicit operator M34d(float[] a)
        {
            return new M34d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11]);
        }

        public static explicit operator M34d(float[,] a)
        {
            return new M34d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3]);
        }

        public static explicit operator float[](M34d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23
            };
        }

        public static explicit operator float[,](M34d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
        }

        public static explicit operator M34d(double[] a)
        {
            return new M34d(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11]);
        }

        public static explicit operator M34d(double[,] a)
        {
            return new M34d(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3]);
        }

        public static explicit operator double[](M34d m)
        {
            return new double[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23
            };
        }

        public static explicit operator double[,](M34d m)
        {
            return new double[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<double, int> element_fun)
        {
            return new M34i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M34i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<double, long> element_fun)
        {
            return new M34l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M34l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<double, float> element_fun)
        {
            return new M34f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M34f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<double, double> element_fun)
        {
            return new M34d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M34d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M34d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3));
        }

        public double[] ToArray()
        {
            var array = new double[12];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d FromCols(V3d col0, V3d col1, V3d col2, V3d col3)
        {
            return new M34d(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d FromRows(V4d row0, V4d row1, V4d row2)
        {
            return new M34d(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d FromDiagonal(double value)
        {
            return new M34d(
                value, 0, 0, 0, 
                0, value, 0, 0, 
                0, 0, value, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d FromDiagonal(double m00, double m11, double m22)
        {
            return new M34d(
                m00, 0, 0, 0, 
                0, m11, 0, 0, 
                0, 0, m22, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d FromDiagonal(V3d s)
        {
            return new M34d(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a homogenous transformation <see cref="M34d"/> using a uniform scale.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Scale(double s)
        {
            return new M34d(
                s, 0, 0, 0, 
                0, s, 0, 0, 
                0, 0, s, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34d"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Scale(double sX, double sY, double sZ)
        {
            return new M34d(
                sX, 0, 0, 0, 
                0, sY, 0, 0, 
                0, 0, sZ, 0);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34d"/> using a <see cref="V3d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Scale(V3d s)
        {
            return new M34d(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        /// <summary>
        /// Creates a scaling transformation <see cref="M34d"/> from a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Scale(Scale3d s)
        {
            return new M34d(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M34d"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Translation(double tX, double tY, double tZ)
        {
            return new M34d(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34d"/> with the translational component given by a <see cref="V3d"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Translation(V3d t)
        {
            return new M34d(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z);
        }

        /// <summary>
        /// Creates a transformation <see cref="M34d"/> from a <see cref="Shift3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Translation(Shift3d s)
        {
            return new M34d(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, s.Z);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in radians.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d Rotation(V3d normalizedAxis, double angleInRadians)
        {
            Debug.Assert(normalizedAxis.LengthSquared.ApproximateEquals(1));
            return (M34d)(Rot3d.Rotation(normalizedAxis, angleInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in degrees.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d RotationInDegrees(V3d normalizedAxis, double angleInDegrees)
            => Rotation(normalizedAxis, angleInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) in radians. 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d RotationEuler(double rollInRadians, double pitchInRadians, double yawInRadians)
        {
            return (M34d)(Rot3d.RotationEuler(rollInRadians, pitchInRadians, yawInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) in degrees. 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d RotationEulerInDegrees(double rollInDegrees, double pitchInDegrees, double yawInDegrees)
            => RotationEuler(
                rollInDegrees.RadiansFromDegrees(),
                pitchInDegrees.RadiansFromDegrees(), 
                yawInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) vector in radians.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d RotationEuler(V3d rollPitchYawInRadians)
            => RotationEuler(
                rollPitchYawInRadians.X,
                rollPitchYawInRadians.Y,
                rollPitchYawInRadians.Z);

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) vector in degrees.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d RotationEulerInDegrees(V3d rollPitchYawInDegrees)
            => RotationEulerInDegrees(
                rollPitchYawInDegrees.X,
                rollPitchYawInDegrees.Y,
                rollPitchYawInDegrees.Z);

        /// <summary>
        /// Creates a 3D rotation matrix which rotates one vector into another.
        /// The input vectors have to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d RotateInto(V3d from, V3d into)
        {
            Debug.Assert(from.LengthSquared.ApproximateEquals(1));
            Debug.Assert(into.LengthSquared.ApproximateEquals(1));
            return (M34d)(Rot3d.RotateInto(from, into));
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d RotationX(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M34d(
                 1,  0,  0,  0, 
                 0,  a, -b,  0, 
                 0,  b,  a,  0);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d RotationXInDegrees(double angleDegrees)
            => RotationX(angleDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d RotationY(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M34d(
                 a,  0,  b,  0, 
                 0,  1,  0,  0, 
                -b,  0,  a,  0);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d RotationYInDegrees(double angleDegrees)
            => RotationY(angleDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d RotationZ(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M34d(
                 a, -b,  0,  0, 
                 b,  a,  0,  0, 
                 0,  0,  1,  0);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d RotationZInDegrees(double angleDegrees)
            => RotationZ(angleDegrees.RadiansFromDegrees());

        #endregion

        #region Shearing

        /// <summary>
        /// Creates a shear transformation matrix along the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d ShearXY(double factorX, double factorY)
        {
            return new M34d(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d ShearXZ(double factorX, double factorZ)
        {
            return new M34d(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d ShearYZ(double factorY, double factorZ)
        {
            return new M34d(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0);
        }

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d DivideByInt(M34d m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<double> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
            }
        }

        public IEnumerable<V4d> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
            }
        }

        public IEnumerable<V3d> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        [XmlIgnore]
        public V4d R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4d( M00,  M01,  M02,  M03); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        [XmlIgnore]
        public V4d R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4d( M10,  M11,  M12,  M13); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        [XmlIgnore]
        public V4d R2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4d( M20,  M21,  M22,  M23); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        [XmlIgnore]
        public V3d C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3d( M00,  M10,  M20); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
            }
        }

        [XmlIgnore]
        public V3d C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3d( M01,  M11,  M21); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
            }
        }

        [XmlIgnore]
        public V3d C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3d( M02,  M12,  M22); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
            }
        }

        [XmlIgnore]
        public V3d C3
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V3d( M03,  M13,  M23); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
            }
        }

        public V3d Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V3d(M00, M11, M22);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public double MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public double MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23);
        }

        public unsafe double this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (double* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (double* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe double this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (double* ptr = &M00) { return ptr[row * 4 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (double* ptr = &M00) { ptr[row * 4 + column] = value; }
            }
        }

        public bool AnyNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNaN(M00) || double.IsNaN(M01) || double.IsNaN(M02) || double.IsNaN(M03) || 
                    double.IsNaN(M10) || double.IsNaN(M11) || double.IsNaN(M12) || double.IsNaN(M13) || 
                    double.IsNaN(M20) || double.IsNaN(M21) || double.IsNaN(M22) || double.IsNaN(M23);
            }
        }

        public bool AllNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNaN(M00) && double.IsNaN(M01) && double.IsNaN(M02) && double.IsNaN(M03) && 
                    double.IsNaN(M10) && double.IsNaN(M11) && double.IsNaN(M12) && double.IsNaN(M13) && 
                    double.IsNaN(M20) && double.IsNaN(M21) && double.IsNaN(M22) && double.IsNaN(M23);
            }
        }

        public bool AnyInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsInfinity(M00) || double.IsInfinity(M01) || double.IsInfinity(M02) || double.IsInfinity(M03) || 
                    double.IsInfinity(M10) || double.IsInfinity(M11) || double.IsInfinity(M12) || double.IsInfinity(M13) || 
                    double.IsInfinity(M20) || double.IsInfinity(M21) || double.IsInfinity(M22) || double.IsInfinity(M23);
            }
        }

        public bool AllInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsInfinity(M00) && double.IsInfinity(M01) && double.IsInfinity(M02) && double.IsInfinity(M03) && 
                    double.IsInfinity(M10) && double.IsInfinity(M11) && double.IsInfinity(M12) && double.IsInfinity(M13) && 
                    double.IsInfinity(M20) && double.IsInfinity(M21) && double.IsInfinity(M22) && double.IsInfinity(M23);
            }
        }

        public bool AnyPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsPositiveInfinity(M00) || double.IsPositiveInfinity(M01) || double.IsPositiveInfinity(M02) || double.IsPositiveInfinity(M03) || 
                    double.IsPositiveInfinity(M10) || double.IsPositiveInfinity(M11) || double.IsPositiveInfinity(M12) || double.IsPositiveInfinity(M13) || 
                    double.IsPositiveInfinity(M20) || double.IsPositiveInfinity(M21) || double.IsPositiveInfinity(M22) || double.IsPositiveInfinity(M23);
            }
        }

        public bool AllPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsPositiveInfinity(M00) && double.IsPositiveInfinity(M01) && double.IsPositiveInfinity(M02) && double.IsPositiveInfinity(M03) && 
                    double.IsPositiveInfinity(M10) && double.IsPositiveInfinity(M11) && double.IsPositiveInfinity(M12) && double.IsPositiveInfinity(M13) && 
                    double.IsPositiveInfinity(M20) && double.IsPositiveInfinity(M21) && double.IsPositiveInfinity(M22) && double.IsPositiveInfinity(M23);
            }
        }

        public bool AnyNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNegativeInfinity(M00) || double.IsNegativeInfinity(M01) || double.IsNegativeInfinity(M02) || double.IsNegativeInfinity(M03) || 
                    double.IsNegativeInfinity(M10) || double.IsNegativeInfinity(M11) || double.IsNegativeInfinity(M12) || double.IsNegativeInfinity(M13) || 
                    double.IsNegativeInfinity(M20) || double.IsNegativeInfinity(M21) || double.IsNegativeInfinity(M22) || double.IsNegativeInfinity(M23);
            }
        }

        public bool AllNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNegativeInfinity(M00) && double.IsNegativeInfinity(M01) && double.IsNegativeInfinity(M02) && double.IsNegativeInfinity(M03) && 
                    double.IsNegativeInfinity(M10) && double.IsNegativeInfinity(M11) && double.IsNegativeInfinity(M12) && double.IsNegativeInfinity(M13) && 
                    double.IsNegativeInfinity(M20) && double.IsNegativeInfinity(M21) && double.IsNegativeInfinity(M22) && double.IsNegativeInfinity(M23);
            }
        }

        public bool AnyTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) || Fun.IsTiny(M01) || Fun.IsTiny(M02) || Fun.IsTiny(M03) || 
                    Fun.IsTiny(M10) || Fun.IsTiny(M11) || Fun.IsTiny(M12) || Fun.IsTiny(M13) || 
                    Fun.IsTiny(M20) || Fun.IsTiny(M21) || Fun.IsTiny(M22) || Fun.IsTiny(M23);
            }
        }

        public bool AllTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) && Fun.IsTiny(M01) && Fun.IsTiny(M02) && Fun.IsTiny(M03) && 
                    Fun.IsTiny(M10) && Fun.IsTiny(M11) && Fun.IsTiny(M12) && Fun.IsTiny(M13) && 
                    Fun.IsTiny(M20) && Fun.IsTiny(M21) && Fun.IsTiny(M22) && Fun.IsTiny(M23);
            }
        }

        /// <summary>
        /// Returns true if the absolute value of each element of the matrix is smaller than Constant&lt;double&gt;.PositiveTinyValue, false otherwise.
        /// </summary>
        public bool IsTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AllTiny;
        }

        /// <summary>
        /// Returns true if any element of the matrix is NaN, false otherwise.
        /// </summary>
        public bool IsNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyNaN;
        }

        /// <summary>
        /// Returns true if any element of the matrix is infinite (positive or negative), false otherwise.
        /// </summary>
        public bool IsInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyInfinity;
        }

        /// <summary>
        /// Returns whether all elements of the matrix are finite (i.e. not NaN and not infinity).
        /// </summary>
        public bool IsFinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => !(IsInfinity || IsNaN);
        }

        #endregion

        #region Constants

        public const int RowCount = 3;
        public const int ColumnCount = 4;
        public const int ElementCount = 3 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(3, 4);
        }

        public static M34d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M34d(0);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator -(M34d m)
        {
            return new M34d(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  + (M34d a, M34d b)
        {
            return new M34d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  + (M34d m, double s)
        {
            return new M34d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  + (double s, M34d m)
        {
            return new M34d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  - (M34d a, M34d b)
        {
            return new M34d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  - (M34d m, double s)
        {
            return new M34d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  - (double s, M34d m)
        {
            return new M34d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  % (M34d a, M34d b)
        {
            return new M34d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  % (M34d m, double s)
        {
            return new M34d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  % (double s, M34d m)
        {
            return new M34d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  / (M34d a, M34d b)
        {
            return new M34d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  / (M34d m, double s)
        {
            return new M34d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  / (double s, M34d m)
        {
            return new M34d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  * (M34d m, double s)
        {
            return new M34d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d operator  * (double s, M34d m)
        {
            return new M34d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M34d matrix with a V4d column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d operator *(M34d m, V4d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W);
        }

        /// <summary>
        /// Multiplies a V3d row vector with a M34d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d operator *(V3d v, M34d m)
        {
            return new V4d(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M34d a, M34d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M34d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(double s, M34d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M34d a, M34d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M34d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(double s, M34d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M34d a, M34d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M34d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(double s, M34d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M34d a, M34d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M34d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(double s, M34d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M34d a, M34d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M34d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(double s, M34d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M34d a, M34d b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M34d m, double s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(double s, M34d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02, M03),
                        HashCode.GetCombined(M10, M11, M12, M13),
                        HashCode.GetCombined(M20, M21, M22, M23));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M34d other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && M03.Equals(other.M03) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12) && M13.Equals(other.M13) && 
                M20.Equals(other.M20) && M21.Equals(other.M21) && M22.Equals(other.M22) && M23.Equals(other.M23);
        }

        public override bool Equals(object other)
            => (other is M34d o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M34d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M34d.FromRows(
                V4d.Parse(x[0]), 
                V4d.Parse(x[1]), 
                V4d.Parse(x[2])
            );
        }

        #endregion

        #region Matrix Operations

        #endregion

        #region Matrix Multiplication

        public static M34d operator *(M33d a, M34d b)
        {
            return new M34d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23
             );
        }

        public static M34d operator *(M34d a, M44d b)
        {
            return new M34d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M34dEqualityComparer : IEqualityComparer<M34d>
    {
        public static readonly M34dEqualityComparer Default
            = new M34dEqualityComparer();

        #region IEqualityComparer<M34d> Members

        public bool Equals(M34d v0, M34d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M34d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M34d m)
            => (m.C0.Length + m.C1.Length + m.C2.Length) / 3;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetScaleVector(this M34d m)
            => new V3d(m.C0.Length, m.C1.Length, m.C2.Length);

        /// <summary>
        /// Extracts the forward vector from the given view transformation matrix.
        /// NOTE: A left-handed coordinates system transformation is expected, 
        /// where the view-space z-axis points in forward direction.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetViewDirectionLH(this M34d m)
            => m.R2.XYZ.Normalized;

        /// <summary>
        /// Extracts the forward vector from the given view transformation matrix.
        /// NOTE: A right-handed coordinates system transformation is expected, where 
        /// the view-space z-axis points opposit the forward vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetViewDirectionRH(this M34d m)
            => -m.R2.XYZ.Normalized;

        /// <summary>
        /// Extracts the translation component of the given transformation matrix, which when given 
        /// a model transformation represents the model origin in world position.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetModelOrigin(this M34d m)
            => m.C3;

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm1(M34d m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M34d m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMax(M34d m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMin(M34d m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M34d m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(this M34d a, M34d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M34d a, M34d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M34d a, M34d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(this M34d a, M34d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(this M34d a, M34d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d Transform(this M34d m, V4d v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d TransposedTransform(this M34d m, V3d v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3d TransformDir(this M34d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// </summary>
        public static V3d TransformPos(this M34d m, V3d p)
        {
            return new V3d(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Multiplies two <see cref="M34d"/> matrices as 4x4 matrices.
        /// </summary>
        public static M34d MultiplyAffine(this M34d a, M34d b)
        {
            return new M34d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23
            );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V4d Row(this M34d m, int index)
        {
            double* ptr = &m.M00;
            return new V4d(ptr[index * 4], ptr[index * 4 + 1], ptr[index * 4 + 2], ptr[index * 4 + 3]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V3d Column(this M34d m, int index)
        {
            double* ptr = &m.M00;
            return new V3d(ptr[index], ptr[index + 4], ptr[index + 8]);
        }

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M34d"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double MinElement(M34d m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M34d"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double MaxElement(M34d m)
            => m.MaxElement;

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M34d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M34d m, double epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M03.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon) || m.M13.IsTiny(epsilon) || m.M20.IsTiny(epsilon) || m.M21.IsTiny(epsilon) || m.M22.IsTiny(epsilon) || m.M23.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M34d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M34d m, double epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M03.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon) && m.M13.IsTiny(epsilon) && m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon) && m.M22.IsTiny(epsilon) && m.M23.IsTiny(epsilon);

        #endregion

        #region Special Floating Point Value Checks

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNaN(M34d m)
            => m.AnyNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNaN(M34d m)
            => m.AllNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyInfinity(M34d m)
            => m.AnyInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllInfinity(M34d m)
            => m.AllInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyPositiveInfinity(M34d m)
            => m.AnyPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllPositiveInfinity(M34d m)
            => m.AllPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNegativeInfinity(M34d m)
            => m.AnyNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNegativeInfinity(M34d m)
            => m.AllNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(M34d m)
            => m.AnyTiny;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(M34d m)
            => m.AllTiny;

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M34d a, M34d b)
            => ApproximateEquals(a, b, Constant<double>.PositiveTinyValue);

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M34d a, M34d b, double epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M34d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M34d m, double epsilon)
            => Mat.AllTiny(m, epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M34d"/> is smaller than Constant&lt;double&gt;.PositiveTinyValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(M34d m)
            => m.IsTiny;

        #endregion

        #region Special Floating Point Value Checks

        /// <summary>
        /// Returns whether any element of the given <see cref="M34d"/> is NaN.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNaN(M34d v)
            => v.IsNaN;

        /// <summary>
        /// Returns whether any element of the given <see cref="M34d"/> is infinity (positive or negative).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInfinity(M34d v)
            => v.IsInfinity;

        /// <summary>
        /// Returns whether all elements of the given <see cref="M34d"/> are finite (i.e. not NaN and not infinity).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsFinite(M34d v)
            => v.IsFinite;

        #endregion
    }

    public static class IRandomUniformM34dExtensions
    {
        #region IRandomUniform extensions for M34d

        /// <summary>
        /// Uses UniformDouble() to generate the elements of an M34d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d UniformM34d(this IRandomUniform rnd)
        {
            return new M34d(
                rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), 
                rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), 
                rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble());
        }

        /// <summary>
        /// Uses UniformDoubleClosed() to generate the elements of an M34d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d UniformM34dClosed(this IRandomUniform rnd)
        {
            return new M34d(
                rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), 
                rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), 
                rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed());
        }

        /// <summary>
        /// Uses UniformDoubleOpen() to generate the elements of an M34d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d UniformM34dOpen(this IRandomUniform rnd)
        {
            return new M34d(
                rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), 
                rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), 
                rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen());
        }

        /// <summary>
        /// Uses UniformDoubleFull() to generate the elements of an M34d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d UniformM34dFull(this IRandomUniform rnd)
        {
            return new M34d(
                rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), 
                rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), 
                rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull());
        }

        /// <summary>
        /// Uses UniformDoubleFullClosed() to generate the elements of an M34d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d UniformM34dFullClosed(this IRandomUniform rnd)
        {
            return new M34d(
                rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), 
                rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), 
                rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed());
        }

        /// <summary>
        /// Uses UniformDoubleFullOpen() to generate the elements of an M34d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M34d UniformM34dFullOpen(this IRandomUniform rnd)
        {
            return new M34d(
                rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), 
                rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), 
                rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen());
        }

        #endregion
    }

    #endregion

    #region M44i

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M44i : IEquatable<M44i>, IValidity, IMatrix<double>
    {
        [DataMember]
        public int M00, M01, M02, M03;
        [DataMember]
        public int M10, M11, M12, M13;
        [DataMember]
        public int M20, M21, M22, M23;
        [DataMember]
        public int M30, M31, M32, M33;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(int value)
        {
            M00 = value; M01 = 0; M02 = 0; M03 = 0; 
            M10 = 0; M11 = value; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = value; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = value; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(
                int m00, int m01, int m02, int m03, 
                int m10, int m11, int m12, int m13, 
                int m20, int m21, int m22, int m23, 
                int m30, int m31, int m32, int m33)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
            M30 = m30; M31 = m31; M32 = m32; M33 = m33; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(int[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
            M30 = a[12];
            M31 = a[13];
            M32 = a[14];
            M33 = a[15];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(int[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
            M30 = a[start + 12];
            M31 = a[start + 13];
            M32 = a[start + 14];
            M33 = a[start + 15];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M22i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M23i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M33i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M34i m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M22l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M23l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M33l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M34l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M44l m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
            M30 = (int)m.M30; M31 = (int)m.M31; M32 = (int)m.M32; M33 = (int)m.M33; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M22f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M23f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M33f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M34f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M44f m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
            M30 = (int)m.M30; M31 = (int)m.M31; M32 = (int)m.M32; M33 = (int)m.M33; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M22d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = 0; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M23d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M33d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = 0; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = 0; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M34d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44i(M44d m)
        {
            M00 = (int)m.M00; M01 = (int)m.M01; M02 = (int)m.M02; M03 = (int)m.M03; 
            M10 = (int)m.M10; M11 = (int)m.M11; M12 = (int)m.M12; M13 = (int)m.M13; 
            M20 = (int)m.M20; M21 = (int)m.M21; M22 = (int)m.M22; M23 = (int)m.M23; 
            M30 = (int)m.M30; M31 = (int)m.M31; M32 = (int)m.M32; M33 = (int)m.M33; 
        }

        #endregion

        #region Conversions

        public static explicit operator M44i(M22i m)
        {
            return new M44i {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M23i m)
        {
            return new M44i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M33i m)
        {
            return new M44i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M34i m)
        {
            return new M44i {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M22l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M23l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M33l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M34l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M44l m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = (int)m.M30, M31 = (int)m.M31, M32 = (int)m.M32, M33 = (int)m.M33, 
            };
        }

        public static explicit operator M44i(M22f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M23f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M33f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M34f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M44f m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = (int)m.M30, M31 = (int)m.M31, M32 = (int)m.M32, M33 = (int)m.M33, 
            };
        }

        public static explicit operator M44i(M22d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = 0, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M23d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M33d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = 0, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = 0, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M34d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44i(M44d m)
        {
            return new M44i {
                M00 = (int)m.M00, M01 = (int)m.M01, M02 = (int)m.M02, M03 = (int)m.M03, 
                M10 = (int)m.M10, M11 = (int)m.M11, M12 = (int)m.M12, M13 = (int)m.M13, 
                M20 = (int)m.M20, M21 = (int)m.M21, M22 = (int)m.M22, M23 = (int)m.M23, 
                M30 = (int)m.M30, M31 = (int)m.M31, M32 = (int)m.M32, M33 = (int)m.M33, 
            };
        }

        public static explicit operator M44i(int[] a)
        {
            return new M44i(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11], 
                a[12], a[13], a[14], a[15]);
        }

        public static explicit operator M44i(int[,] a)
        {
            return new M44i(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3], 
                a[3, 0], a[3, 1], a[3, 2], a[3, 3]);
        }

        public static explicit operator int[](M44i m)
        {
            return new int[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23, 
                m.M30, m.M31, m.M32, m.M33
            };
        }

        public static explicit operator int[,](M44i m)
        {
            return new int[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }, 
                { m.M30, m.M31, m.M32, m.M33 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
            array[index + 12] = M30;
            array[index + 13] = M31;
            array[index + 14] = M32;
            array[index + 15] = M33;
        }

        public static explicit operator M44i(long[] a)
        {
            return new M44i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11], 
                (int)a[12], (int)a[13], (int)a[14], (int)a[15]);
        }

        public static explicit operator M44i(long[,] a)
        {
            return new M44i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3], 
                (int)a[3, 0], (int)a[3, 1], (int)a[3, 2], (int)a[3, 3]);
        }

        public static explicit operator long[](M44i m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23, 
                (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33
            };
        }

        public static explicit operator long[,](M44i m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }, 
                { (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
            array[index + 12] = (long)M30;
            array[index + 13] = (long)M31;
            array[index + 14] = (long)M32;
            array[index + 15] = (long)M33;
        }

        public static explicit operator M44i(float[] a)
        {
            return new M44i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11], 
                (int)a[12], (int)a[13], (int)a[14], (int)a[15]);
        }

        public static explicit operator M44i(float[,] a)
        {
            return new M44i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3], 
                (int)a[3, 0], (int)a[3, 1], (int)a[3, 2], (int)a[3, 3]);
        }

        public static explicit operator float[](M44i m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23, 
                (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33
            };
        }

        public static explicit operator float[,](M44i m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }, 
                { (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
            array[index + 12] = (float)M30;
            array[index + 13] = (float)M31;
            array[index + 14] = (float)M32;
            array[index + 15] = (float)M33;
        }

        public static explicit operator M44i(double[] a)
        {
            return new M44i(
                (int)a[0], (int)a[1], (int)a[2], (int)a[3], 
                (int)a[4], (int)a[5], (int)a[6], (int)a[7], 
                (int)a[8], (int)a[9], (int)a[10], (int)a[11], 
                (int)a[12], (int)a[13], (int)a[14], (int)a[15]);
        }

        public static explicit operator M44i(double[,] a)
        {
            return new M44i(
                (int)a[0, 0], (int)a[0, 1], (int)a[0, 2], (int)a[0, 3], 
                (int)a[1, 0], (int)a[1, 1], (int)a[1, 2], (int)a[1, 3], 
                (int)a[2, 0], (int)a[2, 1], (int)a[2, 2], (int)a[2, 3], 
                (int)a[3, 0], (int)a[3, 1], (int)a[3, 2], (int)a[3, 3]);
        }

        public static explicit operator double[](M44i m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23, 
                (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33
            };
        }

        public static explicit operator double[,](M44i m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }, 
                { (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
            array[index + 12] = (double)M30;
            array[index + 13] = (double)M31;
            array[index + 14] = (double)M32;
            array[index + 15] = (double)M33;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<int, int> element_fun)
        {
            return new M44i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<int, int, int, int> element_index0_index1_fun)
        {
            return new M44i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<int, long> element_fun)
        {
            return new M44l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<int, int, int, long> element_index0_index1_fun)
        {
            return new M44l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<int, float> element_fun)
        {
            return new M44f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<int, int, int, float> element_index0_index1_fun)
        {
            return new M44f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<int, double> element_fun)
        {
            return new M44d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<int, int, int, double> element_index0_index1_fun)
        {
            return new M44d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M33i UpperLeftM33()
        {
            return (M33i)this;
        }

        public int[] ToArray()
        {
            var array = new int[16];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            array[12] = M30;
            array[13] = M31;
            array[14] = M32;
            array[15] = M33;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i FromCols(V4i col0, V4i col1, V4i col2, V4i col3)
        {
            return new M44i(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z, 
                col0.W, col1.W, col2.W, col3.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i FromRows(V4i row0, V4i row1, V4i row2, V4i row3)
        {
            return new M44i(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W, 
                row3.X, row3.Y, row3.Z, row3.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i FromDiagonal(int value)
        {
            return new M44i(
                value, 0, 0, 0, 
                0, value, 0, 0, 
                0, 0, value, 0, 
                0, 0, 0, value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i FromDiagonal(int m00, int m11, int m22, int m33)
        {
            return new M44i(
                m00, 0, 0, 0, 
                0, m11, 0, 0, 
                0, 0, m22, 0, 
                0, 0, 0, m33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i FromDiagonal(V4i s)
        {
            return new M44i(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, s.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i FromAntiDiagonal(int value)
        {
            return new M44i(
                 0, 0, 0, value, 
                 0, 0, value, 0, 
                 0, value, 0, 0, 
                 value, 0, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i FromAntiDiagonal(int m03, int m12, int m21, int m30)
        {
            return new M44i(
                0, 0, 0, m03, 
                0, 0, m12, 0, 
                0, m21, 0, 0, 
                m30, 0, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i FromAntiDiagonal(V4i s)
        {
            return new M44i(
                0, 0, 0, s.X, 
                0, 0, s.Y, 0, 
                0, s.Z, 0, 0, 
                s.W, 0, 0, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M44i"/> using 4 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i Scale(int sX, int sY, int sZ, int sW)
            => FromDiagonal(sX, sY, sZ, sW);

        /// <summary>
        /// Creates a transformation <see cref="M44i"/> using a <see cref="V4i"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i Scale(V4i s)
            => FromDiagonal(s);

        /// <summary>
        /// Creates a homogenous transformation <see cref="M44i"/> using a uniform scale.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i Scale(int s)
        {
            return new M44i(
                s, 0, 0, 0, 
                0, s, 0, 0, 
                0, 0, s, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44i"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i Scale(int sX, int sY, int sZ)
        {
            return new M44i(
                sX, 0, 0, 0, 
                0, sY, 0, 0, 
                0, 0, sZ, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44i"/> using a <see cref="V3i"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i Scale(V3i s)
        {
            return new M44i(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, 1);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M44i"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i Translation(int tX, int tY, int tZ)
        {
            return new M44i(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44i"/> with the translational component given by a <see cref="V3i"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i Translation(V3i t)
        {
            return new M44i(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z, 
                0, 0, 0, 1);
        }

        #endregion

        #region Shearing

        /// <summary>
        /// Creates a shear transformation matrix along the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i ShearXY(int factorX, int factorY)
        {
            return new M44i(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i ShearXZ(int factorX, int factorZ)
        {
            return new M44i(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i ShearYZ(int factorY, int factorZ)
        {
            return new M44i(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0, 
                0, 0, 0, 1);
        }

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i DivideByInt(M44i m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<int> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
                yield return M30;
                yield return M31;
                yield return M32;
                yield return M33;
            }
        }

        public IEnumerable<V4i> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
                yield return R3;
            }
        }

        public IEnumerable<V4i> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        [XmlIgnore]
        public V4i R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4i( M00,  M01,  M02,  M03); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        [XmlIgnore]
        public V4i R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4i( M10,  M11,  M12,  M13); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        [XmlIgnore]
        public V4i R2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4i( M20,  M21,  M22,  M23); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        [XmlIgnore]
        public V4i R3
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4i( M30,  M31,  M32,  M33); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M30 = value.X;
                M31 = value.Y;
                M32 = value.Z;
                M33 = value.W;
            }
        }

        [XmlIgnore]
        public V4i C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4i( M00,  M10,  M20,  M30); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
                M30 = value.W;
            }
        }

        [XmlIgnore]
        public V4i C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4i( M01,  M11,  M21,  M31); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
                M31 = value.W;
            }
        }

        [XmlIgnore]
        public V4i C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4i( M02,  M12,  M22,  M32); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
                M32 = value.W;
            }
        }

        [XmlIgnore]
        public V4i C3
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4i( M03,  M13,  M23,  M33); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
                M33 = value.W;
            }
        }

        public V4i Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V4i(M00, M11, M22, M33);
        }

        public V4i AntiDiagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V4i(M03, M12, M21, M30);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public int MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23, M30, M31, M32, M33);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public int MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23, M30, M31, M32, M33);
        }

        public unsafe int this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (int* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (int* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe int this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (int* ptr = &M00) { return ptr[row * 4 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (int* ptr = &M00) { ptr[row * 4 + column] = value; }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 4;
        public const int ColumnCount = 4;
        public const int ElementCount = 4 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(4, 4);
        }

        public static M44i Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44i(0);
        }

        public static M44i Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44i(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public int Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23) + 
                    Fun.Abs(M30) + Fun.Abs(M31) + Fun.Abs(M32) + Fun.Abs(M33);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23 + 
                    M30 * M30 + M31 * M31 + M32 * M32 + M33 * M33);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public int NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Max(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public int NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Min(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator -(M44i m)
        {
            return new M44i(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23, 
                -m.M30, -m.M31, -m.M32, -m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator  + (M44i a, M44i b)
        {
            return new M44i(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator  + (M44i m, int s)
        {
            return new M44i(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator  + (int s, M44i m)
        {
            return new M44i(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  + (M44i a, M44l b)
        {
            return new M44l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  + (M44i m, long s)
        {
            return new M44l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  + (long s, M44i m)
        {
            return new M44l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  + (M44i a, M44f b)
        {
            return new M44f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  + (M44i m, float s)
        {
            return new M44f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  + (float s, M44i m)
        {
            return new M44f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  + (M44i a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  + (M44i m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  + (double s, M44i m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator  - (M44i a, M44i b)
        {
            return new M44i(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator  - (M44i m, int s)
        {
            return new M44i(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator  - (int s, M44i m)
        {
            return new M44i(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  - (M44i a, M44l b)
        {
            return new M44l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  - (M44i m, long s)
        {
            return new M44l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  - (long s, M44i m)
        {
            return new M44l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  - (M44i a, M44f b)
        {
            return new M44f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  - (M44i m, float s)
        {
            return new M44f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  - (float s, M44i m)
        {
            return new M44f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  - (M44i a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  - (M44i m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  - (double s, M44i m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator  % (M44i a, M44i b)
        {
            return new M44i(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator  % (M44i m, int s)
        {
            return new M44i(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator  % (int s, M44i m)
        {
            return new M44i(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  % (M44i a, M44l b)
        {
            return new M44l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  % (M44i m, long s)
        {
            return new M44l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  % (long s, M44i m)
        {
            return new M44l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  % (M44i a, M44f b)
        {
            return new M44f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  % (M44i m, float s)
        {
            return new M44f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  % (float s, M44i m)
        {
            return new M44f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  % (M44i a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  % (M44i m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  % (double s, M44i m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator  / (M44i a, M44i b)
        {
            return new M44i(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator  / (M44i m, int s)
        {
            return new M44i(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator  / (int s, M44i m)
        {
            return new M44i(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  / (M44i a, M44l b)
        {
            return new M44l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  / (M44i m, long s)
        {
            return new M44l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  / (long s, M44i m)
        {
            return new M44l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  / (M44i a, M44f b)
        {
            return new M44f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  / (M44i m, float s)
        {
            return new M44f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  / (float s, M44i m)
        {
            return new M44f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  / (M44i a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  / (M44i m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  / (double s, M44i m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator  * (M44i m, int s)
        {
            return new M44i(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator  * (int s, M44i m)
        {
            return new M44i(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  * (M44i m, long s)
        {
            return new M44l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  * (long s, M44i m)
        {
            return new M44l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  * (M44i m, float s)
        {
            return new M44f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  * (float s, M44i m)
        {
            return new M44f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  * (M44i m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  * (double s, M44i m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        #endregion

        #region Bitwise Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator ~(M44i m)
        {
            return new M44i(
                ~m.M00, ~m.M01, ~m.M02, ~m.M03, 
                ~m.M10, ~m.M11, ~m.M12, ~m.M13, 
                ~m.M20, ~m.M21, ~m.M22, ~m.M23, 
                ~m.M30, ~m.M31, ~m.M32, ~m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator <<(M44i a, int s)
        {
            return new M44i(
                a.M00 << s, a.M01 << s, a.M02 << s, a.M03 << s, 
                a.M10 << s, a.M11 << s, a.M12 << s, a.M13 << s, 
                a.M20 << s, a.M21 << s, a.M22 << s, a.M23 << s, 
                a.M30 << s, a.M31 << s, a.M32 << s, a.M33 << s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator >>(M44i a, int s)
        {
            return new M44i(
                a.M00 >> s, a.M01 >> s, a.M02 >> s, a.M03 >> s, 
                a.M10 >> s, a.M11 >> s, a.M12 >> s, a.M13 >> s, 
                a.M20 >> s, a.M21 >> s, a.M22 >> s, a.M23 >> s, 
                a.M30 >> s, a.M31 >> s, a.M32 >> s, a.M33 >> s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator &(M44i a, M44i b)
        {
            return new M44i(
                a.M00 & b.M00, a.M01 & b.M01, a.M02 & b.M02, a.M03 & b.M03, 
                a.M10 & b.M10, a.M11 & b.M11, a.M12 & b.M12, a.M13 & b.M13, 
                a.M20 & b.M20, a.M21 & b.M21, a.M22 & b.M22, a.M23 & b.M23, 
                a.M30 & b.M30, a.M31 & b.M31, a.M32 & b.M32, a.M33 & b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator &(M44i a, int s)
        {
            return new M44i(
                a.M00 & s, a.M01 & s, a.M02 & s, a.M03 & s, 
                a.M10 & s, a.M11 & s, a.M12 & s, a.M13 & s, 
                a.M20 & s, a.M21 & s, a.M22 & s, a.M23 & s, 
                a.M30 & s, a.M31 & s, a.M32 & s, a.M33 & s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator &(int s, M44i a)
        {
            return new M44i(
                s & a.M00, s & a.M01, s & a.M02, s & a.M03, 
                s & a.M10, s & a.M11, s & a.M12, s & a.M13, 
                s & a.M20, s & a.M21, s & a.M22, s & a.M23, 
                s & a.M30, s & a.M31, s & a.M32, s & a.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator |(M44i a, M44i b)
        {
            return new M44i(
                a.M00 | b.M00, a.M01 | b.M01, a.M02 | b.M02, a.M03 | b.M03, 
                a.M10 | b.M10, a.M11 | b.M11, a.M12 | b.M12, a.M13 | b.M13, 
                a.M20 | b.M20, a.M21 | b.M21, a.M22 | b.M22, a.M23 | b.M23, 
                a.M30 | b.M30, a.M31 | b.M31, a.M32 | b.M32, a.M33 | b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator |(M44i a, int s)
        {
            return new M44i(
                a.M00 | s, a.M01 | s, a.M02 | s, a.M03 | s, 
                a.M10 | s, a.M11 | s, a.M12 | s, a.M13 | s, 
                a.M20 | s, a.M21 | s, a.M22 | s, a.M23 | s, 
                a.M30 | s, a.M31 | s, a.M32 | s, a.M33 | s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator |(int s, M44i a)
        {
            return new M44i(
                s | a.M00, s | a.M01, s | a.M02, s | a.M03, 
                s | a.M10, s | a.M11, s | a.M12, s | a.M13, 
                s | a.M20, s | a.M21, s | a.M22, s | a.M23, 
                s | a.M30, s | a.M31, s | a.M32, s | a.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator ^(M44i a, M44i b)
        {
            return new M44i(
                a.M00 ^ b.M00, a.M01 ^ b.M01, a.M02 ^ b.M02, a.M03 ^ b.M03, 
                a.M10 ^ b.M10, a.M11 ^ b.M11, a.M12 ^ b.M12, a.M13 ^ b.M13, 
                a.M20 ^ b.M20, a.M21 ^ b.M21, a.M22 ^ b.M22, a.M23 ^ b.M23, 
                a.M30 ^ b.M30, a.M31 ^ b.M31, a.M32 ^ b.M32, a.M33 ^ b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator ^(M44i a, int s)
        {
            return new M44i(
                a.M00 ^ s, a.M01 ^ s, a.M02 ^ s, a.M03 ^ s, 
                a.M10 ^ s, a.M11 ^ s, a.M12 ^ s, a.M13 ^ s, 
                a.M20 ^ s, a.M21 ^ s, a.M22 ^ s, a.M23 ^ s, 
                a.M30 ^ s, a.M31 ^ s, a.M32 ^ s, a.M33 ^ s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i operator ^(int s, M44i a)
        {
            return new M44i(
                s ^ a.M00, s ^ a.M01, s ^ a.M02, s ^ a.M03, 
                s ^ a.M10, s ^ a.M11, s ^ a.M12, s ^ a.M13, 
                s ^ a.M20, s ^ a.M21, s ^ a.M22, s ^ a.M23, 
                s ^ a.M30, s ^ a.M31, s ^ a.M32, s ^ a.M33);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M44i matrix with a V4i column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i operator *(M44i m, V4i v)
        {
            return new V4i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        /// <summary>
        /// Multiplies a V4i row vector with a M44i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i operator *(V4i v, M44i m)
        {
            return new V4i(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20 + v.W * m.M30, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21 + v.W * m.M31, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22 + v.W * m.M32, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23 + v.W * m.M33);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M44i a, M44i b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23 && 
                a.M30 < b.M30 && 
                a.M31 < b.M31 && 
                a.M32 < b.M32 && 
                a.M33 < b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M44i a, int s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s && 
                a.M30 < s && 
                a.M31 < s && 
                a.M32 < s && 
                a.M33 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(int s, M44i a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23  && 
                s < a.M30  && 
                s < a.M31  && 
                s < a.M32  && 
                s < a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M44i a, M44i b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23 && 
                a.M30 > b.M30 && 
                a.M31 > b.M31 && 
                a.M32 > b.M32 && 
                a.M33 > b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M44i a, int s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s && 
                a.M30 > s && 
                a.M31 > s && 
                a.M32 > s && 
                a.M33 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(int s, M44i a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23  && 
                s > a.M30  && 
                s > a.M31  && 
                s > a.M32  && 
                s > a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M44i a, M44i b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23 && 
                a.M30 == b.M30 && 
                a.M31 == b.M31 && 
                a.M32 == b.M32 && 
                a.M33 == b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M44i a, int s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s && 
                a.M30 == s && 
                a.M31 == s && 
                a.M32 == s && 
                a.M33 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(int s, M44i a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23  && 
                s == a.M30  && 
                s == a.M31  && 
                s == a.M32  && 
                s == a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M44i a, M44i b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23 && 
                a.M30 <= b.M30 && 
                a.M31 <= b.M31 && 
                a.M32 <= b.M32 && 
                a.M33 <= b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M44i a, int s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s && 
                a.M30 <= s && 
                a.M31 <= s && 
                a.M32 <= s && 
                a.M33 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(int s, M44i a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23  && 
                s <= a.M30  && 
                s <= a.M31  && 
                s <= a.M32  && 
                s <= a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M44i a, M44i b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23 && 
                a.M30 >= b.M30 && 
                a.M31 >= b.M31 && 
                a.M32 >= b.M32 && 
                a.M33 >= b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M44i a, int s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s && 
                a.M30 >= s && 
                a.M31 >= s && 
                a.M32 >= s && 
                a.M33 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(int s, M44i a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23  && 
                s >= a.M30  && 
                s >= a.M31  && 
                s >= a.M32  && 
                s >= a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M44i a, M44i b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M44i m, int s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(int s, M44i m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02, M03),
                        HashCode.GetCombined(M10, M11, M12, M13),
                        HashCode.GetCombined(M20, M21, M22, M23),
                        HashCode.GetCombined(M30, M31, M32, M33));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M44i other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && M03.Equals(other.M03) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12) && M13.Equals(other.M13) && 
                M20.Equals(other.M20) && M21.Equals(other.M21) && M22.Equals(other.M22) && M23.Equals(other.M23) && 
                M30.Equals(other.M30) && M31.Equals(other.M31) && M32.Equals(other.M32) && M33.Equals(other.M33);
        }

        public override bool Equals(object other)
            => (other is M44i o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R3.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M44i Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M44i.FromRows(
                V4i.Parse(x[0]), 
                V4i.Parse(x[1]), 
                V4i.Parse(x[2]), 
                V4i.Parse(x[3])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M44i Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M44i result = new M44i();
                for (int row = 0; row < 4; row++)
                {
                    for (int col = 0; col < 4; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public int Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 + M33 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public int Determinant
        {
            get
            {
                // using bottom row because elements M30, M31, and M32
                // are zero most of the time.
                int d = 0;
                if (M30 != 0.0f) d -= M30 * (
                M01 * M12 * M23 + M02 * M13 * M21 + M03 * M11 * M22
                - M21 * M12 * M03 - M22 * M13 * M01 - M23 * M11 * M02
                );
                if (M31 != 0.0f) d += M31 * (
                M00 * M12 * M23 + M02 * M13 * M20 + M03 * M10 * M22
                - M20 * M12 * M03 - M22 * M13 * M00 - M23 * M10 * M02
                );
                if (M32 != 0.0f) d -= M32 * (
                M00 * M11 * M23 + M01 * M13 * M20 + M03 * M10 * M21
                - M20 * M11 * M03 - M21 * M13 * M00 - M23 * M10 * M01
                );
                if (M33 != 0.0f) d += M33 * (
                M00 * M11 * M22 + M01 * M12 * M20 + M02 * M10 * M21
                - M20 * M11 * M02 - M21 * M12 * M00 - M22 * M10 * M01
                );
                return d;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M44i Transposed
        {
            get
            {
                return new M44i {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    M03 = M30, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    M13 = M31, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22, 
                    M23 = M32, 
                    
                    M30 = M03, 
                    M31 = M13, 
                    M32 = M23, 
                    M33 = M33
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M44i operator *(M44i a, M44i b)
        {
            return new M44i(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (int)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (int)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (int)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (int)value;
        }

        #endregion
    }

    public class M44iEqualityComparer : IEqualityComparer<M44i>
    {
        public static readonly M44iEqualityComparer Default
            = new M44iEqualityComparer();

        #region IEqualityComparer<M44i> Members

        public bool Equals(M44i v0, M44i v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M44i v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M44i m)
            => (m.C0.Length + m.C1.Length + m.C2.Length + m.C3.Length) / 4;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d GetScaleVector(this M44i m)
            => new V4d(m.C0.Length, m.C1.Length, m.C2.Length, m.C3.Length);

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of 3D basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale3(this M44i m)
            => (m.C0.XYZ.Length + m.C1.XYZ.Length + m.C2.XYZ.Length) / 3;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the 3D basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetScaleVector3(this M44i m)
            => new V3d(m.C0.XYZ.Length, m.C1.XYZ.Length, m.C2.XYZ.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Norm1(M44i m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M44i m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMax(M44i m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int NormMin(M44i m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M44i m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p) + 
                Fun.Abs(m.M30).Pow(p) + 
                Fun.Abs(m.M31).Pow(p) + 
                Fun.Abs(m.M32).Pow(p) + 
                Fun.Abs(m.M33).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static int Distance1(this M44i a, M44i b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23) + 
                Fun.Abs(b.M30 - a.M30) + 
                Fun.Abs(b.M31 - a.M31) + 
                Fun.Abs(b.M32 - a.M32) + 
                Fun.Abs(b.M33 - a.M33);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M44i a, M44i b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23) + 
                        Fun.Square(b.M30 - a.M30) + 
                        Fun.Square(b.M31 - a.M31) + 
                        Fun.Square(b.M32 - a.M32) + 
                        Fun.Square(b.M33 - a.M33));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M44i a, M44i b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p) + 
                Fun.Abs(b.M30 - a.M30).Pow(p) + 
                Fun.Abs(b.M31 - a.M31).Pow(p) + 
                Fun.Abs(b.M32 - a.M32).Pow(p) + 
                Fun.Abs(b.M33 - a.M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMax(this M44i a, M44i b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Max(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static int DistanceMin(this M44i a, M44i b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Min(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i Transform(this M44i m, V4i v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4i TransposedTransform(this M44i m, V4i v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3i TransformDir(this M44i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3i TransformPos(this M44i m, V3i p)
        {
            return new V3i(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3i TransformPosProj(this M44i m, V3i p)
        {
            int s = m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V4i TransformPosProjFull(this M44i m, V3i p)
        {
            return new V4i(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23, 
                m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V3i TransposedTransformDir(this M44i m, V3i v)
        {
            return new V3i(
                m.M00 * v.X + m.M10 * v.Y + m.M20 * v.Z, 
                m.M01 * v.X + m.M11 * v.Y + m.M21 * v.Z, 
                m.M02 * v.X + m.M12 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3i TransposedTransformPos(this M44i m, V3i p)
        {
            return new V3i(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3i TransposedTransformProj(this M44i m, V3i p)
        {
            var s = m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V4i TransposedTransformProjFull(this M44i m, V3i p)
        {
            return new V4i(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32, 
                m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M44i"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M33i Minor(this M44i m, int row, int column)
        {
            M33i rs = new M33i();

            for (int k = 0; k < 9; k++)
            {
                var i = k / 3;
                var j = k % 3;
                var ii = (i < row) ? i : i + 1;
                var jj = (j < column) ? j : j + 1;

                rs[k] = m[ii * 4 + jj];
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V4i Row(this M44i m, int index)
        {
            int* ptr = &m.M00;
            return new V4i(ptr[index * 4], ptr[index * 4 + 1], ptr[index * 4 + 2], ptr[index * 4 + 3]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V4i Column(this M44i m, int index)
        {
            int* ptr = &m.M00;
            return new V4i(ptr[index], ptr[index + 4], ptr[index + 8], ptr[index + 12]);
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Determinant(M44i m)
            => m.Determinant;

        /// <summary>
        /// Returns the transpose of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i Transposed(M44i m)
            => m.Transposed;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Transpose(this ref M44i m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
            Fun.Swap(ref m.M30, ref m.M03);
            Fun.Swap(ref m.M31, ref m.M13);
            Fun.Swap(ref m.M32, ref m.M23);
        }

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M44i"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int MinElement(M44i m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M44i"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int MaxElement(M44i m)
            => m.MaxElement;

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M44i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M44i m, int epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M03.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon) || m.M13.IsTiny(epsilon) || m.M20.IsTiny(epsilon) || m.M21.IsTiny(epsilon) || m.M22.IsTiny(epsilon) || m.M23.IsTiny(epsilon) || m.M30.IsTiny(epsilon) || m.M31.IsTiny(epsilon) || m.M32.IsTiny(epsilon) || m.M33.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M44i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M44i m, int epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M03.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon) && m.M13.IsTiny(epsilon) && m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon) && m.M22.IsTiny(epsilon) && m.M23.IsTiny(epsilon) && m.M30.IsTiny(epsilon) && m.M31.IsTiny(epsilon) && m.M32.IsTiny(epsilon) && m.M33.IsTiny(epsilon);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M44i a, M44i b, int epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M44i"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M44i m, int epsilon)
            => Mat.AllTiny(m, epsilon);

        #endregion
    }

    public static class IRandomUniformM44iExtensions
    {
        #region IRandomUniform extensions for M44i

        /// <summary>
        /// Uses UniformInt() to generate the elements of an M44i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i UniformM44i(this IRandomUniform rnd)
        {
            return new M44i(
                rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), 
                rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), 
                rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), 
                rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt(), rnd.UniformInt());
        }

        /// <summary>
        /// Uses UniformIntNonZero() to generate the elements of an M44i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i UniformM44iNonZero(this IRandomUniform rnd)
        {
            return new M44i(
                rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), 
                rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), 
                rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), 
                rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero(), rnd.UniformIntNonZero());
        }

        /// <summary>
        /// Uses UniformInt(int) to generate the elements of an M44i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i UniformM44i(this IRandomUniform rnd, int size)
        {
            return new M44i(
                rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), 
                rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), 
                rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), 
                rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size), rnd.UniformInt(size));
        }

        /// <summary>
        /// Uses UniformInt(int) to generate the elements of an M44i matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44i UniformM44i(this IRandomUniform rnd, M44i size)
        {
            return new M44i(
                rnd.UniformInt(size.M00), rnd.UniformInt(size.M01), rnd.UniformInt(size.M02), rnd.UniformInt(size.M03), 
                rnd.UniformInt(size.M10), rnd.UniformInt(size.M11), rnd.UniformInt(size.M12), rnd.UniformInt(size.M13), 
                rnd.UniformInt(size.M20), rnd.UniformInt(size.M21), rnd.UniformInt(size.M22), rnd.UniformInt(size.M23), 
                rnd.UniformInt(size.M30), rnd.UniformInt(size.M31), rnd.UniformInt(size.M32), rnd.UniformInt(size.M33));
        }

        #endregion
    }

    #endregion

    #region M44l

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M44l : IEquatable<M44l>, IValidity, IMatrix<double>
    {
        [DataMember]
        public long M00, M01, M02, M03;
        [DataMember]
        public long M10, M11, M12, M13;
        [DataMember]
        public long M20, M21, M22, M23;
        [DataMember]
        public long M30, M31, M32, M33;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(long value)
        {
            M00 = value; M01 = 0; M02 = 0; M03 = 0; 
            M10 = 0; M11 = value; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = value; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = value; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(
                long m00, long m01, long m02, long m03, 
                long m10, long m11, long m12, long m13, 
                long m20, long m21, long m22, long m23, 
                long m30, long m31, long m32, long m33)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
            M30 = m30; M31 = m31; M32 = m32; M33 = m33; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(long[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
            M30 = a[12];
            M31 = a[13];
            M32 = a[14];
            M33 = a[15];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(long[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
            M30 = a[start + 12];
            M31 = a[start + 13];
            M32 = a[start + 14];
            M33 = a[start + 15];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M22i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M23i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M33i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M34i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M44i m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
            M30 = (long)m.M30; M31 = (long)m.M31; M32 = (long)m.M32; M33 = (long)m.M33; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M22l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M23l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M33l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M34l m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M22f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M23f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M33f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M34f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M44f m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
            M30 = (long)m.M30; M31 = (long)m.M31; M32 = (long)m.M32; M33 = (long)m.M33; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M22d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = 0; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M23d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M33d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = 0; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = 0; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M34d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44l(M44d m)
        {
            M00 = (long)m.M00; M01 = (long)m.M01; M02 = (long)m.M02; M03 = (long)m.M03; 
            M10 = (long)m.M10; M11 = (long)m.M11; M12 = (long)m.M12; M13 = (long)m.M13; 
            M20 = (long)m.M20; M21 = (long)m.M21; M22 = (long)m.M22; M23 = (long)m.M23; 
            M30 = (long)m.M30; M31 = (long)m.M31; M32 = (long)m.M32; M33 = (long)m.M33; 
        }

        #endregion

        #region Conversions

        public static explicit operator M44l(M22i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M23i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M33i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M34i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M44i m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = (long)m.M30, M31 = (long)m.M31, M32 = (long)m.M32, M33 = (long)m.M33, 
            };
        }

        public static explicit operator M44l(M22l m)
        {
            return new M44l {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M23l m)
        {
            return new M44l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M33l m)
        {
            return new M44l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M34l m)
        {
            return new M44l {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M22f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M23f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M33f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M34f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M44f m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = (long)m.M30, M31 = (long)m.M31, M32 = (long)m.M32, M33 = (long)m.M33, 
            };
        }

        public static explicit operator M44l(M22d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = 0, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M23d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M33d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = 0, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = 0, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M34d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44l(M44d m)
        {
            return new M44l {
                M00 = (long)m.M00, M01 = (long)m.M01, M02 = (long)m.M02, M03 = (long)m.M03, 
                M10 = (long)m.M10, M11 = (long)m.M11, M12 = (long)m.M12, M13 = (long)m.M13, 
                M20 = (long)m.M20, M21 = (long)m.M21, M22 = (long)m.M22, M23 = (long)m.M23, 
                M30 = (long)m.M30, M31 = (long)m.M31, M32 = (long)m.M32, M33 = (long)m.M33, 
            };
        }

        public static explicit operator M44l(int[] a)
        {
            return new M44l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11], 
                (long)a[12], (long)a[13], (long)a[14], (long)a[15]);
        }

        public static explicit operator M44l(int[,] a)
        {
            return new M44l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3], 
                (long)a[3, 0], (long)a[3, 1], (long)a[3, 2], (long)a[3, 3]);
        }

        public static explicit operator int[](M44l m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23, 
                (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33
            };
        }

        public static explicit operator int[,](M44l m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }, 
                { (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
            array[index + 12] = (int)M30;
            array[index + 13] = (int)M31;
            array[index + 14] = (int)M32;
            array[index + 15] = (int)M33;
        }

        public static explicit operator M44l(long[] a)
        {
            return new M44l(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11], 
                a[12], a[13], a[14], a[15]);
        }

        public static explicit operator M44l(long[,] a)
        {
            return new M44l(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3], 
                a[3, 0], a[3, 1], a[3, 2], a[3, 3]);
        }

        public static explicit operator long[](M44l m)
        {
            return new long[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23, 
                m.M30, m.M31, m.M32, m.M33
            };
        }

        public static explicit operator long[,](M44l m)
        {
            return new long[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }, 
                { m.M30, m.M31, m.M32, m.M33 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
            array[index + 12] = M30;
            array[index + 13] = M31;
            array[index + 14] = M32;
            array[index + 15] = M33;
        }

        public static explicit operator M44l(float[] a)
        {
            return new M44l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11], 
                (long)a[12], (long)a[13], (long)a[14], (long)a[15]);
        }

        public static explicit operator M44l(float[,] a)
        {
            return new M44l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3], 
                (long)a[3, 0], (long)a[3, 1], (long)a[3, 2], (long)a[3, 3]);
        }

        public static explicit operator float[](M44l m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23, 
                (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33
            };
        }

        public static explicit operator float[,](M44l m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }, 
                { (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
            array[index + 12] = (float)M30;
            array[index + 13] = (float)M31;
            array[index + 14] = (float)M32;
            array[index + 15] = (float)M33;
        }

        public static explicit operator M44l(double[] a)
        {
            return new M44l(
                (long)a[0], (long)a[1], (long)a[2], (long)a[3], 
                (long)a[4], (long)a[5], (long)a[6], (long)a[7], 
                (long)a[8], (long)a[9], (long)a[10], (long)a[11], 
                (long)a[12], (long)a[13], (long)a[14], (long)a[15]);
        }

        public static explicit operator M44l(double[,] a)
        {
            return new M44l(
                (long)a[0, 0], (long)a[0, 1], (long)a[0, 2], (long)a[0, 3], 
                (long)a[1, 0], (long)a[1, 1], (long)a[1, 2], (long)a[1, 3], 
                (long)a[2, 0], (long)a[2, 1], (long)a[2, 2], (long)a[2, 3], 
                (long)a[3, 0], (long)a[3, 1], (long)a[3, 2], (long)a[3, 3]);
        }

        public static explicit operator double[](M44l m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23, 
                (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33
            };
        }

        public static explicit operator double[,](M44l m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }, 
                { (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
            array[index + 12] = (double)M30;
            array[index + 13] = (double)M31;
            array[index + 14] = (double)M32;
            array[index + 15] = (double)M33;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<long, int> element_fun)
        {
            return new M44i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<long, int, int, int> element_index0_index1_fun)
        {
            return new M44i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<long, long> element_fun)
        {
            return new M44l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<long, int, int, long> element_index0_index1_fun)
        {
            return new M44l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<long, float> element_fun)
        {
            return new M44f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<long, int, int, float> element_index0_index1_fun)
        {
            return new M44f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<long, double> element_fun)
        {
            return new M44d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<long, int, int, double> element_index0_index1_fun)
        {
            return new M44d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M33l UpperLeftM33()
        {
            return (M33l)this;
        }

        public long[] ToArray()
        {
            var array = new long[16];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            array[12] = M30;
            array[13] = M31;
            array[14] = M32;
            array[15] = M33;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l FromCols(V4l col0, V4l col1, V4l col2, V4l col3)
        {
            return new M44l(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z, 
                col0.W, col1.W, col2.W, col3.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l FromRows(V4l row0, V4l row1, V4l row2, V4l row3)
        {
            return new M44l(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W, 
                row3.X, row3.Y, row3.Z, row3.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l FromDiagonal(long value)
        {
            return new M44l(
                value, 0, 0, 0, 
                0, value, 0, 0, 
                0, 0, value, 0, 
                0, 0, 0, value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l FromDiagonal(long m00, long m11, long m22, long m33)
        {
            return new M44l(
                m00, 0, 0, 0, 
                0, m11, 0, 0, 
                0, 0, m22, 0, 
                0, 0, 0, m33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l FromDiagonal(V4l s)
        {
            return new M44l(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, s.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l FromAntiDiagonal(long value)
        {
            return new M44l(
                 0, 0, 0, value, 
                 0, 0, value, 0, 
                 0, value, 0, 0, 
                 value, 0, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l FromAntiDiagonal(long m03, long m12, long m21, long m30)
        {
            return new M44l(
                0, 0, 0, m03, 
                0, 0, m12, 0, 
                0, m21, 0, 0, 
                m30, 0, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l FromAntiDiagonal(V4l s)
        {
            return new M44l(
                0, 0, 0, s.X, 
                0, 0, s.Y, 0, 
                0, s.Z, 0, 0, 
                s.W, 0, 0, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M44l"/> using 4 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l Scale(long sX, long sY, long sZ, long sW)
            => FromDiagonal(sX, sY, sZ, sW);

        /// <summary>
        /// Creates a transformation <see cref="M44l"/> using a <see cref="V4l"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l Scale(V4l s)
            => FromDiagonal(s);

        /// <summary>
        /// Creates a homogenous transformation <see cref="M44l"/> using a uniform scale.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l Scale(long s)
        {
            return new M44l(
                s, 0, 0, 0, 
                0, s, 0, 0, 
                0, 0, s, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44l"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l Scale(long sX, long sY, long sZ)
        {
            return new M44l(
                sX, 0, 0, 0, 
                0, sY, 0, 0, 
                0, 0, sZ, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44l"/> using a <see cref="V3l"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l Scale(V3l s)
        {
            return new M44l(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, 1);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M44l"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l Translation(long tX, long tY, long tZ)
        {
            return new M44l(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44l"/> with the translational component given by a <see cref="V3l"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l Translation(V3l t)
        {
            return new M44l(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z, 
                0, 0, 0, 1);
        }

        #endregion

        #region Shearing

        /// <summary>
        /// Creates a shear transformation matrix along the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l ShearXY(long factorX, long factorY)
        {
            return new M44l(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l ShearXZ(long factorX, long factorZ)
        {
            return new M44l(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l ShearYZ(long factorY, long factorZ)
        {
            return new M44l(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0, 
                0, 0, 0, 1);
        }

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l DivideByInt(M44l m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<long> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
                yield return M30;
                yield return M31;
                yield return M32;
                yield return M33;
            }
        }

        public IEnumerable<V4l> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
                yield return R3;
            }
        }

        public IEnumerable<V4l> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        [XmlIgnore]
        public V4l R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4l( M00,  M01,  M02,  M03); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        [XmlIgnore]
        public V4l R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4l( M10,  M11,  M12,  M13); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        [XmlIgnore]
        public V4l R2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4l( M20,  M21,  M22,  M23); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        [XmlIgnore]
        public V4l R3
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4l( M30,  M31,  M32,  M33); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M30 = value.X;
                M31 = value.Y;
                M32 = value.Z;
                M33 = value.W;
            }
        }

        [XmlIgnore]
        public V4l C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4l( M00,  M10,  M20,  M30); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
                M30 = value.W;
            }
        }

        [XmlIgnore]
        public V4l C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4l( M01,  M11,  M21,  M31); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
                M31 = value.W;
            }
        }

        [XmlIgnore]
        public V4l C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4l( M02,  M12,  M22,  M32); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
                M32 = value.W;
            }
        }

        [XmlIgnore]
        public V4l C3
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4l( M03,  M13,  M23,  M33); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
                M33 = value.W;
            }
        }

        public V4l Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V4l(M00, M11, M22, M33);
        }

        public V4l AntiDiagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V4l(M03, M12, M21, M30);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public long MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23, M30, M31, M32, M33);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public long MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23, M30, M31, M32, M33);
        }

        public unsafe long this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (long* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (long* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe long this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (long* ptr = &M00) { return ptr[row * 4 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (long* ptr = &M00) { ptr[row * 4 + column] = value; }
            }
        }

        #endregion

        #region Constants

        public const int RowCount = 4;
        public const int ColumnCount = 4;
        public const int ElementCount = 4 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(4, 4);
        }

        public static M44l Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44l(0);
        }

        public static M44l Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44l(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public long Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23) + 
                    Fun.Abs(M30) + Fun.Abs(M31) + Fun.Abs(M32) + Fun.Abs(M33);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23 + 
                    M30 * M30 + M31 * M31 + M32 * M32 + M33 * M33);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public long NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Max(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public long NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Min(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator -(M44l m)
        {
            return new M44l(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23, 
                -m.M30, -m.M31, -m.M32, -m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  + (M44l a, M44l b)
        {
            return new M44l(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  + (M44l m, long s)
        {
            return new M44l(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  + (long s, M44l m)
        {
            return new M44l(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  + (M44l a, M44f b)
        {
            return new M44f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  + (M44l m, float s)
        {
            return new M44f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  + (float s, M44l m)
        {
            return new M44f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  + (M44l a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  + (M44l m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  + (double s, M44l m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  - (M44l a, M44l b)
        {
            return new M44l(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  - (M44l m, long s)
        {
            return new M44l(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  - (long s, M44l m)
        {
            return new M44l(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  - (M44l a, M44f b)
        {
            return new M44f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  - (M44l m, float s)
        {
            return new M44f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  - (float s, M44l m)
        {
            return new M44f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  - (M44l a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  - (M44l m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  - (double s, M44l m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  % (M44l a, M44l b)
        {
            return new M44l(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  % (M44l m, long s)
        {
            return new M44l(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  % (long s, M44l m)
        {
            return new M44l(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  % (M44l a, M44f b)
        {
            return new M44f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  % (M44l m, float s)
        {
            return new M44f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  % (float s, M44l m)
        {
            return new M44f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  % (M44l a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  % (M44l m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  % (double s, M44l m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  / (M44l a, M44l b)
        {
            return new M44l(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  / (M44l m, long s)
        {
            return new M44l(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  / (long s, M44l m)
        {
            return new M44l(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  / (M44l a, M44f b)
        {
            return new M44f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  / (M44l m, float s)
        {
            return new M44f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  / (float s, M44l m)
        {
            return new M44f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  / (M44l a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  / (M44l m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  / (double s, M44l m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  * (M44l m, long s)
        {
            return new M44l(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator  * (long s, M44l m)
        {
            return new M44l(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  * (M44l m, float s)
        {
            return new M44f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  * (float s, M44l m)
        {
            return new M44f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  * (M44l m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  * (double s, M44l m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        #endregion

        #region Bitwise Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator ~(M44l m)
        {
            return new M44l(
                ~m.M00, ~m.M01, ~m.M02, ~m.M03, 
                ~m.M10, ~m.M11, ~m.M12, ~m.M13, 
                ~m.M20, ~m.M21, ~m.M22, ~m.M23, 
                ~m.M30, ~m.M31, ~m.M32, ~m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator <<(M44l a, int s)
        {
            return new M44l(
                a.M00 << s, a.M01 << s, a.M02 << s, a.M03 << s, 
                a.M10 << s, a.M11 << s, a.M12 << s, a.M13 << s, 
                a.M20 << s, a.M21 << s, a.M22 << s, a.M23 << s, 
                a.M30 << s, a.M31 << s, a.M32 << s, a.M33 << s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator >>(M44l a, int s)
        {
            return new M44l(
                a.M00 >> s, a.M01 >> s, a.M02 >> s, a.M03 >> s, 
                a.M10 >> s, a.M11 >> s, a.M12 >> s, a.M13 >> s, 
                a.M20 >> s, a.M21 >> s, a.M22 >> s, a.M23 >> s, 
                a.M30 >> s, a.M31 >> s, a.M32 >> s, a.M33 >> s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator &(M44l a, M44l b)
        {
            return new M44l(
                a.M00 & b.M00, a.M01 & b.M01, a.M02 & b.M02, a.M03 & b.M03, 
                a.M10 & b.M10, a.M11 & b.M11, a.M12 & b.M12, a.M13 & b.M13, 
                a.M20 & b.M20, a.M21 & b.M21, a.M22 & b.M22, a.M23 & b.M23, 
                a.M30 & b.M30, a.M31 & b.M31, a.M32 & b.M32, a.M33 & b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator &(M44l a, long s)
        {
            return new M44l(
                a.M00 & s, a.M01 & s, a.M02 & s, a.M03 & s, 
                a.M10 & s, a.M11 & s, a.M12 & s, a.M13 & s, 
                a.M20 & s, a.M21 & s, a.M22 & s, a.M23 & s, 
                a.M30 & s, a.M31 & s, a.M32 & s, a.M33 & s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator &(long s, M44l a)
        {
            return new M44l(
                s & a.M00, s & a.M01, s & a.M02, s & a.M03, 
                s & a.M10, s & a.M11, s & a.M12, s & a.M13, 
                s & a.M20, s & a.M21, s & a.M22, s & a.M23, 
                s & a.M30, s & a.M31, s & a.M32, s & a.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator |(M44l a, M44l b)
        {
            return new M44l(
                a.M00 | b.M00, a.M01 | b.M01, a.M02 | b.M02, a.M03 | b.M03, 
                a.M10 | b.M10, a.M11 | b.M11, a.M12 | b.M12, a.M13 | b.M13, 
                a.M20 | b.M20, a.M21 | b.M21, a.M22 | b.M22, a.M23 | b.M23, 
                a.M30 | b.M30, a.M31 | b.M31, a.M32 | b.M32, a.M33 | b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator |(M44l a, long s)
        {
            return new M44l(
                a.M00 | s, a.M01 | s, a.M02 | s, a.M03 | s, 
                a.M10 | s, a.M11 | s, a.M12 | s, a.M13 | s, 
                a.M20 | s, a.M21 | s, a.M22 | s, a.M23 | s, 
                a.M30 | s, a.M31 | s, a.M32 | s, a.M33 | s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator |(long s, M44l a)
        {
            return new M44l(
                s | a.M00, s | a.M01, s | a.M02, s | a.M03, 
                s | a.M10, s | a.M11, s | a.M12, s | a.M13, 
                s | a.M20, s | a.M21, s | a.M22, s | a.M23, 
                s | a.M30, s | a.M31, s | a.M32, s | a.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator ^(M44l a, M44l b)
        {
            return new M44l(
                a.M00 ^ b.M00, a.M01 ^ b.M01, a.M02 ^ b.M02, a.M03 ^ b.M03, 
                a.M10 ^ b.M10, a.M11 ^ b.M11, a.M12 ^ b.M12, a.M13 ^ b.M13, 
                a.M20 ^ b.M20, a.M21 ^ b.M21, a.M22 ^ b.M22, a.M23 ^ b.M23, 
                a.M30 ^ b.M30, a.M31 ^ b.M31, a.M32 ^ b.M32, a.M33 ^ b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator ^(M44l a, long s)
        {
            return new M44l(
                a.M00 ^ s, a.M01 ^ s, a.M02 ^ s, a.M03 ^ s, 
                a.M10 ^ s, a.M11 ^ s, a.M12 ^ s, a.M13 ^ s, 
                a.M20 ^ s, a.M21 ^ s, a.M22 ^ s, a.M23 ^ s, 
                a.M30 ^ s, a.M31 ^ s, a.M32 ^ s, a.M33 ^ s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l operator ^(long s, M44l a)
        {
            return new M44l(
                s ^ a.M00, s ^ a.M01, s ^ a.M02, s ^ a.M03, 
                s ^ a.M10, s ^ a.M11, s ^ a.M12, s ^ a.M13, 
                s ^ a.M20, s ^ a.M21, s ^ a.M22, s ^ a.M23, 
                s ^ a.M30, s ^ a.M31, s ^ a.M32, s ^ a.M33);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M44l matrix with a V4l column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l operator *(M44l m, V4l v)
        {
            return new V4l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        /// <summary>
        /// Multiplies a V4l row vector with a M44l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l operator *(V4l v, M44l m)
        {
            return new V4l(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20 + v.W * m.M30, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21 + v.W * m.M31, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22 + v.W * m.M32, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23 + v.W * m.M33);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M44l a, M44l b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23 && 
                a.M30 < b.M30 && 
                a.M31 < b.M31 && 
                a.M32 < b.M32 && 
                a.M33 < b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M44l a, long s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s && 
                a.M30 < s && 
                a.M31 < s && 
                a.M32 < s && 
                a.M33 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(long s, M44l a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23  && 
                s < a.M30  && 
                s < a.M31  && 
                s < a.M32  && 
                s < a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M44l a, M44l b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23 && 
                a.M30 > b.M30 && 
                a.M31 > b.M31 && 
                a.M32 > b.M32 && 
                a.M33 > b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M44l a, long s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s && 
                a.M30 > s && 
                a.M31 > s && 
                a.M32 > s && 
                a.M33 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(long s, M44l a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23  && 
                s > a.M30  && 
                s > a.M31  && 
                s > a.M32  && 
                s > a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M44l a, M44l b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23 && 
                a.M30 == b.M30 && 
                a.M31 == b.M31 && 
                a.M32 == b.M32 && 
                a.M33 == b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M44l a, long s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s && 
                a.M30 == s && 
                a.M31 == s && 
                a.M32 == s && 
                a.M33 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(long s, M44l a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23  && 
                s == a.M30  && 
                s == a.M31  && 
                s == a.M32  && 
                s == a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M44l a, M44l b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23 && 
                a.M30 <= b.M30 && 
                a.M31 <= b.M31 && 
                a.M32 <= b.M32 && 
                a.M33 <= b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M44l a, long s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s && 
                a.M30 <= s && 
                a.M31 <= s && 
                a.M32 <= s && 
                a.M33 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(long s, M44l a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23  && 
                s <= a.M30  && 
                s <= a.M31  && 
                s <= a.M32  && 
                s <= a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M44l a, M44l b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23 && 
                a.M30 >= b.M30 && 
                a.M31 >= b.M31 && 
                a.M32 >= b.M32 && 
                a.M33 >= b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M44l a, long s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s && 
                a.M30 >= s && 
                a.M31 >= s && 
                a.M32 >= s && 
                a.M33 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(long s, M44l a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23  && 
                s >= a.M30  && 
                s >= a.M31  && 
                s >= a.M32  && 
                s >= a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M44l a, M44l b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M44l m, long s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(long s, M44l m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02, M03),
                        HashCode.GetCombined(M10, M11, M12, M13),
                        HashCode.GetCombined(M20, M21, M22, M23),
                        HashCode.GetCombined(M30, M31, M32, M33));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M44l other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && M03.Equals(other.M03) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12) && M13.Equals(other.M13) && 
                M20.Equals(other.M20) && M21.Equals(other.M21) && M22.Equals(other.M22) && M23.Equals(other.M23) && 
                M30.Equals(other.M30) && M31.Equals(other.M31) && M32.Equals(other.M32) && M33.Equals(other.M33);
        }

        public override bool Equals(object other)
            => (other is M44l o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R3.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M44l Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M44l.FromRows(
                V4l.Parse(x[0]), 
                V4l.Parse(x[1]), 
                V4l.Parse(x[2]), 
                V4l.Parse(x[3])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M44l Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M44l result = new M44l();
                for (int row = 0; row < 4; row++)
                {
                    for (int col = 0; col < 4; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public long Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 + M33 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public long Determinant
        {
            get
            {
                // using bottom row because elements M30, M31, and M32
                // are zero most of the time.
                long d = 0;
                if (M30 != 0.0f) d -= M30 * (
                M01 * M12 * M23 + M02 * M13 * M21 + M03 * M11 * M22
                - M21 * M12 * M03 - M22 * M13 * M01 - M23 * M11 * M02
                );
                if (M31 != 0.0f) d += M31 * (
                M00 * M12 * M23 + M02 * M13 * M20 + M03 * M10 * M22
                - M20 * M12 * M03 - M22 * M13 * M00 - M23 * M10 * M02
                );
                if (M32 != 0.0f) d -= M32 * (
                M00 * M11 * M23 + M01 * M13 * M20 + M03 * M10 * M21
                - M20 * M11 * M03 - M21 * M13 * M00 - M23 * M10 * M01
                );
                if (M33 != 0.0f) d += M33 * (
                M00 * M11 * M22 + M01 * M12 * M20 + M02 * M10 * M21
                - M20 * M11 * M02 - M21 * M12 * M00 - M22 * M10 * M01
                );
                return d;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M44l Transposed
        {
            get
            {
                return new M44l {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    M03 = M30, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    M13 = M31, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22, 
                    M23 = M32, 
                    
                    M30 = M03, 
                    M31 = M13, 
                    M32 = M23, 
                    M33 = M33
                };
            }
        }

        #endregion

        #region Matrix Multiplication

        public static M44l operator *(M44l a, M44l b)
        {
            return new M44l(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (long)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (long)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (long)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (long)value;
        }

        #endregion
    }

    public class M44lEqualityComparer : IEqualityComparer<M44l>
    {
        public static readonly M44lEqualityComparer Default
            = new M44lEqualityComparer();

        #region IEqualityComparer<M44l> Members

        public bool Equals(M44l v0, M44l v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M44l v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M44l m)
            => (m.C0.Length + m.C1.Length + m.C2.Length + m.C3.Length) / 4;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d GetScaleVector(this M44l m)
            => new V4d(m.C0.Length, m.C1.Length, m.C2.Length, m.C3.Length);

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of 3D basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale3(this M44l m)
            => (m.C0.XYZ.Length + m.C1.XYZ.Length + m.C2.XYZ.Length) / 3;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the 3D basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetScaleVector3(this M44l m)
            => new V3d(m.C0.XYZ.Length, m.C1.XYZ.Length, m.C2.XYZ.Length);

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Norm1(M44l m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M44l m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMax(M44l m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long NormMin(M44l m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M44l m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p) + 
                Fun.Abs(m.M30).Pow(p) + 
                Fun.Abs(m.M31).Pow(p) + 
                Fun.Abs(m.M32).Pow(p) + 
                Fun.Abs(m.M33).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static long Distance1(this M44l a, M44l b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23) + 
                Fun.Abs(b.M30 - a.M30) + 
                Fun.Abs(b.M31 - a.M31) + 
                Fun.Abs(b.M32 - a.M32) + 
                Fun.Abs(b.M33 - a.M33);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M44l a, M44l b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23) + 
                        Fun.Square(b.M30 - a.M30) + 
                        Fun.Square(b.M31 - a.M31) + 
                        Fun.Square(b.M32 - a.M32) + 
                        Fun.Square(b.M33 - a.M33));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M44l a, M44l b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p) + 
                Fun.Abs(b.M30 - a.M30).Pow(p) + 
                Fun.Abs(b.M31 - a.M31).Pow(p) + 
                Fun.Abs(b.M32 - a.M32).Pow(p) + 
                Fun.Abs(b.M33 - a.M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMax(this M44l a, M44l b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Max(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static long DistanceMin(this M44l a, M44l b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Min(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l Transform(this M44l m, V4l v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4l TransposedTransform(this M44l m, V4l v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3l TransformDir(this M44l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3l TransformPos(this M44l m, V3l p)
        {
            return new V3l(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3l TransformPosProj(this M44l m, V3l p)
        {
            long s = m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V4l TransformPosProjFull(this M44l m, V3l p)
        {
            return new V4l(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23, 
                m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V3l TransposedTransformDir(this M44l m, V3l v)
        {
            return new V3l(
                m.M00 * v.X + m.M10 * v.Y + m.M20 * v.Z, 
                m.M01 * v.X + m.M11 * v.Y + m.M21 * v.Z, 
                m.M02 * v.X + m.M12 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3l TransposedTransformPos(this M44l m, V3l p)
        {
            return new V3l(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3l TransposedTransformProj(this M44l m, V3l p)
        {
            var s = m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V4l TransposedTransformProjFull(this M44l m, V3l p)
        {
            return new V4l(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32, 
                m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M44l"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M33l Minor(this M44l m, int row, int column)
        {
            M33l rs = new M33l();

            for (int k = 0; k < 9; k++)
            {
                var i = k / 3;
                var j = k % 3;
                var ii = (i < row) ? i : i + 1;
                var jj = (j < column) ? j : j + 1;

                rs[k] = m[ii * 4 + jj];
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V4l Row(this M44l m, int index)
        {
            long* ptr = &m.M00;
            return new V4l(ptr[index * 4], ptr[index * 4 + 1], ptr[index * 4 + 2], ptr[index * 4 + 3]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V4l Column(this M44l m, int index)
        {
            long* ptr = &m.M00;
            return new V4l(ptr[index], ptr[index + 4], ptr[index + 8], ptr[index + 12]);
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long Determinant(M44l m)
            => m.Determinant;

        /// <summary>
        /// Returns the transpose of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l Transposed(M44l m)
            => m.Transposed;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Transpose(this ref M44l m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
            Fun.Swap(ref m.M30, ref m.M03);
            Fun.Swap(ref m.M31, ref m.M13);
            Fun.Swap(ref m.M32, ref m.M23);
        }

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M44l"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long MinElement(M44l m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M44l"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static long MaxElement(M44l m)
            => m.MaxElement;

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M44l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M44l m, long epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M03.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon) || m.M13.IsTiny(epsilon) || m.M20.IsTiny(epsilon) || m.M21.IsTiny(epsilon) || m.M22.IsTiny(epsilon) || m.M23.IsTiny(epsilon) || m.M30.IsTiny(epsilon) || m.M31.IsTiny(epsilon) || m.M32.IsTiny(epsilon) || m.M33.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M44l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M44l m, long epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M03.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon) && m.M13.IsTiny(epsilon) && m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon) && m.M22.IsTiny(epsilon) && m.M23.IsTiny(epsilon) && m.M30.IsTiny(epsilon) && m.M31.IsTiny(epsilon) && m.M32.IsTiny(epsilon) && m.M33.IsTiny(epsilon);

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M44l a, M44l b, long epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M44l"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M44l m, long epsilon)
            => Mat.AllTiny(m, epsilon);

        #endregion
    }

    public static class IRandomUniformM44lExtensions
    {
        #region IRandomUniform extensions for M44l

        /// <summary>
        /// Uses UniformLong() to generate the elements of an M44l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l UniformM44l(this IRandomUniform rnd)
        {
            return new M44l(
                rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), 
                rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), 
                rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), 
                rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong(), rnd.UniformLong());
        }

        /// <summary>
        /// Uses UniformLongNonZero() to generate the elements of an M44l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l UniformM44lNonZero(this IRandomUniform rnd)
        {
            return new M44l(
                rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), 
                rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), 
                rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), 
                rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero(), rnd.UniformLongNonZero());
        }

        /// <summary>
        /// Uses UniformLong(long) to generate the elements of an M44l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l UniformM44l(this IRandomUniform rnd, long size)
        {
            return new M44l(
                rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), 
                rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), 
                rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), 
                rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size), rnd.UniformLong(size));
        }

        /// <summary>
        /// Uses UniformLong(long) to generate the elements of an M44l matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44l UniformM44l(this IRandomUniform rnd, M44l size)
        {
            return new M44l(
                rnd.UniformLong(size.M00), rnd.UniformLong(size.M01), rnd.UniformLong(size.M02), rnd.UniformLong(size.M03), 
                rnd.UniformLong(size.M10), rnd.UniformLong(size.M11), rnd.UniformLong(size.M12), rnd.UniformLong(size.M13), 
                rnd.UniformLong(size.M20), rnd.UniformLong(size.M21), rnd.UniformLong(size.M22), rnd.UniformLong(size.M23), 
                rnd.UniformLong(size.M30), rnd.UniformLong(size.M31), rnd.UniformLong(size.M32), rnd.UniformLong(size.M33));
        }

        #endregion
    }

    #endregion

    #region M44f

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M44f : IEquatable<M44f>, IValidity, IMatrix<double>
    {
        [DataMember]
        public float M00, M01, M02, M03;
        [DataMember]
        public float M10, M11, M12, M13;
        [DataMember]
        public float M20, M21, M22, M23;
        [DataMember]
        public float M30, M31, M32, M33;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(float value)
        {
            M00 = value; M01 = 0; M02 = 0; M03 = 0; 
            M10 = 0; M11 = value; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = value; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = value; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(
                float m00, float m01, float m02, float m03, 
                float m10, float m11, float m12, float m13, 
                float m20, float m21, float m22, float m23, 
                float m30, float m31, float m32, float m33)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
            M30 = m30; M31 = m31; M32 = m32; M33 = m33; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(float[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
            M30 = a[12];
            M31 = a[13];
            M32 = a[14];
            M33 = a[15];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(float[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
            M30 = a[start + 12];
            M31 = a[start + 13];
            M32 = a[start + 14];
            M33 = a[start + 15];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M22i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M23i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M33i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M34i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M44i m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
            M30 = (float)m.M30; M31 = (float)m.M31; M32 = (float)m.M32; M33 = (float)m.M33; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M22l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M23l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M33l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M34l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M44l m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
            M30 = (float)m.M30; M31 = (float)m.M31; M32 = (float)m.M32; M33 = (float)m.M33; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M22f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M23f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M33f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M34f m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M22d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = 0; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M23d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M33d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = 0; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = 0; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M34d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44f(M44d m)
        {
            M00 = (float)m.M00; M01 = (float)m.M01; M02 = (float)m.M02; M03 = (float)m.M03; 
            M10 = (float)m.M10; M11 = (float)m.M11; M12 = (float)m.M12; M13 = (float)m.M13; 
            M20 = (float)m.M20; M21 = (float)m.M21; M22 = (float)m.M22; M23 = (float)m.M23; 
            M30 = (float)m.M30; M31 = (float)m.M31; M32 = (float)m.M32; M33 = (float)m.M33; 
        }

        #endregion

        #region Conversions

        public static explicit operator M44f(M22i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M23i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M33i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M34i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M44i m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = (float)m.M30, M31 = (float)m.M31, M32 = (float)m.M32, M33 = (float)m.M33, 
            };
        }

        public static explicit operator M44f(M22l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M23l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M33l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M34l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M44l m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = (float)m.M30, M31 = (float)m.M31, M32 = (float)m.M32, M33 = (float)m.M33, 
            };
        }

        public static explicit operator M44f(M22f m)
        {
            return new M44f {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M23f m)
        {
            return new M44f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M33f m)
        {
            return new M44f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M34f m)
        {
            return new M44f {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M22d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = 0, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M23d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M33d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = 0, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = 0, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M34d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44f(M44d m)
        {
            return new M44f {
                M00 = (float)m.M00, M01 = (float)m.M01, M02 = (float)m.M02, M03 = (float)m.M03, 
                M10 = (float)m.M10, M11 = (float)m.M11, M12 = (float)m.M12, M13 = (float)m.M13, 
                M20 = (float)m.M20, M21 = (float)m.M21, M22 = (float)m.M22, M23 = (float)m.M23, 
                M30 = (float)m.M30, M31 = (float)m.M31, M32 = (float)m.M32, M33 = (float)m.M33, 
            };
        }

        public static explicit operator M44f(int[] a)
        {
            return new M44f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11], 
                (float)a[12], (float)a[13], (float)a[14], (float)a[15]);
        }

        public static explicit operator M44f(int[,] a)
        {
            return new M44f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3], 
                (float)a[3, 0], (float)a[3, 1], (float)a[3, 2], (float)a[3, 3]);
        }

        public static explicit operator int[](M44f m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23, 
                (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33
            };
        }

        public static explicit operator int[,](M44f m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }, 
                { (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
            array[index + 12] = (int)M30;
            array[index + 13] = (int)M31;
            array[index + 14] = (int)M32;
            array[index + 15] = (int)M33;
        }

        public static explicit operator M44f(long[] a)
        {
            return new M44f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11], 
                (float)a[12], (float)a[13], (float)a[14], (float)a[15]);
        }

        public static explicit operator M44f(long[,] a)
        {
            return new M44f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3], 
                (float)a[3, 0], (float)a[3, 1], (float)a[3, 2], (float)a[3, 3]);
        }

        public static explicit operator long[](M44f m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23, 
                (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33
            };
        }

        public static explicit operator long[,](M44f m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }, 
                { (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
            array[index + 12] = (long)M30;
            array[index + 13] = (long)M31;
            array[index + 14] = (long)M32;
            array[index + 15] = (long)M33;
        }

        public static explicit operator M44f(float[] a)
        {
            return new M44f(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11], 
                a[12], a[13], a[14], a[15]);
        }

        public static explicit operator M44f(float[,] a)
        {
            return new M44f(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3], 
                a[3, 0], a[3, 1], a[3, 2], a[3, 3]);
        }

        public static explicit operator float[](M44f m)
        {
            return new float[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23, 
                m.M30, m.M31, m.M32, m.M33
            };
        }

        public static explicit operator float[,](M44f m)
        {
            return new float[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }, 
                { m.M30, m.M31, m.M32, m.M33 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
            array[index + 12] = M30;
            array[index + 13] = M31;
            array[index + 14] = M32;
            array[index + 15] = M33;
        }

        public static explicit operator M44f(double[] a)
        {
            return new M44f(
                (float)a[0], (float)a[1], (float)a[2], (float)a[3], 
                (float)a[4], (float)a[5], (float)a[6], (float)a[7], 
                (float)a[8], (float)a[9], (float)a[10], (float)a[11], 
                (float)a[12], (float)a[13], (float)a[14], (float)a[15]);
        }

        public static explicit operator M44f(double[,] a)
        {
            return new M44f(
                (float)a[0, 0], (float)a[0, 1], (float)a[0, 2], (float)a[0, 3], 
                (float)a[1, 0], (float)a[1, 1], (float)a[1, 2], (float)a[1, 3], 
                (float)a[2, 0], (float)a[2, 1], (float)a[2, 2], (float)a[2, 3], 
                (float)a[3, 0], (float)a[3, 1], (float)a[3, 2], (float)a[3, 3]);
        }

        public static explicit operator double[](M44f m)
        {
            return new double[] {
                (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03, 
                (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13, 
                (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23, 
                (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33
            };
        }

        public static explicit operator double[,](M44f m)
        {
            return new double[,] {
                { (double)m.M00, (double)m.M01, (double)m.M02, (double)m.M03 }, 
                { (double)m.M10, (double)m.M11, (double)m.M12, (double)m.M13 }, 
                { (double)m.M20, (double)m.M21, (double)m.M22, (double)m.M23 }, 
                { (double)m.M30, (double)m.M31, (double)m.M32, (double)m.M33 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = (double)M00;
            array[index + 1] = (double)M01;
            array[index + 2] = (double)M02;
            array[index + 3] = (double)M03;
            array[index + 4] = (double)M10;
            array[index + 5] = (double)M11;
            array[index + 6] = (double)M12;
            array[index + 7] = (double)M13;
            array[index + 8] = (double)M20;
            array[index + 9] = (double)M21;
            array[index + 10] = (double)M22;
            array[index + 11] = (double)M23;
            array[index + 12] = (double)M30;
            array[index + 13] = (double)M31;
            array[index + 14] = (double)M32;
            array[index + 15] = (double)M33;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<float, int> element_fun)
        {
            return new M44i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<float, int, int, int> element_index0_index1_fun)
        {
            return new M44i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<float, long> element_fun)
        {
            return new M44l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<float, int, int, long> element_index0_index1_fun)
        {
            return new M44l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<float, float> element_fun)
        {
            return new M44f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<float, int, int, float> element_index0_index1_fun)
        {
            return new M44f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<float, double> element_fun)
        {
            return new M44d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<float, int, int, double> element_index0_index1_fun)
        {
            return new M44d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M33f UpperLeftM33()
        {
            return (M33f)this;
        }

        public float[] ToArray()
        {
            var array = new float[16];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            array[12] = M30;
            array[13] = M31;
            array[14] = M32;
            array[15] = M33;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f FromCols(V4f col0, V4f col1, V4f col2, V4f col3)
        {
            return new M44f(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z, 
                col0.W, col1.W, col2.W, col3.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f FromRows(V4f row0, V4f row1, V4f row2, V4f row3)
        {
            return new M44f(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W, 
                row3.X, row3.Y, row3.Z, row3.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f FromDiagonal(float value)
        {
            return new M44f(
                value, 0, 0, 0, 
                0, value, 0, 0, 
                0, 0, value, 0, 
                0, 0, 0, value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f FromDiagonal(float m00, float m11, float m22, float m33)
        {
            return new M44f(
                m00, 0, 0, 0, 
                0, m11, 0, 0, 
                0, 0, m22, 0, 
                0, 0, 0, m33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f FromDiagonal(V4f s)
        {
            return new M44f(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, s.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f FromAntiDiagonal(float value)
        {
            return new M44f(
                 0, 0, 0, value, 
                 0, 0, value, 0, 
                 0, value, 0, 0, 
                 value, 0, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f FromAntiDiagonal(float m03, float m12, float m21, float m30)
        {
            return new M44f(
                0, 0, 0, m03, 
                0, 0, m12, 0, 
                0, m21, 0, 0, 
                m30, 0, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f FromAntiDiagonal(V4f s)
        {
            return new M44f(
                0, 0, 0, s.X, 
                0, 0, s.Y, 0, 
                0, s.Z, 0, 0, 
                s.W, 0, 0, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M44f"/> using 4 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Scale(float sX, float sY, float sZ, float sW)
            => FromDiagonal(sX, sY, sZ, sW);

        /// <summary>
        /// Creates a transformation <see cref="M44f"/> using a <see cref="V4f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Scale(V4f s)
            => FromDiagonal(s);

        /// <summary>
        /// Creates a homogenous transformation <see cref="M44f"/> using a uniform scale.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Scale(float s)
        {
            return new M44f(
                s, 0, 0, 0, 
                0, s, 0, 0, 
                0, 0, s, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44f"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Scale(float sX, float sY, float sZ)
        {
            return new M44f(
                sX, 0, 0, 0, 
                0, sY, 0, 0, 
                0, 0, sZ, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44f"/> using a <see cref="V3f"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Scale(V3f s)
        {
            return new M44f(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a scaling transformation <see cref="M44f"/> from a <see cref="Scale3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Scale(Scale3f s)
        {
            return new M44f(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, 1);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M44f"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Translation(float tX, float tY, float tZ)
        {
            return new M44f(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44f"/> with the translational component given by a <see cref="V3f"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Translation(V3f t)
        {
            return new M44f(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44f"/> from a <see cref="Shift3f"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Translation(Shift3f s)
        {
            return new M44f(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, s.Z, 
                0, 0, 0, 1);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 3D rotation matrix from a <see cref="Rot3f"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Rotation(Rot3f r)
            => (M44f)r;

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in radians.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Rotation(V3f normalizedAxis, float angleInRadians)
        {
            Debug.Assert(normalizedAxis.LengthSquared.ApproximateEquals(1));
            return (M44f)(Rot3f.Rotation(normalizedAxis, angleInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in degrees.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f RotationInDegrees(V3f normalizedAxis, float angleInDegrees)
            => Rotation(normalizedAxis, angleInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) in radians. 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f RotationEuler(float rollInRadians, float pitchInRadians, float yawInRadians)
        {
            return (M44f)(Rot3f.RotationEuler(rollInRadians, pitchInRadians, yawInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) in degrees. 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f RotationEulerInDegrees(float rollInDegrees, float pitchInDegrees, float yawInDegrees)
            => RotationEuler(
                rollInDegrees.RadiansFromDegrees(),
                pitchInDegrees.RadiansFromDegrees(), 
                yawInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) vector in radians.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f RotationEuler(V3f rollPitchYawInRadians)
            => RotationEuler(
                rollPitchYawInRadians.X,
                rollPitchYawInRadians.Y,
                rollPitchYawInRadians.Z);

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) vector in degrees.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f RotationEulerInDegrees(V3f rollPitchYawInDegrees)
            => RotationEulerInDegrees(
                rollPitchYawInDegrees.X,
                rollPitchYawInDegrees.Y,
                rollPitchYawInDegrees.Z);

        /// <summary>
        /// Creates a 3D rotation matrix which rotates one vector into another.
        /// The input vectors have to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f RotateInto(V3f from, V3f into)
        {
            Debug.Assert(from.LengthSquared.ApproximateEquals(1));
            Debug.Assert(into.LengthSquared.ApproximateEquals(1));
            return (M44f)(Rot3f.RotateInto(from, into));
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f RotationX(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M44f(
                 1,  0,  0,  0, 
                 0,  a, -b,  0, 
                 0,  b,  a,  0, 
                 0,  0,  0,  1);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f RotationXInDegrees(float angleDegrees)
            => RotationX(angleDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f RotationY(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M44f(
                 a,  0,  b,  0, 
                 0,  1,  0,  0, 
                -b,  0,  a,  0, 
                 0,  0,  0,  1);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f RotationYInDegrees(float angleDegrees)
            => RotationY(angleDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f RotationZ(float angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M44f(
                 a, -b,  0,  0, 
                 b,  a,  0,  0, 
                 0,  0,  1,  0, 
                 0,  0,  0,  1);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f RotationZInDegrees(float angleDegrees)
            => RotationZ(angleDegrees.RadiansFromDegrees());

        #endregion

        #region Shearing

        /// <summary>
        /// Creates a shear transformation matrix along the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f ShearXY(float factorX, float factorY)
        {
            return new M44f(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f ShearXZ(float factorX, float factorZ)
        {
            return new M44f(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f ShearYZ(float factorY, float factorZ)
        {
            return new M44f(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0, 
                0, 0, 0, 1);
        }

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f DivideByInt(M44f m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<float> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
                yield return M30;
                yield return M31;
                yield return M32;
                yield return M33;
            }
        }

        public IEnumerable<V4f> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
                yield return R3;
            }
        }

        public IEnumerable<V4f> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        [XmlIgnore]
        public V4f R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4f( M00,  M01,  M02,  M03); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        [XmlIgnore]
        public V4f R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4f( M10,  M11,  M12,  M13); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        [XmlIgnore]
        public V4f R2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4f( M20,  M21,  M22,  M23); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        [XmlIgnore]
        public V4f R3
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4f( M30,  M31,  M32,  M33); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M30 = value.X;
                M31 = value.Y;
                M32 = value.Z;
                M33 = value.W;
            }
        }

        [XmlIgnore]
        public V4f C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4f( M00,  M10,  M20,  M30); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
                M30 = value.W;
            }
        }

        [XmlIgnore]
        public V4f C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4f( M01,  M11,  M21,  M31); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
                M31 = value.W;
            }
        }

        [XmlIgnore]
        public V4f C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4f( M02,  M12,  M22,  M32); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
                M32 = value.W;
            }
        }

        [XmlIgnore]
        public V4f C3
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4f( M03,  M13,  M23,  M33); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
                M33 = value.W;
            }
        }

        public V4f Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V4f(M00, M11, M22, M33);
        }

        public V4f AntiDiagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V4f(M03, M12, M21, M30);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public float MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23, M30, M31, M32, M33);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public float MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23, M30, M31, M32, M33);
        }

        public unsafe float this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (float* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (float* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe float this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (float* ptr = &M00) { return ptr[row * 4 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (float* ptr = &M00) { ptr[row * 4 + column] = value; }
            }
        }

        public bool AnyNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNaN(M00) || float.IsNaN(M01) || float.IsNaN(M02) || float.IsNaN(M03) || 
                    float.IsNaN(M10) || float.IsNaN(M11) || float.IsNaN(M12) || float.IsNaN(M13) || 
                    float.IsNaN(M20) || float.IsNaN(M21) || float.IsNaN(M22) || float.IsNaN(M23) || 
                    float.IsNaN(M30) || float.IsNaN(M31) || float.IsNaN(M32) || float.IsNaN(M33);
            }
        }

        public bool AllNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNaN(M00) && float.IsNaN(M01) && float.IsNaN(M02) && float.IsNaN(M03) && 
                    float.IsNaN(M10) && float.IsNaN(M11) && float.IsNaN(M12) && float.IsNaN(M13) && 
                    float.IsNaN(M20) && float.IsNaN(M21) && float.IsNaN(M22) && float.IsNaN(M23) && 
                    float.IsNaN(M30) && float.IsNaN(M31) && float.IsNaN(M32) && float.IsNaN(M33);
            }
        }

        public bool AnyInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsInfinity(M00) || float.IsInfinity(M01) || float.IsInfinity(M02) || float.IsInfinity(M03) || 
                    float.IsInfinity(M10) || float.IsInfinity(M11) || float.IsInfinity(M12) || float.IsInfinity(M13) || 
                    float.IsInfinity(M20) || float.IsInfinity(M21) || float.IsInfinity(M22) || float.IsInfinity(M23) || 
                    float.IsInfinity(M30) || float.IsInfinity(M31) || float.IsInfinity(M32) || float.IsInfinity(M33);
            }
        }

        public bool AllInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsInfinity(M00) && float.IsInfinity(M01) && float.IsInfinity(M02) && float.IsInfinity(M03) && 
                    float.IsInfinity(M10) && float.IsInfinity(M11) && float.IsInfinity(M12) && float.IsInfinity(M13) && 
                    float.IsInfinity(M20) && float.IsInfinity(M21) && float.IsInfinity(M22) && float.IsInfinity(M23) && 
                    float.IsInfinity(M30) && float.IsInfinity(M31) && float.IsInfinity(M32) && float.IsInfinity(M33);
            }
        }

        public bool AnyPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsPositiveInfinity(M00) || float.IsPositiveInfinity(M01) || float.IsPositiveInfinity(M02) || float.IsPositiveInfinity(M03) || 
                    float.IsPositiveInfinity(M10) || float.IsPositiveInfinity(M11) || float.IsPositiveInfinity(M12) || float.IsPositiveInfinity(M13) || 
                    float.IsPositiveInfinity(M20) || float.IsPositiveInfinity(M21) || float.IsPositiveInfinity(M22) || float.IsPositiveInfinity(M23) || 
                    float.IsPositiveInfinity(M30) || float.IsPositiveInfinity(M31) || float.IsPositiveInfinity(M32) || float.IsPositiveInfinity(M33);
            }
        }

        public bool AllPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsPositiveInfinity(M00) && float.IsPositiveInfinity(M01) && float.IsPositiveInfinity(M02) && float.IsPositiveInfinity(M03) && 
                    float.IsPositiveInfinity(M10) && float.IsPositiveInfinity(M11) && float.IsPositiveInfinity(M12) && float.IsPositiveInfinity(M13) && 
                    float.IsPositiveInfinity(M20) && float.IsPositiveInfinity(M21) && float.IsPositiveInfinity(M22) && float.IsPositiveInfinity(M23) && 
                    float.IsPositiveInfinity(M30) && float.IsPositiveInfinity(M31) && float.IsPositiveInfinity(M32) && float.IsPositiveInfinity(M33);
            }
        }

        public bool AnyNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNegativeInfinity(M00) || float.IsNegativeInfinity(M01) || float.IsNegativeInfinity(M02) || float.IsNegativeInfinity(M03) || 
                    float.IsNegativeInfinity(M10) || float.IsNegativeInfinity(M11) || float.IsNegativeInfinity(M12) || float.IsNegativeInfinity(M13) || 
                    float.IsNegativeInfinity(M20) || float.IsNegativeInfinity(M21) || float.IsNegativeInfinity(M22) || float.IsNegativeInfinity(M23) || 
                    float.IsNegativeInfinity(M30) || float.IsNegativeInfinity(M31) || float.IsNegativeInfinity(M32) || float.IsNegativeInfinity(M33);
            }
        }

        public bool AllNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    float.IsNegativeInfinity(M00) && float.IsNegativeInfinity(M01) && float.IsNegativeInfinity(M02) && float.IsNegativeInfinity(M03) && 
                    float.IsNegativeInfinity(M10) && float.IsNegativeInfinity(M11) && float.IsNegativeInfinity(M12) && float.IsNegativeInfinity(M13) && 
                    float.IsNegativeInfinity(M20) && float.IsNegativeInfinity(M21) && float.IsNegativeInfinity(M22) && float.IsNegativeInfinity(M23) && 
                    float.IsNegativeInfinity(M30) && float.IsNegativeInfinity(M31) && float.IsNegativeInfinity(M32) && float.IsNegativeInfinity(M33);
            }
        }

        public bool AnyTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) || Fun.IsTiny(M01) || Fun.IsTiny(M02) || Fun.IsTiny(M03) || 
                    Fun.IsTiny(M10) || Fun.IsTiny(M11) || Fun.IsTiny(M12) || Fun.IsTiny(M13) || 
                    Fun.IsTiny(M20) || Fun.IsTiny(M21) || Fun.IsTiny(M22) || Fun.IsTiny(M23) || 
                    Fun.IsTiny(M30) || Fun.IsTiny(M31) || Fun.IsTiny(M32) || Fun.IsTiny(M33);
            }
        }

        public bool AllTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) && Fun.IsTiny(M01) && Fun.IsTiny(M02) && Fun.IsTiny(M03) && 
                    Fun.IsTiny(M10) && Fun.IsTiny(M11) && Fun.IsTiny(M12) && Fun.IsTiny(M13) && 
                    Fun.IsTiny(M20) && Fun.IsTiny(M21) && Fun.IsTiny(M22) && Fun.IsTiny(M23) && 
                    Fun.IsTiny(M30) && Fun.IsTiny(M31) && Fun.IsTiny(M32) && Fun.IsTiny(M33);
            }
        }

        /// <summary>
        /// Returns true if the absolute value of each element of the matrix is smaller than Constant&lt;float&gt;.PositiveTinyValue, false otherwise.
        /// </summary>
        public bool IsTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AllTiny;
        }

        /// <summary>
        /// Returns true if any element of the matrix is NaN, false otherwise.
        /// </summary>
        public bool IsNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyNaN;
        }

        /// <summary>
        /// Returns true if any element of the matrix is infinite (positive or negative), false otherwise.
        /// </summary>
        public bool IsInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyInfinity;
        }

        /// <summary>
        /// Returns whether all elements of the matrix are finite (i.e. not NaN and not infinity).
        /// </summary>
        public bool IsFinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => !(IsInfinity || IsNaN);
        }

        #endregion

        #region Constants

        public const int RowCount = 4;
        public const int ColumnCount = 4;
        public const int ElementCount = 4 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(4, 4);
        }

        public static M44f Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44f(0);
        }

        public static M44f Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44f(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public float Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23) + 
                    Fun.Abs(M30) + Fun.Abs(M31) + Fun.Abs(M32) + Fun.Abs(M33);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public float Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23 + 
                    M30 * M30 + M31 * M31 + M32 * M32 + M33 * M33);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public float NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Max(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public float NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Min(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator -(M44f m)
        {
            return new M44f(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23, 
                -m.M30, -m.M31, -m.M32, -m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  + (M44f a, M44f b)
        {
            return new M44f(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  + (M44f m, float s)
        {
            return new M44f(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  + (float s, M44f m)
        {
            return new M44f(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  + (M44f a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  + (M44f m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  + (double s, M44f m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  - (M44f a, M44f b)
        {
            return new M44f(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  - (M44f m, float s)
        {
            return new M44f(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  - (float s, M44f m)
        {
            return new M44f(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  - (M44f a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  - (M44f m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  - (double s, M44f m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  % (M44f a, M44f b)
        {
            return new M44f(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  % (M44f m, float s)
        {
            return new M44f(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  % (float s, M44f m)
        {
            return new M44f(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  % (M44f a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  % (M44f m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  % (double s, M44f m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  / (M44f a, M44f b)
        {
            return new M44f(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  / (M44f m, float s)
        {
            return new M44f(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  / (float s, M44f m)
        {
            return new M44f(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  / (M44f a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  / (M44f m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  / (double s, M44f m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  * (M44f m, float s)
        {
            return new M44f(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f operator  * (float s, M44f m)
        {
            return new M44f(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  * (M44f m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  * (double s, M44f m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M44f matrix with a V4f column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f operator *(M44f m, V4f v)
        {
            return new V4f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        /// <summary>
        /// Multiplies a V4f row vector with a M44f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f operator *(V4f v, M44f m)
        {
            return new V4f(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20 + v.W * m.M30, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21 + v.W * m.M31, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22 + v.W * m.M32, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23 + v.W * m.M33);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M44f a, M44f b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23 && 
                a.M30 < b.M30 && 
                a.M31 < b.M31 && 
                a.M32 < b.M32 && 
                a.M33 < b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M44f a, float s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s && 
                a.M30 < s && 
                a.M31 < s && 
                a.M32 < s && 
                a.M33 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(float s, M44f a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23  && 
                s < a.M30  && 
                s < a.M31  && 
                s < a.M32  && 
                s < a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M44f a, M44f b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23 && 
                a.M30 > b.M30 && 
                a.M31 > b.M31 && 
                a.M32 > b.M32 && 
                a.M33 > b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M44f a, float s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s && 
                a.M30 > s && 
                a.M31 > s && 
                a.M32 > s && 
                a.M33 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(float s, M44f a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23  && 
                s > a.M30  && 
                s > a.M31  && 
                s > a.M32  && 
                s > a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M44f a, M44f b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23 && 
                a.M30 == b.M30 && 
                a.M31 == b.M31 && 
                a.M32 == b.M32 && 
                a.M33 == b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M44f a, float s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s && 
                a.M30 == s && 
                a.M31 == s && 
                a.M32 == s && 
                a.M33 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(float s, M44f a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23  && 
                s == a.M30  && 
                s == a.M31  && 
                s == a.M32  && 
                s == a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M44f a, M44f b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23 && 
                a.M30 <= b.M30 && 
                a.M31 <= b.M31 && 
                a.M32 <= b.M32 && 
                a.M33 <= b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M44f a, float s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s && 
                a.M30 <= s && 
                a.M31 <= s && 
                a.M32 <= s && 
                a.M33 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(float s, M44f a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23  && 
                s <= a.M30  && 
                s <= a.M31  && 
                s <= a.M32  && 
                s <= a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M44f a, M44f b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23 && 
                a.M30 >= b.M30 && 
                a.M31 >= b.M31 && 
                a.M32 >= b.M32 && 
                a.M33 >= b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M44f a, float s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s && 
                a.M30 >= s && 
                a.M31 >= s && 
                a.M32 >= s && 
                a.M33 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(float s, M44f a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23  && 
                s >= a.M30  && 
                s >= a.M31  && 
                s >= a.M32  && 
                s >= a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M44f a, M44f b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M44f m, float s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(float s, M44f m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02, M03),
                        HashCode.GetCombined(M10, M11, M12, M13),
                        HashCode.GetCombined(M20, M21, M22, M23),
                        HashCode.GetCombined(M30, M31, M32, M33));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M44f other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && M03.Equals(other.M03) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12) && M13.Equals(other.M13) && 
                M20.Equals(other.M20) && M21.Equals(other.M21) && M22.Equals(other.M22) && M23.Equals(other.M23) && 
                M30.Equals(other.M30) && M31.Equals(other.M31) && M32.Equals(other.M32) && M33.Equals(other.M33);
        }

        public override bool Equals(object other)
            => (other is M44f o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R3.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M44f Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M44f.FromRows(
                V4f.Parse(x[0]), 
                V4f.Parse(x[1]), 
                V4f.Parse(x[2]), 
                V4f.Parse(x[3])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M44f Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M44f result = new M44f();
                for (int row = 0; row < 4; row++)
                {
                    for (int col = 0; col < 4; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public float Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 + M33 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public float Determinant
        {
            get
            {
                // using bottom row because elements M30, M31, and M32
                // are zero most of the time.
                float d = 0;
                if (M30 != 0.0f) d -= M30 * (
                M01 * M12 * M23 + M02 * M13 * M21 + M03 * M11 * M22
                - M21 * M12 * M03 - M22 * M13 * M01 - M23 * M11 * M02
                );
                if (M31 != 0.0f) d += M31 * (
                M00 * M12 * M23 + M02 * M13 * M20 + M03 * M10 * M22
                - M20 * M12 * M03 - M22 * M13 * M00 - M23 * M10 * M02
                );
                if (M32 != 0.0f) d -= M32 * (
                M00 * M11 * M23 + M01 * M13 * M20 + M03 * M10 * M21
                - M20 * M11 * M03 - M21 * M13 * M00 - M23 * M10 * M01
                );
                if (M33 != 0.0f) d += M33 * (
                M00 * M11 * M22 + M01 * M12 * M20 + M02 * M10 * M21
                - M20 * M11 * M02 - M21 * M12 * M00 - M22 * M10 * M01
                );
                return d;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M44f Transposed
        {
            get
            {
                return new M44f {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    M03 = M30, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    M13 = M31, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22, 
                    M23 = M32, 
                    
                    M30 = M03, 
                    M31 = M13, 
                    M32 = M23, 
                    M33 = M33
                };
            }
        }

        private static V2l s_luSize = new V2l(4, 4);
        private static V2l s_luDelta = new V2l(1, 4);

        /// <summary>
        /// Inverts the given matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public bool LuInvert()
        {
            M44d dbl = (M44d)this;
            if(dbl.LuInvert()) 
            { 
                this = (M44f)dbl;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M44f.Zero is returned.
        /// </summary>
        public M44f LuInverse()
        {
            return (M44f)((M44d)this).LuInverse();
        }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M44f.Zero is returned.
        /// </summary>
        public M44f Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => LuInverse();
        }

        #endregion

        #region Matrix Multiplication

        public static M44f operator *(M44f a, M44f b)
        {
            return new M44f(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return (double)this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = (float)value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return (double)this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = (float)value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (float)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (float)value;
        }

        #endregion
    }

    public class M44fEqualityComparer : IEqualityComparer<M44f>
    {
        public static readonly M44fEqualityComparer Default
            = new M44fEqualityComparer();

        #region IEqualityComparer<M44f> Members

        public bool Equals(M44f v0, M44f v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M44f v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float GetScale(this M44f m)
            => (m.C0.Length + m.C1.Length + m.C2.Length + m.C3.Length) / 4;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f GetScaleVector(this M44f m)
            => new V4f(m.C0.Length, m.C1.Length, m.C2.Length, m.C3.Length);

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of 3D basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float GetScale3(this M44f m)
            => (m.C0.XYZ.Length + m.C1.XYZ.Length + m.C2.XYZ.Length) / 3;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the 3D basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f GetScaleVector3(this M44f m)
            => new V3f(m.C0.XYZ.Length, m.C1.XYZ.Length, m.C2.XYZ.Length);

        /// <summary>
        /// Extracts the forward vector from the given view transformation matrix.
        /// NOTE: A left-handed coordinates system transformation is expected, 
        /// where the view-space z-axis points in forward direction.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f GetViewDirectionLH(this M44f m)
            => m.R2.XYZ.Normalized;

        /// <summary>
        /// Extracts the forward vector from the given view transformation matrix.
        /// NOTE: A right-handed coordinates system transformation is expected, where 
        /// the view-space z-axis points opposit the forward vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f GetViewDirectionRH(this M44f m)
            => -m.R2.XYZ.Normalized;

        /// <summary>
        /// Extracts the translation component of the given transformation matrix, which when given 
        /// a model transformation represents the model origin in world position.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3f GetModelOrigin(this M44f m)
            => m.C3.XYZ;

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm1(M44f m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm2(M44f m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMax(M44f m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float NormMin(M44f m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Norm(this M44f m, float p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p) + 
                Fun.Abs(m.M30).Pow(p) + 
                Fun.Abs(m.M31).Pow(p) + 
                Fun.Abs(m.M32).Pow(p) + 
                Fun.Abs(m.M33).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static float Distance1(this M44f a, M44f b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23) + 
                Fun.Abs(b.M30 - a.M30) + 
                Fun.Abs(b.M31 - a.M31) + 
                Fun.Abs(b.M32 - a.M32) + 
                Fun.Abs(b.M33 - a.M33);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static float Distance2(this M44f a, M44f b)
        {
            return (float)Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23) + 
                        Fun.Square(b.M30 - a.M30) + 
                        Fun.Square(b.M31 - a.M31) + 
                        Fun.Square(b.M32 - a.M32) + 
                        Fun.Square(b.M33 - a.M33));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static float Distance(this M44f a, M44f b, float p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p) + 
                Fun.Abs(b.M30 - a.M30).Pow(p) + 
                Fun.Abs(b.M31 - a.M31).Pow(p) + 
                Fun.Abs(b.M32 - a.M32).Pow(p) + 
                Fun.Abs(b.M33 - a.M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMax(this M44f a, M44f b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Max(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static float DistanceMin(this M44f a, M44f b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Min(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f Transform(this M44f m, V4f v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4f TransposedTransform(this M44f m, V4f v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3f TransformDir(this M44f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3f TransformPos(this M44f m, V3f p)
        {
            return new V3f(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3f TransformPosProj(this M44f m, V3f p)
        {
            float s = m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V4f TransformPosProjFull(this M44f m, V3f p)
        {
            return new V4f(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23, 
                m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V3f TransposedTransformDir(this M44f m, V3f v)
        {
            return new V3f(
                m.M00 * v.X + m.M10 * v.Y + m.M20 * v.Z, 
                m.M01 * v.X + m.M11 * v.Y + m.M21 * v.Z, 
                m.M02 * v.X + m.M12 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3f TransposedTransformPos(this M44f m, V3f p)
        {
            return new V3f(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3f TransposedTransformProj(this M44f m, V3f p)
        {
            var s = m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V4f TransposedTransformProjFull(this M44f m, V3f p)
        {
            return new V4f(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32, 
                m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M44f"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M33f Minor(this M44f m, int row, int column)
        {
            M33f rs = new M33f();

            for (int k = 0; k < 9; k++)
            {
                var i = k / 3;
                var j = k % 3;
                var ii = (i < row) ? i : i + 1;
                var jj = (j < column) ? j : j + 1;

                rs[k] = m[ii * 4 + jj];
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V4f Row(this M44f m, int index)
        {
            float* ptr = &m.M00;
            return new V4f(ptr[index * 4], ptr[index * 4 + 1], ptr[index * 4 + 2], ptr[index * 4 + 3]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V4f Column(this M44f m, int index)
        {
            float* ptr = &m.M00;
            return new V4f(ptr[index], ptr[index + 4], ptr[index + 8], ptr[index + 12]);
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Determinant(M44f m)
            => m.Determinant;

        /// <summary>
        /// Returns the transpose of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Transposed(M44f m)
            => m.Transposed;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Transpose(this ref M44f m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
            Fun.Swap(ref m.M30, ref m.M03);
            Fun.Swap(ref m.M31, ref m.M13);
            Fun.Swap(ref m.M32, ref m.M23);
        }

        /// <summary>
        /// Returns the inverse of the given matrix. If the matrix is not invertible
        /// M44f.Zero is returned.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Inverse(M44f m)
            => m.Inverse;

        /// <summary>
        /// Inverts the given matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Invert(this ref M44f m) { return m.LuInvert(); }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M44f m, float epsilon)
        {
            return Fun.ApproximateEquals(m, M44f.Identity, epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M44f m)
            => IsIdentity(m, Constant<float>.PositiveTinyValue);

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M44f m, float epsilon)
        {
            var i = m * m.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M44f m)
            => IsOrthonormal(m, Constant<float>.PositiveTinyValue);

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M44f m, float epsilon)
        {
            var i = m * m.Transposed;
            for (int j = 0; j < 4; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M44f m)
            => IsOrthogonal(m, Constant<float>.PositiveTinyValue);

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M44f"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MinElement(M44f m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M44f"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MaxElement(M44f m)
            => m.MaxElement;

        #endregion

        #region Orthogonalization

        /// <summary>
        /// Orthogonalizes the columns of the given <see cref="M44f"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        public static void Orthogonalize(this ref M44f matrix)
        {
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C3 -= (Vec.Dot(matrix.C0, matrix.C3) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C3 -= (Vec.Dot(matrix.C1, matrix.C3) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C3 -= (Vec.Dot(matrix.C2, matrix.C3) / Vec.Dot(matrix.C2, matrix.C2)) * matrix.C2;
            matrix.C3 -= (Vec.Dot(matrix.C0, matrix.C3) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C3 -= (Vec.Dot(matrix.C1, matrix.C3) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C3 -= (Vec.Dot(matrix.C2, matrix.C3) / Vec.Dot(matrix.C2, matrix.C2)) * matrix.C2;
        }

        /// <summary>
        /// Orthogonalizes the columns of the given <see cref="M44f"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Orthogonalized(this M44f matrix)
        {
            M44f m = matrix;
            Orthogonalize(ref m);
            return m;
        }

        /// <summary>
        /// Orthonormalizes the columns of the given <see cref="M44f"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        public static void Orthonormalize(this ref M44f matrix)
        {
            matrix.C0 = matrix.C0.Normalized;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 = matrix.C1.Normalized;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C2 = matrix.C2.Normalized;
            matrix.C3 -= (Vec.Dot(matrix.C0, matrix.C3) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C3 -= (Vec.Dot(matrix.C1, matrix.C3) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C3 -= (Vec.Dot(matrix.C2, matrix.C3) / Vec.Dot(matrix.C2, matrix.C2)) * matrix.C2;
            matrix.C3 -= (Vec.Dot(matrix.C0, matrix.C3) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C3 -= (Vec.Dot(matrix.C1, matrix.C3) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C3 -= (Vec.Dot(matrix.C2, matrix.C3) / Vec.Dot(matrix.C2, matrix.C2)) * matrix.C2;
            matrix.C3 = matrix.C3.Normalized;
        }

        /// <summary>
        /// Orthonormalizes the columns of the given <see cref="M44f"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f Orthonormalized(this M44f matrix)
        {
            M44f m = matrix;
            Orthonormalize(ref m);
            return m;
        }

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M44f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M44f m, float epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M03.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon) || m.M13.IsTiny(epsilon) || m.M20.IsTiny(epsilon) || m.M21.IsTiny(epsilon) || m.M22.IsTiny(epsilon) || m.M23.IsTiny(epsilon) || m.M30.IsTiny(epsilon) || m.M31.IsTiny(epsilon) || m.M32.IsTiny(epsilon) || m.M33.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M44f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M44f m, float epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M03.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon) && m.M13.IsTiny(epsilon) && m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon) && m.M22.IsTiny(epsilon) && m.M23.IsTiny(epsilon) && m.M30.IsTiny(epsilon) && m.M31.IsTiny(epsilon) && m.M32.IsTiny(epsilon) && m.M33.IsTiny(epsilon);

        #endregion

        #region Special Floating Point Value Checks

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNaN(M44f m)
            => m.AnyNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNaN(M44f m)
            => m.AllNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyInfinity(M44f m)
            => m.AnyInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllInfinity(M44f m)
            => m.AllInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyPositiveInfinity(M44f m)
            => m.AnyPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllPositiveInfinity(M44f m)
            => m.AllPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNegativeInfinity(M44f m)
            => m.AnyNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNegativeInfinity(M44f m)
            => m.AllNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(M44f m)
            => m.AnyTiny;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(M44f m)
            => m.AllTiny;

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M44f a, M44f b)
            => ApproximateEquals(a, b, Constant<float>.PositiveTinyValue);

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M44f a, M44f b, float epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M44f"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M44f m, float epsilon)
            => Mat.AllTiny(m, epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M44f"/> is smaller than Constant&lt;float&gt;.PositiveTinyValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(M44f m)
            => m.IsTiny;

        #endregion

        #region Special Floating Point Value Checks

        /// <summary>
        /// Returns whether any element of the given <see cref="M44f"/> is NaN.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNaN(M44f v)
            => v.IsNaN;

        /// <summary>
        /// Returns whether any element of the given <see cref="M44f"/> is infinity (positive or negative).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInfinity(M44f v)
            => v.IsInfinity;

        /// <summary>
        /// Returns whether all elements of the given <see cref="M44f"/> are finite (i.e. not NaN and not infinity).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsFinite(M44f v)
            => v.IsFinite;

        #endregion
    }

    public static class IRandomUniformM44fExtensions
    {
        #region IRandomUniform extensions for M44f

        /// <summary>
        /// Uses UniformFloat() to generate the elements of an M44f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f UniformM44f(this IRandomUniform rnd)
        {
            return new M44f(
                rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), 
                rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), 
                rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), 
                rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat(), rnd.UniformFloat());
        }

        /// <summary>
        /// Uses UniformFloatClosed() to generate the elements of an M44f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f UniformM44fClosed(this IRandomUniform rnd)
        {
            return new M44f(
                rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), 
                rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), 
                rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), 
                rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed(), rnd.UniformFloatClosed());
        }

        /// <summary>
        /// Uses UniformFloatOpen() to generate the elements of an M44f matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44f UniformM44fOpen(this IRandomUniform rnd)
        {
            return new M44f(
                rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), 
                rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), 
                rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), 
                rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen(), rnd.UniformFloatOpen());
        }

        #endregion
    }

    #endregion

    #region M44d

    [DataContract]
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct M44d : IEquatable<M44d>, IValidity, IMatrix<double>
    {
        [DataMember]
        public double M00, M01, M02, M03;
        [DataMember]
        public double M10, M11, M12, M13;
        [DataMember]
        public double M20, M21, M22, M23;
        [DataMember]
        public double M30, M31, M32, M33;

        #region Constructors

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(double value)
        {
            M00 = value; M01 = 0; M02 = 0; M03 = 0; 
            M10 = 0; M11 = value; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = value; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = value; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(
                double m00, double m01, double m02, double m03, 
                double m10, double m11, double m12, double m13, 
                double m20, double m21, double m22, double m23, 
                double m30, double m31, double m32, double m33)
        {
            M00 = m00; M01 = m01; M02 = m02; M03 = m03; 
            M10 = m10; M11 = m11; M12 = m12; M13 = m13; 
            M20 = m20; M21 = m21; M22 = m22; M23 = m23; 
            M30 = m30; M31 = m31; M32 = m32; M33 = m33; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(double[] a)
        {
            M00 = a[0];
            M01 = a[1];
            M02 = a[2];
            M03 = a[3];
            M10 = a[4];
            M11 = a[5];
            M12 = a[6];
            M13 = a[7];
            M20 = a[8];
            M21 = a[9];
            M22 = a[10];
            M23 = a[11];
            M30 = a[12];
            M31 = a[13];
            M32 = a[14];
            M33 = a[15];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(double[] a, int start)
        {
            M00 = a[start + 0];
            M01 = a[start + 1];
            M02 = a[start + 2];
            M03 = a[start + 3];
            M10 = a[start + 4];
            M11 = a[start + 5];
            M12 = a[start + 6];
            M13 = a[start + 7];
            M20 = a[start + 8];
            M21 = a[start + 9];
            M22 = a[start + 10];
            M23 = a[start + 11];
            M30 = a[start + 12];
            M31 = a[start + 13];
            M32 = a[start + 14];
            M33 = a[start + 15];
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M22i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M23i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M33i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M34i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M44i m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
            M30 = (double)m.M30; M31 = (double)m.M31; M32 = (double)m.M32; M33 = (double)m.M33; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M22l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M23l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M33l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M34l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M44l m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
            M30 = (double)m.M30; M31 = (double)m.M31; M32 = (double)m.M32; M33 = (double)m.M33; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M22f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = 0; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M23f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M33f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = 0; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = 0; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M34f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M44f m)
        {
            M00 = (double)m.M00; M01 = (double)m.M01; M02 = (double)m.M02; M03 = (double)m.M03; 
            M10 = (double)m.M10; M11 = (double)m.M11; M12 = (double)m.M12; M13 = (double)m.M13; 
            M20 = (double)m.M20; M21 = (double)m.M21; M22 = (double)m.M22; M23 = (double)m.M23; 
            M30 = (double)m.M30; M31 = (double)m.M31; M32 = (double)m.M32; M33 = (double)m.M33; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M22d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = 0; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = 0; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M23d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = 0; M21 = 0; M22 = 1; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M33d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = 0; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = 0; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = 0; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public M44d(M34d m)
        {
            M00 = m.M00; M01 = m.M01; M02 = m.M02; M03 = m.M03; 
            M10 = m.M10; M11 = m.M11; M12 = m.M12; M13 = m.M13; 
            M20 = m.M20; M21 = m.M21; M22 = m.M22; M23 = m.M23; 
            M30 = 0; M31 = 0; M32 = 0; M33 = 1; 
        }

        #endregion

        #region Conversions

        public static explicit operator M44d(M22i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M23i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M33i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M34i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M44i m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = (double)m.M30, M31 = (double)m.M31, M32 = (double)m.M32, M33 = (double)m.M33, 
            };
        }

        public static explicit operator M44d(M22l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M23l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M33l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M34l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M44l m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = (double)m.M30, M31 = (double)m.M31, M32 = (double)m.M32, M33 = (double)m.M33, 
            };
        }

        public static explicit operator M44d(M22f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = 0, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M23f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M33f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = 0, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = 0, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M34f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M44f m)
        {
            return new M44d {
                M00 = (double)m.M00, M01 = (double)m.M01, M02 = (double)m.M02, M03 = (double)m.M03, 
                M10 = (double)m.M10, M11 = (double)m.M11, M12 = (double)m.M12, M13 = (double)m.M13, 
                M20 = (double)m.M20, M21 = (double)m.M21, M22 = (double)m.M22, M23 = (double)m.M23, 
                M30 = (double)m.M30, M31 = (double)m.M31, M32 = (double)m.M32, M33 = (double)m.M33, 
            };
        }

        public static explicit operator M44d(M22d m)
        {
            return new M44d {
                M00 = m.M00, M01 = m.M01, M02 = 0, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = 0, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M23d m)
        {
            return new M44d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = 0, M21 = 0, M22 = 1, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M33d m)
        {
            return new M44d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = 0, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = 0, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = 0, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(M34d m)
        {
            return new M44d {
                M00 = m.M00, M01 = m.M01, M02 = m.M02, M03 = m.M03, 
                M10 = m.M10, M11 = m.M11, M12 = m.M12, M13 = m.M13, 
                M20 = m.M20, M21 = m.M21, M22 = m.M22, M23 = m.M23, 
                M30 = 0, M31 = 0, M32 = 0, M33 = 1, 
            };
        }

        public static explicit operator M44d(int[] a)
        {
            return new M44d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11], 
                (double)a[12], (double)a[13], (double)a[14], (double)a[15]);
        }

        public static explicit operator M44d(int[,] a)
        {
            return new M44d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3], 
                (double)a[3, 0], (double)a[3, 1], (double)a[3, 2], (double)a[3, 3]);
        }

        public static explicit operator int[](M44d m)
        {
            return new int[] {
                (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03, 
                (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13, 
                (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23, 
                (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33
            };
        }

        public static explicit operator int[,](M44d m)
        {
            return new int[,] {
                { (int)m.M00, (int)m.M01, (int)m.M02, (int)m.M03 }, 
                { (int)m.M10, (int)m.M11, (int)m.M12, (int)m.M13 }, 
                { (int)m.M20, (int)m.M21, (int)m.M22, (int)m.M23 }, 
                { (int)m.M30, (int)m.M31, (int)m.M32, (int)m.M33 }
            };
        }

        public void CopyTo(int[] array, long index)
        {
            array[index + 0] = (int)M00;
            array[index + 1] = (int)M01;
            array[index + 2] = (int)M02;
            array[index + 3] = (int)M03;
            array[index + 4] = (int)M10;
            array[index + 5] = (int)M11;
            array[index + 6] = (int)M12;
            array[index + 7] = (int)M13;
            array[index + 8] = (int)M20;
            array[index + 9] = (int)M21;
            array[index + 10] = (int)M22;
            array[index + 11] = (int)M23;
            array[index + 12] = (int)M30;
            array[index + 13] = (int)M31;
            array[index + 14] = (int)M32;
            array[index + 15] = (int)M33;
        }

        public static explicit operator M44d(long[] a)
        {
            return new M44d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11], 
                (double)a[12], (double)a[13], (double)a[14], (double)a[15]);
        }

        public static explicit operator M44d(long[,] a)
        {
            return new M44d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3], 
                (double)a[3, 0], (double)a[3, 1], (double)a[3, 2], (double)a[3, 3]);
        }

        public static explicit operator long[](M44d m)
        {
            return new long[] {
                (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03, 
                (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13, 
                (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23, 
                (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33
            };
        }

        public static explicit operator long[,](M44d m)
        {
            return new long[,] {
                { (long)m.M00, (long)m.M01, (long)m.M02, (long)m.M03 }, 
                { (long)m.M10, (long)m.M11, (long)m.M12, (long)m.M13 }, 
                { (long)m.M20, (long)m.M21, (long)m.M22, (long)m.M23 }, 
                { (long)m.M30, (long)m.M31, (long)m.M32, (long)m.M33 }
            };
        }

        public void CopyTo(long[] array, long index)
        {
            array[index + 0] = (long)M00;
            array[index + 1] = (long)M01;
            array[index + 2] = (long)M02;
            array[index + 3] = (long)M03;
            array[index + 4] = (long)M10;
            array[index + 5] = (long)M11;
            array[index + 6] = (long)M12;
            array[index + 7] = (long)M13;
            array[index + 8] = (long)M20;
            array[index + 9] = (long)M21;
            array[index + 10] = (long)M22;
            array[index + 11] = (long)M23;
            array[index + 12] = (long)M30;
            array[index + 13] = (long)M31;
            array[index + 14] = (long)M32;
            array[index + 15] = (long)M33;
        }

        public static explicit operator M44d(float[] a)
        {
            return new M44d(
                (double)a[0], (double)a[1], (double)a[2], (double)a[3], 
                (double)a[4], (double)a[5], (double)a[6], (double)a[7], 
                (double)a[8], (double)a[9], (double)a[10], (double)a[11], 
                (double)a[12], (double)a[13], (double)a[14], (double)a[15]);
        }

        public static explicit operator M44d(float[,] a)
        {
            return new M44d(
                (double)a[0, 0], (double)a[0, 1], (double)a[0, 2], (double)a[0, 3], 
                (double)a[1, 0], (double)a[1, 1], (double)a[1, 2], (double)a[1, 3], 
                (double)a[2, 0], (double)a[2, 1], (double)a[2, 2], (double)a[2, 3], 
                (double)a[3, 0], (double)a[3, 1], (double)a[3, 2], (double)a[3, 3]);
        }

        public static explicit operator float[](M44d m)
        {
            return new float[] {
                (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03, 
                (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13, 
                (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23, 
                (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33
            };
        }

        public static explicit operator float[,](M44d m)
        {
            return new float[,] {
                { (float)m.M00, (float)m.M01, (float)m.M02, (float)m.M03 }, 
                { (float)m.M10, (float)m.M11, (float)m.M12, (float)m.M13 }, 
                { (float)m.M20, (float)m.M21, (float)m.M22, (float)m.M23 }, 
                { (float)m.M30, (float)m.M31, (float)m.M32, (float)m.M33 }
            };
        }

        public void CopyTo(float[] array, long index)
        {
            array[index + 0] = (float)M00;
            array[index + 1] = (float)M01;
            array[index + 2] = (float)M02;
            array[index + 3] = (float)M03;
            array[index + 4] = (float)M10;
            array[index + 5] = (float)M11;
            array[index + 6] = (float)M12;
            array[index + 7] = (float)M13;
            array[index + 8] = (float)M20;
            array[index + 9] = (float)M21;
            array[index + 10] = (float)M22;
            array[index + 11] = (float)M23;
            array[index + 12] = (float)M30;
            array[index + 13] = (float)M31;
            array[index + 14] = (float)M32;
            array[index + 15] = (float)M33;
        }

        public static explicit operator M44d(double[] a)
        {
            return new M44d(
                a[0], a[1], a[2], a[3], 
                a[4], a[5], a[6], a[7], 
                a[8], a[9], a[10], a[11], 
                a[12], a[13], a[14], a[15]);
        }

        public static explicit operator M44d(double[,] a)
        {
            return new M44d(
                a[0, 0], a[0, 1], a[0, 2], a[0, 3], 
                a[1, 0], a[1, 1], a[1, 2], a[1, 3], 
                a[2, 0], a[2, 1], a[2, 2], a[2, 3], 
                a[3, 0], a[3, 1], a[3, 2], a[3, 3]);
        }

        public static explicit operator double[](M44d m)
        {
            return new double[] {
                m.M00, m.M01, m.M02, m.M03, 
                m.M10, m.M11, m.M12, m.M13, 
                m.M20, m.M21, m.M22, m.M23, 
                m.M30, m.M31, m.M32, m.M33
            };
        }

        public static explicit operator double[,](M44d m)
        {
            return new double[,] {
                { m.M00, m.M01, m.M02, m.M03 }, 
                { m.M10, m.M11, m.M12, m.M13 }, 
                { m.M20, m.M21, m.M22, m.M23 }, 
                { m.M30, m.M31, m.M32, m.M33 }
            };
        }

        public void CopyTo(double[] array, long index)
        {
            array[index + 0] = M00;
            array[index + 1] = M01;
            array[index + 2] = M02;
            array[index + 3] = M03;
            array[index + 4] = M10;
            array[index + 5] = M11;
            array[index + 6] = M12;
            array[index + 7] = M13;
            array[index + 8] = M20;
            array[index + 9] = M21;
            array[index + 10] = M22;
            array[index + 11] = M23;
            array[index + 12] = M30;
            array[index + 13] = M31;
            array[index + 14] = M32;
            array[index + 15] = M33;
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<double, int> element_fun)
        {
            return new M44i(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44i Copy(Func<double, int, int, int> element_index0_index1_fun)
        {
            return new M44i(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<double, long> element_fun)
        {
            return new M44l(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44l Copy(Func<double, int, int, long> element_index0_index1_fun)
        {
            return new M44l(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<double, float> element_fun)
        {
            return new M44f(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44f Copy(Func<double, int, int, float> element_index0_index1_fun)
        {
            return new M44f(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<double, double> element_fun)
        {
            return new M44d(
                element_fun(M00), element_fun(M01), element_fun(M02), element_fun(M03), 
                element_fun(M10), element_fun(M11), element_fun(M12), element_fun(M13), 
                element_fun(M20), element_fun(M21), element_fun(M22), element_fun(M23), 
                element_fun(M30), element_fun(M31), element_fun(M32), element_fun(M33));
        }

        /// <summary>
        /// Returns a copy with all elements transformed by the supplied function.
        /// </summary>
        public M44d Copy(Func<double, int, int, double> element_index0_index1_fun)
        {
            return new M44d(
                element_index0_index1_fun(M00, 0, 0), element_index0_index1_fun(M01, 0, 1), element_index0_index1_fun(M02, 0, 2), element_index0_index1_fun(M03, 0, 3), 
                element_index0_index1_fun(M10, 1, 0), element_index0_index1_fun(M11, 1, 1), element_index0_index1_fun(M12, 1, 2), element_index0_index1_fun(M13, 1, 3), 
                element_index0_index1_fun(M20, 2, 0), element_index0_index1_fun(M21, 2, 1), element_index0_index1_fun(M22, 2, 2), element_index0_index1_fun(M23, 2, 3), 
                element_index0_index1_fun(M30, 3, 0), element_index0_index1_fun(M31, 3, 1), element_index0_index1_fun(M32, 3, 2), element_index0_index1_fun(M33, 3, 3));
        }

        /// <summary>
        /// Returns a copy of the upper left sub matrix.
        /// </summary>
        public M33d UpperLeftM33()
        {
            return (M33d)this;
        }

        public double[] ToArray()
        {
            var array = new double[16];
            array[0] = M00;
            array[1] = M01;
            array[2] = M02;
            array[3] = M03;
            array[4] = M10;
            array[5] = M11;
            array[6] = M12;
            array[7] = M13;
            array[8] = M20;
            array[9] = M21;
            array[10] = M22;
            array[11] = M23;
            array[12] = M30;
            array[13] = M31;
            array[14] = M32;
            array[15] = M33;
            return array;
        }

        #endregion

        #region Static Creators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d FromCols(V4d col0, V4d col1, V4d col2, V4d col3)
        {
            return new M44d(
                col0.X, col1.X, col2.X, col3.X, 
                col0.Y, col1.Y, col2.Y, col3.Y, 
                col0.Z, col1.Z, col2.Z, col3.Z, 
                col0.W, col1.W, col2.W, col3.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d FromRows(V4d row0, V4d row1, V4d row2, V4d row3)
        {
            return new M44d(
                row0.X, row0.Y, row0.Z, row0.W, 
                row1.X, row1.Y, row1.Z, row1.W, 
                row2.X, row2.Y, row2.Z, row2.W, 
                row3.X, row3.Y, row3.Z, row3.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d FromDiagonal(double value)
        {
            return new M44d(
                value, 0, 0, 0, 
                0, value, 0, 0, 
                0, 0, value, 0, 
                0, 0, 0, value);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d FromDiagonal(double m00, double m11, double m22, double m33)
        {
            return new M44d(
                m00, 0, 0, 0, 
                0, m11, 0, 0, 
                0, 0, m22, 0, 
                0, 0, 0, m33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d FromDiagonal(V4d s)
        {
            return new M44d(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, s.W);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d FromAntiDiagonal(double value)
        {
            return new M44d(
                 0, 0, 0, value, 
                 0, 0, value, 0, 
                 0, value, 0, 0, 
                 value, 0, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d FromAntiDiagonal(double m03, double m12, double m21, double m30)
        {
            return new M44d(
                0, 0, 0, m03, 
                0, 0, m12, 0, 
                0, m21, 0, 0, 
                m30, 0, 0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d FromAntiDiagonal(V4d s)
        {
            return new M44d(
                0, 0, 0, s.X, 
                0, 0, s.Y, 0, 
                0, s.Z, 0, 0, 
                s.W, 0, 0, 0);
        }

        #region Scale

        /// <summary>
        /// Creates a transformation <see cref="M44d"/> using 4 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Scale(double sX, double sY, double sZ, double sW)
            => FromDiagonal(sX, sY, sZ, sW);

        /// <summary>
        /// Creates a transformation <see cref="M44d"/> using a <see cref="V4d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Scale(V4d s)
            => FromDiagonal(s);

        /// <summary>
        /// Creates a homogenous transformation <see cref="M44d"/> using a uniform scale.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Scale(double s)
        {
            return new M44d(
                s, 0, 0, 0, 
                0, s, 0, 0, 
                0, 0, s, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44d"/> using 3 scalars as scaling factors.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Scale(double sX, double sY, double sZ)
        {
            return new M44d(
                sX, 0, 0, 0, 
                0, sY, 0, 0, 
                0, 0, sZ, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44d"/> using a <see cref="V3d"/> as scaling factor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Scale(V3d s)
        {
            return new M44d(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a scaling transformation <see cref="M44d"/> from a <see cref="Scale3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Scale(Scale3d s)
        {
            return new M44d(
                s.X, 0, 0, 0, 
                0, s.Y, 0, 0, 
                0, 0, s.Z, 0, 
                0, 0, 0, 1);
        }

        #endregion

        #region Translation

        /// <summary>
        /// Creates a transformation <see cref="M44d"/> with the translational component given by 3 scalars.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Translation(double tX, double tY, double tZ)
        {
            return new M44d(
                1, 0, 0, tX, 
                0, 1, 0, tY, 
                0, 0, 1, tZ, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44d"/> with the translational component given by a <see cref="V3d"/> vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Translation(V3d t)
        {
            return new M44d(
                1, 0, 0, t.X, 
                0, 1, 0, t.Y, 
                0, 0, 1, t.Z, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a transformation <see cref="M44d"/> from a <see cref="Shift3d"/> transformation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Translation(Shift3d s)
        {
            return new M44d(
                1, 0, 0, s.X, 
                0, 1, 0, s.Y, 
                0, 0, 1, s.Z, 
                0, 0, 0, 1);
        }

        #endregion

        #region Rotation

        /// <summary>
        /// Creates a 3D rotation matrix from a <see cref="Rot3d"/>
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Rotation(Rot3d r)
            => (M44d)r;

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in radians.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Rotation(V3d normalizedAxis, double angleInRadians)
        {
            Debug.Assert(normalizedAxis.LengthSquared.ApproximateEquals(1));
            return (M44d)(Rot3d.Rotation(normalizedAxis, angleInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from an axis vector and an angle in degrees.
        /// The axis vector has to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d RotationInDegrees(V3d normalizedAxis, double angleInDegrees)
            => Rotation(normalizedAxis, angleInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) in radians. 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d RotationEuler(double rollInRadians, double pitchInRadians, double yawInRadians)
        {
            return (M44d)(Rot3d.RotationEuler(rollInRadians, pitchInRadians, yawInRadians));
        }

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) in degrees. 
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d RotationEulerInDegrees(double rollInDegrees, double pitchInDegrees, double yawInDegrees)
            => RotationEuler(
                rollInDegrees.RadiansFromDegrees(),
                pitchInDegrees.RadiansFromDegrees(), 
                yawInDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) vector in radians.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d RotationEuler(V3d rollPitchYawInRadians)
            => RotationEuler(
                rollPitchYawInRadians.X,
                rollPitchYawInRadians.Y,
                rollPitchYawInRadians.Z);

        /// <summary>
        /// Creates a 3D rotation matrix from roll (X), pitch (Y), and yaw (Z) vector in degrees.
        /// The rotation order is: Z, Y, X.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d RotationEulerInDegrees(V3d rollPitchYawInDegrees)
            => RotationEulerInDegrees(
                rollPitchYawInDegrees.X,
                rollPitchYawInDegrees.Y,
                rollPitchYawInDegrees.Z);

        /// <summary>
        /// Creates a 3D rotation matrix which rotates one vector into another.
        /// The input vectors have to be normalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d RotateInto(V3d from, V3d into)
        {
            Debug.Assert(from.LengthSquared.ApproximateEquals(1));
            Debug.Assert(into.LengthSquared.ApproximateEquals(1));
            return (M44d)(Rot3d.RotateInto(from, into));
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d RotationX(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M44d(
                 1,  0,  0,  0, 
                 0,  a, -b,  0, 
                 0,  b,  a,  0, 
                 0,  0,  0,  1);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d RotationXInDegrees(double angleDegrees)
            => RotationX(angleDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d RotationY(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M44d(
                 a,  0,  b,  0, 
                 0,  1,  0,  0, 
                -b,  0,  a,  0, 
                 0,  0,  0,  1);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d RotationYInDegrees(double angleDegrees)
            => RotationY(angleDegrees.RadiansFromDegrees());

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleRadians"/> radians around the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d RotationZ(double angleRadians)
        {
            var a = Fun.Cos(angleRadians);
            var b = Fun.Sin(angleRadians);

            return new M44d(
                 a, -b,  0,  0, 
                 b,  a,  0,  0, 
                 0,  0,  1,  0, 
                 0,  0,  0,  1);
        }

        /// <summary>
        /// Creates a 3D rotation matrix for <paramref name="angleDegrees"/> degrees around the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d RotationZInDegrees(double angleDegrees)
            => RotationZ(angleDegrees.RadiansFromDegrees());

        #endregion

        #region Shearing

        /// <summary>
        /// Creates a shear transformation matrix along the z-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d ShearXY(double factorX, double factorY)
        {
            return new M44d(
                1, 0, factorX, 0, 
                0, 1, factorY, 0, 
                0, 0, 1, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the y-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d ShearXZ(double factorX, double factorZ)
        {
            return new M44d(
                1, factorX, 0, 0, 
                0, 1, 0, 0, 
                0, factorZ, 1, 0, 
                0, 0, 0, 1);
        }

        /// <summary>
        /// Creates a shear transformation matrix along the x-axis.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d ShearYZ(double factorY, double factorZ)
        {
            return new M44d(
                1, 0, 0, 0, 
                factorY, 1, 0, 0, 
                factorZ, 0, 1, 0, 
                0, 0, 0, 1);
        }

        #endregion

        #endregion

        #region Static methods for F# core and Aardvark library support

        /// <summary>
        /// Returns the given matrix, with each element divided by <paramref name="x"/>.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d DivideByInt(M44d m, int x)
            => m / x;

        #endregion

        #region Properties and Indexers

        public bool IsValid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => true;
        }

        public bool IsInvalid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => false;
        }

        public IEnumerable<double> Elements
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return M00;
                yield return M01;
                yield return M02;
                yield return M03;
                yield return M10;
                yield return M11;
                yield return M12;
                yield return M13;
                yield return M20;
                yield return M21;
                yield return M22;
                yield return M23;
                yield return M30;
                yield return M31;
                yield return M32;
                yield return M33;
            }
        }

        public IEnumerable<V4d> Rows
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return R0;
                yield return R1;
                yield return R2;
                yield return R3;
            }
        }

        public IEnumerable<V4d> Columns
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                yield return C0;
                yield return C1;
                yield return C2;
                yield return C3;
            }
        }

        [XmlIgnore]
        public V4d R0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4d( M00,  M01,  M02,  M03); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M01 = value.Y;
                M02 = value.Z;
                M03 = value.W;
            }
        }

        [XmlIgnore]
        public V4d R1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4d( M10,  M11,  M12,  M13); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M10 = value.X;
                M11 = value.Y;
                M12 = value.Z;
                M13 = value.W;
            }
        }

        [XmlIgnore]
        public V4d R2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4d( M20,  M21,  M22,  M23); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M20 = value.X;
                M21 = value.Y;
                M22 = value.Z;
                M23 = value.W;
            }
        }

        [XmlIgnore]
        public V4d R3
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4d( M30,  M31,  M32,  M33); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M30 = value.X;
                M31 = value.Y;
                M32 = value.Z;
                M33 = value.W;
            }
        }

        [XmlIgnore]
        public V4d C0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4d( M00,  M10,  M20,  M30); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M00 = value.X;
                M10 = value.Y;
                M20 = value.Z;
                M30 = value.W;
            }
        }

        [XmlIgnore]
        public V4d C1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4d( M01,  M11,  M21,  M31); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M01 = value.X;
                M11 = value.Y;
                M21 = value.Z;
                M31 = value.W;
            }
        }

        [XmlIgnore]
        public V4d C2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4d( M02,  M12,  M22,  M32); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M02 = value.X;
                M12 = value.Y;
                M22 = value.Z;
                M32 = value.W;
            }
        }

        [XmlIgnore]
        public V4d C3
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return new V4d( M03,  M13,  M23,  M33); }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                M03 = value.X;
                M13 = value.Y;
                M23 = value.Z;
                M33 = value.W;
            }
        }

        public V4d Diagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V4d(M00, M11, M22, M33);
        }

        public V4d AntiDiagonal
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V4d(M03, M12, M21, M30);
        }

        /// <summary>
        /// Returns the minimum element of the matrix.
        /// </summary>
        public double MinElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Min(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23, M30, M31, M32, M33);
        }

        /// <summary>
        /// Returns the maximum element of the matrix.
        /// </summary>
        public double MaxElement
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Fun.Max(M00, M01, M02, M03, M10, M11, M12, M13, M20, M21, M22, M23, M30, M31, M32, M33);
        }

        public unsafe double this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (double* ptr = &M00) { return ptr[index]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (double* ptr = &M00) { ptr[index] = value; }
            }
        }

        public unsafe double this[int row, int column]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                fixed (double* ptr = &M00) { return ptr[row * 4 + column]; }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                fixed (double* ptr = &M00) { ptr[row * 4 + column] = value; }
            }
        }

        public bool AnyNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNaN(M00) || double.IsNaN(M01) || double.IsNaN(M02) || double.IsNaN(M03) || 
                    double.IsNaN(M10) || double.IsNaN(M11) || double.IsNaN(M12) || double.IsNaN(M13) || 
                    double.IsNaN(M20) || double.IsNaN(M21) || double.IsNaN(M22) || double.IsNaN(M23) || 
                    double.IsNaN(M30) || double.IsNaN(M31) || double.IsNaN(M32) || double.IsNaN(M33);
            }
        }

        public bool AllNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNaN(M00) && double.IsNaN(M01) && double.IsNaN(M02) && double.IsNaN(M03) && 
                    double.IsNaN(M10) && double.IsNaN(M11) && double.IsNaN(M12) && double.IsNaN(M13) && 
                    double.IsNaN(M20) && double.IsNaN(M21) && double.IsNaN(M22) && double.IsNaN(M23) && 
                    double.IsNaN(M30) && double.IsNaN(M31) && double.IsNaN(M32) && double.IsNaN(M33);
            }
        }

        public bool AnyInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsInfinity(M00) || double.IsInfinity(M01) || double.IsInfinity(M02) || double.IsInfinity(M03) || 
                    double.IsInfinity(M10) || double.IsInfinity(M11) || double.IsInfinity(M12) || double.IsInfinity(M13) || 
                    double.IsInfinity(M20) || double.IsInfinity(M21) || double.IsInfinity(M22) || double.IsInfinity(M23) || 
                    double.IsInfinity(M30) || double.IsInfinity(M31) || double.IsInfinity(M32) || double.IsInfinity(M33);
            }
        }

        public bool AllInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsInfinity(M00) && double.IsInfinity(M01) && double.IsInfinity(M02) && double.IsInfinity(M03) && 
                    double.IsInfinity(M10) && double.IsInfinity(M11) && double.IsInfinity(M12) && double.IsInfinity(M13) && 
                    double.IsInfinity(M20) && double.IsInfinity(M21) && double.IsInfinity(M22) && double.IsInfinity(M23) && 
                    double.IsInfinity(M30) && double.IsInfinity(M31) && double.IsInfinity(M32) && double.IsInfinity(M33);
            }
        }

        public bool AnyPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsPositiveInfinity(M00) || double.IsPositiveInfinity(M01) || double.IsPositiveInfinity(M02) || double.IsPositiveInfinity(M03) || 
                    double.IsPositiveInfinity(M10) || double.IsPositiveInfinity(M11) || double.IsPositiveInfinity(M12) || double.IsPositiveInfinity(M13) || 
                    double.IsPositiveInfinity(M20) || double.IsPositiveInfinity(M21) || double.IsPositiveInfinity(M22) || double.IsPositiveInfinity(M23) || 
                    double.IsPositiveInfinity(M30) || double.IsPositiveInfinity(M31) || double.IsPositiveInfinity(M32) || double.IsPositiveInfinity(M33);
            }
        }

        public bool AllPositiveInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsPositiveInfinity(M00) && double.IsPositiveInfinity(M01) && double.IsPositiveInfinity(M02) && double.IsPositiveInfinity(M03) && 
                    double.IsPositiveInfinity(M10) && double.IsPositiveInfinity(M11) && double.IsPositiveInfinity(M12) && double.IsPositiveInfinity(M13) && 
                    double.IsPositiveInfinity(M20) && double.IsPositiveInfinity(M21) && double.IsPositiveInfinity(M22) && double.IsPositiveInfinity(M23) && 
                    double.IsPositiveInfinity(M30) && double.IsPositiveInfinity(M31) && double.IsPositiveInfinity(M32) && double.IsPositiveInfinity(M33);
            }
        }

        public bool AnyNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNegativeInfinity(M00) || double.IsNegativeInfinity(M01) || double.IsNegativeInfinity(M02) || double.IsNegativeInfinity(M03) || 
                    double.IsNegativeInfinity(M10) || double.IsNegativeInfinity(M11) || double.IsNegativeInfinity(M12) || double.IsNegativeInfinity(M13) || 
                    double.IsNegativeInfinity(M20) || double.IsNegativeInfinity(M21) || double.IsNegativeInfinity(M22) || double.IsNegativeInfinity(M23) || 
                    double.IsNegativeInfinity(M30) || double.IsNegativeInfinity(M31) || double.IsNegativeInfinity(M32) || double.IsNegativeInfinity(M33);
            }
        }

        public bool AllNegativeInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    double.IsNegativeInfinity(M00) && double.IsNegativeInfinity(M01) && double.IsNegativeInfinity(M02) && double.IsNegativeInfinity(M03) && 
                    double.IsNegativeInfinity(M10) && double.IsNegativeInfinity(M11) && double.IsNegativeInfinity(M12) && double.IsNegativeInfinity(M13) && 
                    double.IsNegativeInfinity(M20) && double.IsNegativeInfinity(M21) && double.IsNegativeInfinity(M22) && double.IsNegativeInfinity(M23) && 
                    double.IsNegativeInfinity(M30) && double.IsNegativeInfinity(M31) && double.IsNegativeInfinity(M32) && double.IsNegativeInfinity(M33);
            }
        }

        public bool AnyTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) || Fun.IsTiny(M01) || Fun.IsTiny(M02) || Fun.IsTiny(M03) || 
                    Fun.IsTiny(M10) || Fun.IsTiny(M11) || Fun.IsTiny(M12) || Fun.IsTiny(M13) || 
                    Fun.IsTiny(M20) || Fun.IsTiny(M21) || Fun.IsTiny(M22) || Fun.IsTiny(M23) || 
                    Fun.IsTiny(M30) || Fun.IsTiny(M31) || Fun.IsTiny(M32) || Fun.IsTiny(M33);
            }
        }

        public bool AllTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return 
                    Fun.IsTiny(M00) && Fun.IsTiny(M01) && Fun.IsTiny(M02) && Fun.IsTiny(M03) && 
                    Fun.IsTiny(M10) && Fun.IsTiny(M11) && Fun.IsTiny(M12) && Fun.IsTiny(M13) && 
                    Fun.IsTiny(M20) && Fun.IsTiny(M21) && Fun.IsTiny(M22) && Fun.IsTiny(M23) && 
                    Fun.IsTiny(M30) && Fun.IsTiny(M31) && Fun.IsTiny(M32) && Fun.IsTiny(M33);
            }
        }

        /// <summary>
        /// Returns true if the absolute value of each element of the matrix is smaller than Constant&lt;double&gt;.PositiveTinyValue, false otherwise.
        /// </summary>
        public bool IsTiny
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AllTiny;
        }

        /// <summary>
        /// Returns true if any element of the matrix is NaN, false otherwise.
        /// </summary>
        public bool IsNaN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyNaN;
        }

        /// <summary>
        /// Returns true if any element of the matrix is infinite (positive or negative), false otherwise.
        /// </summary>
        public bool IsInfinity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => AnyInfinity;
        }

        /// <summary>
        /// Returns whether all elements of the matrix are finite (i.e. not NaN and not infinity).
        /// </summary>
        public bool IsFinite
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => !(IsInfinity || IsNaN);
        }

        #endregion

        #region Constants

        public const int RowCount = 4;
        public const int ColumnCount = 4;
        public const int ElementCount = 4 * 4;

        public static V2l Dimensions
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new V2l(4, 4);
        }

        public static M44d Zero
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44d(0);
        }

        public static M44d Identity
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new M44d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        public double Norm1
        {
            get
            {
                return 
                    Fun.Abs(M00) + Fun.Abs(M01) + Fun.Abs(M02) + Fun.Abs(M03) + 
                    Fun.Abs(M10) + Fun.Abs(M11) + Fun.Abs(M12) + Fun.Abs(M13) + 
                    Fun.Abs(M20) + Fun.Abs(M21) + Fun.Abs(M22) + Fun.Abs(M23) + 
                    Fun.Abs(M30) + Fun.Abs(M31) + Fun.Abs(M32) + Fun.Abs(M33);
            }
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        public double Norm2
        {
            get
            {
                return Fun.Sqrt(
                    M00 * M00 + M01 * M01 + M02 * M02 + M03 * M03 + 
                    M10 * M10 + M11 * M11 + M12 * M12 + M13 * M13 + 
                    M20 * M20 + M21 * M21 + M22 * M22 + M23 * M23 + 
                    M30 * M30 + M31 * M31 + M32 * M32 + M33 * M33);
            }
        }

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        public double NormMax
        {
            get
            {
                return Fun.Max(
                            Fun.Max(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Max(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Max(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Max(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        public double NormMin
        {
            get
            {
                return Fun.Min(
                            Fun.Min(
                                Fun.Abs(M00), 
                                Fun.Abs(M01), 
                                Fun.Abs(M02), 
                                Fun.Abs(M03)), 
                            Fun.Min(
                                Fun.Abs(M10), 
                                Fun.Abs(M11), 
                                Fun.Abs(M12), 
                                Fun.Abs(M13)), 
                            Fun.Min(
                                Fun.Abs(M20), 
                                Fun.Abs(M21), 
                                Fun.Abs(M22), 
                                Fun.Abs(M23)), 
                            Fun.Min(
                                Fun.Abs(M30), 
                                Fun.Abs(M31), 
                                Fun.Abs(M32), 
                                Fun.Abs(M33)));
            }
        }

        #endregion

        #region Mathematical Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator -(M44d m)
        {
            return new M44d(
                -m.M00, -m.M01, -m.M02, -m.M03, 
                -m.M10, -m.M11, -m.M12, -m.M13, 
                -m.M20, -m.M21, -m.M22, -m.M23, 
                -m.M30, -m.M31, -m.M32, -m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  + (M44d a, M44d b)
        {
            return new M44d(
                a.M00 + b.M00, a.M01 + b.M01, a.M02 + b.M02, a.M03 + b.M03, 
                a.M10 + b.M10, a.M11 + b.M11, a.M12 + b.M12, a.M13 + b.M13, 
                a.M20 + b.M20, a.M21 + b.M21, a.M22 + b.M22, a.M23 + b.M23, 
                a.M30 + b.M30, a.M31 + b.M31, a.M32 + b.M32, a.M33 + b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  + (M44d m, double s)
        {
            return new M44d(
                m.M00 + s, m.M01 + s, m.M02 + s, m.M03 + s, 
                m.M10 + s, m.M11 + s, m.M12 + s, m.M13 + s, 
                m.M20 + s, m.M21 + s, m.M22 + s, m.M23 + s, 
                m.M30 + s, m.M31 + s, m.M32 + s, m.M33 + s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  + (double s, M44d m)
        {
            return new M44d(
                s + m.M00, s + m.M01, s + m.M02, s + m.M03, 
                s + m.M10, s + m.M11, s + m.M12, s + m.M13, 
                s + m.M20, s + m.M21, s + m.M22, s + m.M23, 
                s + m.M30, s + m.M31, s + m.M32, s + m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  - (M44d a, M44d b)
        {
            return new M44d(
                a.M00 - b.M00, a.M01 - b.M01, a.M02 - b.M02, a.M03 - b.M03, 
                a.M10 - b.M10, a.M11 - b.M11, a.M12 - b.M12, a.M13 - b.M13, 
                a.M20 - b.M20, a.M21 - b.M21, a.M22 - b.M22, a.M23 - b.M23, 
                a.M30 - b.M30, a.M31 - b.M31, a.M32 - b.M32, a.M33 - b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  - (M44d m, double s)
        {
            return new M44d(
                m.M00 - s, m.M01 - s, m.M02 - s, m.M03 - s, 
                m.M10 - s, m.M11 - s, m.M12 - s, m.M13 - s, 
                m.M20 - s, m.M21 - s, m.M22 - s, m.M23 - s, 
                m.M30 - s, m.M31 - s, m.M32 - s, m.M33 - s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  - (double s, M44d m)
        {
            return new M44d(
                s - m.M00, s - m.M01, s - m.M02, s - m.M03, 
                s - m.M10, s - m.M11, s - m.M12, s - m.M13, 
                s - m.M20, s - m.M21, s - m.M22, s - m.M23, 
                s - m.M30, s - m.M31, s - m.M32, s - m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  % (M44d a, M44d b)
        {
            return new M44d(
                a.M00 % b.M00, a.M01 % b.M01, a.M02 % b.M02, a.M03 % b.M03, 
                a.M10 % b.M10, a.M11 % b.M11, a.M12 % b.M12, a.M13 % b.M13, 
                a.M20 % b.M20, a.M21 % b.M21, a.M22 % b.M22, a.M23 % b.M23, 
                a.M30 % b.M30, a.M31 % b.M31, a.M32 % b.M32, a.M33 % b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  % (M44d m, double s)
        {
            return new M44d(
                m.M00 % s, m.M01 % s, m.M02 % s, m.M03 % s, 
                m.M10 % s, m.M11 % s, m.M12 % s, m.M13 % s, 
                m.M20 % s, m.M21 % s, m.M22 % s, m.M23 % s, 
                m.M30 % s, m.M31 % s, m.M32 % s, m.M33 % s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  % (double s, M44d m)
        {
            return new M44d(
                s % m.M00, s % m.M01, s % m.M02, s % m.M03, 
                s % m.M10, s % m.M11, s % m.M12, s % m.M13, 
                s % m.M20, s % m.M21, s % m.M22, s % m.M23, 
                s % m.M30, s % m.M31, s % m.M32, s % m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  / (M44d a, M44d b)
        {
            return new M44d(
                a.M00 / b.M00, a.M01 / b.M01, a.M02 / b.M02, a.M03 / b.M03, 
                a.M10 / b.M10, a.M11 / b.M11, a.M12 / b.M12, a.M13 / b.M13, 
                a.M20 / b.M20, a.M21 / b.M21, a.M22 / b.M22, a.M23 / b.M23, 
                a.M30 / b.M30, a.M31 / b.M31, a.M32 / b.M32, a.M33 / b.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  / (M44d m, double s)
        {
            return new M44d(
                m.M00 / s, m.M01 / s, m.M02 / s, m.M03 / s, 
                m.M10 / s, m.M11 / s, m.M12 / s, m.M13 / s, 
                m.M20 / s, m.M21 / s, m.M22 / s, m.M23 / s, 
                m.M30 / s, m.M31 / s, m.M32 / s, m.M33 / s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  / (double s, M44d m)
        {
            return new M44d(
                s / m.M00, s / m.M01, s / m.M02, s / m.M03, 
                s / m.M10, s / m.M11, s / m.M12, s / m.M13, 
                s / m.M20, s / m.M21, s / m.M22, s / m.M23, 
                s / m.M30, s / m.M31, s / m.M32, s / m.M33);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  * (M44d m, double s)
        {
            return new M44d(
                m.M00 * s, m.M01 * s, m.M02 * s, m.M03 * s, 
                m.M10 * s, m.M11 * s, m.M12 * s, m.M13 * s, 
                m.M20 * s, m.M21 * s, m.M22 * s, m.M23 * s, 
                m.M30 * s, m.M31 * s, m.M32 * s, m.M33 * s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d operator  * (double s, M44d m)
        {
            return new M44d(
                s * m.M00, s * m.M01, s * m.M02, s * m.M03, 
                s * m.M10, s * m.M11, s * m.M12, s * m.M13, 
                s * m.M20, s * m.M21, s * m.M22, s * m.M23, 
                s * m.M30, s * m.M31, s * m.M32, s * m.M33);
        }

        #endregion

        #region Matrix/Vector Multiplication

        /// <summary>
        /// Multiplies a M44d matrix with a V4d column vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d operator *(M44d m, V4d v)
        {
            return new V4d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z + m.M03 * v.W, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z + m.M13 * v.W, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z + m.M23 * v.W, 
                m.M30 * v.X + m.M31 * v.Y + m.M32 * v.Z + m.M33 * v.W);
        }

        /// <summary>
        /// Multiplies a V4d row vector with a M44d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d operator *(V4d v, M44d m)
        {
            return new V4d(
                v.X * m.M00 + v.Y * m.M10 + v.Z * m.M20 + v.W * m.M30, 
                v.X * m.M01 + v.Y * m.M11 + v.Z * m.M21 + v.W * m.M31, 
                v.X * m.M02 + v.Y * m.M12 + v.Z * m.M22 + v.W * m.M32, 
                v.X * m.M03 + v.Y * m.M13 + v.Z * m.M23 + v.W * m.M33);
        }

        #endregion

        #region Bool Operators

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M44d a, M44d b)
        {
            return
                a.M00 < b.M00 && 
                a.M01 < b.M01 && 
                a.M02 < b.M02 && 
                a.M03 < b.M03 && 
                a.M10 < b.M10 && 
                a.M11 < b.M11 && 
                a.M12 < b.M12 && 
                a.M13 < b.M13 && 
                a.M20 < b.M20 && 
                a.M21 < b.M21 && 
                a.M22 < b.M22 && 
                a.M23 < b.M23 && 
                a.M30 < b.M30 && 
                a.M31 < b.M31 && 
                a.M32 < b.M32 && 
                a.M33 < b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(M44d a, double s)
        {
            return
                a.M00 < s && 
                a.M01 < s && 
                a.M02 < s && 
                a.M03 < s && 
                a.M10 < s && 
                a.M11 < s && 
                a.M12 < s && 
                a.M13 < s && 
                a.M20 < s && 
                a.M21 < s && 
                a.M22 < s && 
                a.M23 < s && 
                a.M30 < s && 
                a.M31 < s && 
                a.M32 < s && 
                a.M33 < s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(double s, M44d a)
        {
            return
                s < a.M00  && 
                s < a.M01  && 
                s < a.M02  && 
                s < a.M03  && 
                s < a.M10  && 
                s < a.M11  && 
                s < a.M12  && 
                s < a.M13  && 
                s < a.M20  && 
                s < a.M21  && 
                s < a.M22  && 
                s < a.M23  && 
                s < a.M30  && 
                s < a.M31  && 
                s < a.M32  && 
                s < a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M44d a, M44d b)
        {
            return
                a.M00 > b.M00 && 
                a.M01 > b.M01 && 
                a.M02 > b.M02 && 
                a.M03 > b.M03 && 
                a.M10 > b.M10 && 
                a.M11 > b.M11 && 
                a.M12 > b.M12 && 
                a.M13 > b.M13 && 
                a.M20 > b.M20 && 
                a.M21 > b.M21 && 
                a.M22 > b.M22 && 
                a.M23 > b.M23 && 
                a.M30 > b.M30 && 
                a.M31 > b.M31 && 
                a.M32 > b.M32 && 
                a.M33 > b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(M44d a, double s)
        {
            return
                a.M00 > s && 
                a.M01 > s && 
                a.M02 > s && 
                a.M03 > s && 
                a.M10 > s && 
                a.M11 > s && 
                a.M12 > s && 
                a.M13 > s && 
                a.M20 > s && 
                a.M21 > s && 
                a.M22 > s && 
                a.M23 > s && 
                a.M30 > s && 
                a.M31 > s && 
                a.M32 > s && 
                a.M33 > s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(double s, M44d a)
        {
            return
                s > a.M00  && 
                s > a.M01  && 
                s > a.M02  && 
                s > a.M03  && 
                s > a.M10  && 
                s > a.M11  && 
                s > a.M12  && 
                s > a.M13  && 
                s > a.M20  && 
                s > a.M21  && 
                s > a.M22  && 
                s > a.M23  && 
                s > a.M30  && 
                s > a.M31  && 
                s > a.M32  && 
                s > a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M44d a, M44d b)
        {
            return
                a.M00 == b.M00 && 
                a.M01 == b.M01 && 
                a.M02 == b.M02 && 
                a.M03 == b.M03 && 
                a.M10 == b.M10 && 
                a.M11 == b.M11 && 
                a.M12 == b.M12 && 
                a.M13 == b.M13 && 
                a.M20 == b.M20 && 
                a.M21 == b.M21 && 
                a.M22 == b.M22 && 
                a.M23 == b.M23 && 
                a.M30 == b.M30 && 
                a.M31 == b.M31 && 
                a.M32 == b.M32 && 
                a.M33 == b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(M44d a, double s)
        {
            return
                a.M00 == s && 
                a.M01 == s && 
                a.M02 == s && 
                a.M03 == s && 
                a.M10 == s && 
                a.M11 == s && 
                a.M12 == s && 
                a.M13 == s && 
                a.M20 == s && 
                a.M21 == s && 
                a.M22 == s && 
                a.M23 == s && 
                a.M30 == s && 
                a.M31 == s && 
                a.M32 == s && 
                a.M33 == s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(double s, M44d a)
        {
            return
                s == a.M00  && 
                s == a.M01  && 
                s == a.M02  && 
                s == a.M03  && 
                s == a.M10  && 
                s == a.M11  && 
                s == a.M12  && 
                s == a.M13  && 
                s == a.M20  && 
                s == a.M21  && 
                s == a.M22  && 
                s == a.M23  && 
                s == a.M30  && 
                s == a.M31  && 
                s == a.M32  && 
                s == a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M44d a, M44d b)
        {
            return
                a.M00 <= b.M00 && 
                a.M01 <= b.M01 && 
                a.M02 <= b.M02 && 
                a.M03 <= b.M03 && 
                a.M10 <= b.M10 && 
                a.M11 <= b.M11 && 
                a.M12 <= b.M12 && 
                a.M13 <= b.M13 && 
                a.M20 <= b.M20 && 
                a.M21 <= b.M21 && 
                a.M22 <= b.M22 && 
                a.M23 <= b.M23 && 
                a.M30 <= b.M30 && 
                a.M31 <= b.M31 && 
                a.M32 <= b.M32 && 
                a.M33 <= b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(M44d a, double s)
        {
            return
                a.M00 <= s && 
                a.M01 <= s && 
                a.M02 <= s && 
                a.M03 <= s && 
                a.M10 <= s && 
                a.M11 <= s && 
                a.M12 <= s && 
                a.M13 <= s && 
                a.M20 <= s && 
                a.M21 <= s && 
                a.M22 <= s && 
                a.M23 <= s && 
                a.M30 <= s && 
                a.M31 <= s && 
                a.M32 <= s && 
                a.M33 <= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(double s, M44d a)
        {
            return
                s <= a.M00  && 
                s <= a.M01  && 
                s <= a.M02  && 
                s <= a.M03  && 
                s <= a.M10  && 
                s <= a.M11  && 
                s <= a.M12  && 
                s <= a.M13  && 
                s <= a.M20  && 
                s <= a.M21  && 
                s <= a.M22  && 
                s <= a.M23  && 
                s <= a.M30  && 
                s <= a.M31  && 
                s <= a.M32  && 
                s <= a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M44d a, M44d b)
        {
            return
                a.M00 >= b.M00 && 
                a.M01 >= b.M01 && 
                a.M02 >= b.M02 && 
                a.M03 >= b.M03 && 
                a.M10 >= b.M10 && 
                a.M11 >= b.M11 && 
                a.M12 >= b.M12 && 
                a.M13 >= b.M13 && 
                a.M20 >= b.M20 && 
                a.M21 >= b.M21 && 
                a.M22 >= b.M22 && 
                a.M23 >= b.M23 && 
                a.M30 >= b.M30 && 
                a.M31 >= b.M31 && 
                a.M32 >= b.M32 && 
                a.M33 >= b.M33;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(M44d a, double s)
        {
            return
                a.M00 >= s && 
                a.M01 >= s && 
                a.M02 >= s && 
                a.M03 >= s && 
                a.M10 >= s && 
                a.M11 >= s && 
                a.M12 >= s && 
                a.M13 >= s && 
                a.M20 >= s && 
                a.M21 >= s && 
                a.M22 >= s && 
                a.M23 >= s && 
                a.M30 >= s && 
                a.M31 >= s && 
                a.M32 >= s && 
                a.M33 >= s;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(double s, M44d a)
        {
            return
                s >= a.M00  && 
                s >= a.M01  && 
                s >= a.M02  && 
                s >= a.M03  && 
                s >= a.M10  && 
                s >= a.M11  && 
                s >= a.M12  && 
                s >= a.M13  && 
                s >= a.M20  && 
                s >= a.M21  && 
                s >= a.M22  && 
                s >= a.M23  && 
                s >= a.M30  && 
                s >= a.M31  && 
                s >= a.M32  && 
                s >= a.M33 ;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M44d a, M44d b)
        {
            return !(a == b);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(M44d m, double s)
        {
            return !(m == s);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(double s, M44d m)
        {
            return !(s == m);
        }

        #endregion

        #region Overrides

        public override int GetHashCode()
        {
            return HashCode.GetCombined(
                        HashCode.GetCombined(M00, M01, M02, M03),
                        HashCode.GetCombined(M10, M11, M12, M13),
                        HashCode.GetCombined(M20, M21, M22, M23),
                        HashCode.GetCombined(M30, M31, M32, M33));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(M44d other)
        {
            return 
                M00.Equals(other.M00) && M01.Equals(other.M01) && M02.Equals(other.M02) && M03.Equals(other.M03) && 
                M10.Equals(other.M10) && M11.Equals(other.M11) && M12.Equals(other.M12) && M13.Equals(other.M13) && 
                M20.Equals(other.M20) && M21.Equals(other.M21) && M22.Equals(other.M22) && M23.Equals(other.M23) && 
                M30.Equals(other.M30) && M31.Equals(other.M31) && M32.Equals(other.M32) && M33.Equals(other.M33);
        }

        public override bool Equals(object other)
            => (other is M44d o) ? Equals(o) : false;

        public override string ToString()
        {
            return ToString(null, CultureInfo.InvariantCulture);
        }

        public string ToString(string format)
        {
            return ToString(format, CultureInfo.InvariantCulture);
        }

        public string ToString(string format, IFormatProvider fp)
        {
            return ToString(format, fp, "[", ", ", "]", "[", ", ", "]");
        }

        /// <summary>
        /// Outputs e.g. a 2x2-Matrix in the form "(beginM)(beginR)m00(betweenR)m01(endR)(betweenM)(beginR)m10(betweenR)m11(endR)(endM)".
        /// </summary>
        public string ToString(string format, IFormatProvider fp, string beginM, string betweenM, string endM, string beginR, string betweenR, string endR)
        {
            if (fp == null) fp = CultureInfo.InvariantCulture;
            return beginM
                + R0.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R1.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R2.ToString(format, fp, beginR, betweenR, endR)  + betweenM 
                + R3.ToString(format, fp, beginR, betweenR, endR) 
            + endM;
        }

        public static M44d Parse(string s)
        {
            var x = s.NestedBracketSplitLevelOne().ToArray();
            return M44d.FromRows(
                V4d.Parse(x[0]), 
                V4d.Parse(x[1]), 
                V4d.Parse(x[2]), 
                V4d.Parse(x[3])
            );
        }

        #endregion

        #region Matrix Operations

        /// <summary>
        /// Returns adjoint of this matrix.
        /// </summary>
        public M44d Adjoint
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                M44d result = new M44d();
                for (int row = 0; row < 4; row++)
                {
                    for (int col = 0; col < 4; col++)
                    {
                        if (((col + row) % 2) == 0)
                            result[col, row] = this.Minor(row, col).Determinant;
                        else
                            result[col, row] = -this.Minor(row, col).Determinant;
                    }
                }

                return result;
            }
        }

        /// <summary>
        /// Returns the trace of this matrix.
        /// The trace is defined as the sum of the diagonal elements,
        /// and is only defined for square matrices.
        /// </summary>
        public double Trace
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return M00 + M11 + M22 + M33 ; }
        }

        /// <summary>
        /// Gets the determinant of this matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        public double Determinant
        {
            get
            {
                // using bottom row because elements M30, M31, and M32
                // are zero most of the time.
                double d = 0;
                if (M30 != 0.0f) d -= M30 * (
                M01 * M12 * M23 + M02 * M13 * M21 + M03 * M11 * M22
                - M21 * M12 * M03 - M22 * M13 * M01 - M23 * M11 * M02
                );
                if (M31 != 0.0f) d += M31 * (
                M00 * M12 * M23 + M02 * M13 * M20 + M03 * M10 * M22
                - M20 * M12 * M03 - M22 * M13 * M00 - M23 * M10 * M02
                );
                if (M32 != 0.0f) d -= M32 * (
                M00 * M11 * M23 + M01 * M13 * M20 + M03 * M10 * M21
                - M20 * M11 * M03 - M21 * M13 * M00 - M23 * M10 * M01
                );
                if (M33 != 0.0f) d += M33 * (
                M00 * M11 * M22 + M01 * M12 * M20 + M02 * M10 * M21
                - M20 * M11 * M02 - M21 * M12 * M00 - M22 * M10 * M01
                );
                return d;
            }
        }

        /// <summary>
        /// Returns whether this matrix is invertible.
        /// A matrix is invertible if its determinant is not zero.
        /// </summary>
        public bool Invertible
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant != 0; }
        }

        /// <summary>
        /// Returns whether this matrix is singular.
        /// A matrix is singular if its determinant is zero.
        /// </summary>
        public bool Singular
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get { return Determinant == 0; }
        }

        /// <summary>
        /// Gets transpose of this matrix.
        /// </summary>
        public M44d Transposed
        {
            get
            {
                return new M44d {
                    
                    M00 = M00, 
                    M01 = M10, 
                    M02 = M20, 
                    M03 = M30, 
                    
                    M10 = M01, 
                    M11 = M11, 
                    M12 = M21, 
                    M13 = M31, 
                    
                    M20 = M02, 
                    M21 = M12, 
                    M22 = M22, 
                    M23 = M32, 
                    
                    M30 = M03, 
                    M31 = M13, 
                    M32 = M23, 
                    M33 = M33
                };
            }
        }

        private static V2l s_luSize = new V2l(4, 4);
        private static V2l s_luDelta = new V2l(1, 4);

        /// <summary>
        /// Inverts the given matrix using lu factorization in place. Returns true
        /// if the matrix was invertible, otherwise the matrix remains unchanged.
        /// </summary>
        public unsafe bool LuInvert()
        {
            fixed (M44d* self = &this)
            {
                var lu = this;
                V4i perm;
                if (NumericExtensions.LuFactorize((double*)&lu, 0, 1, 4, (int*)&perm, 4))
                {
                    NumericExtensions.LuInverse((double*)&lu, 0, 1, 4, (int*)&perm, (double*)self, 0, 1, 4, 4);
                    return true;
                }
                return false;
            }
        }

        /// <summary>
        /// Returns the inverse of the matrix using lu factorization.
        /// If the matrix is not invertible, M44d.Zero is returned.
        /// </summary>
        public unsafe M44d LuInverse()
        {
            var lu = this;
            M44d res;
            V4i perm;
            if (NumericExtensions.LuFactorize((double*)&lu, 0, 1, 4, (int*)&perm, 4))
            {
                NumericExtensions.LuInverse((double*)&lu, 0, 1, 4, (int*)&perm, (double*)&res, 0, 1, 4, 4);
                return res;
            }
            return M44d.Zero;
        }

        /// <summary>
        /// Returns the inverse of this matrix. If the matrix is not invertible
        /// M44d.Zero is returned.
        /// </summary>
        public M44d Inverse
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => LuInverse();
        }

        #endregion

        #region Matrix Multiplication

        public static M44d operator *(M44d a, M44d b)
        {
            return new M44d(
                a.M00 * b.M00 + a.M01 * b.M10 + a.M02 * b.M20 + a.M03 * b.M30, 
                a.M00 * b.M01 + a.M01 * b.M11 + a.M02 * b.M21 + a.M03 * b.M31, 
                a.M00 * b.M02 + a.M01 * b.M12 + a.M02 * b.M22 + a.M03 * b.M32, 
                a.M00 * b.M03 + a.M01 * b.M13 + a.M02 * b.M23 + a.M03 * b.M33, 
                a.M10 * b.M00 + a.M11 * b.M10 + a.M12 * b.M20 + a.M13 * b.M30, 
                a.M10 * b.M01 + a.M11 * b.M11 + a.M12 * b.M21 + a.M13 * b.M31, 
                a.M10 * b.M02 + a.M11 * b.M12 + a.M12 * b.M22 + a.M13 * b.M32, 
                a.M10 * b.M03 + a.M11 * b.M13 + a.M12 * b.M23 + a.M13 * b.M33, 
                a.M20 * b.M00 + a.M21 * b.M10 + a.M22 * b.M20 + a.M23 * b.M30, 
                a.M20 * b.M01 + a.M21 * b.M11 + a.M22 * b.M21 + a.M23 * b.M31, 
                a.M20 * b.M02 + a.M21 * b.M12 + a.M22 * b.M22 + a.M23 * b.M32, 
                a.M20 * b.M03 + a.M21 * b.M13 + a.M22 * b.M23 + a.M23 * b.M33, 
                a.M30 * b.M00 + a.M31 * b.M10 + a.M32 * b.M20 + a.M33 * b.M30, 
                a.M30 * b.M01 + a.M31 * b.M11 + a.M32 * b.M21 + a.M33 * b.M31, 
                a.M30 * b.M02 + a.M31 * b.M12 + a.M32 * b.M22 + a.M33 * b.M32, 
                a.M30 * b.M03 + a.M31 * b.M13 + a.M32 * b.M23 + a.M33 * b.M33
             );
        }

        #endregion

        #region IMatrix<double>

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[long x, long y]
        {
            get
            {
                return this[(int)y, (int)x];
            }
            set
            {
                this[(int)y, (int)x] = value;
            }
        }

        /// <summary>
        /// NOTE: this indexer has reversed order of coordinates with respect to
        /// the default indexer!!!
        /// </summary>
        public double this[V2l v]
        {
            get
            {
                return this[(int)v.Y, (int)v.X];
            }
            set
            {
                this[(int)v.Y, (int)v.X] = value;
            }
        }

        #endregion

        #region IMatrix

        public V2l Dim
        {
            get { return Dimensions; }
        }

        public object GetValue(long x, long y)
        {
            return (object)this[(int)x, (int)y];
        }

        public void SetValue(object value, long x, long y)
        {
            this[(int)x, (int)y] = (double)value;
        }

        public object GetValue(V2l v)
        {
            return (object)this[(int)(v.X), (int)(v.Y)];
        }

        public void SetValue(object value, V2l v)
        {
            this[(int)(v.X), (int)(v.Y)] = (double)value;
        }

        #endregion
    }

    public class M44dEqualityComparer : IEqualityComparer<M44d>
    {
        public static readonly M44dEqualityComparer Default
            = new M44dEqualityComparer();

        #region IEqualityComparer<M44d> Members

        public bool Equals(M44d v0, M44d v1)
        {
            return v0 == v1;
        }

        public int GetHashCode(M44d v)
        {
            return v.GetHashCode();
        }

        #endregion
    }

    /// <summary>
    /// Contains static methods.
    /// </summary>
    public static partial class Mat
    {
        #region Transformation Extraction

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale(this M44d m)
            => (m.C0.Length + m.C1.Length + m.C2.Length + m.C3.Length) / 4;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d GetScaleVector(this M44d m)
            => new V4d(m.C0.Length, m.C1.Length, m.C2.Length, m.C3.Length);

        /// <summary>
        /// Approximates the uniform scale value of the given transformation matrix (average length of 3D basis vectors).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double GetScale3(this M44d m)
            => (m.C0.XYZ.Length + m.C1.XYZ.Length + m.C2.XYZ.Length) / 3;

        /// <summary>
        /// Extracts a scale vector from the given matrix by calculating the lengths of the 3D basis vectors.
        /// NOTE: The extraction only gives absolute value (negative scale will be ignored)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetScaleVector3(this M44d m)
            => new V3d(m.C0.XYZ.Length, m.C1.XYZ.Length, m.C2.XYZ.Length);

        /// <summary>
        /// Extracts the forward vector from the given view transformation matrix.
        /// NOTE: A left-handed coordinates system transformation is expected, 
        /// where the view-space z-axis points in forward direction.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetViewDirectionLH(this M44d m)
            => m.R2.XYZ.Normalized;

        /// <summary>
        /// Extracts the forward vector from the given view transformation matrix.
        /// NOTE: A right-handed coordinates system transformation is expected, where 
        /// the view-space z-axis points opposit the forward vector.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetViewDirectionRH(this M44d m)
            => -m.R2.XYZ.Normalized;

        /// <summary>
        /// Extracts the translation component of the given transformation matrix, which when given 
        /// a model transformation represents the model origin in world position.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V3d GetModelOrigin(this M44d m)
            => m.C3.XYZ;

        /// <summary>
        /// Builds a hull from the given view-projection transformation matrix (left, right, bottom, top, near, far).
        /// The view volume is assumed to be [-1, -1, -1] [1, 1, 1].
        /// The normals of the hull planes point to the outside and are normalized. 
        /// A point inside the visual hull will has negative height to all planes.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Hull3d GetVisualHull(this M44d viewProj)
        {
            var r0 = viewProj.R0;
            var r1 = viewProj.R1;
            var r2 = viewProj.R2;
            var r3 = viewProj.R3;

            return new Hull3d(new[]
            {
                new Plane3d((-(r3 + r0))).Normalized, // left
                new Plane3d((-(r3 - r0))).Normalized, // right
                new Plane3d((-(r3 + r1))).Normalized, // bottom
                new Plane3d((-(r3 - r1))).Normalized, // top
                new Plane3d((-(r3 + r2))).Normalized, // near
                new Plane3d((-(r3 - r2))).Normalized, // far
            });
        }

        #endregion

        #region Norms

        /// <summary>
        /// Returns the Manhattan (or 1-) norm of the matrix. This is
        /// calculated as |M00| + |M01| + ...
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm1(M44d m)
            => m.Norm1;

        /// <summary>
        /// Returns the Euclidean (or 2-) norm of the matrix. This is
        /// calculated as Sqrt(M00 * M00 + M01 * M01 + ... )
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm2(M44d m)
            => m.Norm2;

        /// <summary>
        /// Returns the infinite (or maximum) norm of the matrix. This is
        /// calculated as max(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMax(M44d m)
            => m.NormMax;

        /// <summary>
        /// Returns the minimum norm of the matrix. This is calculated as
        /// min(|M00|, |M01|, ...).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double NormMin(M44d m)
            => m.NormMin;

        /// <summary>
        /// Returns the p-norm of the matrix. This is calculated as
        /// (|M00|^p + |M01|^p + ... )^(1/p)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Norm(this M44d m, double p)
        {
            return (
                Fun.Abs(m.M00).Pow(p) + 
                Fun.Abs(m.M01).Pow(p) + 
                Fun.Abs(m.M02).Pow(p) + 
                Fun.Abs(m.M03).Pow(p) + 
                Fun.Abs(m.M10).Pow(p) + 
                Fun.Abs(m.M11).Pow(p) + 
                Fun.Abs(m.M12).Pow(p) + 
                Fun.Abs(m.M13).Pow(p) + 
                Fun.Abs(m.M20).Pow(p) + 
                Fun.Abs(m.M21).Pow(p) + 
                Fun.Abs(m.M22).Pow(p) + 
                Fun.Abs(m.M23).Pow(p) + 
                Fun.Abs(m.M30).Pow(p) + 
                Fun.Abs(m.M31).Pow(p) + 
                Fun.Abs(m.M32).Pow(p) + 
                Fun.Abs(m.M33).Pow(p)
            ).Pow(1 / p);
        }

        #endregion

        #region Distance functions

        /// <summary>
        /// Returns the Manhatten (or 1-) distance between two matrices.
        /// </summary>
        public static double Distance1(this M44d a, M44d b)
        {
            return
                Fun.Abs(b.M00 - a.M00) + 
                Fun.Abs(b.M01 - a.M01) + 
                Fun.Abs(b.M02 - a.M02) + 
                Fun.Abs(b.M03 - a.M03) + 
                Fun.Abs(b.M10 - a.M10) + 
                Fun.Abs(b.M11 - a.M11) + 
                Fun.Abs(b.M12 - a.M12) + 
                Fun.Abs(b.M13 - a.M13) + 
                Fun.Abs(b.M20 - a.M20) + 
                Fun.Abs(b.M21 - a.M21) + 
                Fun.Abs(b.M22 - a.M22) + 
                Fun.Abs(b.M23 - a.M23) + 
                Fun.Abs(b.M30 - a.M30) + 
                Fun.Abs(b.M31 - a.M31) + 
                Fun.Abs(b.M32 - a.M32) + 
                Fun.Abs(b.M33 - a.M33);
        }

        /// <summary>
        /// Returns the Euclidean (or 2-) distance between two matrices.
        /// </summary>
        public static double Distance2(this M44d a, M44d b)
        {
            return Fun.Sqrt(
                        Fun.Square(b.M00 - a.M00) + 
                        Fun.Square(b.M01 - a.M01) + 
                        Fun.Square(b.M02 - a.M02) + 
                        Fun.Square(b.M03 - a.M03) + 
                        Fun.Square(b.M10 - a.M10) + 
                        Fun.Square(b.M11 - a.M11) + 
                        Fun.Square(b.M12 - a.M12) + 
                        Fun.Square(b.M13 - a.M13) + 
                        Fun.Square(b.M20 - a.M20) + 
                        Fun.Square(b.M21 - a.M21) + 
                        Fun.Square(b.M22 - a.M22) + 
                        Fun.Square(b.M23 - a.M23) + 
                        Fun.Square(b.M30 - a.M30) + 
                        Fun.Square(b.M31 - a.M31) + 
                        Fun.Square(b.M32 - a.M32) + 
                        Fun.Square(b.M33 - a.M33));
        }

        /// <summary>
        /// Returns the p-distance between two matrices.
        /// </summary>
        public static double Distance(this M44d a, M44d b, double p)
        {
            return (
                Fun.Abs(b.M00 - a.M00).Pow(p) + 
                Fun.Abs(b.M01 - a.M01).Pow(p) + 
                Fun.Abs(b.M02 - a.M02).Pow(p) + 
                Fun.Abs(b.M03 - a.M03).Pow(p) + 
                Fun.Abs(b.M10 - a.M10).Pow(p) + 
                Fun.Abs(b.M11 - a.M11).Pow(p) + 
                Fun.Abs(b.M12 - a.M12).Pow(p) + 
                Fun.Abs(b.M13 - a.M13).Pow(p) + 
                Fun.Abs(b.M20 - a.M20).Pow(p) + 
                Fun.Abs(b.M21 - a.M21).Pow(p) + 
                Fun.Abs(b.M22 - a.M22).Pow(p) + 
                Fun.Abs(b.M23 - a.M23).Pow(p) + 
                Fun.Abs(b.M30 - a.M30).Pow(p) + 
                Fun.Abs(b.M31 - a.M31).Pow(p) + 
                Fun.Abs(b.M32 - a.M32).Pow(p) + 
                Fun.Abs(b.M33 - a.M33).Pow(p)
            ).Pow(1 / p);
        }

        /// <summary>
        /// Returns the maximal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMax(this M44d a, M44d b)
        {
            return Fun.Max(
                        Fun.Max(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Max(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Max(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Max(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        /// <summary>
        /// Returns the minimal absolute distance between the components of
        /// the two matrices.
        /// </summary>
        public static double DistanceMin(this M44d a, M44d b)
        {
            return Fun.Min(
                        Fun.Min(
                            Fun.Abs(b.M00 - a.M00), 
                            Fun.Abs(b.M01 - a.M01), 
                            Fun.Abs(b.M02 - a.M02), 
                            Fun.Abs(b.M03 - a.M03)), 
                        Fun.Min(
                            Fun.Abs(b.M10 - a.M10), 
                            Fun.Abs(b.M11 - a.M11), 
                            Fun.Abs(b.M12 - a.M12), 
                            Fun.Abs(b.M13 - a.M13)), 
                        Fun.Min(
                            Fun.Abs(b.M20 - a.M20), 
                            Fun.Abs(b.M21 - a.M21), 
                            Fun.Abs(b.M22 - a.M22), 
                            Fun.Abs(b.M23 - a.M23)), 
                        Fun.Min(
                            Fun.Abs(b.M30 - a.M30), 
                            Fun.Abs(b.M31 - a.M31), 
                            Fun.Abs(b.M32 - a.M32), 
                            Fun.Abs(b.M33 - a.M33)));
        }

        #endregion

        #region Transformations

        /// <summary>
        /// Transforms vector v by matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d Transform(this M44d m, V4d v)
            => m * v;

        /// <summary>
        /// Transforms vector v by the transpose of matrix m.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static V4d TransposedTransform(this M44d m, V4d v)
            => v * m;

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by matrix m.
        /// </summary>
        public static V3d TransformDir(this M44d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M01 * v.Y + m.M02 * v.Z, 
                m.M10 * v.X + m.M11 * v.Y + m.M12 * v.Z, 
                m.M20 * v.X + m.M21 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3d TransformPos(this M44d m, V3d p)
        {
            return new V3d(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23
                );
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3d TransformPosProj(this M44d m, V3d p)
        {
            double s = m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33;
            return TransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (p.W is presumed 1.0) by matrix m.
        /// Projective transform is performed.
        /// </summary>
        public static V4d TransformPosProjFull(this M44d m, V3d p)
        {
            return new V4d(
                m.M00 * p.X + m.M01 * p.Y + m.M02 * p.Z + m.M03, 
                m.M10 * p.X + m.M11 * p.Y + m.M12 * p.Z + m.M13, 
                m.M20 * p.X + m.M21 * p.Y + m.M22 * p.Z + m.M23, 
                m.M30 * p.X + m.M31 * p.Y + m.M32 * p.Z + m.M33
                );
        }

        /// <summary>
        /// Transforms direction vector v (v.W is presumed 0.0) by transposed version of matrix m.
        /// </summary>
        public static V3d TransposedTransformDir(this M44d m, V3d v)
        {
            return new V3d(
                m.M00 * v.X + m.M10 * v.Y + m.M20 * v.Z, 
                m.M01 * v.X + m.M11 * v.Y + m.M21 * v.Z, 
                m.M02 * v.X + m.M12 * v.Y + m.M22 * v.Z
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// No projective transform is performed.
        /// </summary>
        public static V3d TransposedTransformPos(this M44d m, V3d p)
        {
            return new V3d(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32
                );
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V3d TransposedTransformProj(this M44d m, V3d p)
        {
            var s = m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33;
            return TransposedTransformPos(m, p) * (1 / s);
        }

        /// <summary>
        /// Transforms point p (v.W is presumed 1.0) by transposed version of matrix m.
        /// Projective transform is performed. Perspective Division is performed.
        /// </summary>
        public static V4d TransposedTransformProjFull(this M44d m, V3d p)
        {
            return new V4d(
                m.M00 * p.X + m.M10 * p.Y + m.M20 * p.Z + m.M30, 
                m.M01 * p.X + m.M11 * p.Y + m.M21 * p.Z + m.M31, 
                m.M02 * p.X + m.M12 * p.Y + m.M22 * p.Z + m.M32, 
                m.M03 * p.X + m.M13 * p.Y + m.M23 * p.Z + m.M33
                );
        }

        #endregion

        #region Operations

        /// <summary>
        /// Returns the given <see cref="M44d"/> to a deleting the
        /// specified row and column.
        /// </summary>
        public static M33d Minor(this M44d m, int row, int column)
        {
            M33d rs = new M33d();

            for (int k = 0; k < 9; k++)
            {
                var i = k / 3;
                var j = k % 3;
                var ii = (i < row) ? i : i + 1;
                var jj = (j < column) ? j : j + 1;

                rs[k] = m[ii * 4 + jj];
            }

            return rs;
        }

        /// <summary>
        /// Returns index-th row of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V4d Row(this M44d m, int index)
        {
            double* ptr = &m.M00;
            return new V4d(ptr[index * 4], ptr[index * 4 + 1], ptr[index * 4 + 2], ptr[index * 4 + 3]);
        }

        /// <summary>
        /// Returns index-th column of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public unsafe static V4d Column(this M44d m, int index)
        {
            double* ptr = &m.M00;
            return new V4d(ptr[index], ptr[index + 4], ptr[index + 8], ptr[index + 12]);
        }

        /// <summary>
        /// Returns the determinant of the given matrix.
        /// The determinant is only defined for square matrices.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Determinant(M44d m)
            => m.Determinant;

        /// <summary>
        /// Returns the transpose of the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Transposed(M44d m)
            => m.Transposed;

        /// <summary>
        /// Transposes the given matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Transpose(this ref M44d m)
        {
            Fun.Swap(ref m.M10, ref m.M01);
            Fun.Swap(ref m.M20, ref m.M02);
            Fun.Swap(ref m.M21, ref m.M12);
            Fun.Swap(ref m.M30, ref m.M03);
            Fun.Swap(ref m.M31, ref m.M13);
            Fun.Swap(ref m.M32, ref m.M23);
        }

        /// <summary>
        /// Returns the inverse of the given matrix. If the matrix is not invertible
        /// M44d.Zero is returned.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Inverse(M44d m)
            => m.Inverse;

        /// <summary>
        /// Inverts the given matrix in place. Returns true if the matrix was invertible,
        /// otherwise the matrix remains unchanged.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Invert(this ref M44d m) { return m.LuInvert(); }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M44d m, double epsilon)
        {
            return Fun.ApproximateEquals(m, M44d.Identity, epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is the identity matrix I.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsIdentity(this M44d m)
            => IsIdentity(m, Constant<double>.PositiveTinyValue);

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M44d m, double epsilon)
        {
            var i = m * m.Transposed;
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthonormal (i.e. M * M^t == I)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthonormal(this M44d m)
            => IsOrthonormal(m, Constant<double>.PositiveTinyValue);

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M44d m, double epsilon)
        {
            var i = m * m.Transposed;
            for (int j = 0; j < 4; j++)
                i[j, j] = 1; //inefficient implementation: just leave out the comparisons at the diagonal entries.
            return i.IsIdentity(epsilon);
        }

        /// <summary>
        /// Returns if the given matrix is orthogonal (i.e. all non-diagonal entries of M * M^t == 0)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsOrthogonal(this M44d m)
            => IsOrthogonal(m, Constant<double>.PositiveTinyValue);

        #endregion

        #region Min- / MaxElement

        /// <summary>
        /// Returns the minimum element of the given <see cref="M44d"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double MinElement(M44d m)
            => m.MinElement;

        /// <summary>
        /// Returns the maximum element of the given <see cref="M44d"/> matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double MaxElement(M44d m)
            => m.MaxElement;

        #endregion

        #region Orthogonalization

        /// <summary>
        /// Orthogonalizes the columns of the given <see cref="M44d"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        public static void Orthogonalize(this ref M44d matrix)
        {
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C3 -= (Vec.Dot(matrix.C0, matrix.C3) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C3 -= (Vec.Dot(matrix.C1, matrix.C3) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C3 -= (Vec.Dot(matrix.C2, matrix.C3) / Vec.Dot(matrix.C2, matrix.C2)) * matrix.C2;
            matrix.C3 -= (Vec.Dot(matrix.C0, matrix.C3) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C3 -= (Vec.Dot(matrix.C1, matrix.C3) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C3 -= (Vec.Dot(matrix.C2, matrix.C3) / Vec.Dot(matrix.C2, matrix.C2)) * matrix.C2;
        }

        /// <summary>
        /// Orthogonalizes the columns of the given <see cref="M44d"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Orthogonalized(this M44d matrix)
        {
            M44d m = matrix;
            Orthogonalize(ref m);
            return m;
        }

        /// <summary>
        /// Orthonormalizes the columns of the given <see cref="M44d"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        public static void Orthonormalize(this ref M44d matrix)
        {
            matrix.C0 = matrix.C0.Normalized;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 -= (Vec.Dot(matrix.C0, matrix.C1) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C1 = matrix.C1.Normalized;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C2 -= (Vec.Dot(matrix.C0, matrix.C2) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C2 -= (Vec.Dot(matrix.C1, matrix.C2) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C2 = matrix.C2.Normalized;
            matrix.C3 -= (Vec.Dot(matrix.C0, matrix.C3) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C3 -= (Vec.Dot(matrix.C1, matrix.C3) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C3 -= (Vec.Dot(matrix.C2, matrix.C3) / Vec.Dot(matrix.C2, matrix.C2)) * matrix.C2;
            matrix.C3 -= (Vec.Dot(matrix.C0, matrix.C3) / Vec.Dot(matrix.C0, matrix.C0)) * matrix.C0;
            matrix.C3 -= (Vec.Dot(matrix.C1, matrix.C3) / Vec.Dot(matrix.C1, matrix.C1)) * matrix.C1;
            matrix.C3 -= (Vec.Dot(matrix.C2, matrix.C3) / Vec.Dot(matrix.C2, matrix.C2)) * matrix.C2;
            matrix.C3 = matrix.C3.Normalized;
        }

        /// <summary>
        /// Orthonormalizes the columns of the given <see cref="M44d"/> using the (modified) Gram-Schmidt algorithm with
        /// an additional reorthogonalization step.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d Orthonormalized(this M44d matrix)
        {
            M44d m = matrix;
            Orthonormalize(ref m);
            return m;
        }

        #endregion

        #region AnyTiny, AllTiny

        /// <summary>
        /// Returns whether the absolute value of any element of the given <see cref="M44d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(this M44d m, double epsilon)
            => m.M00.IsTiny(epsilon) || m.M01.IsTiny(epsilon) || m.M02.IsTiny(epsilon) || m.M03.IsTiny(epsilon) || m.M10.IsTiny(epsilon) || m.M11.IsTiny(epsilon) || m.M12.IsTiny(epsilon) || m.M13.IsTiny(epsilon) || m.M20.IsTiny(epsilon) || m.M21.IsTiny(epsilon) || m.M22.IsTiny(epsilon) || m.M23.IsTiny(epsilon) || m.M30.IsTiny(epsilon) || m.M31.IsTiny(epsilon) || m.M32.IsTiny(epsilon) || m.M33.IsTiny(epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M44d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(this M44d m, double epsilon)
            => m.M00.IsTiny(epsilon) && m.M01.IsTiny(epsilon) && m.M02.IsTiny(epsilon) && m.M03.IsTiny(epsilon) && m.M10.IsTiny(epsilon) && m.M11.IsTiny(epsilon) && m.M12.IsTiny(epsilon) && m.M13.IsTiny(epsilon) && m.M20.IsTiny(epsilon) && m.M21.IsTiny(epsilon) && m.M22.IsTiny(epsilon) && m.M23.IsTiny(epsilon) && m.M30.IsTiny(epsilon) && m.M31.IsTiny(epsilon) && m.M32.IsTiny(epsilon) && m.M33.IsTiny(epsilon);

        #endregion

        #region Special Floating Point Value Checks

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNaN(M44d m)
            => m.AnyNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNaN(M44d m)
            => m.AllNaN;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyInfinity(M44d m)
            => m.AnyInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllInfinity(M44d m)
            => m.AllInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyPositiveInfinity(M44d m)
            => m.AnyPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllPositiveInfinity(M44d m)
            => m.AllPositiveInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyNegativeInfinity(M44d m)
            => m.AnyNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllNegativeInfinity(M44d m)
            => m.AllNegativeInfinity;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AnyTiny(M44d m)
            => m.AnyTiny;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool AllTiny(M44d m)
            => m.AllTiny;

        #endregion
    }

    public static partial class Fun
    {
        #region ApproximateEquals

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M44d a, M44d b)
            => ApproximateEquals(a, b, Constant<double>.PositiveTinyValue);

        /// <summary>
        /// Returns if all entries in the matrix a are approximately equal to the respective entries in matrix b.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool ApproximateEquals(this M44d a, M44d b, double epsilon)
        {
            return Mat.DistanceMax(a, b) <= epsilon; //Inefficient implementation, no early exit of comparisons.
        }

        #endregion

        #region IsTiny

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M44d"/> is smaller than <paramref name="epsilon"/>.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(this M44d m, double epsilon)
            => Mat.AllTiny(m, epsilon);

        /// <summary>
        /// Returns whether the absolute value of each element of the given <see cref="M44d"/> is smaller than Constant&lt;double&gt;.PositiveTinyValue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsTiny(M44d m)
            => m.IsTiny;

        #endregion

        #region Special Floating Point Value Checks

        /// <summary>
        /// Returns whether any element of the given <see cref="M44d"/> is NaN.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNaN(M44d v)
            => v.IsNaN;

        /// <summary>
        /// Returns whether any element of the given <see cref="M44d"/> is infinity (positive or negative).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInfinity(M44d v)
            => v.IsInfinity;

        /// <summary>
        /// Returns whether all elements of the given <see cref="M44d"/> are finite (i.e. not NaN and not infinity).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsFinite(M44d v)
            => v.IsFinite;

        #endregion
    }

    public static class IRandomUniformM44dExtensions
    {
        #region IRandomUniform extensions for M44d

        /// <summary>
        /// Uses UniformDouble() to generate the elements of an M44d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d UniformM44d(this IRandomUniform rnd)
        {
            return new M44d(
                rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), 
                rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), 
                rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), 
                rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble(), rnd.UniformDouble());
        }

        /// <summary>
        /// Uses UniformDoubleClosed() to generate the elements of an M44d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d UniformM44dClosed(this IRandomUniform rnd)
        {
            return new M44d(
                rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), 
                rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), 
                rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), 
                rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed(), rnd.UniformDoubleClosed());
        }

        /// <summary>
        /// Uses UniformDoubleOpen() to generate the elements of an M44d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d UniformM44dOpen(this IRandomUniform rnd)
        {
            return new M44d(
                rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), 
                rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), 
                rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), 
                rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen(), rnd.UniformDoubleOpen());
        }

        /// <summary>
        /// Uses UniformDoubleFull() to generate the elements of an M44d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d UniformM44dFull(this IRandomUniform rnd)
        {
            return new M44d(
                rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), 
                rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), 
                rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), 
                rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull(), rnd.UniformDoubleFull());
        }

        /// <summary>
        /// Uses UniformDoubleFullClosed() to generate the elements of an M44d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d UniformM44dFullClosed(this IRandomUniform rnd)
        {
            return new M44d(
                rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), 
                rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), 
                rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), 
                rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed(), rnd.UniformDoubleFullClosed());
        }

        /// <summary>
        /// Uses UniformDoubleFullOpen() to generate the elements of an M44d matrix.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static M44d UniformM44dFullOpen(this IRandomUniform rnd)
        {
            return new M44d(
                rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), 
                rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), 
                rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), 
                rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen(), rnd.UniformDoubleFullOpen());
        }

        #endregion
    }

    #endregion

}
